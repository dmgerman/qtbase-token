begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtNetwork module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qnetworkcookie.h"
end_include
begin_include
include|#
directive|include
file|"qnetworkcookie_p.h"
end_include
begin_include
include|#
directive|include
file|"qnetworkrequest.h"
end_include
begin_include
include|#
directive|include
file|"qnetworkreply.h"
end_include
begin_include
include|#
directive|include
file|"QtCore/qbytearray.h"
end_include
begin_include
include|#
directive|include
file|"QtCore/qdebug.h"
end_include
begin_include
include|#
directive|include
file|"QtCore/qlist.h"
end_include
begin_include
include|#
directive|include
file|"QtCore/qlocale.h"
end_include
begin_include
include|#
directive|include
file|"QtCore/qstring.h"
end_include
begin_include
include|#
directive|include
file|"QtCore/qstringlist.h"
end_include
begin_include
include|#
directive|include
file|"QtCore/qurl.h"
end_include
begin_include
include|#
directive|include
file|"private/qobject_p.h"
end_include
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_comment
comment|/*!     \class QNetworkCookie     \since 4.4     \ingroup shared     \inmodule QtNetwork      \brief The QNetworkCookie class holds one network cookie.      Cookies are small bits of information that stateless protocols     like HTTP use to maintain some persistent information across     requests.      A cookie is set by a remote server when it replies to a request     and it expects the same cookie to be sent back when further     requests are sent.      QNetworkCookie holds one such cookie as received from the     network. A cookie has a name and a value, but those are opaque to     the application (that is, the information stored in them has no     meaning to the application). A cookie has an associated path name     and domain, which indicate when the cookie should be sent again to     the server.      A cookie can also have an expiration date, indicating its     validity. If the expiration date is not present, the cookie is     considered a "session cookie" and should be discarded when the     application exits (or when its concept of session is over).      QNetworkCookie provides a way of parsing a cookie from the HTTP     header format using the QNetworkCookie::parseCookies()     function. However, when received in a QNetworkReply, the cookie is     already parsed.      This class implements cookies as described by the     \l{Netscape Cookie Specification}{initial cookie specification by     Netscape}, which is somewhat similar to the \l{http://www.rfc-editor.org/rfc/rfc2109.txt}{RFC 2109} specification,     plus the \l{Mitigating Cross-site Scripting With HTTP-only Cookies}     {"HttpOnly" extension}. The more recent \l{http://www.rfc-editor.org/rfc/rfc2965.txt}{RFC 2965} specification     (which uses the Set-Cookie2 header) is not supported.      \sa QNetworkCookieJar, QNetworkRequest, QNetworkReply */
end_comment
begin_comment
comment|/*!     Create a new QNetworkCookie object, initializing the cookie name     to \a name and its value to \a value.      A cookie is only valid if it has a name. However, the value is     opaque to the application and being empty may have significance to     the remote server. */
end_comment
begin_constructor
DECL|function|QNetworkCookie
name|QNetworkCookie
operator|::
name|QNetworkCookie
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|name
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|value
parameter_list|)
member_init_list|:
name|d
argument_list|(
operator|new
name|QNetworkCookiePrivate
argument_list|)
block|{
name|qRegisterMetaType
argument_list|<
name|QNetworkCookie
argument_list|>
argument_list|()
expr_stmt|;
name|qRegisterMetaType
argument_list|<
name|QList
argument_list|<
name|QNetworkCookie
argument_list|>
argument_list|>
argument_list|()
expr_stmt|;
name|d
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|d
operator|->
name|value
operator|=
name|value
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Creates a new QNetworkCookie object by copying the contents of \a     other. */
end_comment
begin_constructor
DECL|function|QNetworkCookie
name|QNetworkCookie
operator|::
name|QNetworkCookie
parameter_list|(
specifier|const
name|QNetworkCookie
modifier|&
name|other
parameter_list|)
member_init_list|:
name|d
argument_list|(
name|other
operator|.
name|d
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Destroys this QNetworkCookie object. */
end_comment
begin_destructor
DECL|function|~QNetworkCookie
name|QNetworkCookie
operator|::
name|~
name|QNetworkCookie
parameter_list|()
block|{
comment|// QSharedDataPointer auto deletes
name|d
operator|=
literal|0
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     Copies the contents of the QNetworkCookie object \a other to this     object. */
end_comment
begin_function
DECL|function|operator =
name|QNetworkCookie
modifier|&
name|QNetworkCookie
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QNetworkCookie
modifier|&
name|other
parameter_list|)
block|{
name|d
operator|=
name|other
operator|.
name|d
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QNetworkCookie::swap(QNetworkCookie&other)     \since 5.0      Swaps this cookie with \a other. This function is very fast and     never fails. */
end_comment
begin_comment
comment|/*!     \fn bool QNetworkCookie::operator!=(const QNetworkCookie&other) const      Returns true if this cookie is not equal to \a other.      \sa operator==() */
end_comment
begin_comment
comment|/*!     \since 5.0     Returns true if this cookie is equal to \a other. This function     only returns true if all fields of the cookie are the same.      However, in some contexts, two cookies of the same name could be     considered equal.      \sa operator!=(), hasSameIdentifier() */
end_comment
begin_function
DECL|function|operator ==
name|bool
name|QNetworkCookie
operator|::
name|operator
name|==
parameter_list|(
specifier|const
name|QNetworkCookie
modifier|&
name|other
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|d
operator|==
name|other
operator|.
name|d
condition|)
return|return
literal|true
return|;
return|return
name|d
operator|->
name|name
operator|==
name|other
operator|.
name|d
operator|->
name|name
operator|&&
name|d
operator|->
name|value
operator|==
name|other
operator|.
name|d
operator|->
name|value
operator|&&
name|d
operator|->
name|expirationDate
operator|.
name|toUTC
argument_list|()
operator|==
name|other
operator|.
name|d
operator|->
name|expirationDate
operator|.
name|toUTC
argument_list|()
operator|&&
name|d
operator|->
name|domain
operator|==
name|other
operator|.
name|d
operator|->
name|domain
operator|&&
name|d
operator|->
name|path
operator|==
name|other
operator|.
name|d
operator|->
name|path
operator|&&
name|d
operator|->
name|secure
operator|==
name|other
operator|.
name|d
operator|->
name|secure
operator|&&
name|d
operator|->
name|comment
operator|==
name|other
operator|.
name|d
operator|->
name|comment
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if this cookie has the same identifier tuple as \a other.     The identifier tuple is composed of the name, domain and path.      \sa operator==() */
end_comment
begin_function
DECL|function|hasSameIdentifier
name|bool
name|QNetworkCookie
operator|::
name|hasSameIdentifier
parameter_list|(
specifier|const
name|QNetworkCookie
modifier|&
name|other
parameter_list|)
specifier|const
block|{
return|return
name|d
operator|->
name|name
operator|==
name|other
operator|.
name|d
operator|->
name|name
operator|&&
name|d
operator|->
name|domain
operator|==
name|other
operator|.
name|d
operator|->
name|domain
operator|&&
name|d
operator|->
name|path
operator|==
name|other
operator|.
name|d
operator|->
name|path
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the "secure" option was specified in the cookie     string, false otherwise.      Secure cookies may contain private information and should not be     resent over unencrypted connections.      \sa setSecure() */
end_comment
begin_function
DECL|function|isSecure
name|bool
name|QNetworkCookie
operator|::
name|isSecure
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|secure
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the secure flag of this cookie to \a enable.      Secure cookies may contain private information and should not be     resent over unencrypted connections.      \sa isSecure() */
end_comment
begin_function
DECL|function|setSecure
name|void
name|QNetworkCookie
operator|::
name|setSecure
parameter_list|(
name|bool
name|enable
parameter_list|)
block|{
name|d
operator|->
name|secure
operator|=
name|enable
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5      Returns true if the "HttpOnly" flag is enabled for this cookie.      A cookie that is "HttpOnly" is only set and retrieved by the     network requests and replies; i.e., the HTTP protocol. It is not     accessible from scripts running on browsers.      \sa isSecure() */
end_comment
begin_function
DECL|function|isHttpOnly
name|bool
name|QNetworkCookie
operator|::
name|isHttpOnly
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|httpOnly
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5      Sets this cookie's "HttpOnly" flag to \a enable. */
end_comment
begin_function
DECL|function|setHttpOnly
name|void
name|QNetworkCookie
operator|::
name|setHttpOnly
parameter_list|(
name|bool
name|enable
parameter_list|)
block|{
name|d
operator|->
name|httpOnly
operator|=
name|enable
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns true if this cookie is a session cookie. A session cookie     is a cookie which has no expiration date, which means it should be     discarded when the application's concept of session is over     (usually, when the application exits).      \sa expirationDate(), setExpirationDate() */
end_comment
begin_function
DECL|function|isSessionCookie
name|bool
name|QNetworkCookie
operator|::
name|isSessionCookie
parameter_list|()
specifier|const
block|{
return|return
operator|!
name|d
operator|->
name|expirationDate
operator|.
name|isValid
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the expiration date for this cookie. If this cookie is a     session cookie, the QDateTime returned will not be valid. If the     date is in the past, this cookie has already expired and should     not be sent again back to a remote server.      The expiration date corresponds to the parameters of the "expires"     entry in the cookie string.      \sa isSessionCookie(), setExpirationDate() */
end_comment
begin_function
DECL|function|expirationDate
name|QDateTime
name|QNetworkCookie
operator|::
name|expirationDate
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|expirationDate
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the expiration date of this cookie to \a date. Setting an     invalid expiration date to this cookie will mean it's a session     cookie.      \sa isSessionCookie(), expirationDate() */
end_comment
begin_function
DECL|function|setExpirationDate
name|void
name|QNetworkCookie
operator|::
name|setExpirationDate
parameter_list|(
specifier|const
name|QDateTime
modifier|&
name|date
parameter_list|)
block|{
name|d
operator|->
name|expirationDate
operator|=
name|date
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the domain this cookie is associated with. This     corresponds to the "domain" field of the cookie string.      Note that the domain here may start with a dot, which is not a     valid hostname. However, it means this cookie matches all     hostnames ending with that domain name.      \sa setDomain() */
end_comment
begin_function
DECL|function|domain
name|QString
name|QNetworkCookie
operator|::
name|domain
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|domain
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the domain associated with this cookie to be \a domain.      \sa domain() */
end_comment
begin_function
DECL|function|setDomain
name|void
name|QNetworkCookie
operator|::
name|setDomain
parameter_list|(
specifier|const
name|QString
modifier|&
name|domain
parameter_list|)
block|{
name|d
operator|->
name|domain
operator|=
name|domain
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the path associated with this cookie. This corresponds to     the "path" field of the cookie string.      \sa setPath() */
end_comment
begin_function
DECL|function|path
name|QString
name|QNetworkCookie
operator|::
name|path
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|path
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the path associated with this cookie to be \a path.      \sa path() */
end_comment
begin_function
DECL|function|setPath
name|void
name|QNetworkCookie
operator|::
name|setPath
parameter_list|(
specifier|const
name|QString
modifier|&
name|path
parameter_list|)
block|{
name|d
operator|->
name|path
operator|=
name|path
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the name of this cookie. The only mandatory field of a     cookie is its name, without which it is not considered valid.      \sa setName(), value() */
end_comment
begin_function
DECL|function|name
name|QByteArray
name|QNetworkCookie
operator|::
name|name
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|name
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the name of this cookie to be \a cookieName. Note that     setting a cookie name to an empty QByteArray will make this cookie     invalid.      \sa name(), value() */
end_comment
begin_function
DECL|function|setName
name|void
name|QNetworkCookie
operator|::
name|setName
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|cookieName
parameter_list|)
block|{
name|d
operator|->
name|name
operator|=
name|cookieName
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns this cookies value, as specified in the cookie     string. Note that a cookie is still valid if its value is empty.      Cookie name-value pairs are considered opaque to the application:     that is, their values don't mean anything.      \sa setValue(), name() */
end_comment
begin_function
DECL|function|value
name|QByteArray
name|QNetworkCookie
operator|::
name|value
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|value
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the value of this cookie to be \a value.      \sa value(), name() */
end_comment
begin_function
DECL|function|setValue
name|void
name|QNetworkCookie
operator|::
name|setValue
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|value
parameter_list|)
block|{
name|d
operator|->
name|value
operator|=
name|value
expr_stmt|;
block|}
end_function
begin_comment
comment|// ### move this to qnetworkcookie_p.h and share with qnetworkaccesshttpbackend
end_comment
begin_function
DECL|function|nextField
specifier|static
name|QPair
argument_list|<
name|QByteArray
argument_list|,
name|QByteArray
argument_list|>
name|nextField
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|text
parameter_list|,
name|int
modifier|&
name|position
parameter_list|,
name|bool
name|isNameValue
parameter_list|)
block|{
comment|// format is one of:
comment|//    (1)  token
comment|//    (2)  token = token
comment|//    (3)  token = quoted-string
specifier|const
name|int
name|length
init|=
name|text
operator|.
name|length
argument_list|()
decl_stmt|;
name|position
operator|=
name|nextNonWhitespace
argument_list|(
name|text
argument_list|,
name|position
argument_list|)
expr_stmt|;
name|int
name|semiColonPosition
init|=
name|text
operator|.
name|indexOf
argument_list|(
literal|';'
argument_list|,
name|position
argument_list|)
decl_stmt|;
if|if
condition|(
name|semiColonPosition
operator|<
literal|0
condition|)
name|semiColonPosition
operator|=
name|length
expr_stmt|;
comment|//no ';' means take everything to end of string
name|int
name|equalsPosition
init|=
name|text
operator|.
name|indexOf
argument_list|(
literal|'='
argument_list|,
name|position
argument_list|)
decl_stmt|;
if|if
condition|(
name|equalsPosition
argument_list|<
literal|0
operator|||
name|equalsPosition
argument_list|>
name|semiColonPosition
condition|)
block|{
if|if
condition|(
name|isNameValue
condition|)
return|return
name|qMakePair
argument_list|(
name|QByteArray
argument_list|()
argument_list|,
name|QByteArray
argument_list|()
argument_list|)
return|;
comment|//'=' is required for name-value-pair (RFC6265 section 5.2, rule 2)
name|equalsPosition
operator|=
name|semiColonPosition
expr_stmt|;
comment|//no '=' means there is an attribute-name but no attribute-value
block|}
name|QByteArray
name|first
init|=
name|text
operator|.
name|mid
argument_list|(
name|position
argument_list|,
name|equalsPosition
operator|-
name|position
argument_list|)
operator|.
name|trimmed
argument_list|()
decl_stmt|;
name|QByteArray
name|second
decl_stmt|;
name|int
name|secondLength
init|=
name|semiColonPosition
operator|-
name|equalsPosition
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|secondLength
operator|>
literal|0
condition|)
name|second
operator|=
name|text
operator|.
name|mid
argument_list|(
name|equalsPosition
operator|+
literal|1
argument_list|,
name|secondLength
argument_list|)
operator|.
name|trimmed
argument_list|()
expr_stmt|;
name|position
operator|=
name|semiColonPosition
expr_stmt|;
return|return
name|qMakePair
argument_list|(
name|first
argument_list|,
name|second
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \enum QNetworkCookie::RawForm      This enum is used with the toRawForm() function to declare which     form of a cookie shall be returned.      \value NameAndValueOnly     makes toRawForm() return only the         "NAME=VALUE" part of the cookie, as suitable for sending back         to a server in a client request's "Cookie:" header. Multiple         cookies are separated by a semi-colon in the "Cookie:" header         field.      \value Full                 makes toRawForm() return the full         cookie contents, as suitable for sending to a client in a         server's "Set-Cookie:" header.      Note that only the Full form of the cookie can be parsed back into     its original contents.      \sa toRawForm(), parseCookies() */
end_comment
begin_comment
comment|/*!     Returns the raw form of this QNetworkCookie. The QByteArray     returned by this function is suitable for an HTTP header, either     in a server response (the Set-Cookie header) or the client request     (the Cookie header). You can choose from one of two formats, using     \a form.      \sa parseCookies() */
end_comment
begin_function
DECL|function|toRawForm
name|QByteArray
name|QNetworkCookie
operator|::
name|toRawForm
parameter_list|(
name|RawForm
name|form
parameter_list|)
specifier|const
block|{
name|QByteArray
name|result
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|name
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|result
return|;
comment|// not a valid cookie
name|result
operator|=
name|d
operator|->
name|name
expr_stmt|;
name|result
operator|+=
literal|'='
expr_stmt|;
name|result
operator|+=
name|d
operator|->
name|value
expr_stmt|;
if|if
condition|(
name|form
operator|==
name|Full
condition|)
block|{
comment|// same as above, but encoding everything back
if|if
condition|(
name|isSecure
argument_list|()
condition|)
name|result
operator|+=
literal|"; secure"
expr_stmt|;
if|if
condition|(
name|isHttpOnly
argument_list|()
condition|)
name|result
operator|+=
literal|"; HttpOnly"
expr_stmt|;
if|if
condition|(
operator|!
name|isSessionCookie
argument_list|()
condition|)
block|{
name|result
operator|+=
literal|"; expires="
expr_stmt|;
name|result
operator|+=
name|QLocale
operator|::
name|c
argument_list|()
operator|.
name|toString
argument_list|(
name|d
operator|->
name|expirationDate
operator|.
name|toUTC
argument_list|()
argument_list|,
name|QLatin1String
argument_list|(
literal|"ddd, dd-MMM-yyyy hh:mm:ss 'GMT"
argument_list|)
argument_list|)
operator|.
name|toLatin1
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|d
operator|->
name|domain
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|result
operator|+=
literal|"; domain="
expr_stmt|;
name|QString
name|domainNoDot
init|=
name|d
operator|->
name|domain
decl_stmt|;
if|if
condition|(
name|domainNoDot
operator|.
name|startsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
argument_list|)
condition|)
block|{
name|result
operator|+=
literal|'.'
expr_stmt|;
name|domainNoDot
operator|=
name|domainNoDot
operator|.
name|mid
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|result
operator|+=
name|QUrl
operator|::
name|toAce
argument_list|(
name|domainNoDot
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|d
operator|->
name|path
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|result
operator|+=
literal|"; path="
expr_stmt|;
name|result
operator|+=
name|d
operator|->
name|path
operator|.
name|toUtf8
argument_list|()
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function
begin_decl_stmt
DECL|variable|zones
specifier|static
specifier|const
name|char
name|zones
index|[]
init|=
literal|"pst\0"
comment|// -8
literal|"pdt\0"
literal|"mst\0"
comment|// -7
literal|"mdt\0"
literal|"cst\0"
comment|// -6
literal|"cdt\0"
literal|"est\0"
comment|// -5
literal|"edt\0"
literal|"ast\0"
comment|// -4
literal|"nst\0"
comment|// -3
literal|"gmt\0"
comment|// 0
literal|"utc\0"
literal|"bst\0"
literal|"met\0"
comment|// 1
literal|"eet\0"
comment|// 2
literal|"jst\0"
comment|// 9
literal|"\0"
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|zoneOffsets
specifier|static
name|int
name|zoneOffsets
index|[]
init|=
block|{
operator|-
literal|8
block|,
operator|-
literal|8
block|,
operator|-
literal|7
block|,
operator|-
literal|7
block|,
operator|-
literal|6
block|,
operator|-
literal|6
block|,
operator|-
literal|5
block|,
operator|-
literal|5
block|,
operator|-
literal|4
block|,
operator|-
literal|3
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|9
block|}
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|months
specifier|static
specifier|const
name|char
name|months
index|[]
init|=
literal|"jan\0"
literal|"feb\0"
literal|"mar\0"
literal|"apr\0"
literal|"may\0"
literal|"jun\0"
literal|"jul\0"
literal|"aug\0"
literal|"sep\0"
literal|"oct\0"
literal|"nov\0"
literal|"dec\0"
literal|"\0"
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|isNumber
specifier|static
specifier|inline
name|bool
name|isNumber
parameter_list|(
name|char
name|s
parameter_list|)
block|{
return|return
name|s
operator|>=
literal|'0'
operator|&&
name|s
operator|<=
literal|'9'
return|;
block|}
end_function
begin_function
DECL|function|isTerminator
specifier|static
specifier|inline
name|bool
name|isTerminator
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|'\r'
return|;
block|}
end_function
begin_function
DECL|function|isValueSeparator
specifier|static
specifier|inline
name|bool
name|isValueSeparator
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
name|isTerminator
argument_list|(
name|c
argument_list|)
operator|||
name|c
operator|==
literal|';'
return|;
block|}
end_function
begin_function
DECL|function|isWhitespace
specifier|static
specifier|inline
name|bool
name|isWhitespace
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
return|;
block|}
end_function
begin_function
DECL|function|checkStaticArray
specifier|static
name|bool
name|checkStaticArray
parameter_list|(
name|int
modifier|&
name|val
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|dateString
parameter_list|,
name|int
name|at
parameter_list|,
specifier|const
name|char
modifier|*
name|array
parameter_list|,
name|int
name|size
parameter_list|)
block|{
if|if
condition|(
name|dateString
index|[
name|at
index|]
operator|<
literal|'a'
operator|||
name|dateString
index|[
name|at
index|]
operator|>
literal|'z'
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|val
operator|==
operator|-
literal|1
operator|&&
name|dateString
operator|.
name|length
argument_list|()
operator|>=
name|at
operator|+
literal|3
condition|)
block|{
name|int
name|j
init|=
literal|0
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|<=
name|size
condition|)
block|{
specifier|const
name|char
modifier|*
name|str
init|=
name|array
operator|+
name|i
decl_stmt|;
if|if
condition|(
name|str
index|[
literal|0
index|]
operator|==
name|dateString
index|[
name|at
index|]
operator|&&
name|str
index|[
literal|1
index|]
operator|==
name|dateString
index|[
name|at
operator|+
literal|1
index|]
operator|&&
name|str
index|[
literal|2
index|]
operator|==
name|dateString
index|[
name|at
operator|+
literal|2
index|]
condition|)
block|{
name|val
operator|=
name|j
expr_stmt|;
return|return
literal|true
return|;
block|}
name|i
operator|+=
name|int
argument_list|(
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|)
operator|+
literal|1
expr_stmt|;
operator|++
name|j
expr_stmt|;
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|//#define PARSEDATESTRINGDEBUG
end_comment
begin_define
DECL|macro|ADAY
define|#
directive|define
name|ADAY
value|1
end_define
begin_define
DECL|macro|AMONTH
define|#
directive|define
name|AMONTH
value|2
end_define
begin_define
DECL|macro|AYEAR
define|#
directive|define
name|AYEAR
value|4
end_define
begin_comment
comment|/*     Parse all the date formats that Firefox can.      The official format is:     expires=ddd(d)?, dd-MMM-yyyy hh:mm:ss GMT      But browsers have been supporting a very wide range of date     strings. To work on many sites we need to support more then     just the official date format.      For reference see Firefox's PR_ParseTimeStringToExplodedTime in     prtime.c. The Firefox date parser is coded in a very complex way     and is slightly over ~700 lines long.  While this implementation     will be slightly slower for the non standard dates it is smaller,     more readable, and maintainable.      Or in their own words:         "} // else what the hell is this." */
end_comment
begin_function
DECL|function|parseDateString
specifier|static
name|QDateTime
name|parseDateString
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|dateString
parameter_list|)
block|{
name|QTime
name|time
decl_stmt|;
comment|// placeholders for values when we are not sure it is a year, month or day
name|int
name|unknown
index|[
literal|3
index|]
init|=
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
name|int
name|month
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|day
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|year
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|zoneOffset
init|=
operator|-
literal|1
decl_stmt|;
comment|// hour:minute:second.ms pm
name|QRegExp
name|timeRx
argument_list|(
name|QLatin1String
argument_list|(
literal|"(\\d{1,2}):(\\d{1,2})(:(\\d{1,2})|)(\\.(\\d{1,3})|)((\\s{0,}(am|pm))|)"
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|at
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|at
operator|<
name|dateString
operator|.
name|length
argument_list|()
condition|)
block|{
ifdef|#
directive|ifdef
name|PARSEDATESTRINGDEBUG
name|qDebug
argument_list|()
operator|<<
name|dateString
operator|.
name|mid
argument_list|(
name|at
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bool
name|isNum
init|=
name|isNumber
argument_list|(
name|dateString
index|[
name|at
index|]
argument_list|)
decl_stmt|;
comment|// Month
if|if
condition|(
operator|!
name|isNum
operator|&&
name|checkStaticArray
argument_list|(
name|month
argument_list|,
name|dateString
argument_list|,
name|at
argument_list|,
name|months
argument_list|,
sizeof|sizeof
argument_list|(
name|months
argument_list|)
operator|-
literal|1
argument_list|)
condition|)
block|{
operator|++
name|month
expr_stmt|;
ifdef|#
directive|ifdef
name|PARSEDATESTRINGDEBUG
name|qDebug
argument_list|()
operator|<<
literal|"Month:"
operator|<<
name|month
expr_stmt|;
endif|#
directive|endif
name|at
operator|+=
literal|3
expr_stmt|;
continue|continue;
block|}
comment|// Zone
if|if
condition|(
operator|!
name|isNum
operator|&&
name|zoneOffset
operator|==
operator|-
literal|1
operator|&&
name|checkStaticArray
argument_list|(
name|zoneOffset
argument_list|,
name|dateString
argument_list|,
name|at
argument_list|,
name|zones
argument_list|,
sizeof|sizeof
argument_list|(
name|zones
argument_list|)
operator|-
literal|1
argument_list|)
condition|)
block|{
name|int
name|sign
init|=
operator|(
name|at
operator|>=
literal|0
operator|&&
name|dateString
index|[
name|at
operator|-
literal|1
index|]
operator|==
literal|'-'
operator|)
condition|?
operator|-
literal|1
else|:
literal|1
decl_stmt|;
name|zoneOffset
operator|=
name|sign
operator|*
name|zoneOffsets
index|[
name|zoneOffset
index|]
operator|*
literal|60
operator|*
literal|60
expr_stmt|;
ifdef|#
directive|ifdef
name|PARSEDATESTRINGDEBUG
name|qDebug
argument_list|()
operator|<<
literal|"Zone:"
operator|<<
name|month
expr_stmt|;
endif|#
directive|endif
name|at
operator|+=
literal|3
expr_stmt|;
continue|continue;
block|}
comment|// Zone offset
if|if
condition|(
operator|!
name|isNum
operator|&&
operator|(
name|zoneOffset
operator|==
operator|-
literal|1
operator|||
name|zoneOffset
operator|==
literal|0
operator|)
comment|// Can only go after gmt
operator|&&
operator|(
name|dateString
index|[
name|at
index|]
operator|==
literal|'+'
operator|||
name|dateString
index|[
name|at
index|]
operator|==
literal|'-'
operator|)
operator|&&
operator|(
name|at
operator|==
literal|0
operator|||
name|isWhitespace
argument_list|(
name|dateString
index|[
name|at
operator|-
literal|1
index|]
argument_list|)
operator|||
name|dateString
index|[
name|at
operator|-
literal|1
index|]
operator|==
literal|','
operator|||
operator|(
name|at
operator|>=
literal|3
operator|&&
operator|(
name|dateString
index|[
name|at
operator|-
literal|3
index|]
operator|==
literal|'g'
operator|)
operator|&&
operator|(
name|dateString
index|[
name|at
operator|-
literal|2
index|]
operator|==
literal|'m'
operator|)
operator|&&
operator|(
name|dateString
index|[
name|at
operator|-
literal|1
index|]
operator|==
literal|'t'
operator|)
operator|)
operator|)
condition|)
block|{
name|int
name|end
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|end
argument_list|<
literal|5
operator|&&
name|dateString
operator|.
name|length
operator|(
operator|)
argument_list|>
name|at
operator|+
name|end
operator|&&
name|dateString
index|[
name|at
operator|+
name|end
index|]
operator|>=
literal|'0'
operator|&&
name|dateString
index|[
name|at
operator|+
name|end
index|]
operator|<=
literal|'9'
condition|)
operator|++
name|end
expr_stmt|;
name|int
name|minutes
init|=
literal|0
decl_stmt|;
name|int
name|hours
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|end
operator|-
literal|1
condition|)
block|{
case|case
literal|4
case|:
name|minutes
operator|=
name|atoi
argument_list|(
name|dateString
operator|.
name|mid
argument_list|(
name|at
operator|+
literal|3
argument_list|,
literal|2
argument_list|)
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
comment|// fall through
case|case
literal|2
case|:
name|hours
operator|=
name|atoi
argument_list|(
name|dateString
operator|.
name|mid
argument_list|(
name|at
operator|+
literal|1
argument_list|,
literal|2
argument_list|)
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|hours
operator|=
name|atoi
argument_list|(
name|dateString
operator|.
name|mid
argument_list|(
name|at
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
name|at
operator|+=
name|end
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|end
operator|!=
literal|1
condition|)
block|{
name|int
name|sign
init|=
name|dateString
index|[
name|at
index|]
operator|==
literal|'-'
condition|?
operator|-
literal|1
else|:
literal|1
decl_stmt|;
name|zoneOffset
operator|=
name|sign
operator|*
operator|(
operator|(
name|minutes
operator|*
literal|60
operator|)
operator|+
operator|(
name|hours
operator|*
literal|60
operator|*
literal|60
operator|)
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PARSEDATESTRINGDEBUG
name|qDebug
argument_list|()
operator|<<
literal|"Zone offset:"
operator|<<
name|zoneOffset
operator|<<
name|hours
operator|<<
name|minutes
expr_stmt|;
endif|#
directive|endif
name|at
operator|+=
name|end
expr_stmt|;
continue|continue;
block|}
block|}
comment|// Time
if|if
condition|(
name|isNum
operator|&&
name|time
operator|.
name|isNull
argument_list|()
operator|&&
name|dateString
operator|.
name|length
argument_list|()
operator|>=
name|at
operator|+
literal|3
operator|&&
operator|(
name|dateString
index|[
name|at
operator|+
literal|2
index|]
operator|==
literal|':'
operator|||
name|dateString
index|[
name|at
operator|+
literal|1
index|]
operator|==
literal|':'
operator|)
condition|)
block|{
comment|// While the date can be found all over the string the format
comment|// for the time is set and a nice regexp can be used.
name|int
name|pos
init|=
name|timeRx
operator|.
name|indexIn
argument_list|(
name|QLatin1String
argument_list|(
name|dateString
argument_list|)
argument_list|,
name|at
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|!=
operator|-
literal|1
condition|)
block|{
name|QStringList
name|list
init|=
name|timeRx
operator|.
name|capturedTexts
argument_list|()
decl_stmt|;
name|int
name|h
init|=
name|atoi
argument_list|(
name|list
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|m
init|=
name|atoi
argument_list|(
name|list
operator|.
name|at
argument_list|(
literal|2
argument_list|)
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|s
init|=
name|atoi
argument_list|(
name|list
operator|.
name|at
argument_list|(
literal|4
argument_list|)
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|ms
init|=
name|atoi
argument_list|(
name|list
operator|.
name|at
argument_list|(
literal|6
argument_list|)
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|h
operator|<
literal|12
operator|&&
operator|!
name|list
operator|.
name|at
argument_list|(
literal|9
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
if|if
condition|(
name|list
operator|.
name|at
argument_list|(
literal|9
argument_list|)
operator|==
name|QLatin1String
argument_list|(
literal|"pm"
argument_list|)
condition|)
name|h
operator|+=
literal|12
expr_stmt|;
name|time
operator|=
name|QTime
argument_list|(
name|h
argument_list|,
name|m
argument_list|,
name|s
argument_list|,
name|ms
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PARSEDATESTRINGDEBUG
name|qDebug
argument_list|()
operator|<<
literal|"Time:"
operator|<<
name|list
operator|<<
name|timeRx
operator|.
name|matchedLength
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|at
operator|+=
name|timeRx
operator|.
name|matchedLength
argument_list|()
expr_stmt|;
continue|continue;
block|}
block|}
comment|// 4 digit Year
if|if
condition|(
name|isNum
operator|&&
name|year
operator|==
operator|-
literal|1
operator|&&
name|dateString
operator|.
name|length
argument_list|()
operator|>
name|at
operator|+
literal|3
condition|)
block|{
if|if
condition|(
name|isNumber
argument_list|(
name|dateString
index|[
name|at
operator|+
literal|1
index|]
argument_list|)
operator|&&
name|isNumber
argument_list|(
name|dateString
index|[
name|at
operator|+
literal|2
index|]
argument_list|)
operator|&&
name|isNumber
argument_list|(
name|dateString
index|[
name|at
operator|+
literal|3
index|]
argument_list|)
condition|)
block|{
name|year
operator|=
name|atoi
argument_list|(
name|dateString
operator|.
name|mid
argument_list|(
name|at
argument_list|,
literal|4
argument_list|)
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
name|at
operator|+=
literal|4
expr_stmt|;
ifdef|#
directive|ifdef
name|PARSEDATESTRINGDEBUG
name|qDebug
argument_list|()
operator|<<
literal|"Year:"
operator|<<
name|year
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
block|}
comment|// a one or two digit number
comment|// Could be month, day or year
if|if
condition|(
name|isNum
condition|)
block|{
name|int
name|length
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|dateString
operator|.
name|length
argument_list|()
operator|>
name|at
operator|+
literal|1
operator|&&
name|isNumber
argument_list|(
name|dateString
index|[
name|at
operator|+
literal|1
index|]
argument_list|)
condition|)
operator|++
name|length
expr_stmt|;
name|int
name|x
init|=
name|atoi
argument_list|(
name|dateString
operator|.
name|mid
argument_list|(
name|at
argument_list|,
name|length
argument_list|)
operator|.
name|constData
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|year
operator|==
operator|-
literal|1
operator|&&
operator|(
name|x
operator|>
literal|31
operator|||
name|x
operator|==
literal|0
operator|)
condition|)
block|{
name|year
operator|=
name|x
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|unknown
index|[
literal|0
index|]
operator|==
operator|-
literal|1
condition|)
name|unknown
index|[
literal|0
index|]
operator|=
name|x
expr_stmt|;
elseif|else
if|if
condition|(
name|unknown
index|[
literal|1
index|]
operator|==
operator|-
literal|1
condition|)
name|unknown
index|[
literal|1
index|]
operator|=
name|x
expr_stmt|;
elseif|else
if|if
condition|(
name|unknown
index|[
literal|2
index|]
operator|==
operator|-
literal|1
condition|)
name|unknown
index|[
literal|2
index|]
operator|=
name|x
expr_stmt|;
block|}
name|at
operator|+=
name|length
expr_stmt|;
ifdef|#
directive|ifdef
name|PARSEDATESTRINGDEBUG
name|qDebug
argument_list|()
operator|<<
literal|"Saving"
operator|<<
name|x
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
comment|// Unknown character, typically a weekday such as 'Mon'
operator|++
name|at
expr_stmt|;
block|}
comment|// Once we are done parsing the string take the digits in unknown
comment|// and determine which is the unknown year/month/day
name|int
name|couldBe
index|[
literal|3
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|int
name|unknownCount
init|=
literal|3
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|unknownCount
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|unknown
index|[
name|i
index|]
operator|==
operator|-
literal|1
condition|)
block|{
name|couldBe
index|[
name|i
index|]
operator|=
name|ADAY
operator||
name|AYEAR
operator||
name|AMONTH
expr_stmt|;
name|unknownCount
operator|=
name|i
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|unknown
index|[
name|i
index|]
operator|>=
literal|1
condition|)
name|couldBe
index|[
name|i
index|]
operator|=
name|ADAY
expr_stmt|;
if|if
condition|(
name|month
operator|==
operator|-
literal|1
operator|&&
name|unknown
index|[
name|i
index|]
operator|>=
literal|1
operator|&&
name|unknown
index|[
name|i
index|]
operator|<=
literal|12
condition|)
name|couldBe
index|[
name|i
index|]
operator||=
name|AMONTH
expr_stmt|;
if|if
condition|(
name|year
operator|==
operator|-
literal|1
condition|)
name|couldBe
index|[
name|i
index|]
operator||=
name|AYEAR
expr_stmt|;
block|}
comment|// For any possible day make sure one of the values that could be a month
comment|// can contain that day.
comment|// For any possible month make sure one of the values that can be a
comment|// day that month can have.
comment|// Example: 31 11 06
comment|// 31 can't be a day because 11 and 6 don't have 31 days
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|unknownCount
condition|;
operator|++
name|i
control|)
block|{
name|int
name|currentValue
init|=
name|unknown
index|[
name|i
index|]
decl_stmt|;
name|bool
name|findMatchingMonth
init|=
name|couldBe
index|[
name|i
index|]
operator|&
name|ADAY
operator|&&
name|currentValue
operator|>=
literal|29
decl_stmt|;
name|bool
name|findMatchingDay
init|=
name|couldBe
index|[
name|i
index|]
operator|&
name|AMONTH
decl_stmt|;
if|if
condition|(
operator|!
name|findMatchingMonth
operator|||
operator|!
name|findMatchingDay
condition|)
continue|continue;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
literal|3
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|j
operator|==
name|i
condition|)
continue|continue;
for|for
control|(
name|int
name|k
init|=
literal|0
init|;
name|k
operator|<
literal|2
condition|;
operator|++
name|k
control|)
block|{
if|if
condition|(
name|k
operator|==
literal|0
operator|&&
operator|!
operator|(
name|findMatchingMonth
operator|&&
operator|(
name|couldBe
index|[
name|j
index|]
operator|&
name|AMONTH
operator|)
operator|)
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|k
operator|==
literal|1
operator|&&
operator|!
operator|(
name|findMatchingDay
operator|&&
operator|(
name|couldBe
index|[
name|j
index|]
operator|&
name|ADAY
operator|)
operator|)
condition|)
continue|continue;
name|int
name|m
init|=
name|currentValue
decl_stmt|;
name|int
name|d
init|=
name|unknown
index|[
name|j
index|]
decl_stmt|;
if|if
condition|(
name|k
operator|==
literal|0
condition|)
name|qSwap
argument_list|(
name|m
argument_list|,
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
operator|-
literal|1
condition|)
name|m
operator|=
name|month
expr_stmt|;
name|bool
name|found
init|=
literal|true
decl_stmt|;
switch|switch
condition|(
name|m
condition|)
block|{
case|case
literal|2
case|:
comment|// When we get 29 and the year ends up having only 28
comment|// See date.isValid below
comment|// Example: 29 23 Feb
if|if
condition|(
name|d
operator|<=
literal|29
condition|)
name|found
operator|=
literal|false
expr_stmt|;
break|break;
case|case
literal|4
case|:
case|case
literal|6
case|:
case|case
literal|9
case|:
case|case
literal|11
case|:
if|if
condition|(
name|d
operator|<=
literal|30
condition|)
name|found
operator|=
literal|false
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|d
operator|>
literal|0
operator|&&
name|d
operator|<=
literal|31
condition|)
name|found
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|k
operator|==
literal|0
condition|)
name|findMatchingMonth
operator|=
name|found
expr_stmt|;
elseif|else
if|if
condition|(
name|k
operator|==
literal|1
condition|)
name|findMatchingDay
operator|=
name|found
expr_stmt|;
block|}
block|}
if|if
condition|(
name|findMatchingMonth
condition|)
name|couldBe
index|[
name|i
index|]
operator|&=
operator|~
name|ADAY
expr_stmt|;
if|if
condition|(
name|findMatchingDay
condition|)
name|couldBe
index|[
name|i
index|]
operator|&=
operator|~
name|AMONTH
expr_stmt|;
block|}
comment|// First set the year/month/day that have been deduced
comment|// and reduce the set as we go along to deduce more
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|unknownCount
condition|;
operator|++
name|i
control|)
block|{
name|int
name|unset
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
literal|3
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|couldBe
index|[
name|j
index|]
operator|==
name|ADAY
operator|&&
name|day
operator|==
operator|-
literal|1
condition|)
block|{
name|day
operator|=
name|unknown
index|[
name|j
index|]
expr_stmt|;
name|unset
operator||=
name|ADAY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|couldBe
index|[
name|j
index|]
operator|==
name|AMONTH
operator|&&
name|month
operator|==
operator|-
literal|1
condition|)
block|{
name|month
operator|=
name|unknown
index|[
name|j
index|]
expr_stmt|;
name|unset
operator||=
name|AMONTH
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|couldBe
index|[
name|j
index|]
operator|==
name|AYEAR
operator|&&
name|year
operator|==
operator|-
literal|1
condition|)
block|{
name|year
operator|=
name|unknown
index|[
name|j
index|]
expr_stmt|;
name|unset
operator||=
name|AYEAR
expr_stmt|;
block|}
else|else
block|{
comment|// common case
break|break;
block|}
name|couldBe
index|[
name|j
index|]
operator|&=
operator|~
name|unset
expr_stmt|;
block|}
block|}
comment|// Now fallback to a standardized order to fill in the rest with
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|unknownCount
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|couldBe
index|[
name|i
index|]
operator|&
name|AMONTH
operator|&&
name|month
operator|==
operator|-
literal|1
condition|)
name|month
operator|=
name|unknown
index|[
name|i
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|couldBe
index|[
name|i
index|]
operator|&
name|ADAY
operator|&&
name|day
operator|==
operator|-
literal|1
condition|)
name|day
operator|=
name|unknown
index|[
name|i
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|couldBe
index|[
name|i
index|]
operator|&
name|AYEAR
operator|&&
name|year
operator|==
operator|-
literal|1
condition|)
name|year
operator|=
name|unknown
index|[
name|i
index|]
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PARSEDATESTRINGDEBUG
name|qDebug
argument_list|()
operator|<<
literal|"Final set"
operator|<<
name|year
operator|<<
name|month
operator|<<
name|day
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|year
operator|==
operator|-
literal|1
operator|||
name|month
operator|==
operator|-
literal|1
operator|||
name|day
operator|==
operator|-
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|PARSEDATESTRINGDEBUG
name|qDebug
argument_list|()
operator|<<
literal|"Parser failure"
operator|<<
name|year
operator|<<
name|month
operator|<<
name|day
expr_stmt|;
endif|#
directive|endif
return|return
name|QDateTime
argument_list|()
return|;
block|}
comment|// Y2k behavior
name|int
name|y2k
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|year
operator|<
literal|70
condition|)
name|y2k
operator|=
literal|2000
expr_stmt|;
elseif|else
if|if
condition|(
name|year
operator|<
literal|100
condition|)
name|y2k
operator|=
literal|1900
expr_stmt|;
name|QDate
name|date
argument_list|(
name|year
operator|+
name|y2k
argument_list|,
name|month
argument_list|,
name|day
argument_list|)
decl_stmt|;
comment|// When we were given a bad cookie that when parsed
comment|// set the day to 29 and the year to one that doesn't
comment|// have the 29th of Feb rather then adding the extra
comment|// complicated checking earlier just swap here.
comment|// Example: 29 23 Feb
if|if
condition|(
operator|!
name|date
operator|.
name|isValid
argument_list|()
condition|)
name|date
operator|=
name|QDate
argument_list|(
name|day
operator|+
name|y2k
argument_list|,
name|month
argument_list|,
name|year
argument_list|)
expr_stmt|;
name|QDateTime
name|dateTime
argument_list|(
name|date
argument_list|,
name|time
argument_list|,
name|Qt
operator|::
name|UTC
argument_list|)
decl_stmt|;
if|if
condition|(
name|zoneOffset
operator|!=
operator|-
literal|1
condition|)
block|{
name|dateTime
operator|=
name|dateTime
operator|.
name|addSecs
argument_list|(
name|zoneOffset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|dateTime
operator|.
name|isValid
argument_list|()
condition|)
return|return
name|QDateTime
argument_list|()
return|;
return|return
name|dateTime
return|;
block|}
end_function
begin_comment
comment|/*!     Parses the cookie string \a cookieString as received from a server     response in the "Set-Cookie:" header. If there's a parsing error,     this function returns an empty list.      Since the HTTP header can set more than one cookie at the same     time, this function returns a QList<QNetworkCookie>, one for each     cookie that is parsed.      \sa toRawForm() */
end_comment
begin_function
DECL|function|parseCookies
name|QList
argument_list|<
name|QNetworkCookie
argument_list|>
name|QNetworkCookie
operator|::
name|parseCookies
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|cookieString
parameter_list|)
block|{
comment|// cookieString can be a number of set-cookie header strings joined together
comment|// by \n, parse each line separately.
name|QList
argument_list|<
name|QNetworkCookie
argument_list|>
name|cookies
decl_stmt|;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|list
init|=
name|cookieString
operator|.
name|split
argument_list|(
literal|'\n'
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|a
init|=
literal|0
init|;
name|a
operator|<
name|list
operator|.
name|size
argument_list|()
condition|;
name|a
operator|++
control|)
name|cookies
operator|+=
name|QNetworkCookiePrivate
operator|::
name|parseSetCookieHeaderLine
argument_list|(
name|list
operator|.
name|at
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cookies
return|;
block|}
end_function
begin_function
DECL|function|parseSetCookieHeaderLine
name|QList
argument_list|<
name|QNetworkCookie
argument_list|>
name|QNetworkCookiePrivate
operator|::
name|parseSetCookieHeaderLine
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|cookieString
parameter_list|)
block|{
comment|// According to http://wp.netscape.com/newsref/std/cookie_spec.html,<
comment|// the Set-Cookie response header is of the format:
comment|//
comment|//   Set-Cookie: NAME=VALUE; expires=DATE; path=PATH; domain=DOMAIN_NAME; secure
comment|//
comment|// where only the NAME=VALUE part is mandatory
comment|//
comment|// We do not support RFC 2965 Set-Cookie2-style cookies
name|QList
argument_list|<
name|QNetworkCookie
argument_list|>
name|result
decl_stmt|;
name|QDateTime
name|now
init|=
name|QDateTime
operator|::
name|currentDateTime
argument_list|()
operator|.
name|toUTC
argument_list|()
decl_stmt|;
name|int
name|position
init|=
literal|0
decl_stmt|;
specifier|const
name|int
name|length
init|=
name|cookieString
operator|.
name|length
argument_list|()
decl_stmt|;
while|while
condition|(
name|position
operator|<
name|length
condition|)
block|{
name|QNetworkCookie
name|cookie
decl_stmt|;
comment|// The first part is always the "NAME=VALUE" part
name|QPair
argument_list|<
name|QByteArray
argument_list|,
name|QByteArray
argument_list|>
name|field
init|=
name|nextField
argument_list|(
name|cookieString
argument_list|,
name|position
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|field
operator|.
name|first
operator|.
name|isEmpty
argument_list|()
condition|)
comment|// parsing error
break|break;
name|cookie
operator|.
name|setName
argument_list|(
name|field
operator|.
name|first
argument_list|)
expr_stmt|;
name|cookie
operator|.
name|setValue
argument_list|(
name|field
operator|.
name|second
argument_list|)
expr_stmt|;
name|position
operator|=
name|nextNonWhitespace
argument_list|(
name|cookieString
argument_list|,
name|position
argument_list|)
expr_stmt|;
while|while
condition|(
name|position
operator|<
name|length
condition|)
block|{
switch|switch
condition|(
name|cookieString
operator|.
name|at
argument_list|(
name|position
operator|++
argument_list|)
condition|)
block|{
case|case
literal|';'
case|:
comment|// new field in the cookie
name|field
operator|=
name|nextField
argument_list|(
name|cookieString
argument_list|,
name|position
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|field
operator|.
name|first
operator|=
name|field
operator|.
name|first
operator|.
name|toLower
argument_list|()
expr_stmt|;
comment|// everything but the NAME=VALUE is case-insensitive
if|if
condition|(
name|field
operator|.
name|first
operator|==
literal|"expires"
condition|)
block|{
name|position
operator|-=
name|field
operator|.
name|second
operator|.
name|length
argument_list|()
expr_stmt|;
name|int
name|end
decl_stmt|;
for|for
control|(
name|end
operator|=
name|position
init|;
name|end
operator|<
name|length
condition|;
operator|++
name|end
control|)
if|if
condition|(
name|isValueSeparator
argument_list|(
name|cookieString
operator|.
name|at
argument_list|(
name|end
argument_list|)
argument_list|)
condition|)
break|break;
name|QByteArray
name|dateString
init|=
name|cookieString
operator|.
name|mid
argument_list|(
name|position
argument_list|,
name|end
operator|-
name|position
argument_list|)
operator|.
name|trimmed
argument_list|()
decl_stmt|;
name|position
operator|=
name|end
expr_stmt|;
name|QDateTime
name|dt
init|=
name|parseDateString
argument_list|(
name|dateString
operator|.
name|toLower
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|dt
operator|.
name|isValid
argument_list|()
condition|)
name|cookie
operator|.
name|setExpirationDate
argument_list|(
name|dt
argument_list|)
expr_stmt|;
comment|//if unparsed, ignore the attribute but not the whole cookie (RFC6265 section 5.2.1)
block|}
elseif|else
if|if
condition|(
name|field
operator|.
name|first
operator|==
literal|"domain"
condition|)
block|{
name|QByteArray
name|rawDomain
init|=
name|field
operator|.
name|second
decl_stmt|;
comment|//empty domain should be ignored (RFC6265 section 5.2.3)
if|if
condition|(
operator|!
name|rawDomain
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QString
name|maybeLeadingDot
decl_stmt|;
if|if
condition|(
name|rawDomain
operator|.
name|startsWith
argument_list|(
literal|'.'
argument_list|)
condition|)
block|{
name|maybeLeadingDot
operator|=
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
name|rawDomain
operator|=
name|rawDomain
operator|.
name|mid
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|//IDN domains are required by RFC6265, accepting utf8 as well doesn't break any test cases.
name|QString
name|normalizedDomain
init|=
name|QUrl
operator|::
name|fromAce
argument_list|(
name|QUrl
operator|::
name|toAce
argument_list|(
name|QString
operator|::
name|fromUtf8
argument_list|(
name|rawDomain
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|normalizedDomain
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|cookie
operator|.
name|setDomain
argument_list|(
name|maybeLeadingDot
operator|+
name|normalizedDomain
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//Normalization fails for malformed domains, e.g. "..example.org", reject the cookie now
comment|//rather than accepting it but never sending it due to domain match failure, as the
comment|//strict reading of RFC6265 would indicate.
return|return
name|result
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|field
operator|.
name|first
operator|==
literal|"max-age"
condition|)
block|{
name|bool
name|ok
init|=
literal|false
decl_stmt|;
name|int
name|secs
init|=
name|field
operator|.
name|second
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
name|ok
condition|)
block|{
if|if
condition|(
name|secs
operator|<=
literal|0
condition|)
block|{
comment|//earliest representable time (RFC6265 section 5.2.2)
name|cookie
operator|.
name|setExpirationDate
argument_list|(
name|QDateTime
operator|::
name|fromTime_t
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cookie
operator|.
name|setExpirationDate
argument_list|(
name|now
operator|.
name|addSecs
argument_list|(
name|secs
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|//if unparsed, ignore the attribute but not the whole cookie (RFC6265 section 5.2.2)
block|}
elseif|else
if|if
condition|(
name|field
operator|.
name|first
operator|==
literal|"path"
condition|)
block|{
if|if
condition|(
name|field
operator|.
name|second
operator|.
name|startsWith
argument_list|(
literal|'/'
argument_list|)
condition|)
block|{
comment|// ### we should treat cookie paths as an octet sequence internally
comment|// However RFC6265 says we should assume UTF-8 for presentation as a string
name|cookie
operator|.
name|setPath
argument_list|(
name|QString
operator|::
name|fromUtf8
argument_list|(
name|field
operator|.
name|second
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// if the path doesn't start with '/' then set the default path (RFC6265 section 5.2.4)
comment|// and also IETF test case path0030 which has valid and empty path in the same cookie
name|cookie
operator|.
name|setPath
argument_list|(
name|QString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|field
operator|.
name|first
operator|==
literal|"secure"
condition|)
block|{
name|cookie
operator|.
name|setSecure
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|field
operator|.
name|first
operator|==
literal|"httponly"
condition|)
block|{
name|cookie
operator|.
name|setHttpOnly
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// ignore unknown fields in the cookie (RFC6265 section 5.2, rule 6)
block|}
name|position
operator|=
name|nextNonWhitespace
argument_list|(
name|cookieString
argument_list|,
name|position
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|cookie
operator|.
name|name
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|result
operator|+=
name|cookie
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!     \since 5.0     This functions normalizes the path and domain of the cookie if they were previously empty.     The \a url parameter is used to determine the correct domain and path. */
end_comment
begin_function
DECL|function|normalize
name|void
name|QNetworkCookie
operator|::
name|normalize
parameter_list|(
specifier|const
name|QUrl
modifier|&
name|url
parameter_list|)
block|{
comment|// don't do path checking. See http://bugreports.qt-project.org/browse/QTBUG-5815
if|if
condition|(
name|d
operator|->
name|path
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QString
name|pathAndFileName
init|=
name|url
operator|.
name|path
argument_list|()
decl_stmt|;
name|QString
name|defaultPath
init|=
name|pathAndFileName
operator|.
name|left
argument_list|(
name|pathAndFileName
operator|.
name|lastIndexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|defaultPath
operator|.
name|isEmpty
argument_list|()
condition|)
name|defaultPath
operator|=
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
expr_stmt|;
name|d
operator|->
name|path
operator|=
name|defaultPath
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|->
name|domain
operator|.
name|isEmpty
argument_list|()
condition|)
name|d
operator|->
name|domain
operator|=
name|url
operator|.
name|host
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|d
operator|->
name|domain
operator|.
name|startsWith
argument_list|(
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
argument_list|)
condition|)
comment|// Ensure the domain starts with a dot if its field was not empty
comment|// in the HTTP header. There are some servers that forget the
comment|// leading dot and this is actually forbidden according to RFC 2109,
comment|// but all browsers accept it anyway so we do that as well.
name|d
operator|->
name|domain
operator|.
name|prepend
argument_list|(
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DEBUG_STREAM
end_ifndef
begin_function
DECL|function|operator <<
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|s
parameter_list|,
specifier|const
name|QNetworkCookie
modifier|&
name|cookie
parameter_list|)
block|{
name|s
operator|.
name|nospace
argument_list|()
operator|<<
literal|"QNetworkCookie("
operator|<<
name|cookie
operator|.
name|toRawForm
argument_list|(
name|QNetworkCookie
operator|::
name|Full
argument_list|)
operator|<<
literal|')'
expr_stmt|;
return|return
name|s
operator|.
name|space
argument_list|()
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
