begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the QtNetwork module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_comment
comment|//#define QHTTP_DEBUG
end_comment
begin_include
include|#
directive|include
file|<qplatformdefs.h>
end_include
begin_include
include|#
directive|include
file|"qhttp.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_HTTP
end_ifndef
begin_include
include|#
directive|include
file|"private/qobject_p.h"
end_include
begin_include
include|#
directive|include
file|"qtcpsocket.h"
end_include
begin_include
include|#
directive|include
file|"qsslsocket.h"
end_include
begin_include
include|#
directive|include
file|"qtextstream.h"
end_include
begin_include
include|#
directive|include
file|"qmap.h"
end_include
begin_include
include|#
directive|include
file|"qlist.h"
end_include
begin_include
include|#
directive|include
file|"qstring.h"
end_include
begin_include
include|#
directive|include
file|"qstringlist.h"
end_include
begin_include
include|#
directive|include
file|"qbuffer.h"
end_include
begin_include
include|#
directive|include
file|"private/qringbuffer_p.h"
end_include
begin_include
include|#
directive|include
file|"qcoreevent.h"
end_include
begin_include
include|#
directive|include
file|"qurl.h"
end_include
begin_include
include|#
directive|include
file|"qnetworkproxy.h"
end_include
begin_include
include|#
directive|include
file|"qauthenticator.h"
end_include
begin_include
include|#
directive|include
file|"qauthenticator_p.h"
end_include
begin_include
include|#
directive|include
file|"qdebug.h"
end_include
begin_include
include|#
directive|include
file|"qtimer.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_HTTP
end_ifndef
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_class_decl
class_decl|class
name|QHttpNormalRequest
class_decl|;
end_class_decl
begin_class
DECL|class|QHttpRequest
class|class
name|QHttpRequest
block|{
public|public:
DECL|function|QHttpRequest
name|QHttpRequest
parameter_list|()
member_init_list|:
name|finished
argument_list|(
literal|false
argument_list|)
block|{
name|id
operator|=
name|idCounter
operator|.
name|fetchAndAddRelaxed
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
DECL|function|~QHttpRequest
specifier|virtual
name|~
name|QHttpRequest
parameter_list|()
block|{ }
specifier|virtual
name|void
name|start
parameter_list|(
name|QHttp
modifier|*
parameter_list|)
function_decl|=
literal|0
function_decl|;
specifier|virtual
name|bool
name|hasRequestHeader
parameter_list|()
function_decl|;
specifier|virtual
name|QHttpRequestHeader
name|requestHeader
parameter_list|()
function_decl|;
specifier|virtual
name|QIODevice
modifier|*
name|sourceDevice
parameter_list|()
function_decl|=
literal|0
function_decl|;
specifier|virtual
name|QIODevice
modifier|*
name|destinationDevice
parameter_list|()
function_decl|=
literal|0
function_decl|;
DECL|member|id
name|int
name|id
decl_stmt|;
DECL|member|finished
name|bool
name|finished
decl_stmt|;
private|private:
DECL|member|idCounter
specifier|static
name|QBasicAtomicInt
name|idCounter
decl_stmt|;
block|}
class|;
end_class
begin_class
DECL|class|QHttpPrivate
class|class
name|QHttpPrivate
super|:
specifier|public
name|QObjectPrivate
block|{
public|public:
name|Q_DECLARE_PUBLIC
argument_list|(
argument|QHttp
argument_list|)
DECL|function|QHttpPrivate
specifier|inline
name|QHttpPrivate
parameter_list|()
member_init_list|:
name|socket
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|reconnectAttempts
argument_list|(
literal|2
argument_list|)
member_init_list|,
name|deleteSocket
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|state
argument_list|(
name|QHttp
operator|::
name|Unconnected
argument_list|)
member_init_list|,
name|error
argument_list|(
name|QHttp
operator|::
name|NoError
argument_list|)
member_init_list|,
name|port
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|mode
argument_list|(
name|QHttp
operator|::
name|ConnectionModeHttp
argument_list|)
member_init_list|,
name|toDevice
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|postDevice
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|bytesDone
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|chunkedSize
argument_list|(
operator|-
literal|1
argument_list|)
member_init_list|,
name|repost
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|pendingPost
argument_list|(
literal|false
argument_list|)
block|{     }
DECL|function|~QHttpPrivate
specifier|inline
name|~
name|QHttpPrivate
parameter_list|()
block|{
while|while
condition|(
operator|!
name|pending
operator|.
name|isEmpty
argument_list|()
condition|)
operator|delete
name|pending
operator|.
name|takeFirst
argument_list|()
expr_stmt|;
if|if
condition|(
name|deleteSocket
condition|)
operator|delete
name|socket
expr_stmt|;
block|}
comment|// private slots
name|void
name|_q_startNextRequest
parameter_list|()
function_decl|;
name|void
name|_q_slotReadyRead
parameter_list|()
function_decl|;
name|void
name|_q_slotConnected
parameter_list|()
function_decl|;
name|void
name|_q_slotError
parameter_list|(
name|QAbstractSocket
operator|::
name|SocketError
parameter_list|)
function_decl|;
name|void
name|_q_slotClosed
parameter_list|()
function_decl|;
name|void
name|_q_slotBytesWritten
parameter_list|(
name|qint64
name|numBytes
parameter_list|)
function_decl|;
ifndef|#
directive|ifndef
name|QT_NO_OPENSSL
name|void
name|_q_slotEncryptedBytesWritten
parameter_list|(
name|qint64
name|numBytes
parameter_list|)
function_decl|;
endif|#
directive|endif
name|void
name|_q_slotDoFinished
parameter_list|()
function_decl|;
name|void
name|_q_slotSendRequest
parameter_list|()
function_decl|;
name|void
name|_q_continuePost
parameter_list|()
function_decl|;
name|int
name|addRequest
parameter_list|(
name|QHttpNormalRequest
modifier|*
parameter_list|)
function_decl|;
name|int
name|addRequest
parameter_list|(
name|QHttpRequest
modifier|*
parameter_list|)
function_decl|;
name|void
name|finishedWithSuccess
parameter_list|()
function_decl|;
name|void
name|finishedWithError
parameter_list|(
specifier|const
name|QString
modifier|&
name|detail
parameter_list|,
name|int
name|errorCode
parameter_list|)
function_decl|;
name|void
name|init
parameter_list|()
function_decl|;
name|void
name|setState
parameter_list|(
name|int
parameter_list|)
function_decl|;
name|void
name|closeConn
parameter_list|()
function_decl|;
name|void
name|setSock
parameter_list|(
name|QTcpSocket
modifier|*
name|sock
parameter_list|)
function_decl|;
name|void
name|postMoreData
parameter_list|()
function_decl|;
DECL|member|socket
name|QTcpSocket
modifier|*
name|socket
decl_stmt|;
DECL|member|reconnectAttempts
name|int
name|reconnectAttempts
decl_stmt|;
DECL|member|deleteSocket
name|bool
name|deleteSocket
decl_stmt|;
DECL|member|pending
name|QList
argument_list|<
name|QHttpRequest
modifier|*
argument_list|>
name|pending
decl_stmt|;
DECL|member|state
name|QHttp
operator|::
name|State
name|state
decl_stmt|;
DECL|member|error
name|QHttp
operator|::
name|Error
name|error
decl_stmt|;
DECL|member|errorString
name|QString
name|errorString
decl_stmt|;
DECL|member|hostName
name|QString
name|hostName
decl_stmt|;
DECL|member|port
name|quint16
name|port
decl_stmt|;
DECL|member|mode
name|QHttp
operator|::
name|ConnectionMode
name|mode
decl_stmt|;
DECL|member|buffer
name|QByteArray
name|buffer
decl_stmt|;
DECL|member|toDevice
name|QIODevice
modifier|*
name|toDevice
decl_stmt|;
DECL|member|postDevice
name|QIODevice
modifier|*
name|postDevice
decl_stmt|;
DECL|member|bytesDone
name|qint64
name|bytesDone
decl_stmt|;
DECL|member|bytesTotal
name|qint64
name|bytesTotal
decl_stmt|;
DECL|member|chunkedSize
name|qint64
name|chunkedSize
decl_stmt|;
DECL|member|header
name|QHttpRequestHeader
name|header
decl_stmt|;
DECL|member|readHeader
name|bool
name|readHeader
decl_stmt|;
DECL|member|headerStr
name|QString
name|headerStr
decl_stmt|;
DECL|member|response
name|QHttpResponseHeader
name|response
decl_stmt|;
DECL|member|rba
name|QRingBuffer
name|rba
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
DECL|member|proxy
name|QNetworkProxy
name|proxy
decl_stmt|;
DECL|member|proxyAuthenticator
name|QAuthenticator
name|proxyAuthenticator
decl_stmt|;
endif|#
directive|endif
DECL|member|authenticator
name|QAuthenticator
name|authenticator
decl_stmt|;
DECL|member|repost
name|bool
name|repost
decl_stmt|;
DECL|member|hasFinishedWithError
name|bool
name|hasFinishedWithError
decl_stmt|;
DECL|member|pendingPost
name|bool
name|pendingPost
decl_stmt|;
DECL|member|post100ContinueTimer
name|QTimer
name|post100ContinueTimer
decl_stmt|;
block|}
class|;
end_class
begin_decl_stmt
DECL|member|idCounter
name|QBasicAtomicInt
name|QHttpRequest
operator|::
name|idCounter
init|=
name|Q_BASIC_ATOMIC_INITIALIZER
argument_list|(
literal|1
argument_list|)
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|hasRequestHeader
name|bool
name|QHttpRequest
operator|::
name|hasRequestHeader
parameter_list|()
block|{
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|requestHeader
name|QHttpRequestHeader
name|QHttpRequest
operator|::
name|requestHeader
parameter_list|()
block|{
return|return
name|QHttpRequestHeader
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/****************************************************  *  * QHttpNormalRequest  *  ****************************************************/
end_comment
begin_class
DECL|class|QHttpNormalRequest
class|class
name|QHttpNormalRequest
super|:
specifier|public
name|QHttpRequest
block|{
public|public:
DECL|function|QHttpNormalRequest
name|QHttpNormalRequest
parameter_list|(
specifier|const
name|QHttpRequestHeader
modifier|&
name|h
parameter_list|,
name|QIODevice
modifier|*
name|d
parameter_list|,
name|QIODevice
modifier|*
name|t
parameter_list|)
member_init_list|:
name|header
argument_list|(
name|h
argument_list|)
member_init_list|,
name|to
argument_list|(
name|t
argument_list|)
block|{
name|is_ba
operator|=
literal|false
expr_stmt|;
name|data
operator|.
name|dev
operator|=
name|d
expr_stmt|;
block|}
DECL|function|QHttpNormalRequest
name|QHttpNormalRequest
parameter_list|(
specifier|const
name|QHttpRequestHeader
modifier|&
name|h
parameter_list|,
name|QByteArray
modifier|*
name|d
parameter_list|,
name|QIODevice
modifier|*
name|t
parameter_list|)
member_init_list|:
name|header
argument_list|(
name|h
argument_list|)
member_init_list|,
name|to
argument_list|(
name|t
argument_list|)
block|{
name|is_ba
operator|=
literal|true
expr_stmt|;
name|data
operator|.
name|ba
operator|=
name|d
expr_stmt|;
block|}
DECL|function|~QHttpNormalRequest
name|~
name|QHttpNormalRequest
parameter_list|()
block|{
if|if
condition|(
name|is_ba
condition|)
operator|delete
name|data
operator|.
name|ba
expr_stmt|;
block|}
name|void
name|start
parameter_list|(
name|QHttp
modifier|*
parameter_list|)
function_decl|;
name|bool
name|hasRequestHeader
parameter_list|()
function_decl|;
name|QHttpRequestHeader
name|requestHeader
parameter_list|()
function_decl|;
DECL|function|setRequestHeader
specifier|inline
name|void
name|setRequestHeader
parameter_list|(
specifier|const
name|QHttpRequestHeader
modifier|&
name|h
parameter_list|)
block|{
name|header
operator|=
name|h
expr_stmt|;
block|}
name|QIODevice
modifier|*
name|sourceDevice
parameter_list|()
function_decl|;
name|QIODevice
modifier|*
name|destinationDevice
parameter_list|()
function_decl|;
protected|protected:
DECL|member|header
name|QHttpRequestHeader
name|header
decl_stmt|;
private|private:
union|union
block|{
DECL|member|ba
name|QByteArray
modifier|*
name|ba
decl_stmt|;
DECL|member|dev
name|QIODevice
modifier|*
name|dev
decl_stmt|;
DECL|member|data
block|}
name|data
union|;
DECL|member|is_ba
name|bool
name|is_ba
decl_stmt|;
DECL|member|to
name|QIODevice
modifier|*
name|to
decl_stmt|;
block|}
class|;
end_class
begin_function
DECL|function|start
name|void
name|QHttpNormalRequest
operator|::
name|start
parameter_list|(
name|QHttp
modifier|*
name|http
parameter_list|)
block|{
if|if
condition|(
operator|!
name|http
operator|->
name|d_func
argument_list|()
operator|->
name|socket
condition|)
name|http
operator|->
name|d_func
argument_list|()
operator|->
name|setSock
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|http
operator|->
name|d_func
argument_list|()
operator|->
name|header
operator|=
name|header
expr_stmt|;
if|if
condition|(
name|is_ba
condition|)
block|{
name|http
operator|->
name|d_func
argument_list|()
operator|->
name|buffer
operator|=
operator|*
name|data
operator|.
name|ba
expr_stmt|;
if|if
condition|(
name|http
operator|->
name|d_func
argument_list|()
operator|->
name|buffer
operator|.
name|size
argument_list|()
operator|>=
literal|0
condition|)
name|http
operator|->
name|d_func
argument_list|()
operator|->
name|header
operator|.
name|setContentLength
argument_list|(
name|http
operator|->
name|d_func
argument_list|()
operator|->
name|buffer
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|http
operator|->
name|d_func
argument_list|()
operator|->
name|postDevice
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|http
operator|->
name|d_func
argument_list|()
operator|->
name|buffer
operator|=
name|QByteArray
argument_list|()
expr_stmt|;
if|if
condition|(
name|data
operator|.
name|dev
operator|&&
operator|(
name|data
operator|.
name|dev
operator|->
name|isOpen
argument_list|()
operator|||
name|data
operator|.
name|dev
operator|->
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
operator|)
condition|)
block|{
name|http
operator|->
name|d_func
argument_list|()
operator|->
name|postDevice
operator|=
name|data
operator|.
name|dev
expr_stmt|;
if|if
condition|(
name|http
operator|->
name|d_func
argument_list|()
operator|->
name|postDevice
operator|->
name|size
argument_list|()
operator|>=
literal|0
condition|)
name|http
operator|->
name|d_func
argument_list|()
operator|->
name|header
operator|.
name|setContentLength
argument_list|(
name|http
operator|->
name|d_func
argument_list|()
operator|->
name|postDevice
operator|->
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|http
operator|->
name|d_func
argument_list|()
operator|->
name|postDevice
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|to
operator|&&
operator|(
name|to
operator|->
name|isOpen
argument_list|()
operator|||
name|to
operator|->
name|open
argument_list|(
name|QIODevice
operator|::
name|WriteOnly
argument_list|)
operator|)
condition|)
name|http
operator|->
name|d_func
argument_list|()
operator|->
name|toDevice
operator|=
name|to
expr_stmt|;
else|else
name|http
operator|->
name|d_func
argument_list|()
operator|->
name|toDevice
operator|=
literal|0
expr_stmt|;
name|http
operator|->
name|d_func
argument_list|()
operator|->
name|reconnectAttempts
operator|=
literal|2
expr_stmt|;
name|http
operator|->
name|d_func
argument_list|()
operator|->
name|_q_slotSendRequest
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|hasRequestHeader
name|bool
name|QHttpNormalRequest
operator|::
name|hasRequestHeader
parameter_list|()
block|{
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|requestHeader
name|QHttpRequestHeader
name|QHttpNormalRequest
operator|::
name|requestHeader
parameter_list|()
block|{
return|return
name|header
return|;
block|}
end_function
begin_function
DECL|function|sourceDevice
name|QIODevice
modifier|*
name|QHttpNormalRequest
operator|::
name|sourceDevice
parameter_list|()
block|{
if|if
condition|(
name|is_ba
condition|)
return|return
literal|0
return|;
return|return
name|data
operator|.
name|dev
return|;
block|}
end_function
begin_function
DECL|function|destinationDevice
name|QIODevice
modifier|*
name|QHttpNormalRequest
operator|::
name|destinationDevice
parameter_list|()
block|{
return|return
name|to
return|;
block|}
end_function
begin_comment
comment|/****************************************************  *  * QHttpPGHRequest  * (like a QHttpNormalRequest, but for the convenience  * functions put(), get() and head() -- i.e. set the  * host header field correctly before sending the  * request)  *  ****************************************************/
end_comment
begin_class
DECL|class|QHttpPGHRequest
class|class
name|QHttpPGHRequest
super|:
specifier|public
name|QHttpNormalRequest
block|{
public|public:
DECL|function|QHttpPGHRequest
name|QHttpPGHRequest
parameter_list|(
specifier|const
name|QHttpRequestHeader
modifier|&
name|h
parameter_list|,
name|QIODevice
modifier|*
name|d
parameter_list|,
name|QIODevice
modifier|*
name|t
parameter_list|)
member_init_list|:
name|QHttpNormalRequest
argument_list|(
name|h
argument_list|,
name|d
argument_list|,
name|t
argument_list|)
block|{ }
DECL|function|QHttpPGHRequest
name|QHttpPGHRequest
parameter_list|(
specifier|const
name|QHttpRequestHeader
modifier|&
name|h
parameter_list|,
name|QByteArray
modifier|*
name|d
parameter_list|,
name|QIODevice
modifier|*
name|t
parameter_list|)
member_init_list|:
name|QHttpNormalRequest
argument_list|(
name|h
argument_list|,
name|d
argument_list|,
name|t
argument_list|)
block|{ }
DECL|function|~QHttpPGHRequest
name|~
name|QHttpPGHRequest
parameter_list|()
block|{ }
name|void
name|start
parameter_list|(
name|QHttp
modifier|*
parameter_list|)
function_decl|;
block|}
class|;
end_class
begin_function
DECL|function|start
name|void
name|QHttpPGHRequest
operator|::
name|start
parameter_list|(
name|QHttp
modifier|*
name|http
parameter_list|)
block|{
if|if
condition|(
name|http
operator|->
name|d_func
argument_list|()
operator|->
name|port
operator|&&
name|http
operator|->
name|d_func
argument_list|()
operator|->
name|port
operator|!=
literal|80
condition|)
name|header
operator|.
name|setValue
argument_list|(
name|QLatin1String
argument_list|(
literal|"Host"
argument_list|)
argument_list|,
name|http
operator|->
name|d_func
argument_list|()
operator|->
name|hostName
operator|+
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
operator|+
name|QString
operator|::
name|number
argument_list|(
name|http
operator|->
name|d_func
argument_list|()
operator|->
name|port
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|header
operator|.
name|setValue
argument_list|(
name|QLatin1String
argument_list|(
literal|"Host"
argument_list|)
argument_list|,
name|http
operator|->
name|d_func
argument_list|()
operator|->
name|hostName
argument_list|)
expr_stmt|;
name|QHttpNormalRequest
operator|::
name|start
argument_list|(
name|http
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/****************************************************  *  * QHttpSetHostRequest  *  ****************************************************/
end_comment
begin_class
DECL|class|QHttpSetHostRequest
class|class
name|QHttpSetHostRequest
super|:
specifier|public
name|QHttpRequest
block|{
public|public:
DECL|function|QHttpSetHostRequest
name|QHttpSetHostRequest
parameter_list|(
specifier|const
name|QString
modifier|&
name|h
parameter_list|,
name|quint16
name|p
parameter_list|,
name|QHttp
operator|::
name|ConnectionMode
name|m
parameter_list|)
member_init_list|:
name|hostName
argument_list|(
name|h
argument_list|)
member_init_list|,
name|port
argument_list|(
name|p
argument_list|)
member_init_list|,
name|mode
argument_list|(
name|m
argument_list|)
block|{ }
name|void
name|start
parameter_list|(
name|QHttp
modifier|*
parameter_list|)
function_decl|;
DECL|function|sourceDevice
name|QIODevice
modifier|*
name|sourceDevice
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
DECL|function|destinationDevice
name|QIODevice
modifier|*
name|destinationDevice
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
private|private:
DECL|member|hostName
name|QString
name|hostName
decl_stmt|;
DECL|member|port
name|quint16
name|port
decl_stmt|;
DECL|member|mode
name|QHttp
operator|::
name|ConnectionMode
name|mode
decl_stmt|;
block|}
class|;
end_class
begin_function
DECL|function|start
name|void
name|QHttpSetHostRequest
operator|::
name|start
parameter_list|(
name|QHttp
modifier|*
name|http
parameter_list|)
block|{
name|http
operator|->
name|d_func
argument_list|()
operator|->
name|hostName
operator|=
name|hostName
expr_stmt|;
name|http
operator|->
name|d_func
argument_list|()
operator|->
name|port
operator|=
name|port
expr_stmt|;
name|http
operator|->
name|d_func
argument_list|()
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
ifdef|#
directive|ifdef
name|QT_NO_OPENSSL
if|if
condition|(
name|mode
operator|==
name|QHttp
operator|::
name|ConnectionModeHttps
condition|)
block|{
comment|// SSL requested but no SSL support compiled in
name|http
operator|->
name|d_func
argument_list|()
operator|->
name|finishedWithError
argument_list|(
name|QLatin1String
argument_list|(
name|QT_TRANSLATE_NOOP
argument_list|(
literal|"QHttp"
argument_list|,
literal|"HTTPS connection requested but SSL support not compiled in"
argument_list|)
argument_list|)
argument_list|,
name|QHttp
operator|::
name|UnknownError
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|http
operator|->
name|d_func
argument_list|()
operator|->
name|finishedWithSuccess
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/****************************************************  *  * QHttpSetUserRequest  *  ****************************************************/
end_comment
begin_class
DECL|class|QHttpSetUserRequest
class|class
name|QHttpSetUserRequest
super|:
specifier|public
name|QHttpRequest
block|{
public|public:
DECL|function|QHttpSetUserRequest
name|QHttpSetUserRequest
parameter_list|(
specifier|const
name|QString
modifier|&
name|userName
parameter_list|,
specifier|const
name|QString
modifier|&
name|password
parameter_list|)
member_init_list|:
name|user
argument_list|(
name|userName
argument_list|)
member_init_list|,
name|pass
argument_list|(
name|password
argument_list|)
block|{ }
name|void
name|start
parameter_list|(
name|QHttp
modifier|*
parameter_list|)
function_decl|;
DECL|function|sourceDevice
name|QIODevice
modifier|*
name|sourceDevice
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
DECL|function|destinationDevice
name|QIODevice
modifier|*
name|destinationDevice
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
private|private:
DECL|member|user
name|QString
name|user
decl_stmt|;
DECL|member|pass
name|QString
name|pass
decl_stmt|;
block|}
class|;
end_class
begin_function
DECL|function|start
name|void
name|QHttpSetUserRequest
operator|::
name|start
parameter_list|(
name|QHttp
modifier|*
name|http
parameter_list|)
block|{
name|http
operator|->
name|d_func
argument_list|()
operator|->
name|authenticator
operator|.
name|setUser
argument_list|(
name|user
argument_list|)
expr_stmt|;
name|http
operator|->
name|d_func
argument_list|()
operator|->
name|authenticator
operator|.
name|setPassword
argument_list|(
name|pass
argument_list|)
expr_stmt|;
name|http
operator|->
name|d_func
argument_list|()
operator|->
name|finishedWithSuccess
argument_list|()
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
end_ifndef
begin_comment
comment|/****************************************************  *  * QHttpSetProxyRequest  *  ****************************************************/
end_comment
begin_class
DECL|class|QHttpSetProxyRequest
class|class
name|QHttpSetProxyRequest
super|:
specifier|public
name|QHttpRequest
block|{
public|public:
DECL|function|QHttpSetProxyRequest
specifier|inline
name|QHttpSetProxyRequest
parameter_list|(
specifier|const
name|QNetworkProxy
modifier|&
name|proxy
parameter_list|)
block|{
name|this
operator|->
name|proxy
operator|=
name|proxy
expr_stmt|;
block|}
DECL|function|start
specifier|inline
name|void
name|start
parameter_list|(
name|QHttp
modifier|*
name|http
parameter_list|)
block|{
name|http
operator|->
name|d_func
argument_list|()
operator|->
name|proxy
operator|=
name|proxy
expr_stmt|;
name|QString
name|user
init|=
name|proxy
operator|.
name|user
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|user
operator|.
name|isEmpty
argument_list|()
condition|)
name|http
operator|->
name|d_func
argument_list|()
operator|->
name|proxyAuthenticator
operator|.
name|setUser
argument_list|(
name|user
argument_list|)
expr_stmt|;
name|QString
name|password
init|=
name|proxy
operator|.
name|password
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|password
operator|.
name|isEmpty
argument_list|()
condition|)
name|http
operator|->
name|d_func
argument_list|()
operator|->
name|proxyAuthenticator
operator|.
name|setPassword
argument_list|(
name|password
argument_list|)
expr_stmt|;
name|http
operator|->
name|d_func
argument_list|()
operator|->
name|finishedWithSuccess
argument_list|()
expr_stmt|;
block|}
DECL|function|sourceDevice
specifier|inline
name|QIODevice
modifier|*
name|sourceDevice
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
DECL|function|destinationDevice
specifier|inline
name|QIODevice
modifier|*
name|destinationDevice
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
private|private:
DECL|member|proxy
name|QNetworkProxy
name|proxy
decl_stmt|;
block|}
class|;
end_class
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_NETWORKPROXY
end_comment
begin_comment
comment|/****************************************************  *  * QHttpSetSocketRequest  *  ****************************************************/
end_comment
begin_class
DECL|class|QHttpSetSocketRequest
class|class
name|QHttpSetSocketRequest
super|:
specifier|public
name|QHttpRequest
block|{
public|public:
DECL|function|QHttpSetSocketRequest
name|QHttpSetSocketRequest
parameter_list|(
name|QTcpSocket
modifier|*
name|s
parameter_list|)
member_init_list|:
name|socket
argument_list|(
name|s
argument_list|)
block|{ }
name|void
name|start
parameter_list|(
name|QHttp
modifier|*
parameter_list|)
function_decl|;
DECL|function|sourceDevice
name|QIODevice
modifier|*
name|sourceDevice
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
DECL|function|destinationDevice
name|QIODevice
modifier|*
name|destinationDevice
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
private|private:
DECL|member|socket
name|QTcpSocket
modifier|*
name|socket
decl_stmt|;
block|}
class|;
end_class
begin_function
DECL|function|start
name|void
name|QHttpSetSocketRequest
operator|::
name|start
parameter_list|(
name|QHttp
modifier|*
name|http
parameter_list|)
block|{
name|http
operator|->
name|d_func
argument_list|()
operator|->
name|setSock
argument_list|(
name|socket
argument_list|)
expr_stmt|;
name|http
operator|->
name|d_func
argument_list|()
operator|->
name|finishedWithSuccess
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/****************************************************  *  * QHttpCloseRequest  *  ****************************************************/
end_comment
begin_class
DECL|class|QHttpCloseRequest
class|class
name|QHttpCloseRequest
super|:
specifier|public
name|QHttpRequest
block|{
public|public:
DECL|function|QHttpCloseRequest
name|QHttpCloseRequest
parameter_list|()
block|{ }
name|void
name|start
parameter_list|(
name|QHttp
modifier|*
parameter_list|)
function_decl|;
DECL|function|sourceDevice
name|QIODevice
modifier|*
name|sourceDevice
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
DECL|function|destinationDevice
name|QIODevice
modifier|*
name|destinationDevice
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
block|}
class|;
end_class
begin_function
DECL|function|start
name|void
name|QHttpCloseRequest
operator|::
name|start
parameter_list|(
name|QHttp
modifier|*
name|http
parameter_list|)
block|{
name|http
operator|->
name|d_func
argument_list|()
operator|->
name|closeConn
argument_list|()
expr_stmt|;
block|}
end_function
begin_class
DECL|class|QHttpHeaderPrivate
class|class
name|QHttpHeaderPrivate
block|{
name|Q_DECLARE_PUBLIC
parameter_list|(
name|QHttpHeader
parameter_list|)
specifier|public
private|:
DECL|function|~QHttpHeaderPrivate
specifier|inline
specifier|virtual
name|~
name|QHttpHeaderPrivate
parameter_list|()
block|{}
DECL|member|values
name|QList
argument_list|<
name|QPair
argument_list|<
name|QString
argument_list|,
name|QString
argument_list|>
argument_list|>
name|values
decl_stmt|;
DECL|member|valid
name|bool
name|valid
decl_stmt|;
DECL|member|q_ptr
name|QHttpHeader
modifier|*
name|q_ptr
decl_stmt|;
block|}
class|;
end_class
begin_comment
comment|/****************************************************  *  * QHttpHeader  *  ****************************************************/
end_comment
begin_comment
comment|/*!     \class QHttpHeader     \obsolete     \brief The QHttpHeader class contains header information for HTTP.      \ingroup network     \inmodule QtNetwork      In most cases you should use the more specialized derivatives of     this class, QHttpResponseHeader and QHttpRequestHeader, rather     than directly using QHttpHeader.      QHttpHeader provides the HTTP header fields. A HTTP header field     consists of a name followed by a colon, a single space, and the     field value. (See RFC 1945.) Field names are case-insensitive. A     typical header field looks like this:     \snippet doc/src/snippets/code/src_network_access_qhttp.cpp 0      In the API the header field name is called the "key" and the     content is called the "value". You can get and set a header     field's value by using its key with value() and setValue(), e.g.     \snippet doc/src/snippets/code/src_network_access_qhttp.cpp 1      Some fields are so common that getters and setters are provided     for them as a convenient alternative to using \l value() and     \l setValue(), e.g. contentLength() and contentType(),     setContentLength() and setContentType().      Each header key has a \e single value associated with it. If you     set the value for a key which already exists the previous value     will be discarded.      \sa QHttpRequestHeader QHttpResponseHeader */
end_comment
begin_comment
comment|/*!     \fn int QHttpHeader::majorVersion() const      Returns the major protocol-version of the HTTP header. */
end_comment
begin_comment
comment|/*!     \fn int QHttpHeader::minorVersion() const      Returns the minor protocol-version of the HTTP header. */
end_comment
begin_comment
comment|/*!         Constructs an empty HTTP header. */
end_comment
begin_constructor
DECL|function|QHttpHeader
name|QHttpHeader
operator|::
name|QHttpHeader
parameter_list|()
member_init_list|:
name|d_ptr
argument_list|(
operator|new
name|QHttpHeaderPrivate
argument_list|)
block|{
name|Q_D
argument_list|(
name|QHttpHeader
argument_list|)
expr_stmt|;
name|d
operator|->
name|q_ptr
operator|=
name|this
expr_stmt|;
name|d
operator|->
name|valid
operator|=
literal|true
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!         Constructs a copy of \a header. */
end_comment
begin_constructor
DECL|function|QHttpHeader
name|QHttpHeader
operator|::
name|QHttpHeader
parameter_list|(
specifier|const
name|QHttpHeader
modifier|&
name|header
parameter_list|)
member_init_list|:
name|d_ptr
argument_list|(
operator|new
name|QHttpHeaderPrivate
argument_list|)
block|{
name|Q_D
argument_list|(
name|QHttpHeader
argument_list|)
expr_stmt|;
name|d
operator|->
name|q_ptr
operator|=
name|this
expr_stmt|;
name|d
operator|->
name|valid
operator|=
name|header
operator|.
name|d_func
argument_list|()
operator|->
name|valid
expr_stmt|;
name|d
operator|->
name|values
operator|=
name|header
operator|.
name|d_func
argument_list|()
operator|->
name|values
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a HTTP header for \a str.      This constructor parses the string \a str for header fields and     adds this information. The \a str should consist of one or more     "\r\n" delimited lines; each of these lines should have the format     key, colon, space, value. */
end_comment
begin_constructor
DECL|function|QHttpHeader
name|QHttpHeader
operator|::
name|QHttpHeader
parameter_list|(
specifier|const
name|QString
modifier|&
name|str
parameter_list|)
member_init_list|:
name|d_ptr
argument_list|(
operator|new
name|QHttpHeaderPrivate
argument_list|)
block|{
name|Q_D
argument_list|(
name|QHttpHeader
argument_list|)
expr_stmt|;
name|d
operator|->
name|q_ptr
operator|=
name|this
expr_stmt|;
name|d
operator|->
name|valid
operator|=
literal|true
expr_stmt|;
name|parse
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*! \internal  */
end_comment
begin_constructor
DECL|function|QHttpHeader
name|QHttpHeader
operator|::
name|QHttpHeader
parameter_list|(
name|QHttpHeaderPrivate
modifier|&
name|dd
parameter_list|,
specifier|const
name|QString
modifier|&
name|str
parameter_list|)
member_init_list|:
name|d_ptr
argument_list|(
operator|&
name|dd
argument_list|)
block|{
name|Q_D
argument_list|(
name|QHttpHeader
argument_list|)
expr_stmt|;
name|d
operator|->
name|q_ptr
operator|=
name|this
expr_stmt|;
name|d
operator|->
name|valid
operator|=
literal|true
expr_stmt|;
if|if
condition|(
operator|!
name|str
operator|.
name|isEmpty
argument_list|()
condition|)
name|parse
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*! \internal  */
end_comment
begin_constructor
DECL|function|QHttpHeader
name|QHttpHeader
operator|::
name|QHttpHeader
parameter_list|(
name|QHttpHeaderPrivate
modifier|&
name|dd
parameter_list|,
specifier|const
name|QHttpHeader
modifier|&
name|header
parameter_list|)
member_init_list|:
name|d_ptr
argument_list|(
operator|&
name|dd
argument_list|)
block|{
name|Q_D
argument_list|(
name|QHttpHeader
argument_list|)
expr_stmt|;
name|d
operator|->
name|q_ptr
operator|=
name|this
expr_stmt|;
name|d
operator|->
name|valid
operator|=
name|header
operator|.
name|d_func
argument_list|()
operator|->
name|valid
expr_stmt|;
name|d
operator|->
name|values
operator|=
name|header
operator|.
name|d_func
argument_list|()
operator|->
name|values
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Destructor. */
end_comment
begin_destructor
DECL|function|~QHttpHeader
name|QHttpHeader
operator|::
name|~
name|QHttpHeader
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     Assigns \a h and returns a reference to this http header. */
end_comment
begin_function
DECL|function|operator =
name|QHttpHeader
modifier|&
name|QHttpHeader
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QHttpHeader
modifier|&
name|h
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QHttpHeader
argument_list|)
expr_stmt|;
name|d
operator|->
name|values
operator|=
name|h
operator|.
name|d_func
argument_list|()
operator|->
name|values
expr_stmt|;
name|d
operator|->
name|valid
operator|=
name|h
operator|.
name|d_func
argument_list|()
operator|->
name|valid
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the HTTP header is valid; otherwise returns false.      A QHttpHeader is invalid if it was created by parsing a malformed string. */
end_comment
begin_function
DECL|function|isValid
name|bool
name|QHttpHeader
operator|::
name|isValid
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QHttpHeader
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|valid
return|;
block|}
end_function
begin_comment
comment|/*! \internal     Parses the HTTP header string \a str for header fields and adds     the keys/values it finds. If the string is not parsed successfully     the QHttpHeader becomes \link isValid() invalid\endlink.      Returns true if \a str was successfully parsed; otherwise returns false.      \sa toString() */
end_comment
begin_function
DECL|function|parse
name|bool
name|QHttpHeader
operator|::
name|parse
parameter_list|(
specifier|const
name|QString
modifier|&
name|str
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QHttpHeader
argument_list|)
expr_stmt|;
name|QStringList
name|lst
decl_stmt|;
name|int
name|pos
init|=
name|str
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'\n'
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|>
literal|0
operator|&&
name|str
operator|.
name|at
argument_list|(
name|pos
operator|-
literal|1
argument_list|)
operator|==
name|QLatin1Char
argument_list|(
literal|'\r'
argument_list|)
condition|)
name|lst
operator|=
name|str
operator|.
name|trimmed
argument_list|()
operator|.
name|split
argument_list|(
name|QLatin1String
argument_list|(
literal|"\r\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|lst
operator|=
name|str
operator|.
name|trimmed
argument_list|()
operator|.
name|split
argument_list|(
name|QLatin1String
argument_list|(
literal|"\n"
argument_list|)
argument_list|)
expr_stmt|;
name|lst
operator|.
name|removeAll
argument_list|(
name|QString
argument_list|()
argument_list|)
expr_stmt|;
comment|// No empties
if|if
condition|(
name|lst
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|true
return|;
name|QStringList
name|lines
decl_stmt|;
name|QStringList
operator|::
name|Iterator
name|it
init|=
name|lst
operator|.
name|begin
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|lst
operator|.
name|end
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|it
operator|)
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|it
operator|)
index|[
literal|0
index|]
operator|.
name|isSpace
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|lines
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|lines
operator|.
name|last
argument_list|()
operator|+=
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|lines
operator|.
name|last
argument_list|()
operator|+=
operator|(
operator|*
name|it
operator|)
operator|.
name|trimmed
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|lines
operator|.
name|append
argument_list|(
operator|(
operator|*
name|it
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|int
name|number
init|=
literal|0
decl_stmt|;
name|it
operator|=
name|lines
operator|.
name|begin
argument_list|()
expr_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|lines
operator|.
name|end
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
if|if
condition|(
operator|!
name|parseLine
argument_list|(
operator|*
name|it
argument_list|,
name|number
operator|++
argument_list|)
condition|)
block|{
name|d
operator|->
name|valid
operator|=
literal|false
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*! \internal */
end_comment
begin_function
DECL|function|setValid
name|void
name|QHttpHeader
operator|::
name|setValid
parameter_list|(
name|bool
name|v
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QHttpHeader
argument_list|)
expr_stmt|;
name|d
operator|->
name|valid
operator|=
name|v
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the first value for the entry with the given \a key. If no entry     has this \a key, an empty string is returned.      \sa setValue() removeValue() hasKey() keys() */
end_comment
begin_function
DECL|function|value
name|QString
name|QHttpHeader
operator|::
name|value
parameter_list|(
specifier|const
name|QString
modifier|&
name|key
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QHttpHeader
argument_list|)
expr_stmt|;
name|QString
name|lowercaseKey
init|=
name|key
operator|.
name|toLower
argument_list|()
decl_stmt|;
name|QList
argument_list|<
name|QPair
argument_list|<
name|QString
argument_list|,
name|QString
argument_list|>
argument_list|>
operator|::
name|ConstIterator
name|it
init|=
name|d
operator|->
name|values
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|d
operator|->
name|values
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|it
operator|)
operator|.
name|first
operator|.
name|toLower
argument_list|()
operator|==
name|lowercaseKey
condition|)
return|return
operator|(
operator|*
name|it
operator|)
operator|.
name|second
return|;
operator|++
name|it
expr_stmt|;
block|}
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns all the entries with the given \a key. If no entry     has this \a key, an empty string list is returned. */
end_comment
begin_function
DECL|function|allValues
name|QStringList
name|QHttpHeader
operator|::
name|allValues
parameter_list|(
specifier|const
name|QString
modifier|&
name|key
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QHttpHeader
argument_list|)
expr_stmt|;
name|QString
name|lowercaseKey
init|=
name|key
operator|.
name|toLower
argument_list|()
decl_stmt|;
name|QStringList
name|valueList
decl_stmt|;
name|QList
argument_list|<
name|QPair
argument_list|<
name|QString
argument_list|,
name|QString
argument_list|>
argument_list|>
operator|::
name|ConstIterator
name|it
init|=
name|d
operator|->
name|values
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|d
operator|->
name|values
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|it
operator|)
operator|.
name|first
operator|.
name|toLower
argument_list|()
operator|==
name|lowercaseKey
condition|)
name|valueList
operator|.
name|append
argument_list|(
operator|(
operator|*
name|it
operator|)
operator|.
name|second
argument_list|)
expr_stmt|;
operator|++
name|it
expr_stmt|;
block|}
return|return
name|valueList
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a list of the keys in the HTTP header.      \sa hasKey() */
end_comment
begin_function
DECL|function|keys
name|QStringList
name|QHttpHeader
operator|::
name|keys
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QHttpHeader
argument_list|)
expr_stmt|;
name|QStringList
name|keyList
decl_stmt|;
name|QSet
argument_list|<
name|QString
argument_list|>
name|seenKeys
decl_stmt|;
name|QList
argument_list|<
name|QPair
argument_list|<
name|QString
argument_list|,
name|QString
argument_list|>
argument_list|>
operator|::
name|ConstIterator
name|it
init|=
name|d
operator|->
name|values
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|d
operator|->
name|values
operator|.
name|constEnd
argument_list|()
condition|)
block|{
specifier|const
name|QString
modifier|&
name|key
init|=
operator|(
operator|*
name|it
operator|)
operator|.
name|first
decl_stmt|;
name|QString
name|lowercaseKey
init|=
name|key
operator|.
name|toLower
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|seenKeys
operator|.
name|contains
argument_list|(
name|lowercaseKey
argument_list|)
condition|)
block|{
name|keyList
operator|.
name|append
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|seenKeys
operator|.
name|insert
argument_list|(
name|lowercaseKey
argument_list|)
expr_stmt|;
block|}
operator|++
name|it
expr_stmt|;
block|}
return|return
name|keyList
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the HTTP header has an entry with the given \a     key; otherwise returns false.      \sa value() setValue() keys() */
end_comment
begin_function
DECL|function|hasKey
name|bool
name|QHttpHeader
operator|::
name|hasKey
parameter_list|(
specifier|const
name|QString
modifier|&
name|key
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QHttpHeader
argument_list|)
expr_stmt|;
name|QString
name|lowercaseKey
init|=
name|key
operator|.
name|toLower
argument_list|()
decl_stmt|;
name|QList
argument_list|<
name|QPair
argument_list|<
name|QString
argument_list|,
name|QString
argument_list|>
argument_list|>
operator|::
name|ConstIterator
name|it
init|=
name|d
operator|->
name|values
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|d
operator|->
name|values
operator|.
name|constEnd
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|it
operator|)
operator|.
name|first
operator|.
name|toLower
argument_list|()
operator|==
name|lowercaseKey
condition|)
return|return
literal|true
return|;
operator|++
name|it
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the value of the entry with the \a key to \a value.      If no entry with \a key exists, a new entry with the given \a key     and \a value is created. If an entry with the \a key already     exists, the first value is discarded and replaced with the given     \a value.      \sa value() hasKey() removeValue() */
end_comment
begin_function
DECL|function|setValue
name|void
name|QHttpHeader
operator|::
name|setValue
parameter_list|(
specifier|const
name|QString
modifier|&
name|key
parameter_list|,
specifier|const
name|QString
modifier|&
name|value
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QHttpHeader
argument_list|)
expr_stmt|;
name|QString
name|lowercaseKey
init|=
name|key
operator|.
name|toLower
argument_list|()
decl_stmt|;
name|QList
argument_list|<
name|QPair
argument_list|<
name|QString
argument_list|,
name|QString
argument_list|>
argument_list|>
operator|::
name|Iterator
name|it
init|=
name|d
operator|->
name|values
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|d
operator|->
name|values
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|it
operator|)
operator|.
name|first
operator|.
name|toLower
argument_list|()
operator|==
name|lowercaseKey
condition|)
block|{
operator|(
operator|*
name|it
operator|)
operator|.
name|second
operator|=
name|value
expr_stmt|;
return|return;
block|}
operator|++
name|it
expr_stmt|;
block|}
comment|// not found so add
name|addValue
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the header entries to be the list of key value pairs in \a values. */
end_comment
begin_function
DECL|function|setValues
name|void
name|QHttpHeader
operator|::
name|setValues
parameter_list|(
specifier|const
name|QList
argument_list|<
name|QPair
argument_list|<
name|QString
argument_list|,
name|QString
argument_list|>
argument_list|>
modifier|&
name|values
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QHttpHeader
argument_list|)
expr_stmt|;
name|d
operator|->
name|values
operator|=
name|values
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Adds a new entry with the \a key and \a value. */
end_comment
begin_function
DECL|function|addValue
name|void
name|QHttpHeader
operator|::
name|addValue
parameter_list|(
specifier|const
name|QString
modifier|&
name|key
parameter_list|,
specifier|const
name|QString
modifier|&
name|value
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QHttpHeader
argument_list|)
expr_stmt|;
name|d
operator|->
name|values
operator|.
name|append
argument_list|(
name|qMakePair
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns all the entries in the header. */
end_comment
begin_function
DECL|function|values
name|QList
argument_list|<
name|QPair
argument_list|<
name|QString
argument_list|,
name|QString
argument_list|>
argument_list|>
name|QHttpHeader
operator|::
name|values
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QHttpHeader
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|values
return|;
block|}
end_function
begin_comment
comment|/*!     Removes the entry with the key \a key from the HTTP header.      \sa value() setValue() */
end_comment
begin_function
DECL|function|removeValue
name|void
name|QHttpHeader
operator|::
name|removeValue
parameter_list|(
specifier|const
name|QString
modifier|&
name|key
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QHttpHeader
argument_list|)
expr_stmt|;
name|QString
name|lowercaseKey
init|=
name|key
operator|.
name|toLower
argument_list|()
decl_stmt|;
name|QList
argument_list|<
name|QPair
argument_list|<
name|QString
argument_list|,
name|QString
argument_list|>
argument_list|>
operator|::
name|Iterator
name|it
init|=
name|d
operator|->
name|values
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|d
operator|->
name|values
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|it
operator|)
operator|.
name|first
operator|.
name|toLower
argument_list|()
operator|==
name|lowercaseKey
condition|)
block|{
name|d
operator|->
name|values
operator|.
name|erase
argument_list|(
name|it
argument_list|)
expr_stmt|;
return|return;
block|}
operator|++
name|it
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Removes all the entries with the key \a key from the HTTP header. */
end_comment
begin_function
DECL|function|removeAllValues
name|void
name|QHttpHeader
operator|::
name|removeAllValues
parameter_list|(
specifier|const
name|QString
modifier|&
name|key
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QHttpHeader
argument_list|)
expr_stmt|;
name|QString
name|lowercaseKey
init|=
name|key
operator|.
name|toLower
argument_list|()
decl_stmt|;
name|QList
argument_list|<
name|QPair
argument_list|<
name|QString
argument_list|,
name|QString
argument_list|>
argument_list|>
operator|::
name|Iterator
name|it
init|=
name|d
operator|->
name|values
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|d
operator|->
name|values
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|it
operator|)
operator|.
name|first
operator|.
name|toLower
argument_list|()
operator|==
name|lowercaseKey
condition|)
block|{
name|it
operator|=
name|d
operator|->
name|values
operator|.
name|erase
argument_list|(
name|it
argument_list|)
expr_stmt|;
continue|continue;
block|}
operator|++
name|it
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*! \internal     Parses the single HTTP header line \a line which has the format     key, colon, space, value, and adds key/value to the headers. The     linenumber is \a number. Returns true if the line was successfully     parsed and the key/value added; otherwise returns false.      \sa parse() */
end_comment
begin_function
DECL|function|parseLine
name|bool
name|QHttpHeader
operator|::
name|parseLine
parameter_list|(
specifier|const
name|QString
modifier|&
name|line
parameter_list|,
name|int
parameter_list|)
block|{
name|int
name|i
init|=
name|line
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
return|return
literal|false
return|;
name|addValue
argument_list|(
name|line
operator|.
name|left
argument_list|(
name|i
argument_list|)
operator|.
name|trimmed
argument_list|()
argument_list|,
name|line
operator|.
name|mid
argument_list|(
name|i
operator|+
literal|1
argument_list|)
operator|.
name|trimmed
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a string representation of the HTTP header.      The string is suitable for use by the constructor that takes a     QString. It consists of lines with the format: key, colon, space,     value, "\r\n". */
end_comment
begin_function
DECL|function|toString
name|QString
name|QHttpHeader
operator|::
name|toString
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QHttpHeader
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
return|return
name|QLatin1String
argument_list|(
literal|""
argument_list|)
return|;
name|QString
name|ret
init|=
name|QLatin1String
argument_list|(
literal|""
argument_list|)
decl_stmt|;
name|QList
argument_list|<
name|QPair
argument_list|<
name|QString
argument_list|,
name|QString
argument_list|>
argument_list|>
operator|::
name|ConstIterator
name|it
init|=
name|d
operator|->
name|values
operator|.
name|constBegin
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|d
operator|->
name|values
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|ret
operator|+=
operator|(
operator|*
name|it
operator|)
operator|.
name|first
operator|+
name|QLatin1String
argument_list|(
literal|": "
argument_list|)
operator|+
operator|(
operator|*
name|it
operator|)
operator|.
name|second
operator|+
name|QLatin1String
argument_list|(
literal|"\r\n"
argument_list|)
expr_stmt|;
operator|++
name|it
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the header has an entry for the special HTTP     header field \c content-length; otherwise returns false.      \sa contentLength() setContentLength() */
end_comment
begin_function
DECL|function|hasContentLength
name|bool
name|QHttpHeader
operator|::
name|hasContentLength
parameter_list|()
specifier|const
block|{
return|return
name|hasKey
argument_list|(
name|QLatin1String
argument_list|(
literal|"content-length"
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the value of the special HTTP header field \c     content-length.      \sa setContentLength() hasContentLength() */
end_comment
begin_function
DECL|function|contentLength
name|uint
name|QHttpHeader
operator|::
name|contentLength
parameter_list|()
specifier|const
block|{
return|return
name|value
argument_list|(
name|QLatin1String
argument_list|(
literal|"content-length"
argument_list|)
argument_list|)
operator|.
name|toUInt
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the value of the special HTTP header field \c content-length     to \a len.      \sa contentLength() hasContentLength() */
end_comment
begin_function
DECL|function|setContentLength
name|void
name|QHttpHeader
operator|::
name|setContentLength
parameter_list|(
name|int
name|len
parameter_list|)
block|{
name|setValue
argument_list|(
name|QLatin1String
argument_list|(
literal|"content-length"
argument_list|)
argument_list|,
name|QString
operator|::
name|number
argument_list|(
name|len
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the header has an entry for the special HTTP     header field \c content-type; otherwise returns false.      \sa contentType() setContentType() */
end_comment
begin_function
DECL|function|hasContentType
name|bool
name|QHttpHeader
operator|::
name|hasContentType
parameter_list|()
specifier|const
block|{
return|return
name|hasKey
argument_list|(
name|QLatin1String
argument_list|(
literal|"content-type"
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the value of the special HTTP header field \c content-type.      \sa setContentType() hasContentType() */
end_comment
begin_function
DECL|function|contentType
name|QString
name|QHttpHeader
operator|::
name|contentType
parameter_list|()
specifier|const
block|{
name|QString
name|type
init|=
name|value
argument_list|(
name|QLatin1String
argument_list|(
literal|"content-type"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|type
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|QString
argument_list|()
return|;
name|int
name|pos
init|=
name|type
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|';'
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|==
operator|-
literal|1
condition|)
return|return
name|type
return|;
return|return
name|type
operator|.
name|left
argument_list|(
name|pos
argument_list|)
operator|.
name|trimmed
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the value of the special HTTP header field \c content-type to     \a type.      \sa contentType() hasContentType() */
end_comment
begin_function
DECL|function|setContentType
name|void
name|QHttpHeader
operator|::
name|setContentType
parameter_list|(
specifier|const
name|QString
modifier|&
name|type
parameter_list|)
block|{
name|setValue
argument_list|(
name|QLatin1String
argument_list|(
literal|"content-type"
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_function
begin_class
DECL|class|QHttpResponseHeaderPrivate
class|class
name|QHttpResponseHeaderPrivate
super|:
specifier|public
name|QHttpHeaderPrivate
block|{
name|Q_DECLARE_PUBLIC
parameter_list|(
name|QHttpResponseHeader
parameter_list|)
specifier|public
private|:
DECL|member|statCode
name|int
name|statCode
decl_stmt|;
DECL|member|reasonPhr
name|QString
name|reasonPhr
decl_stmt|;
DECL|member|majVer
name|int
name|majVer
decl_stmt|;
DECL|member|minVer
name|int
name|minVer
decl_stmt|;
block|}
class|;
end_class
begin_comment
comment|/****************************************************  *  * QHttpResponseHeader  *  ****************************************************/
end_comment
begin_comment
comment|/*!     \class QHttpResponseHeader     \obsolete     \brief The QHttpResponseHeader class contains response header information for HTTP.      \ingroup network     \inmodule QtNetwork      This class is used by the QHttp class to report the header     information that the client received from the server.      HTTP responses have a status code that indicates the status of the     response. This code is a 3-digit integer result code (for details     see to RFC 1945). In addition to the status code, you can also     specify a human-readable text that describes the reason for the     code ("reason phrase"). This class allows you to get the status     code and the reason phrase.      \sa QHttpRequestHeader, QHttp, {HTTP Example} */
end_comment
begin_comment
comment|/*!     Constructs an empty HTTP response header. */
end_comment
begin_constructor
DECL|function|QHttpResponseHeader
name|QHttpResponseHeader
operator|::
name|QHttpResponseHeader
parameter_list|()
member_init_list|:
name|QHttpHeader
argument_list|(
operator|*
operator|new
name|QHttpResponseHeaderPrivate
argument_list|)
block|{
name|setValid
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a copy of \a header. */
end_comment
begin_constructor
DECL|function|QHttpResponseHeader
name|QHttpResponseHeader
operator|::
name|QHttpResponseHeader
parameter_list|(
specifier|const
name|QHttpResponseHeader
modifier|&
name|header
parameter_list|)
member_init_list|:
name|QHttpHeader
argument_list|(
operator|*
operator|new
name|QHttpResponseHeaderPrivate
argument_list|,
name|header
argument_list|)
block|{
name|Q_D
argument_list|(
name|QHttpResponseHeader
argument_list|)
expr_stmt|;
name|d
operator|->
name|statCode
operator|=
name|header
operator|.
name|d_func
argument_list|()
operator|->
name|statCode
expr_stmt|;
name|d
operator|->
name|reasonPhr
operator|=
name|header
operator|.
name|d_func
argument_list|()
operator|->
name|reasonPhr
expr_stmt|;
name|d
operator|->
name|majVer
operator|=
name|header
operator|.
name|d_func
argument_list|()
operator|->
name|majVer
expr_stmt|;
name|d
operator|->
name|minVer
operator|=
name|header
operator|.
name|d_func
argument_list|()
operator|->
name|minVer
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Copies the contents of \a header into this QHttpResponseHeader. */
end_comment
begin_function
DECL|function|operator =
name|QHttpResponseHeader
modifier|&
name|QHttpResponseHeader
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QHttpResponseHeader
modifier|&
name|header
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QHttpResponseHeader
argument_list|)
expr_stmt|;
name|QHttpHeader
operator|::
name|operator
name|=
parameter_list|(
name|header
parameter_list|)
function_decl|;
name|d
operator|->
name|statCode
operator|=
name|header
operator|.
name|d_func
argument_list|()
operator|->
name|statCode
expr_stmt|;
name|d
operator|->
name|reasonPhr
operator|=
name|header
operator|.
name|d_func
argument_list|()
operator|->
name|reasonPhr
expr_stmt|;
name|d
operator|->
name|majVer
operator|=
name|header
operator|.
name|d_func
argument_list|()
operator|->
name|majVer
expr_stmt|;
name|d
operator|->
name|minVer
operator|=
name|header
operator|.
name|d_func
argument_list|()
operator|->
name|minVer
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     Constructs a HTTP response header from the string \a str. The     string is parsed and the information is set. The \a str should     consist of one or more "\r\n" delimited lines; the first line should be the     status-line (format: HTTP-version, space, status-code, space,     reason-phrase); each of remaining lines should have the format key, colon,     space, value. */
end_comment
begin_constructor
DECL|function|QHttpResponseHeader
name|QHttpResponseHeader
operator|::
name|QHttpResponseHeader
parameter_list|(
specifier|const
name|QString
modifier|&
name|str
parameter_list|)
member_init_list|:
name|QHttpHeader
argument_list|(
operator|*
operator|new
name|QHttpResponseHeaderPrivate
argument_list|)
block|{
name|parse
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     \since 4.1      Constructs a QHttpResponseHeader, setting the status code to \a code, the     reason phrase to \a text and the protocol-version to \a majorVer and \a     minorVer.      \sa statusCode() reasonPhrase() majorVersion() minorVersion() */
end_comment
begin_constructor
DECL|function|QHttpResponseHeader
name|QHttpResponseHeader
operator|::
name|QHttpResponseHeader
parameter_list|(
name|int
name|code
parameter_list|,
specifier|const
name|QString
modifier|&
name|text
parameter_list|,
name|int
name|majorVer
parameter_list|,
name|int
name|minorVer
parameter_list|)
member_init_list|:
name|QHttpHeader
argument_list|(
operator|*
operator|new
name|QHttpResponseHeaderPrivate
argument_list|)
block|{
name|setStatusLine
argument_list|(
name|code
argument_list|,
name|text
argument_list|,
name|majorVer
argument_list|,
name|minorVer
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     \since 4.1      Sets the status code to \a code, the reason phrase to \a text and     the protocol-version to \a majorVer and \a minorVer.      \sa statusCode() reasonPhrase() majorVersion() minorVersion() */
end_comment
begin_function
DECL|function|setStatusLine
name|void
name|QHttpResponseHeader
operator|::
name|setStatusLine
parameter_list|(
name|int
name|code
parameter_list|,
specifier|const
name|QString
modifier|&
name|text
parameter_list|,
name|int
name|majorVer
parameter_list|,
name|int
name|minorVer
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QHttpResponseHeader
argument_list|)
expr_stmt|;
name|setValid
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|d
operator|->
name|statCode
operator|=
name|code
expr_stmt|;
name|d
operator|->
name|reasonPhr
operator|=
name|text
expr_stmt|;
name|d
operator|->
name|majVer
operator|=
name|majorVer
expr_stmt|;
name|d
operator|->
name|minVer
operator|=
name|minorVer
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the status code of the HTTP response header.      \sa reasonPhrase() majorVersion() minorVersion() */
end_comment
begin_function
DECL|function|statusCode
name|int
name|QHttpResponseHeader
operator|::
name|statusCode
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QHttpResponseHeader
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|statCode
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the reason phrase of the HTTP response header.      \sa statusCode() majorVersion() minorVersion() */
end_comment
begin_function
DECL|function|reasonPhrase
name|QString
name|QHttpResponseHeader
operator|::
name|reasonPhrase
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QHttpResponseHeader
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|reasonPhr
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the major protocol-version of the HTTP response header.      \sa minorVersion() statusCode() reasonPhrase() */
end_comment
begin_function
DECL|function|majorVersion
name|int
name|QHttpResponseHeader
operator|::
name|majorVersion
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QHttpResponseHeader
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|majVer
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the minor protocol-version of the HTTP response header.      \sa majorVersion() statusCode() reasonPhrase() */
end_comment
begin_function
DECL|function|minorVersion
name|int
name|QHttpResponseHeader
operator|::
name|minorVersion
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QHttpResponseHeader
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|minVer
return|;
block|}
end_function
begin_comment
comment|/*! \internal */
end_comment
begin_function
DECL|function|parseLine
name|bool
name|QHttpResponseHeader
operator|::
name|parseLine
parameter_list|(
specifier|const
name|QString
modifier|&
name|line
parameter_list|,
name|int
name|number
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QHttpResponseHeader
argument_list|)
expr_stmt|;
if|if
condition|(
name|number
operator|!=
literal|0
condition|)
return|return
name|QHttpHeader
operator|::
name|parseLine
argument_list|(
name|line
argument_list|,
name|number
argument_list|)
return|;
name|QString
name|l
init|=
name|line
operator|.
name|simplified
argument_list|()
decl_stmt|;
if|if
condition|(
name|l
operator|.
name|length
argument_list|()
operator|<
literal|10
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|l
operator|.
name|left
argument_list|(
literal|5
argument_list|)
operator|==
name|QLatin1String
argument_list|(
literal|"HTTP/"
argument_list|)
operator|&&
name|l
index|[
literal|5
index|]
operator|.
name|isDigit
argument_list|()
operator|&&
name|l
index|[
literal|6
index|]
operator|==
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
operator|&&
name|l
index|[
literal|7
index|]
operator|.
name|isDigit
argument_list|()
operator|&&
name|l
index|[
literal|8
index|]
operator|==
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
operator|&&
name|l
index|[
literal|9
index|]
operator|.
name|isDigit
argument_list|()
condition|)
block|{
name|d
operator|->
name|majVer
operator|=
name|l
index|[
literal|5
index|]
operator|.
name|toLatin1
argument_list|()
operator|-
literal|'0'
expr_stmt|;
name|d
operator|->
name|minVer
operator|=
name|l
index|[
literal|7
index|]
operator|.
name|toLatin1
argument_list|()
operator|-
literal|'0'
expr_stmt|;
name|int
name|pos
init|=
name|l
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|,
literal|9
argument_list|)
decl_stmt|;
if|if
condition|(
name|pos
operator|!=
operator|-
literal|1
condition|)
block|{
name|d
operator|->
name|reasonPhr
operator|=
name|l
operator|.
name|mid
argument_list|(
name|pos
operator|+
literal|1
argument_list|)
expr_stmt|;
name|d
operator|->
name|statCode
operator|=
name|l
operator|.
name|mid
argument_list|(
literal|9
argument_list|,
name|pos
operator|-
literal|9
argument_list|)
operator|.
name|toInt
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|statCode
operator|=
name|l
operator|.
name|mid
argument_list|(
literal|9
argument_list|)
operator|.
name|toInt
argument_list|()
expr_stmt|;
name|d
operator|->
name|reasonPhr
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|toString
name|QString
name|QHttpResponseHeader
operator|::
name|toString
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QHttpResponseHeader
argument_list|)
expr_stmt|;
name|QString
name|ret
argument_list|(
name|QLatin1String
argument_list|(
literal|"HTTP/%1.%2 %3 %4\r\n%5\r\n"
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|ret
operator|.
name|arg
argument_list|(
name|d
operator|->
name|majVer
argument_list|)
operator|.
name|arg
argument_list|(
name|d
operator|->
name|minVer
argument_list|)
operator|.
name|arg
argument_list|(
name|d
operator|->
name|statCode
argument_list|)
operator|.
name|arg
argument_list|(
name|d
operator|->
name|reasonPhr
argument_list|)
operator|.
name|arg
argument_list|(
name|QHttpHeader
operator|::
name|toString
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_class
DECL|class|QHttpRequestHeaderPrivate
class|class
name|QHttpRequestHeaderPrivate
super|:
specifier|public
name|QHttpHeaderPrivate
block|{
name|Q_DECLARE_PUBLIC
parameter_list|(
name|QHttpRequestHeader
parameter_list|)
specifier|public
private|:
DECL|member|m
name|QString
name|m
decl_stmt|;
DECL|member|p
name|QString
name|p
decl_stmt|;
DECL|member|majVer
name|int
name|majVer
decl_stmt|;
DECL|member|minVer
name|int
name|minVer
decl_stmt|;
block|}
class|;
end_class
begin_comment
comment|/****************************************************  *  * QHttpRequestHeader  *  ****************************************************/
end_comment
begin_comment
comment|/*!     \class QHttpRequestHeader     \obsolete     \brief The QHttpRequestHeader class contains request header information for HTTP.      \ingroup network     \inmodule QtNetwork      This class is used in the QHttp class to report the header     information if the client requests something from the server.      HTTP requests have a method which describes the request's action.     The most common requests are "GET" and "POST". In addition to the     request method the header also includes a request-URI to specify     the location for the method to use.      The method, request-URI and protocol-version can be set using a     constructor or later using setRequest(). The values can be     obtained using method(), path(), majorVersion() and     minorVersion().      Note that the request-URI must be in the format expected by the     HTTP server. That is, all reserved characters must be encoded in     %HH (where HH are two hexadecimal digits). See     QUrl::toPercentEncoding() for more information.      Important inherited functions: setValue() and value().      \sa QHttpResponseHeader QHttp */
end_comment
begin_comment
comment|/*!     Constructs an empty HTTP request header. */
end_comment
begin_constructor
DECL|function|QHttpRequestHeader
name|QHttpRequestHeader
operator|::
name|QHttpRequestHeader
parameter_list|()
member_init_list|:
name|QHttpHeader
argument_list|(
operator|*
operator|new
name|QHttpRequestHeaderPrivate
argument_list|)
block|{
name|setValid
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a HTTP request header for the method \a method, the     request-URI \a path and the protocol-version \a majorVer and \a     minorVer. The \a path argument must be properly encoded for an     HTTP request. */
end_comment
begin_constructor
DECL|function|QHttpRequestHeader
name|QHttpRequestHeader
operator|::
name|QHttpRequestHeader
parameter_list|(
specifier|const
name|QString
modifier|&
name|method
parameter_list|,
specifier|const
name|QString
modifier|&
name|path
parameter_list|,
name|int
name|majorVer
parameter_list|,
name|int
name|minorVer
parameter_list|)
member_init_list|:
name|QHttpHeader
argument_list|(
operator|*
operator|new
name|QHttpRequestHeaderPrivate
argument_list|)
block|{
name|Q_D
argument_list|(
name|QHttpRequestHeader
argument_list|)
expr_stmt|;
name|d
operator|->
name|m
operator|=
name|method
expr_stmt|;
name|d
operator|->
name|p
operator|=
name|path
expr_stmt|;
name|d
operator|->
name|majVer
operator|=
name|majorVer
expr_stmt|;
name|d
operator|->
name|minVer
operator|=
name|minorVer
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a copy of \a header. */
end_comment
begin_constructor
DECL|function|QHttpRequestHeader
name|QHttpRequestHeader
operator|::
name|QHttpRequestHeader
parameter_list|(
specifier|const
name|QHttpRequestHeader
modifier|&
name|header
parameter_list|)
member_init_list|:
name|QHttpHeader
argument_list|(
operator|*
operator|new
name|QHttpRequestHeaderPrivate
argument_list|,
name|header
argument_list|)
block|{
name|Q_D
argument_list|(
name|QHttpRequestHeader
argument_list|)
expr_stmt|;
name|d
operator|->
name|m
operator|=
name|header
operator|.
name|d_func
argument_list|()
operator|->
name|m
expr_stmt|;
name|d
operator|->
name|p
operator|=
name|header
operator|.
name|d_func
argument_list|()
operator|->
name|p
expr_stmt|;
name|d
operator|->
name|majVer
operator|=
name|header
operator|.
name|d_func
argument_list|()
operator|->
name|majVer
expr_stmt|;
name|d
operator|->
name|minVer
operator|=
name|header
operator|.
name|d_func
argument_list|()
operator|->
name|minVer
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Copies the content of \a header into this QHttpRequestHeader */
end_comment
begin_function
DECL|function|operator =
name|QHttpRequestHeader
modifier|&
name|QHttpRequestHeader
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QHttpRequestHeader
modifier|&
name|header
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QHttpRequestHeader
argument_list|)
expr_stmt|;
name|QHttpHeader
operator|::
name|operator
name|=
parameter_list|(
name|header
parameter_list|)
function_decl|;
name|d
operator|->
name|m
operator|=
name|header
operator|.
name|d_func
argument_list|()
operator|->
name|m
expr_stmt|;
name|d
operator|->
name|p
operator|=
name|header
operator|.
name|d_func
argument_list|()
operator|->
name|p
expr_stmt|;
name|d
operator|->
name|majVer
operator|=
name|header
operator|.
name|d_func
argument_list|()
operator|->
name|majVer
expr_stmt|;
name|d
operator|->
name|minVer
operator|=
name|header
operator|.
name|d_func
argument_list|()
operator|->
name|minVer
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     Constructs a HTTP request header from the string \a str. The \a     str should consist of one or more "\r\n" delimited lines; the first line     should be the request-line (format: method, space, request-URI, space     HTTP-version); each of the remaining lines should have the format key,     colon, space, value. */
end_comment
begin_constructor
DECL|function|QHttpRequestHeader
name|QHttpRequestHeader
operator|::
name|QHttpRequestHeader
parameter_list|(
specifier|const
name|QString
modifier|&
name|str
parameter_list|)
member_init_list|:
name|QHttpHeader
argument_list|(
operator|*
operator|new
name|QHttpRequestHeaderPrivate
argument_list|)
block|{
name|parse
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     This function sets the request method to \a method, the     request-URI to \a path and the protocol-version to \a majorVer and     \a minorVer. The \a path argument must be properly encoded for an     HTTP request.      \sa method() path() majorVersion() minorVersion() */
end_comment
begin_function
DECL|function|setRequest
name|void
name|QHttpRequestHeader
operator|::
name|setRequest
parameter_list|(
specifier|const
name|QString
modifier|&
name|method
parameter_list|,
specifier|const
name|QString
modifier|&
name|path
parameter_list|,
name|int
name|majorVer
parameter_list|,
name|int
name|minorVer
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QHttpRequestHeader
argument_list|)
expr_stmt|;
name|setValid
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|d
operator|->
name|m
operator|=
name|method
expr_stmt|;
name|d
operator|->
name|p
operator|=
name|path
expr_stmt|;
name|d
operator|->
name|majVer
operator|=
name|majorVer
expr_stmt|;
name|d
operator|->
name|minVer
operator|=
name|minorVer
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the method of the HTTP request header.      \sa path() majorVersion() minorVersion() setRequest() */
end_comment
begin_function
DECL|function|method
name|QString
name|QHttpRequestHeader
operator|::
name|method
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QHttpRequestHeader
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|m
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the request-URI of the HTTP request header.      \sa method() majorVersion() minorVersion() setRequest() */
end_comment
begin_function
DECL|function|path
name|QString
name|QHttpRequestHeader
operator|::
name|path
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QHttpRequestHeader
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|p
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the major protocol-version of the HTTP request header.      \sa minorVersion() method() path() setRequest() */
end_comment
begin_function
DECL|function|majorVersion
name|int
name|QHttpRequestHeader
operator|::
name|majorVersion
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QHttpRequestHeader
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|majVer
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the minor protocol-version of the HTTP request header.      \sa majorVersion() method() path() setRequest() */
end_comment
begin_function
DECL|function|minorVersion
name|int
name|QHttpRequestHeader
operator|::
name|minorVersion
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QHttpRequestHeader
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|minVer
return|;
block|}
end_function
begin_comment
comment|/*! \internal */
end_comment
begin_function
DECL|function|parseLine
name|bool
name|QHttpRequestHeader
operator|::
name|parseLine
parameter_list|(
specifier|const
name|QString
modifier|&
name|line
parameter_list|,
name|int
name|number
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QHttpRequestHeader
argument_list|)
expr_stmt|;
if|if
condition|(
name|number
operator|!=
literal|0
condition|)
return|return
name|QHttpHeader
operator|::
name|parseLine
argument_list|(
name|line
argument_list|,
name|number
argument_list|)
return|;
name|QStringList
name|lst
init|=
name|line
operator|.
name|simplified
argument_list|()
operator|.
name|split
argument_list|(
name|QLatin1String
argument_list|(
literal|" "
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|lst
operator|.
name|count
argument_list|()
operator|>
literal|0
condition|)
block|{
name|d
operator|->
name|m
operator|=
name|lst
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|lst
operator|.
name|count
argument_list|()
operator|>
literal|1
condition|)
block|{
name|d
operator|->
name|p
operator|=
name|lst
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|lst
operator|.
name|count
argument_list|()
operator|>
literal|2
condition|)
block|{
name|QString
name|v
init|=
name|lst
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|v
operator|.
name|length
argument_list|()
operator|>=
literal|8
operator|&&
name|v
operator|.
name|left
argument_list|(
literal|5
argument_list|)
operator|==
name|QLatin1String
argument_list|(
literal|"HTTP/"
argument_list|)
operator|&&
name|v
index|[
literal|5
index|]
operator|.
name|isDigit
argument_list|()
operator|&&
name|v
index|[
literal|6
index|]
operator|==
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
operator|&&
name|v
index|[
literal|7
index|]
operator|.
name|isDigit
argument_list|()
condition|)
block|{
name|d
operator|->
name|majVer
operator|=
name|v
index|[
literal|5
index|]
operator|.
name|toLatin1
argument_list|()
operator|-
literal|'0'
expr_stmt|;
name|d
operator|->
name|minVer
operator|=
name|v
index|[
literal|7
index|]
operator|.
name|toLatin1
argument_list|()
operator|-
literal|'0'
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
block|}
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|toString
name|QString
name|QHttpRequestHeader
operator|::
name|toString
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QHttpRequestHeader
argument_list|)
expr_stmt|;
name|QString
name|first
argument_list|(
name|QLatin1String
argument_list|(
literal|"%1 %2"
argument_list|)
argument_list|)
decl_stmt|;
name|QString
name|last
argument_list|(
name|QLatin1String
argument_list|(
literal|" HTTP/%3.%4\r\n%5\r\n"
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|first
operator|.
name|arg
argument_list|(
name|d
operator|->
name|m
argument_list|)
operator|.
name|arg
argument_list|(
name|d
operator|->
name|p
argument_list|)
operator|+
name|last
operator|.
name|arg
argument_list|(
name|d
operator|->
name|majVer
argument_list|)
operator|.
name|arg
argument_list|(
name|d
operator|->
name|minVer
argument_list|)
operator|.
name|arg
argument_list|(
name|QHttpHeader
operator|::
name|toString
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/****************************************************  *  * QHttp  *  ****************************************************/
end_comment
begin_comment
comment|/*!     \class QHttp     \obsolete     \reentrant      \brief The QHttp class provides an implementation of the HTTP protocol.      \ingroup network     \inmodule QtNetwork       This class provides a direct interface to HTTP that allows you to     download and upload data with the HTTP protocol.     However, for new applications, it is     recommended to use QNetworkAccessManager and QNetworkReply, as     those classes possess a simpler, yet more powerful API     and a more modern protocol implementation.      The class works asynchronously, so there are no blocking     functions. If an operation cannot be executed immediately, the     function will still return straight away and the operation will be     scheduled for later execution. The results of scheduled operations     are reported via signals. This approach depends on the event loop     being in operation.      The operations that can be scheduled (they are called "requests"     in the rest of the documentation) are the following: setHost(),     get(), post(), head() and request().      All of these requests return a unique identifier that allows you     to keep track of the request that is currently executed. When the     execution of a request starts, the requestStarted() signal with     the identifier is emitted and when the request is finished, the     requestFinished() signal is emitted with the identifier and a bool     that indicates if the request finished with an error.      To make an HTTP request you must set up suitable HTTP headers. The     following example demonstrates how to request the main HTML page     from the Qt website (i.e., the URL \c http://qt.nokia.com/index.html):      \snippet doc/src/snippets/code/src_network_access_qhttp.cpp 2      For the common HTTP requests \c GET, \c POST and \c HEAD, QHttp     provides the convenience functions get(), post() and head(). They     already use a reasonable header and if you don't have to set     special header fields, they are easier to use. The above example     can also be written as:      \snippet doc/src/snippets/code/src_network_access_qhttp.cpp 3      For this example the following sequence of signals is emitted     (with small variations, depending on network traffic, etc.):      \snippet doc/src/snippets/code/src_network_access_qhttp.cpp 4      The dataSendProgress() and dataReadProgress() signals in the above     example are useful if you want to show a \link QProgressBar     progress bar\endlink to inform the user about the progress of the     download. The second argument is the total size of data. In     certain cases it is not possible to know the total amount in     advance, in which case the second argument is 0. (If you connect     to a QProgressBar a total of 0 results in a busy indicator.)      When the response header is read, it is reported with the     responseHeaderReceived() signal.      The readyRead() signal tells you that there is data ready to be     read. The amount of data can then be queried with the     bytesAvailable() function and it can be read with the read()     or readAll() functions.      If an error occurs during the execution of one of the commands in     a sequence of commands, all the pending commands (i.e. scheduled,     but not yet executed commands) are cleared and no signals are     emitted for them.      For example, if you have the following sequence of requests      \snippet doc/src/snippets/code/src_network_access_qhttp.cpp 5      and the get() request fails because the host lookup fails, then     the post() request is never executed and the signals would look     like this:      \snippet doc/src/snippets/code/src_network_access_qhttp.cpp 6      You can then get details about the error with the error() and     errorString() functions. Note that only unexpected behavior, like     network failure is considered as an error. If the server response     contains an error status, like a 404 response, this is reported as     a normal response case. So you should always check the \link     QHttpResponseHeader::statusCode() status code \endlink of the     response header.      The functions currentId() and currentRequest() provide more     information about the currently executing request.      The functions hasPendingRequests() and clearPendingRequests()     allow you to query and clear the list of pending requests.      \sa QFtp, QNetworkAccessManager, QNetworkRequest, QNetworkReply,         {HTTP Example}, {Torrent Example} */
end_comment
begin_comment
comment|/*!     Constructs a QHttp object. The \a parent parameter is passed on     to the QObject constructor. */
end_comment
begin_constructor
DECL|function|QHttp
name|QHttp
operator|::
name|QHttp
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|new
name|QHttpPrivate
argument_list|,
name|parent
argument_list|)
block|{
name|Q_D
argument_list|(
name|QHttp
argument_list|)
expr_stmt|;
name|d
operator|->
name|init
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a QHttp object. Subsequent requests are done by     connecting to the server \a hostName on port \a port.      The \a parent parameter is passed on to the QObject constructor.      \sa setHost() */
end_comment
begin_constructor
DECL|function|QHttp
name|QHttp
operator|::
name|QHttp
parameter_list|(
specifier|const
name|QString
modifier|&
name|hostName
parameter_list|,
name|quint16
name|port
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|new
name|QHttpPrivate
argument_list|,
name|parent
argument_list|)
block|{
name|Q_D
argument_list|(
name|QHttp
argument_list|)
expr_stmt|;
name|d
operator|->
name|init
argument_list|()
expr_stmt|;
name|d
operator|->
name|hostName
operator|=
name|hostName
expr_stmt|;
name|d
operator|->
name|port
operator|=
name|port
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a QHttp object. Subsequent requests are done by     connecting to the server \a hostName on port \a port using the     connection mode \a mode.      If port is 0, it will use the default port for the \a mode used     (80 for Http and 443 for Https).      The \a parent parameter is passed on to the QObject constructor.      \sa setHost() */
end_comment
begin_constructor
DECL|function|QHttp
name|QHttp
operator|::
name|QHttp
parameter_list|(
specifier|const
name|QString
modifier|&
name|hostName
parameter_list|,
name|ConnectionMode
name|mode
parameter_list|,
name|quint16
name|port
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|new
name|QHttpPrivate
argument_list|,
name|parent
argument_list|)
block|{
name|Q_D
argument_list|(
name|QHttp
argument_list|)
expr_stmt|;
name|d
operator|->
name|init
argument_list|()
expr_stmt|;
name|d
operator|->
name|hostName
operator|=
name|hostName
expr_stmt|;
if|if
condition|(
name|port
operator|==
literal|0
condition|)
name|port
operator|=
operator|(
name|mode
operator|==
name|ConnectionModeHttp
operator|)
condition|?
literal|80
else|:
literal|443
expr_stmt|;
name|d
operator|->
name|port
operator|=
name|port
expr_stmt|;
name|d
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
block|}
end_constructor
begin_function
DECL|function|init
name|void
name|QHttpPrivate
operator|::
name|init
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QHttp
argument_list|)
expr_stmt|;
name|errorString
operator|=
name|QLatin1String
argument_list|(
name|QT_TRANSLATE_NOOP
argument_list|(
literal|"QHttp"
argument_list|,
literal|"Unknown error"
argument_list|)
argument_list|)
expr_stmt|;
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|q
argument_list|,
literal|"_q_slotDoFinished"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
name|post100ContinueTimer
operator|.
name|setSingleShot
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
operator|&
name|post100ContinueTimer
argument_list|,
name|SIGNAL
argument_list|(
name|timeout
argument_list|()
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_continuePost
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Destroys the QHttp object. If there is an open connection, it is     closed. */
end_comment
begin_destructor
DECL|function|~QHttp
name|QHttp
operator|::
name|~
name|QHttp
parameter_list|()
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     \enum QHttp::ConnectionMode     \since 4.3      This enum is used to specify the mode of connection to use:      \value ConnectionModeHttp The connection is a regular HTTP connection to the server     \value ConnectionModeHttps The HTTPS protocol is used and the connection is encrypted using SSL.      When using the HTTPS mode, care should be taken to connect to the sslErrors signal, and     handle possible SSL errors.      \sa QSslSocket */
end_comment
begin_comment
comment|/*!     \enum QHttp::State      This enum is used to specify the state the client is in:      \value Unconnected There is no connection to the host.     \value HostLookup A host name lookup is in progress.     \value Connecting An attempt to connect to the host is in progress.     \value Sending The client is sending its request to the server.     \value Reading The client's request has been sent and the client     is reading the server's response.     \value Connected The connection to the host is open, but the client is     neither sending a request, nor waiting for a response.     \value Closing The connection is closing down, but is not yet     closed. (The state will be \c Unconnected when the connection is     closed.)      \sa stateChanged() state() */
end_comment
begin_comment
comment|/*!  \enum QHttp::Error      This enum identifies the error that occurred.      \value NoError No error occurred.     \value HostNotFound The host name lookup failed.     \value ConnectionRefused The server refused the connection.     \value UnexpectedClose The server closed the connection unexpectedly.     \value InvalidResponseHeader The server sent an invalid response header.     \value WrongContentLength The client could not read the content correctly     because an error with respect to the content length occurred.     \value Aborted The request was aborted with abort().     \value ProxyAuthenticationRequiredError QHttp is using a proxy, and the     proxy server requires authentication to establish a connection.     \value AuthenticationRequiredError The web server requires authentication     to complete the request.     \value UnknownError An error other than those specified above     occurred.      \sa error() */
end_comment
begin_comment
comment|/*!     \fn void QHttp::stateChanged(int state)      This signal is emitted when the state of the QHttp object changes.     The argument \a state is the new state of the connection; it is     one of the \l State values.      This usually happens when a request is started, but it can also     happen when the server closes the connection or when a call to     close() succeeded.      \sa get() post() head() request() close() state() State */
end_comment
begin_comment
comment|/*!     \fn void QHttp::responseHeaderReceived(const QHttpResponseHeader&resp);      This signal is emitted when the HTTP header of a server response     is available. The header is passed in \a resp.      \sa get() post() head() request() readyRead() */
end_comment
begin_comment
comment|/*!     \fn void QHttp::readyRead(const QHttpResponseHeader&resp)      This signal is emitted when there is new response data to read.      If you specified a device in the request where the data should be     written to, then this signal is \e not emitted; instead the data     is written directly to the device.      The response header is passed in \a resp.      You can read the data with the readAll() or read() functions      This signal is useful if you want to process the data in chunks as     soon as it becomes available. If you are only interested in the     complete data, just connect to the requestFinished() signal and     read the data then instead.      \sa get() post() request() readAll() read() bytesAvailable() */
end_comment
begin_comment
comment|/*!     \fn void QHttp::dataSendProgress(int done, int total)      This signal is emitted when this object sends data to a HTTP     server to inform it about the progress of the upload.      \a done is the amount of data that has already arrived and \a     total is the total amount of data. It is possible that the total     amount of data that should be transferred cannot be determined, in     which case \a total is 0.(If you connect to a QProgressBar, the     progress bar shows a busy indicator if the total is 0).      \warning \a done and \a total are not necessarily the size in     bytes, since for large files these values might need to be     "scaled" to avoid overflow.      \sa dataReadProgress(), post(), request(), QProgressBar */
end_comment
begin_comment
comment|/*!     \fn void QHttp::dataReadProgress(int done, int total)      This signal is emitted when this object reads data from a HTTP     server to indicate the current progress of the download.      \a done is the amount of data that has already arrived and \a     total is the total amount of data. It is possible that the total     amount of data that should be transferred cannot be determined, in     which case \a total is 0.(If you connect to a QProgressBar, the     progress bar shows a busy indicator if the total is 0).      \warning \a done and \a total are not necessarily the size in     bytes, since for large files these values might need to be     "scaled" to avoid overflow.      \sa dataSendProgress() get() post() request() QProgressBar */
end_comment
begin_comment
comment|/*!     \fn void QHttp::requestStarted(int id)      This signal is emitted when processing the request identified by     \a id starts.      \sa requestFinished() done() */
end_comment
begin_comment
comment|/*!     \fn void QHttp::requestFinished(int id, bool error)      This signal is emitted when processing the request identified by     \a id has finished. \a error is true if an error occurred during     the processing; otherwise \a error is false.      \sa requestStarted() done() error() errorString() */
end_comment
begin_comment
comment|/*!     \fn void QHttp::done(bool error)      This signal is emitted when the last pending request has finished;     (it is emitted after the last request's requestFinished() signal).     \a error is true if an error occurred during the processing;     otherwise \a error is false.      \sa requestFinished() error() errorString() */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
end_ifndef
begin_comment
comment|/*!     \fn void QHttp::proxyAuthenticationRequired(const QNetworkProxy&proxy, QAuthenticator *authenticator)     \since 4.3      This signal can be emitted when a \a proxy that requires     authentication is used. The \a authenticator object can then be     filled in with the required details to allow authentication and     continue the connection.      \note It is not possible to use a QueuedConnection to connect to     this signal, as the connection will fail if the authenticator has     not been filled in with new information when the signal returns.      \sa QAuthenticator, QNetworkProxy */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \fn void QHttp::authenticationRequired(const QString&hostname, quint16 port, QAuthenticator *authenticator)     \since 4.3      This signal can be emitted when a web server on a given \a hostname and \a     port requires authentication. The \a authenticator object can then be     filled in with the required details to allow authentication and continue     the connection.      \note It is not possible to use a QueuedConnection to connect to     this signal, as the connection will fail if the authenticator has     not been filled in with new information when the signal returns.      \sa QAuthenticator, QNetworkProxy */
end_comment
begin_comment
comment|/*!     \fn void QHttp::sslErrors(const QList<QSslError>&errors)     \since 4.3      Forwards the sslErrors signal from the QSslSocket used in QHttp. \a errors     is the list of errors that occurred during the SSL handshake. Unless you     call ignoreSslErrors() from within a slot connected to this signal when an     error occurs, QHttp will tear down the connection immediately after     emitting the signal.      \sa QSslSocket QSslSocket::ignoreSslErrors() */
end_comment
begin_comment
comment|/*!     Aborts the current request and deletes all scheduled requests.      For the current request, the requestFinished() signal with the \c     error argument \c true is emitted. For all other requests that are     affected by the abort(), no signals are emitted.      Since this slot also deletes the scheduled requests, there are no     requests left and the done() signal is emitted (with the \c error     argument \c true).      \sa clearPendingRequests() */
end_comment
begin_function
DECL|function|abort
name|void
name|QHttp
operator|::
name|abort
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QHttp
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|pending
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|d
operator|->
name|finishedWithError
argument_list|(
name|tr
argument_list|(
literal|"Request aborted"
argument_list|)
argument_list|,
name|Aborted
argument_list|)
expr_stmt|;
name|clearPendingRequests
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|socket
condition|)
name|d
operator|->
name|socket
operator|->
name|abort
argument_list|()
expr_stmt|;
name|d
operator|->
name|closeConn
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of bytes that can be read from the response     content at the moment.      \sa get() post() request() readyRead() read() readAll() */
end_comment
begin_function
DECL|function|bytesAvailable
name|qint64
name|QHttp
operator|::
name|bytesAvailable
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QHttp
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QHTTP_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QHttp::bytesAvailable(): %d bytes"
argument_list|,
operator|(
name|int
operator|)
name|d
operator|->
name|rba
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|qint64
argument_list|(
name|d
operator|->
name|rba
operator|.
name|size
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \fn qint64 QHttp::readBlock(char *data, quint64 maxlen)      Use read() instead. */
end_comment
begin_comment
comment|/*!     Reads \a maxlen bytes from the response content into \a data and     returns the number of bytes read. Returns -1 if an error occurred.      \sa get() post() request() readyRead() bytesAvailable() readAll() */
end_comment
begin_function
DECL|function|read
name|qint64
name|QHttp
operator|::
name|read
parameter_list|(
name|char
modifier|*
name|data
parameter_list|,
name|qint64
name|maxlen
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QHttp
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|==
literal|0
operator|&&
name|maxlen
operator|!=
literal|0
condition|)
block|{
name|qWarning
argument_list|(
literal|"QHttp::read: Null pointer error"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|maxlen
operator|>=
name|d
operator|->
name|rba
operator|.
name|size
argument_list|()
condition|)
name|maxlen
operator|=
name|d
operator|->
name|rba
operator|.
name|size
argument_list|()
expr_stmt|;
name|int
name|readSoFar
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|!
name|d
operator|->
name|rba
operator|.
name|isEmpty
argument_list|()
operator|&&
name|readSoFar
operator|<
name|maxlen
condition|)
block|{
name|int
name|nextBlockSize
init|=
name|d
operator|->
name|rba
operator|.
name|nextDataBlockSize
argument_list|()
decl_stmt|;
name|int
name|bytesToRead
init|=
name|qMin
argument_list|<
name|qint64
argument_list|>
argument_list|(
name|maxlen
operator|-
name|readSoFar
argument_list|,
name|nextBlockSize
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|data
operator|+
name|readSoFar
argument_list|,
name|d
operator|->
name|rba
operator|.
name|readPointer
argument_list|()
argument_list|,
name|bytesToRead
argument_list|)
expr_stmt|;
name|d
operator|->
name|rba
operator|.
name|free
argument_list|(
name|bytesToRead
argument_list|)
expr_stmt|;
name|readSoFar
operator|+=
name|bytesToRead
expr_stmt|;
block|}
name|d
operator|->
name|bytesDone
operator|+=
name|maxlen
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QHTTP_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QHttp::read(): read %lld bytes (%lld bytes done)"
argument_list|,
name|maxlen
argument_list|,
name|d
operator|->
name|bytesDone
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|maxlen
return|;
block|}
end_function
begin_comment
comment|/*!     Reads all the bytes from the response content and returns them.      \sa get() post() request() readyRead() bytesAvailable() read() */
end_comment
begin_function
DECL|function|readAll
name|QByteArray
name|QHttp
operator|::
name|readAll
parameter_list|()
block|{
name|qint64
name|avail
init|=
name|bytesAvailable
argument_list|()
decl_stmt|;
name|QByteArray
name|tmp
decl_stmt|;
name|tmp
operator|.
name|resize
argument_list|(
name|int
argument_list|(
name|avail
argument_list|)
argument_list|)
expr_stmt|;
name|qint64
name|got
init|=
name|read
argument_list|(
name|tmp
operator|.
name|data
argument_list|()
argument_list|,
name|int
argument_list|(
name|avail
argument_list|)
argument_list|)
decl_stmt|;
name|tmp
operator|.
name|resize
argument_list|(
name|got
argument_list|)
expr_stmt|;
return|return
name|tmp
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the identifier of the HTTP request being executed or 0 if     there is no request being executed (i.e. they've all finished).      \sa currentRequest() */
end_comment
begin_function
DECL|function|currentId
name|int
name|QHttp
operator|::
name|currentId
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QHttp
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|pending
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|0
return|;
return|return
name|d
operator|->
name|pending
operator|.
name|first
argument_list|()
operator|->
name|id
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the request header of the HTTP request being executed. If     the request is one issued by setHost() or close(), it     returns an invalid request header, i.e.     QHttpRequestHeader::isValid() returns false.      \sa currentId() */
end_comment
begin_function
DECL|function|currentRequest
name|QHttpRequestHeader
name|QHttp
operator|::
name|currentRequest
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QHttp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|pending
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QHttpRequest
modifier|*
name|r
init|=
name|d
operator|->
name|pending
operator|.
name|first
argument_list|()
decl_stmt|;
if|if
condition|(
name|r
operator|->
name|hasRequestHeader
argument_list|()
condition|)
return|return
name|r
operator|->
name|requestHeader
argument_list|()
return|;
block|}
return|return
name|QHttpRequestHeader
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the received response header of the most recently finished HTTP     request. If no response has yet been received     QHttpResponseHeader::isValid() will return false.      \sa currentRequest() */
end_comment
begin_function
DECL|function|lastResponse
name|QHttpResponseHeader
name|QHttp
operator|::
name|lastResponse
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QHttp
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|response
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the QIODevice pointer that is used as the data source of the HTTP     request being executed. If there is no current request or if the request     does not use an IO device as the data source, this function returns 0.      This function can be used to delete the QIODevice in the slot connected to     the requestFinished() signal.      \sa currentDestinationDevice() post() request() */
end_comment
begin_function
DECL|function|currentSourceDevice
name|QIODevice
modifier|*
name|QHttp
operator|::
name|currentSourceDevice
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QHttp
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|pending
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|0
return|;
return|return
name|d
operator|->
name|pending
operator|.
name|first
argument_list|()
operator|->
name|sourceDevice
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the QIODevice pointer that is used as to store the data of the HTTP     request being executed. If there is no current request or if the request     does not store the data to an IO device, this function returns 0.      This function can be used to delete the QIODevice in the slot connected to     the requestFinished() signal.      \sa currentSourceDevice() get() post() request() */
end_comment
begin_function
DECL|function|currentDestinationDevice
name|QIODevice
modifier|*
name|QHttp
operator|::
name|currentDestinationDevice
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QHttp
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|pending
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|0
return|;
return|return
name|d
operator|->
name|pending
operator|.
name|first
argument_list|()
operator|->
name|destinationDevice
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if there are any requests scheduled that have not yet     been executed; otherwise returns false.      The request that is being executed is \e not considered as a     scheduled request.      \sa clearPendingRequests() currentId() currentRequest() */
end_comment
begin_function
DECL|function|hasPendingRequests
name|bool
name|QHttp
operator|::
name|hasPendingRequests
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QHttp
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|pending
operator|.
name|count
argument_list|()
operator|>
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!     Deletes all pending requests from the list of scheduled requests.     This does not affect the request that is being executed. If     you want to stop this as well, use abort().      \sa hasPendingRequests() abort() */
end_comment
begin_function
DECL|function|clearPendingRequests
name|void
name|QHttp
operator|::
name|clearPendingRequests
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QHttp
argument_list|)
expr_stmt|;
comment|// delete all entires except the first one
while|while
condition|(
name|d
operator|->
name|pending
operator|.
name|count
argument_list|()
operator|>
literal|1
condition|)
operator|delete
name|d
operator|->
name|pending
operator|.
name|takeLast
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the HTTP server that is used for requests to \a hostName on     port \a port.      The function does not block; instead, it returns immediately. The request     is scheduled, and its execution is performed asynchronously. The     function returns a unique identifier which is passed by     requestStarted() and requestFinished().      When the request is started the requestStarted() signal is     emitted. When it is finished the requestFinished() signal is     emitted.      \sa get() post() head() request() requestStarted() requestFinished() done() */
end_comment
begin_function
DECL|function|setHost
name|int
name|QHttp
operator|::
name|setHost
parameter_list|(
specifier|const
name|QString
modifier|&
name|hostName
parameter_list|,
name|quint16
name|port
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QHttp
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|addRequest
argument_list|(
operator|new
name|QHttpSetHostRequest
argument_list|(
name|hostName
argument_list|,
name|port
argument_list|,
name|ConnectionModeHttp
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the HTTP server that is used for requests to \a hostName on     port \a port using the connection mode \a mode.      If port is 0, it will use the default port for the \a mode used     (80 for HTTP and 443 for HTTPS).      The function does not block; instead, it returns immediately. The request     is scheduled, and its execution is performed asynchronously. The     function returns a unique identifier which is passed by     requestStarted() and requestFinished().      When the request is started the requestStarted() signal is     emitted. When it is finished the requestFinished() signal is     emitted.      \sa get() post() head() request() requestStarted() requestFinished() done() */
end_comment
begin_function
DECL|function|setHost
name|int
name|QHttp
operator|::
name|setHost
parameter_list|(
specifier|const
name|QString
modifier|&
name|hostName
parameter_list|,
name|ConnectionMode
name|mode
parameter_list|,
name|quint16
name|port
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_NO_OPENSSL
if|if
condition|(
name|mode
operator|==
name|ConnectionModeHttps
condition|)
name|qWarning
argument_list|(
literal|"QHttp::setHost: HTTPS connection requested but SSL support not compiled in"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|Q_D
argument_list|(
name|QHttp
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|==
literal|0
condition|)
name|port
operator|=
operator|(
name|mode
operator|==
name|ConnectionModeHttp
operator|)
condition|?
literal|80
else|:
literal|443
expr_stmt|;
return|return
name|d
operator|->
name|addRequest
argument_list|(
operator|new
name|QHttpSetHostRequest
argument_list|(
name|hostName
argument_list|,
name|port
argument_list|,
name|mode
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Replaces the internal QTcpSocket that QHttp uses with \a     socket. This is useful if you want to use your own custom QTcpSocket     subclass instead of the plain QTcpSocket that QHttp uses by default.     QHttp does not take ownership of the socket, and will not delete \a     socket when destroyed.      The function does not block; instead, it returns immediately. The request     is scheduled, and its execution is performed asynchronously. The     function returns a unique identifier which is passed by     requestStarted() and requestFinished().      When the request is started the requestStarted() signal is     emitted. When it is finished the requestFinished() signal is     emitted.      Note: If QHttp is used in a non-GUI thread that runs its own event     loop, you must move \a socket to that thread before calling setSocket().      \sa QObject::moveToThread(), {Thread Support in Qt} */
end_comment
begin_function
DECL|function|setSocket
name|int
name|QHttp
operator|::
name|setSocket
parameter_list|(
name|QTcpSocket
modifier|*
name|socket
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QHttp
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|addRequest
argument_list|(
operator|new
name|QHttpSetSocketRequest
argument_list|(
name|socket
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     This function sets the user name \a userName and password \a     password for web pages that require authentication.      The function does not block; instead, it returns immediately. The request     is scheduled, and its execution is performed asynchronously. The     function returns a unique identifier which is passed by     requestStarted() and requestFinished().      When the request is started the requestStarted() signal is     emitted. When it is finished the requestFinished() signal is     emitted. */
end_comment
begin_function
DECL|function|setUser
name|int
name|QHttp
operator|::
name|setUser
parameter_list|(
specifier|const
name|QString
modifier|&
name|userName
parameter_list|,
specifier|const
name|QString
modifier|&
name|password
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QHttp
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|addRequest
argument_list|(
operator|new
name|QHttpSetUserRequest
argument_list|(
name|userName
argument_list|,
name|password
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
end_ifndef
begin_comment
comment|/*!     Enables HTTP proxy support, using the proxy server \a host on port \a     port. \a username and \a password can be provided if the proxy server     requires authentication.      Example:      \snippet doc/src/snippets/code/src_network_access_qhttp.cpp 7      QHttp supports non-transparent web proxy servers only, such as the Squid     Web proxy cache server (from \l http://www.squid.org/). For transparent     proxying, such as SOCKS5, use QNetworkProxy instead.      \note setProxy() has to be called before setHost() for it to take effect.     If setProxy() is called after setHost(), then it will not apply until after      setHost() is called again.      \sa QFtp::setProxy() */
end_comment
begin_function
DECL|function|setProxy
name|int
name|QHttp
operator|::
name|setProxy
parameter_list|(
specifier|const
name|QString
modifier|&
name|host
parameter_list|,
name|int
name|port
parameter_list|,
specifier|const
name|QString
modifier|&
name|username
parameter_list|,
specifier|const
name|QString
modifier|&
name|password
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QHttp
argument_list|)
expr_stmt|;
name|QNetworkProxy
name|proxy
argument_list|(
name|QNetworkProxy
operator|::
name|HttpProxy
argument_list|,
name|host
argument_list|,
name|port
argument_list|,
name|username
argument_list|,
name|password
argument_list|)
decl_stmt|;
return|return
name|d
operator|->
name|addRequest
argument_list|(
operator|new
name|QHttpSetProxyRequest
argument_list|(
name|proxy
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Enables HTTP proxy support using the proxy settings from \a     proxy. If \a proxy is a transparent proxy, QHttp will call     QAbstractSocket::setProxy() on the underlying socket. If the type     is QNetworkProxy::HttpCachingProxy, QHttp will behave like the     previous function.      \note for compatibility with Qt 4.3, if the proxy type is     QNetworkProxy::HttpProxy and the request type is unencrypted (that     is, ConnectionModeHttp), QHttp will treat the proxy as a caching     proxy. */
end_comment
begin_function
DECL|function|setProxy
name|int
name|QHttp
operator|::
name|setProxy
parameter_list|(
specifier|const
name|QNetworkProxy
modifier|&
name|proxy
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QHttp
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|addRequest
argument_list|(
operator|new
name|QHttpSetProxyRequest
argument_list|(
name|proxy
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     Sends a get request for \a path to the server set by setHost() or     as specified in the constructor.      \a path must be a absolute path like \c /index.html or an     absolute URI like \c http://example.com/index.html and     must be encoded with either QUrl::toPercentEncoding() or     QUrl::encodedPath().      If the IO device \a to is 0 the readyRead() signal is emitted     every time new content data is available to read.      If the IO device \a to is not 0, the content data of the response     is written directly to the device. Make sure that the \a to     pointer is valid for the duration of the operation (it is safe to     delete it when the requestFinished() signal is emitted).      \section1 Request Processing      The function does not block; instead, it returns immediately. The request     is scheduled, and its execution is performed asynchronously. The     function returns a unique identifier which is passed by     requestStarted() and requestFinished().      When the request is started the requestStarted() signal is     emitted. When it is finished the requestFinished() signal is     emitted.      \sa setHost(), post(), head(), request(), requestStarted(),     requestFinished(), done() */
end_comment
begin_function
DECL|function|get
name|int
name|QHttp
operator|::
name|get
parameter_list|(
specifier|const
name|QString
modifier|&
name|path
parameter_list|,
name|QIODevice
modifier|*
name|to
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QHttp
argument_list|)
expr_stmt|;
name|QHttpRequestHeader
name|header
argument_list|(
name|QLatin1String
argument_list|(
literal|"GET"
argument_list|)
argument_list|,
name|path
argument_list|)
decl_stmt|;
name|header
operator|.
name|setValue
argument_list|(
name|QLatin1String
argument_list|(
literal|"Connection"
argument_list|)
argument_list|,
name|QLatin1String
argument_list|(
literal|"Keep-Alive"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|addRequest
argument_list|(
operator|new
name|QHttpPGHRequest
argument_list|(
name|header
argument_list|,
operator|(
name|QIODevice
operator|*
operator|)
literal|0
argument_list|,
name|to
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Sends a post request for \a path to the server set by setHost() or     as specified in the constructor.      \a path must be an absolute path like \c /index.html or an     absolute URI like \c http://example.com/index.html and     must be encoded with either QUrl::toPercentEncoding() or     QUrl::encodedPath().      The incoming data comes via the \a data IO device.      If the IO device \a to is 0 the readyRead() signal is emitted     every time new content data is available to read.      If the IO device \a to is not 0, the content data of the response     is written directly to the device. Make sure that the \a to     pointer is valid for the duration of the operation (it is safe to     delete it when the requestFinished() signal is emitted).      The function does not block; instead, it returns immediately. The request     is scheduled, and its execution is performed asynchronously. The     function returns a unique identifier which is passed by     requestStarted() and requestFinished().      When the request is started the requestStarted() signal is     emitted. When it is finished the requestFinished() signal is     emitted.      \sa setHost() get() head() request() requestStarted() requestFinished() done() */
end_comment
begin_function
DECL|function|post
name|int
name|QHttp
operator|::
name|post
parameter_list|(
specifier|const
name|QString
modifier|&
name|path
parameter_list|,
name|QIODevice
modifier|*
name|data
parameter_list|,
name|QIODevice
modifier|*
name|to
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QHttp
argument_list|)
expr_stmt|;
name|QHttpRequestHeader
name|header
argument_list|(
name|QLatin1String
argument_list|(
literal|"POST"
argument_list|)
argument_list|,
name|path
argument_list|)
decl_stmt|;
name|header
operator|.
name|setValue
argument_list|(
name|QLatin1String
argument_list|(
literal|"Connection"
argument_list|)
argument_list|,
name|QLatin1String
argument_list|(
literal|"Keep-Alive"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|addRequest
argument_list|(
operator|new
name|QHttpPGHRequest
argument_list|(
name|header
argument_list|,
name|data
argument_list|,
name|to
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      \a data is used as the content data of the HTTP request. */
end_comment
begin_function
DECL|function|post
name|int
name|QHttp
operator|::
name|post
parameter_list|(
specifier|const
name|QString
modifier|&
name|path
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|data
parameter_list|,
name|QIODevice
modifier|*
name|to
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QHttp
argument_list|)
expr_stmt|;
name|QHttpRequestHeader
name|header
argument_list|(
name|QLatin1String
argument_list|(
literal|"POST"
argument_list|)
argument_list|,
name|path
argument_list|)
decl_stmt|;
name|header
operator|.
name|setValue
argument_list|(
name|QLatin1String
argument_list|(
literal|"Connection"
argument_list|)
argument_list|,
name|QLatin1String
argument_list|(
literal|"Keep-Alive"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|addRequest
argument_list|(
operator|new
name|QHttpPGHRequest
argument_list|(
name|header
argument_list|,
operator|new
name|QByteArray
argument_list|(
name|data
argument_list|)
argument_list|,
name|to
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Sends a header request for \a path to the server set by setHost()     or as specified in the constructor.      \a path must be an absolute path like \c /index.html or an     absolute URI like \c http://example.com/index.html.      The function does not block; instead, it returns immediately. The request     is scheduled, and its execution is performed asynchronously. The     function returns a unique identifier which is passed by     requestStarted() and requestFinished().      When the request is started the requestStarted() signal is     emitted. When it is finished the requestFinished() signal is     emitted.      \sa setHost() get() post() request() requestStarted() requestFinished() done() */
end_comment
begin_function
DECL|function|head
name|int
name|QHttp
operator|::
name|head
parameter_list|(
specifier|const
name|QString
modifier|&
name|path
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QHttp
argument_list|)
expr_stmt|;
name|QHttpRequestHeader
name|header
argument_list|(
name|QLatin1String
argument_list|(
literal|"HEAD"
argument_list|)
argument_list|,
name|path
argument_list|)
decl_stmt|;
name|header
operator|.
name|setValue
argument_list|(
name|QLatin1String
argument_list|(
literal|"Connection"
argument_list|)
argument_list|,
name|QLatin1String
argument_list|(
literal|"Keep-Alive"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|addRequest
argument_list|(
operator|new
name|QHttpPGHRequest
argument_list|(
name|header
argument_list|,
operator|(
name|QIODevice
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Sends a request to the server set by setHost() or as specified in     the constructor. Uses the \a header as the HTTP request header.     You are responsible for setting up a header that is appropriate     for your request.      The incoming data comes via the \a data IO device.      If the IO device \a to is 0 the readyRead() signal is emitted     every time new content data is available to read.      If the IO device \a to is not 0, the content data of the response     is written directly to the device. Make sure that the \a to     pointer is valid for the duration of the operation (it is safe to     delete it when the requestFinished() signal is emitted).      The function does not block; instead, it returns immediately. The request     is scheduled, and its execution is performed asynchronously. The     function returns a unique identifier which is passed by     requestStarted() and requestFinished().      When the request is started the requestStarted() signal is     emitted. When it is finished the requestFinished() signal is     emitted.      \sa setHost() get() post() head() requestStarted() requestFinished() done() */
end_comment
begin_function
DECL|function|request
name|int
name|QHttp
operator|::
name|request
parameter_list|(
specifier|const
name|QHttpRequestHeader
modifier|&
name|header
parameter_list|,
name|QIODevice
modifier|*
name|data
parameter_list|,
name|QIODevice
modifier|*
name|to
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QHttp
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|addRequest
argument_list|(
operator|new
name|QHttpNormalRequest
argument_list|(
name|header
argument_list|,
name|data
argument_list|,
name|to
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      \a data is used as the content data of the HTTP request. */
end_comment
begin_function
DECL|function|request
name|int
name|QHttp
operator|::
name|request
parameter_list|(
specifier|const
name|QHttpRequestHeader
modifier|&
name|header
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|data
parameter_list|,
name|QIODevice
modifier|*
name|to
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QHttp
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|addRequest
argument_list|(
operator|new
name|QHttpNormalRequest
argument_list|(
name|header
argument_list|,
operator|new
name|QByteArray
argument_list|(
name|data
argument_list|)
argument_list|,
name|to
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Closes the connection; this is useful if you have a keep-alive     connection and want to close it.      For the requests issued with get(), post() and head(), QHttp sets     the connection to be keep-alive. You can also do this using the     header you pass to the request() function. QHttp only closes the     connection to the HTTP server if the response header requires it     to do so.      The function does not block; instead, it returns immediately. The request     is scheduled, and its execution is performed asynchronously. The     function returns a unique identifier which is passed by     requestStarted() and requestFinished().      When the request is started the requestStarted() signal is     emitted. When it is finished the requestFinished() signal is     emitted.      If you want to close the connection immediately, you have to use     abort() instead.      \sa stateChanged() abort() requestStarted() requestFinished() done() */
end_comment
begin_function
DECL|function|close
name|int
name|QHttp
operator|::
name|close
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QHttp
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|addRequest
argument_list|(
operator|new
name|QHttpCloseRequest
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \obsolete      Behaves the same as close(). */
end_comment
begin_function
DECL|function|closeConnection
name|int
name|QHttp
operator|::
name|closeConnection
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QHttp
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|addRequest
argument_list|(
operator|new
name|QHttpCloseRequest
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|addRequest
name|int
name|QHttpPrivate
operator|::
name|addRequest
parameter_list|(
name|QHttpNormalRequest
modifier|*
name|req
parameter_list|)
block|{
name|QHttpRequestHeader
name|h
init|=
name|req
operator|->
name|requestHeader
argument_list|()
decl_stmt|;
if|if
condition|(
name|h
operator|.
name|path
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// note: the following qWarning is autotested. If you change it, change the test too.
name|qWarning
argument_list|(
literal|"QHttp: empty path requested is invalid -- using '/'"
argument_list|)
expr_stmt|;
name|h
operator|.
name|setRequest
argument_list|(
name|h
operator|.
name|method
argument_list|()
argument_list|,
name|QLatin1String
argument_list|(
literal|"/"
argument_list|)
argument_list|,
name|h
operator|.
name|majorVersion
argument_list|()
argument_list|,
name|h
operator|.
name|minorVersion
argument_list|()
argument_list|)
expr_stmt|;
name|req
operator|->
name|setRequestHeader
argument_list|(
name|h
argument_list|)
expr_stmt|;
block|}
comment|// contine below
return|return
name|addRequest
argument_list|(
cast|static_cast
argument_list|<
name|QHttpRequest
operator|*
argument_list|>
argument_list|(
name|req
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|addRequest
name|int
name|QHttpPrivate
operator|::
name|addRequest
parameter_list|(
name|QHttpRequest
modifier|*
name|req
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QHttp
argument_list|)
expr_stmt|;
name|pending
operator|.
name|append
argument_list|(
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|pending
operator|.
name|count
argument_list|()
operator|==
literal|1
condition|)
block|{
comment|// don't emit the requestStarted() signal before the id is returned
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|q
argument_list|,
literal|"_q_startNextRequest"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
block|}
return|return
name|req
operator|->
name|id
return|;
block|}
end_function
begin_function
DECL|function|_q_startNextRequest
name|void
name|QHttpPrivate
operator|::
name|_q_startNextRequest
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QHttp
argument_list|)
expr_stmt|;
if|if
condition|(
name|pending
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|QHttpRequest
modifier|*
name|r
init|=
name|pending
operator|.
name|first
argument_list|()
decl_stmt|;
name|error
operator|=
name|QHttp
operator|::
name|NoError
expr_stmt|;
name|errorString
operator|=
name|QLatin1String
argument_list|(
name|QT_TRANSLATE_NOOP
argument_list|(
literal|"QHttp"
argument_list|,
literal|"Unknown error"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|bytesAvailable
argument_list|()
operator|!=
literal|0
condition|)
name|q
operator|->
name|readAll
argument_list|()
expr_stmt|;
comment|// clear the data
emit|emit
name|q
operator|->
name|requestStarted
argument_list|(
name|r
operator|->
name|id
argument_list|)
emit|;
name|r
operator|->
name|start
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|_q_slotSendRequest
name|void
name|QHttpPrivate
operator|::
name|_q_slotSendRequest
parameter_list|()
block|{
if|if
condition|(
name|hostName
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|finishedWithError
argument_list|(
name|QLatin1String
argument_list|(
name|QT_TRANSLATE_NOOP
argument_list|(
literal|"QHttp"
argument_list|,
literal|"No server set to connect to"
argument_list|)
argument_list|)
argument_list|,
name|QHttp
operator|::
name|UnknownError
argument_list|)
expr_stmt|;
return|return;
block|}
name|QString
name|connectionHost
init|=
name|hostName
decl_stmt|;
name|int
name|connectionPort
init|=
name|port
decl_stmt|;
name|bool
name|sslInUse
init|=
literal|false
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_OPENSSL
name|QSslSocket
modifier|*
name|sslSocket
init|=
name|qobject_cast
argument_list|<
name|QSslSocket
operator|*
argument_list|>
argument_list|(
name|socket
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|QHttp
operator|::
name|ConnectionModeHttps
operator|||
operator|(
name|sslSocket
operator|&&
name|sslSocket
operator|->
name|isEncrypted
argument_list|()
operator|)
condition|)
name|sslInUse
operator|=
literal|true
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
name|bool
name|cachingProxyInUse
init|=
literal|false
decl_stmt|;
name|bool
name|transparentProxyInUse
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|proxy
operator|.
name|type
argument_list|()
operator|==
name|QNetworkProxy
operator|::
name|DefaultProxy
condition|)
name|proxy
operator|=
name|QNetworkProxy
operator|::
name|applicationProxy
argument_list|()
expr_stmt|;
if|if
condition|(
name|proxy
operator|.
name|type
argument_list|()
operator|==
name|QNetworkProxy
operator|::
name|HttpCachingProxy
condition|)
block|{
if|if
condition|(
name|proxy
operator|.
name|hostName
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|proxy
operator|.
name|setType
argument_list|(
name|QNetworkProxy
operator|::
name|NoProxy
argument_list|)
expr_stmt|;
else|else
name|cachingProxyInUse
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|proxy
operator|.
name|type
argument_list|()
operator|==
name|QNetworkProxy
operator|::
name|HttpProxy
condition|)
block|{
comment|// Compatibility behaviour: HttpProxy can be used to mean both
comment|// transparent and caching proxy
if|if
condition|(
name|proxy
operator|.
name|hostName
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|proxy
operator|.
name|setType
argument_list|(
name|QNetworkProxy
operator|::
name|NoProxy
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sslInUse
condition|)
block|{
comment|// Disallow use of caching proxy with HTTPS; instead fall back to
comment|// transparent HTTP CONNECT proxying.
name|transparentProxyInUse
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|proxy
operator|.
name|setType
argument_list|(
name|QNetworkProxy
operator|::
name|HttpCachingProxy
argument_list|)
expr_stmt|;
name|cachingProxyInUse
operator|=
literal|true
expr_stmt|;
block|}
block|}
comment|// Proxy support. Insert the Proxy-Authorization item into the
comment|// header before it's sent off to the proxy.
if|if
condition|(
name|cachingProxyInUse
condition|)
block|{
name|QUrl
name|proxyUrl
decl_stmt|;
name|proxyUrl
operator|.
name|setScheme
argument_list|(
name|QLatin1String
argument_list|(
literal|"http"
argument_list|)
argument_list|)
expr_stmt|;
name|proxyUrl
operator|.
name|setHost
argument_list|(
name|hostName
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|&&
name|port
operator|!=
literal|80
condition|)
name|proxyUrl
operator|.
name|setPort
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|QString
name|request
init|=
name|QString
operator|::
name|fromAscii
argument_list|(
name|proxyUrl
operator|.
name|resolved
argument_list|(
name|QUrl
operator|::
name|fromEncoded
argument_list|(
name|header
operator|.
name|path
argument_list|()
operator|.
name|toLatin1
argument_list|()
argument_list|)
argument_list|)
operator|.
name|toEncoded
argument_list|()
argument_list|)
decl_stmt|;
name|header
operator|.
name|setRequest
argument_list|(
name|header
operator|.
name|method
argument_list|()
argument_list|,
name|request
argument_list|,
name|header
operator|.
name|majorVersion
argument_list|()
argument_list|,
name|header
operator|.
name|minorVersion
argument_list|()
argument_list|)
expr_stmt|;
name|header
operator|.
name|setValue
argument_list|(
name|QLatin1String
argument_list|(
literal|"Proxy-Connection"
argument_list|)
argument_list|,
name|QLatin1String
argument_list|(
literal|"keep-alive"
argument_list|)
argument_list|)
expr_stmt|;
name|QAuthenticatorPrivate
modifier|*
name|auth
init|=
name|QAuthenticatorPrivate
operator|::
name|getPrivate
argument_list|(
name|proxyAuthenticator
argument_list|)
decl_stmt|;
if|if
condition|(
name|auth
operator|&&
name|auth
operator|->
name|method
operator|!=
name|QAuthenticatorPrivate
operator|::
name|None
condition|)
block|{
name|QByteArray
name|response
init|=
name|auth
operator|->
name|calculateResponse
argument_list|(
name|header
operator|.
name|method
argument_list|()
operator|.
name|toLatin1
argument_list|()
argument_list|,
name|header
operator|.
name|path
argument_list|()
operator|.
name|toLatin1
argument_list|()
argument_list|)
decl_stmt|;
name|header
operator|.
name|setValue
argument_list|(
name|QLatin1String
argument_list|(
literal|"Proxy-Authorization"
argument_list|)
argument_list|,
name|QString
operator|::
name|fromLatin1
argument_list|(
name|response
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|connectionHost
operator|=
name|proxy
operator|.
name|hostName
argument_list|()
expr_stmt|;
name|connectionPort
operator|=
name|proxy
operator|.
name|port
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|transparentProxyInUse
operator|||
name|sslInUse
condition|)
block|{
name|socket
operator|->
name|setProxy
argument_list|(
name|proxy
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|// Username support. Insert the user and password into the query
comment|// string.
name|QAuthenticatorPrivate
modifier|*
name|auth
init|=
name|QAuthenticatorPrivate
operator|::
name|getPrivate
argument_list|(
name|authenticator
argument_list|)
decl_stmt|;
if|if
condition|(
name|auth
operator|&&
name|auth
operator|->
name|method
operator|!=
name|QAuthenticatorPrivate
operator|::
name|None
condition|)
block|{
name|QByteArray
name|response
init|=
name|auth
operator|->
name|calculateResponse
argument_list|(
name|header
operator|.
name|method
argument_list|()
operator|.
name|toLatin1
argument_list|()
argument_list|,
name|header
operator|.
name|path
argument_list|()
operator|.
name|toLatin1
argument_list|()
argument_list|)
decl_stmt|;
name|header
operator|.
name|setValue
argument_list|(
name|QLatin1String
argument_list|(
literal|"Authorization"
argument_list|)
argument_list|,
name|QString
operator|::
name|fromLatin1
argument_list|(
name|response
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Do we need to setup a new connection or can we reuse an
comment|// existing one?
if|if
condition|(
name|socket
operator|->
name|peerName
argument_list|()
operator|!=
name|connectionHost
operator|||
name|socket
operator|->
name|peerPort
argument_list|()
operator|!=
name|connectionPort
operator|||
name|socket
operator|->
name|state
argument_list|()
operator|!=
name|QTcpSocket
operator|::
name|ConnectedState
ifndef|#
directive|ifndef
name|QT_NO_OPENSSL
operator|||
operator|(
name|sslSocket
operator|&&
name|sslSocket
operator|->
name|isEncrypted
argument_list|()
operator|!=
operator|(
name|mode
operator|==
name|QHttp
operator|::
name|ConnectionModeHttps
operator|)
operator|)
endif|#
directive|endif
condition|)
block|{
name|socket
operator|->
name|blockSignals
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|socket
operator|->
name|abort
argument_list|()
expr_stmt|;
name|socket
operator|->
name|blockSignals
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|setState
argument_list|(
name|QHttp
operator|::
name|Connecting
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_OPENSSL
if|if
condition|(
name|sslSocket
operator|&&
name|mode
operator|==
name|QHttp
operator|::
name|ConnectionModeHttps
condition|)
block|{
name|sslSocket
operator|->
name|connectToHostEncrypted
argument_list|(
name|hostName
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|socket
operator|->
name|connectToHost
argument_list|(
name|connectionHost
argument_list|,
name|connectionPort
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|_q_slotConnected
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|finishedWithSuccess
name|void
name|QHttpPrivate
operator|::
name|finishedWithSuccess
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QHttp
argument_list|)
expr_stmt|;
if|if
condition|(
name|pending
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|QHttpRequest
modifier|*
name|r
init|=
name|pending
operator|.
name|first
argument_list|()
decl_stmt|;
comment|// did we recurse?
if|if
condition|(
name|r
operator|->
name|finished
condition|)
return|return;
name|r
operator|->
name|finished
operator|=
literal|true
expr_stmt|;
name|hasFinishedWithError
operator|=
literal|false
expr_stmt|;
emit|emit
name|q
operator|->
name|requestFinished
argument_list|(
name|r
operator|->
name|id
argument_list|,
literal|false
argument_list|)
emit|;
if|if
condition|(
name|hasFinishedWithError
condition|)
block|{
comment|// we recursed and changed into an error. The finishedWithError function
comment|// below has emitted the done(bool) signal and cleared the queue by now.
return|return;
block|}
name|pending
operator|.
name|removeFirst
argument_list|()
expr_stmt|;
operator|delete
name|r
expr_stmt|;
if|if
condition|(
name|pending
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
emit|emit
name|q
operator|->
name|done
argument_list|(
literal|false
argument_list|)
emit|;
block|}
else|else
block|{
name|_q_startNextRequest
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|finishedWithError
name|void
name|QHttpPrivate
operator|::
name|finishedWithError
parameter_list|(
specifier|const
name|QString
modifier|&
name|detail
parameter_list|,
name|int
name|errorCode
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QHttp
argument_list|)
expr_stmt|;
if|if
condition|(
name|pending
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|QHttpRequest
modifier|*
name|r
init|=
name|pending
operator|.
name|first
argument_list|()
decl_stmt|;
name|hasFinishedWithError
operator|=
literal|true
expr_stmt|;
name|error
operator|=
name|QHttp
operator|::
name|Error
argument_list|(
name|errorCode
argument_list|)
expr_stmt|;
name|errorString
operator|=
name|detail
expr_stmt|;
comment|// did we recurse?
if|if
condition|(
operator|!
name|r
operator|->
name|finished
condition|)
block|{
name|r
operator|->
name|finished
operator|=
literal|true
expr_stmt|;
emit|emit
name|q
operator|->
name|requestFinished
argument_list|(
name|r
operator|->
name|id
argument_list|,
literal|true
argument_list|)
emit|;
block|}
while|while
condition|(
operator|!
name|pending
operator|.
name|isEmpty
argument_list|()
condition|)
operator|delete
name|pending
operator|.
name|takeFirst
argument_list|()
expr_stmt|;
emit|emit
name|q
operator|->
name|done
argument_list|(
name|hasFinishedWithError
argument_list|)
emit|;
block|}
end_function
begin_function
DECL|function|_q_slotClosed
name|void
name|QHttpPrivate
operator|::
name|_q_slotClosed
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QHttp
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|QHttp
operator|::
name|Reading
condition|)
block|{
if|if
condition|(
name|response
operator|.
name|hasKey
argument_list|(
name|QLatin1String
argument_list|(
literal|"content-length"
argument_list|)
argument_list|)
condition|)
block|{
comment|// We got Content-Length, so did we get all bytes?
if|if
condition|(
name|bytesDone
operator|+
name|q
operator|->
name|bytesAvailable
argument_list|()
operator|!=
name|response
operator|.
name|contentLength
argument_list|()
condition|)
block|{
name|finishedWithError
argument_list|(
name|QLatin1String
argument_list|(
name|QT_TRANSLATE_NOOP
argument_list|(
literal|"QHttp"
argument_list|,
literal|"Wrong content length"
argument_list|)
argument_list|)
argument_list|,
name|QHttp
operator|::
name|WrongContentLength
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|state
operator|==
name|QHttp
operator|::
name|Connecting
operator|||
name|state
operator|==
name|QHttp
operator|::
name|Sending
condition|)
block|{
name|finishedWithError
argument_list|(
name|QLatin1String
argument_list|(
name|QT_TRANSLATE_NOOP
argument_list|(
literal|"QHttp"
argument_list|,
literal|"Server closed connection unexpectedly"
argument_list|)
argument_list|)
argument_list|,
name|QHttp
operator|::
name|UnexpectedClose
argument_list|)
expr_stmt|;
block|}
name|postDevice
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|state
operator|!=
name|QHttp
operator|::
name|Closing
condition|)
name|setState
argument_list|(
name|QHttp
operator|::
name|Closing
argument_list|)
expr_stmt|;
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|q
argument_list|,
literal|"_q_slotDoFinished"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|_q_continuePost
name|void
name|QHttpPrivate
operator|::
name|_q_continuePost
parameter_list|()
block|{
if|if
condition|(
name|pendingPost
condition|)
block|{
name|pendingPost
operator|=
literal|false
expr_stmt|;
name|setState
argument_list|(
name|QHttp
operator|::
name|Sending
argument_list|)
expr_stmt|;
name|_q_slotBytesWritten
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|_q_slotConnected
name|void
name|QHttpPrivate
operator|::
name|_q_slotConnected
parameter_list|()
block|{
if|if
condition|(
name|state
operator|!=
name|QHttp
operator|::
name|Sending
condition|)
block|{
name|bytesDone
operator|=
literal|0
expr_stmt|;
name|setState
argument_list|(
name|QHttp
operator|::
name|Sending
argument_list|)
expr_stmt|;
block|}
name|QString
name|str
init|=
name|header
operator|.
name|toString
argument_list|()
decl_stmt|;
name|bytesTotal
operator|=
name|str
operator|.
name|length
argument_list|()
expr_stmt|;
name|socket
operator|->
name|write
argument_list|(
name|str
operator|.
name|toLatin1
argument_list|()
argument_list|,
name|bytesTotal
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QHTTP_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QHttp: write request header %p:\n---{\n%s}---"
argument_list|,
operator|&
name|header
argument_list|,
name|str
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|postDevice
condition|)
block|{
name|postDevice
operator|->
name|seek
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|// reposition the device
name|bytesTotal
operator|+=
name|postDevice
operator|->
name|size
argument_list|()
expr_stmt|;
comment|//check for 100-continue
if|if
condition|(
name|header
operator|.
name|value
argument_list|(
name|QLatin1String
argument_list|(
literal|"expect"
argument_list|)
argument_list|)
operator|.
name|contains
argument_list|(
name|QLatin1String
argument_list|(
literal|"100-continue"
argument_list|)
argument_list|,
name|Qt
operator|::
name|CaseInsensitive
argument_list|)
condition|)
block|{
comment|//create a time out for 2 secs.
name|pendingPost
operator|=
literal|true
expr_stmt|;
name|post100ContinueTimer
operator|.
name|start
argument_list|(
literal|2000
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|bytesTotal
operator|+=
name|buffer
operator|.
name|size
argument_list|()
expr_stmt|;
name|socket
operator|->
name|write
argument_list|(
name|buffer
argument_list|,
name|buffer
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|_q_slotError
name|void
name|QHttpPrivate
operator|::
name|_q_slotError
parameter_list|(
name|QAbstractSocket
operator|::
name|SocketError
name|err
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QHttp
argument_list|)
expr_stmt|;
name|postDevice
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|QHttp
operator|::
name|Connecting
operator|||
name|state
operator|==
name|QHttp
operator|::
name|Reading
operator|||
name|state
operator|==
name|QHttp
operator|::
name|Sending
condition|)
block|{
switch|switch
condition|(
name|err
condition|)
block|{
case|case
name|QTcpSocket
operator|::
name|ConnectionRefusedError
case|:
name|finishedWithError
argument_list|(
name|QLatin1String
argument_list|(
name|QT_TRANSLATE_NOOP
argument_list|(
literal|"QHttp"
argument_list|,
literal|"Connection refused (or timed out)"
argument_list|)
argument_list|)
argument_list|,
name|QHttp
operator|::
name|ConnectionRefused
argument_list|)
expr_stmt|;
break|break;
case|case
name|QTcpSocket
operator|::
name|HostNotFoundError
case|:
name|finishedWithError
argument_list|(
name|QString
operator|::
name|fromLatin1
argument_list|(
name|QT_TRANSLATE_NOOP
argument_list|(
literal|"QHttp"
argument_list|,
literal|"Host %1 not found"
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|socket
operator|->
name|peerName
argument_list|()
argument_list|)
argument_list|,
name|QHttp
operator|::
name|HostNotFound
argument_list|)
expr_stmt|;
break|break;
case|case
name|QTcpSocket
operator|::
name|RemoteHostClosedError
case|:
if|if
condition|(
name|state
operator|==
name|QHttp
operator|::
name|Sending
operator|&&
name|reconnectAttempts
operator|--
condition|)
block|{
name|setState
argument_list|(
name|QHttp
operator|::
name|Closing
argument_list|)
expr_stmt|;
name|setState
argument_list|(
name|QHttp
operator|::
name|Unconnected
argument_list|)
expr_stmt|;
name|socket
operator|->
name|blockSignals
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|socket
operator|->
name|abort
argument_list|()
expr_stmt|;
name|socket
operator|->
name|blockSignals
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|q
argument_list|,
literal|"_q_slotSendRequest"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
case|case
name|QTcpSocket
operator|::
name|ProxyAuthenticationRequiredError
case|:
name|finishedWithError
argument_list|(
name|socket
operator|->
name|errorString
argument_list|()
argument_list|,
name|QHttp
operator|::
name|ProxyAuthenticationRequiredError
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|finishedWithError
argument_list|(
name|QLatin1String
argument_list|(
name|QT_TRANSLATE_NOOP
argument_list|(
literal|"QHttp"
argument_list|,
literal|"HTTP request failed"
argument_list|)
argument_list|)
argument_list|,
name|QHttp
operator|::
name|UnknownError
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|closeConn
argument_list|()
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_OPENSSL
end_ifndef
begin_function
DECL|function|_q_slotEncryptedBytesWritten
name|void
name|QHttpPrivate
operator|::
name|_q_slotEncryptedBytesWritten
parameter_list|(
name|qint64
name|written
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|written
argument_list|)
expr_stmt|;
name|postMoreData
argument_list|()
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|_q_slotBytesWritten
name|void
name|QHttpPrivate
operator|::
name|_q_slotBytesWritten
parameter_list|(
name|qint64
name|written
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QHttp
argument_list|)
expr_stmt|;
name|bytesDone
operator|+=
name|written
expr_stmt|;
emit|emit
name|q
operator|->
name|dataSendProgress
argument_list|(
name|bytesDone
argument_list|,
name|bytesTotal
argument_list|)
emit|;
name|postMoreData
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|// Send the POST data
end_comment
begin_function
DECL|function|postMoreData
name|void
name|QHttpPrivate
operator|::
name|postMoreData
parameter_list|()
block|{
if|if
condition|(
name|pendingPost
condition|)
return|return;
if|if
condition|(
operator|!
name|postDevice
condition|)
return|return;
comment|// the following is backported code from Qt 4.6 QNetworkAccessManager.
comment|// We also have to check the encryptedBytesToWrite() if it is an SSL socket.
ifndef|#
directive|ifndef
name|QT_NO_OPENSSL
name|QSslSocket
modifier|*
name|sslSocket
init|=
name|qobject_cast
argument_list|<
name|QSslSocket
operator|*
argument_list|>
argument_list|(
name|socket
argument_list|)
decl_stmt|;
comment|// if it is really an ssl socket, check more than just bytesToWrite()
if|if
condition|(
operator|(
name|socket
operator|->
name|bytesToWrite
argument_list|()
operator|+
operator|(
name|sslSocket
condition|?
name|sslSocket
operator|->
name|encryptedBytesToWrite
argument_list|()
else|:
literal|0
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|socket
operator|->
name|bytesToWrite
argument_list|()
operator|==
literal|0
condition|)
block|{
endif|#
directive|endif
name|int
name|max
init|=
name|qMin
argument_list|<
name|qint64
argument_list|>
argument_list|(
literal|4096
argument_list|,
name|postDevice
operator|->
name|size
argument_list|()
operator|-
name|postDevice
operator|->
name|pos
argument_list|()
argument_list|)
decl_stmt|;
name|QByteArray
name|arr
decl_stmt|;
name|arr
operator|.
name|resize
argument_list|(
name|max
argument_list|)
expr_stmt|;
name|int
name|n
init|=
name|postDevice
operator|->
name|read
argument_list|(
name|arr
operator|.
name|data
argument_list|()
argument_list|,
name|max
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|qWarning
argument_list|(
literal|"Could not read enough bytes from the device"
argument_list|)
expr_stmt|;
name|closeConn
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|postDevice
operator|->
name|atEnd
argument_list|()
condition|)
block|{
name|postDevice
operator|=
literal|0
expr_stmt|;
block|}
name|socket
operator|->
name|write
argument_list|(
name|arr
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
block|}
DECL|function|_q_slotReadyRead
name|void
name|QHttpPrivate
operator|::
name|_q_slotReadyRead
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QHttp
argument_list|)
expr_stmt|;
name|QHttp
operator|::
name|State
name|oldState
init|=
name|state
decl_stmt|;
if|if
condition|(
name|state
operator|!=
name|QHttp
operator|::
name|Reading
condition|)
block|{
name|setState
argument_list|(
name|QHttp
operator|::
name|Reading
argument_list|)
expr_stmt|;
name|readHeader
operator|=
literal|true
expr_stmt|;
name|headerStr
operator|=
name|QLatin1String
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|bytesDone
operator|=
literal|0
expr_stmt|;
name|chunkedSize
operator|=
operator|-
literal|1
expr_stmt|;
name|repost
operator|=
literal|false
expr_stmt|;
block|}
while|while
condition|(
name|readHeader
condition|)
block|{
name|bool
name|end
init|=
literal|false
decl_stmt|;
name|QString
name|tmp
decl_stmt|;
while|while
condition|(
operator|!
name|end
operator|&&
name|socket
operator|->
name|canReadLine
argument_list|()
condition|)
block|{
name|tmp
operator|=
name|QString
operator|::
name|fromAscii
argument_list|(
name|socket
operator|->
name|readLine
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|QLatin1String
argument_list|(
literal|"\r\n"
argument_list|)
operator|||
name|tmp
operator|==
name|QLatin1String
argument_list|(
literal|"\n"
argument_list|)
operator|||
name|tmp
operator|.
name|isEmpty
argument_list|()
condition|)
name|end
operator|=
literal|true
expr_stmt|;
else|else
name|headerStr
operator|+=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|end
condition|)
return|return;
name|response
operator|=
name|QHttpResponseHeader
argument_list|(
name|headerStr
argument_list|)
expr_stmt|;
name|headerStr
operator|=
name|QLatin1String
argument_list|(
literal|""
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QHTTP_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QHttp: read response header:\n---{\n%s}---"
argument_list|,
name|response
operator|.
name|toString
argument_list|()
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// Check header
if|if
condition|(
operator|!
name|response
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|finishedWithError
argument_list|(
name|QLatin1String
argument_list|(
name|QT_TRANSLATE_NOOP
argument_list|(
literal|"QHttp"
argument_list|,
literal|"Invalid HTTP response header"
argument_list|)
argument_list|)
argument_list|,
name|QHttp
operator|::
name|InvalidResponseHeader
argument_list|)
expr_stmt|;
name|closeConn
argument_list|()
expr_stmt|;
return|return;
block|}
name|int
name|statusCode
init|=
name|response
operator|.
name|statusCode
argument_list|()
decl_stmt|;
if|if
condition|(
name|statusCode
operator|==
literal|401
operator|||
name|statusCode
operator|==
literal|407
condition|)
block|{
comment|// (Proxy) Authentication required
name|QAuthenticator
modifier|*
name|auth
init|=
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
name|statusCode
operator|==
literal|407
condition|?
operator|&
name|proxyAuthenticator
else|:
endif|#
directive|endif
operator|&
name|authenticator
decl_stmt|;
if|if
condition|(
name|auth
operator|->
name|isNull
argument_list|()
condition|)
name|auth
operator|->
name|detach
argument_list|()
expr_stmt|;
name|QAuthenticatorPrivate
modifier|*
name|priv
init|=
name|QAuthenticatorPrivate
operator|::
name|getPrivate
argument_list|(
operator|*
name|auth
argument_list|)
decl_stmt|;
name|priv
operator|->
name|parseHttpResponse
argument_list|(
name|response
argument_list|,
operator|(
name|statusCode
operator|==
literal|407
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|->
name|phase
operator|==
name|QAuthenticatorPrivate
operator|::
name|Done
condition|)
block|{
name|socket
operator|->
name|blockSignals
argument_list|(
literal|true
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
if|if
condition|(
name|statusCode
operator|==
literal|407
condition|)
emit|emit
name|q
operator|->
name|proxyAuthenticationRequired
argument_list|(
name|proxy
argument_list|,
name|auth
argument_list|)
emit|;
else|else
endif|#
directive|endif
emit|emit
name|q
operator|->
name|authenticationRequired
argument_list|(
name|hostName
argument_list|,
name|port
argument_list|,
name|auth
argument_list|)
emit|;
name|socket
operator|->
name|blockSignals
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|priv
operator|->
name|phase
operator|==
name|QAuthenticatorPrivate
operator|::
name|Invalid
condition|)
block|{
name|finishedWithError
argument_list|(
name|QLatin1String
argument_list|(
name|QT_TRANSLATE_NOOP
argument_list|(
literal|"QHttp"
argument_list|,
literal|"Unknown authentication method"
argument_list|)
argument_list|)
argument_list|,
name|QHttp
operator|::
name|AuthenticationRequiredError
argument_list|)
expr_stmt|;
name|closeConn
argument_list|()
expr_stmt|;
return|return;
block|}
comment|// priv->phase will get reset to QAuthenticatorPrivate::Start if the authenticator got modified in the signal above.
if|if
condition|(
name|priv
operator|->
name|phase
operator|==
name|QAuthenticatorPrivate
operator|::
name|Done
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
if|if
condition|(
name|statusCode
operator|==
literal|407
condition|)
name|finishedWithError
argument_list|(
name|QLatin1String
argument_list|(
name|QT_TRANSLATE_NOOP
argument_list|(
literal|"QHttp"
argument_list|,
literal|"Proxy authentication required"
argument_list|)
argument_list|)
argument_list|,
name|QHttp
operator|::
name|ProxyAuthenticationRequiredError
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|finishedWithError
argument_list|(
name|QLatin1String
argument_list|(
name|QT_TRANSLATE_NOOP
argument_list|(
literal|"QHttp"
argument_list|,
literal|"Authentication required"
argument_list|)
argument_list|)
argument_list|,
name|QHttp
operator|::
name|AuthenticationRequiredError
argument_list|)
expr_stmt|;
name|closeConn
argument_list|()
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|// close the connection if it isn't already and reconnect using the chosen authentication method
name|bool
name|willClose
init|=
operator|(
name|response
operator|.
name|value
argument_list|(
name|QLatin1String
argument_list|(
literal|"proxy-connection"
argument_list|)
argument_list|)
operator|.
name|toLower
argument_list|()
operator|==
name|QLatin1String
argument_list|(
literal|"close"
argument_list|)
operator|)
operator|||
operator|(
name|response
operator|.
name|value
argument_list|(
name|QLatin1String
argument_list|(
literal|"connection"
argument_list|)
argument_list|)
operator|.
name|toLower
argument_list|()
operator|==
name|QLatin1String
argument_list|(
literal|"close"
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|willClose
condition|)
block|{
if|if
condition|(
name|socket
condition|)
block|{
name|setState
argument_list|(
name|QHttp
operator|::
name|Closing
argument_list|)
expr_stmt|;
name|socket
operator|->
name|blockSignals
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|socket
operator|->
name|close
argument_list|()
expr_stmt|;
name|socket
operator|->
name|blockSignals
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|socket
operator|->
name|readAll
argument_list|()
expr_stmt|;
block|}
name|_q_slotSendRequest
argument_list|()
expr_stmt|;
return|return;
block|}
else|else
block|{
name|repost
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|buffer
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|response
operator|.
name|statusCode
argument_list|()
operator|==
literal|100
operator|&&
name|pendingPost
condition|)
block|{
comment|// if we have pending POST, start sending data otherwise ignore
name|post100ContinueTimer
operator|.
name|stop
argument_list|()
expr_stmt|;
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|q
argument_list|,
literal|"_q_continuePost"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// The 100-continue header is ignored (in case of no 'expect:100-continue' header),
comment|// because when using the POST method, we send both the request header and data in
comment|// one chunk.
if|if
condition|(
name|response
operator|.
name|statusCode
argument_list|()
operator|!=
literal|100
condition|)
block|{
name|post100ContinueTimer
operator|.
name|stop
argument_list|()
expr_stmt|;
name|pendingPost
operator|=
literal|false
expr_stmt|;
name|readHeader
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|response
operator|.
name|hasKey
argument_list|(
name|QLatin1String
argument_list|(
literal|"transfer-encoding"
argument_list|)
argument_list|)
operator|&&
name|response
operator|.
name|value
argument_list|(
name|QLatin1String
argument_list|(
literal|"transfer-encoding"
argument_list|)
argument_list|)
operator|.
name|toLower
argument_list|()
operator|.
name|contains
argument_list|(
name|QLatin1String
argument_list|(
literal|"chunked"
argument_list|)
argument_list|)
condition|)
name|chunkedSize
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|repost
condition|)
emit|emit
name|q
operator|->
name|responseHeaderReceived
argument_list|(
name|response
argument_list|)
emit|;
if|if
condition|(
name|state
operator|==
name|QHttp
operator|::
name|Unconnected
operator|||
name|state
operator|==
name|QHttp
operator|::
name|Closing
condition|)
return|return;
block|}
else|else
block|{
comment|// Restore the state, the next incoming data will be treated as if
comment|// we never say the 100 response.
name|state
operator|=
name|oldState
expr_stmt|;
block|}
block|}
name|bool
name|everythingRead
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|q
operator|->
name|currentRequest
argument_list|()
operator|.
name|method
argument_list|()
operator|==
name|QLatin1String
argument_list|(
literal|"HEAD"
argument_list|)
operator|||
name|response
operator|.
name|statusCode
argument_list|()
operator|==
literal|304
operator|||
name|response
operator|.
name|statusCode
argument_list|()
operator|==
literal|204
operator|||
name|response
operator|.
name|statusCode
argument_list|()
operator|==
literal|205
condition|)
block|{
comment|// HEAD requests have only headers as replies
comment|// These status codes never have a body:
comment|//  304 Not Modified
comment|//  204 No Content
comment|//  205 Reset Content
name|everythingRead
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|qint64
name|n
init|=
name|socket
operator|->
name|bytesAvailable
argument_list|()
decl_stmt|;
name|QByteArray
modifier|*
name|arr
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|chunkedSize
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// transfer-encoding is chunked
for|for
control|(
init|;
condition|;
control|)
block|{
comment|// get chunk size
if|if
condition|(
name|chunkedSize
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|socket
operator|->
name|canReadLine
argument_list|()
condition|)
break|break;
name|QString
name|sizeString
init|=
name|QString
operator|::
name|fromAscii
argument_list|(
name|socket
operator|->
name|readLine
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|tPos
init|=
name|sizeString
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|';'
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|tPos
operator|!=
operator|-
literal|1
condition|)
name|sizeString
operator|.
name|truncate
argument_list|(
name|tPos
argument_list|)
expr_stmt|;
name|bool
name|ok
decl_stmt|;
name|chunkedSize
operator|=
name|sizeString
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
name|finishedWithError
argument_list|(
name|QLatin1String
argument_list|(
name|QT_TRANSLATE_NOOP
argument_list|(
literal|"QHttp"
argument_list|,
literal|"Invalid HTTP chunked body"
argument_list|)
argument_list|)
argument_list|,
name|QHttp
operator|::
name|WrongContentLength
argument_list|)
expr_stmt|;
name|closeConn
argument_list|()
expr_stmt|;
operator|delete
name|arr
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|chunkedSize
operator|==
literal|0
condition|)
comment|// last-chunk
name|chunkedSize
operator|=
operator|-
literal|2
expr_stmt|;
block|}
comment|// read trailer
while|while
condition|(
name|chunkedSize
operator|==
operator|-
literal|2
operator|&&
name|socket
operator|->
name|canReadLine
argument_list|()
condition|)
block|{
name|QString
name|read
init|=
name|QString
operator|::
name|fromAscii
argument_list|(
name|socket
operator|->
name|readLine
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|read
operator|==
name|QLatin1String
argument_list|(
literal|"\r\n"
argument_list|)
operator|||
name|read
operator|==
name|QLatin1String
argument_list|(
literal|"\n"
argument_list|)
condition|)
name|chunkedSize
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|chunkedSize
operator|==
operator|-
literal|1
condition|)
block|{
name|everythingRead
operator|=
literal|true
expr_stmt|;
break|break;
block|}
comment|// make sure that you can read the terminating CRLF,
comment|// otherwise wait until next time...
name|n
operator|=
name|socket
operator|->
name|bytesAvailable
argument_list|()
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|n
operator|==
name|chunkedSize
operator|||
name|n
operator|==
name|chunkedSize
operator|+
literal|1
condition|)
block|{
name|n
operator|=
name|chunkedSize
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
break|break;
block|}
comment|// read data
name|qint64
name|toRead
init|=
name|chunkedSize
operator|<
literal|0
condition|?
name|n
else|:
name|qMin
argument_list|(
name|n
argument_list|,
name|chunkedSize
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|arr
condition|)
name|arr
operator|=
operator|new
name|QByteArray
expr_stmt|;
name|uint
name|oldArrSize
init|=
name|arr
operator|->
name|size
argument_list|()
decl_stmt|;
name|arr
operator|->
name|resize
argument_list|(
name|oldArrSize
operator|+
name|toRead
argument_list|)
expr_stmt|;
name|qint64
name|read
init|=
name|socket
operator|->
name|read
argument_list|(
name|arr
operator|->
name|data
argument_list|()
operator|+
name|oldArrSize
argument_list|,
name|toRead
argument_list|)
decl_stmt|;
name|arr
operator|->
name|resize
argument_list|(
name|oldArrSize
operator|+
name|read
argument_list|)
expr_stmt|;
name|chunkedSize
operator|-=
name|read
expr_stmt|;
if|if
condition|(
name|chunkedSize
operator|==
literal|0
operator|&&
name|n
operator|-
name|read
operator|>=
literal|2
condition|)
block|{
comment|// read terminating CRLF
name|char
name|tmp
index|[
literal|2
index|]
decl_stmt|;
name|socket
operator|->
name|read
argument_list|(
name|tmp
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
index|[
literal|0
index|]
operator|!=
literal|'\r'
operator|||
name|tmp
index|[
literal|1
index|]
operator|!=
literal|'\n'
condition|)
block|{
name|finishedWithError
argument_list|(
name|QLatin1String
argument_list|(
name|QT_TRANSLATE_NOOP
argument_list|(
literal|"QHttp"
argument_list|,
literal|"Invalid HTTP chunked body"
argument_list|)
argument_list|)
argument_list|,
name|QHttp
operator|::
name|WrongContentLength
argument_list|)
expr_stmt|;
name|closeConn
argument_list|()
expr_stmt|;
operator|delete
name|arr
expr_stmt|;
return|return;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|response
operator|.
name|hasContentLength
argument_list|()
condition|)
block|{
if|if
condition|(
name|repost
operator|&&
operator|(
name|n
operator|<
name|response
operator|.
name|contentLength
argument_list|()
operator|)
condition|)
block|{
comment|// wait for the content to be available fully
comment|// if repost is required, the content is ignored
return|return;
block|}
name|n
operator|=
name|qMin
argument_list|(
name|qint64
argument_list|(
name|response
operator|.
name|contentLength
argument_list|()
operator|-
name|bytesDone
argument_list|)
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|arr
operator|=
operator|new
name|QByteArray
expr_stmt|;
name|arr
operator|->
name|resize
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|qint64
name|read
init|=
name|socket
operator|->
name|read
argument_list|(
name|arr
operator|->
name|data
argument_list|()
argument_list|,
name|n
argument_list|)
decl_stmt|;
name|arr
operator|->
name|resize
argument_list|(
name|read
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bytesDone
operator|+
name|q
operator|->
name|bytesAvailable
argument_list|()
operator|+
name|n
operator|==
name|response
operator|.
name|contentLength
argument_list|()
condition|)
name|everythingRead
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
comment|// workaround for VC++ bug
name|QByteArray
name|temp
init|=
name|socket
operator|->
name|readAll
argument_list|()
decl_stmt|;
name|arr
operator|=
operator|new
name|QByteArray
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arr
operator|&&
operator|!
name|repost
condition|)
block|{
name|n
operator|=
name|arr
operator|->
name|size
argument_list|()
expr_stmt|;
if|if
condition|(
name|toDevice
condition|)
block|{
name|qint64
name|bytesWritten
decl_stmt|;
name|bytesWritten
operator|=
name|toDevice
operator|->
name|write
argument_list|(
operator|*
name|arr
argument_list|,
name|n
argument_list|)
expr_stmt|;
operator|delete
name|arr
expr_stmt|;
name|arr
operator|=
literal|0
expr_stmt|;
comment|// if writing to the device does not succeed, quit with error
if|if
condition|(
name|bytesWritten
operator|==
operator|-
literal|1
operator|||
name|bytesWritten
operator|<
name|n
condition|)
block|{
name|finishedWithError
argument_list|(
name|QLatin1String
argument_list|(
name|QT_TRANSLATE_NOOP
argument_list|(
literal|"QHttp"
argument_list|,
literal|"Error writing response to device"
argument_list|)
argument_list|)
argument_list|,
name|QHttp
operator|::
name|UnknownError
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bytesDone
operator|+=
name|bytesWritten
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QHTTP_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QHttp::_q_slotReadyRead(): read %lld bytes (%lld bytes done)"
argument_list|,
name|n
argument_list|,
name|bytesDone
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|response
operator|.
name|hasContentLength
argument_list|()
condition|)
emit|emit
name|q
operator|->
name|dataReadProgress
argument_list|(
name|bytesDone
argument_list|,
name|response
operator|.
name|contentLength
argument_list|()
argument_list|)
emit|;
else|else
emit|emit
name|q
operator|->
name|dataReadProgress
argument_list|(
name|bytesDone
argument_list|,
literal|0
argument_list|)
emit|;
block|}
else|else
block|{
name|char
modifier|*
name|ptr
init|=
name|rba
operator|.
name|reserve
argument_list|(
name|arr
operator|->
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|ptr
argument_list|,
name|arr
operator|->
name|data
argument_list|()
argument_list|,
name|arr
operator|->
name|size
argument_list|()
argument_list|)
expr_stmt|;
operator|delete
name|arr
expr_stmt|;
name|arr
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QHTTP_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QHttp::_q_slotReadyRead(): read %lld bytes (%lld bytes done)"
argument_list|,
name|n
argument_list|,
name|bytesDone
operator|+
name|q
operator|->
name|bytesAvailable
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|response
operator|.
name|hasContentLength
argument_list|()
condition|)
emit|emit
name|q
operator|->
name|dataReadProgress
argument_list|(
name|bytesDone
operator|+
name|q
operator|->
name|bytesAvailable
argument_list|()
argument_list|,
name|response
operator|.
name|contentLength
argument_list|()
argument_list|)
emit|;
else|else
emit|emit
name|q
operator|->
name|dataReadProgress
argument_list|(
name|bytesDone
operator|+
name|q
operator|->
name|bytesAvailable
argument_list|()
argument_list|,
literal|0
argument_list|)
emit|;
emit|emit
name|q
operator|->
name|readyRead
argument_list|(
name|response
argument_list|)
emit|;
block|}
block|}
operator|delete
name|arr
expr_stmt|;
block|}
if|if
condition|(
name|everythingRead
condition|)
block|{
if|if
condition|(
name|repost
condition|)
block|{
name|_q_slotSendRequest
argument_list|()
expr_stmt|;
return|return;
block|}
comment|// Handle "Connection: close"
if|if
condition|(
name|response
operator|.
name|value
argument_list|(
name|QLatin1String
argument_list|(
literal|"connection"
argument_list|)
argument_list|)
operator|.
name|toLower
argument_list|()
operator|==
name|QLatin1String
argument_list|(
literal|"close"
argument_list|)
condition|)
block|{
name|closeConn
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|setState
argument_list|(
name|QHttp
operator|::
name|Connected
argument_list|)
expr_stmt|;
comment|// Start a timer, so that we emit the keep alive signal
comment|// "after" this method returned.
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|q
argument_list|,
literal|"_q_slotDoFinished"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
block|}
block|}
block|}
DECL|function|_q_slotDoFinished
name|void
name|QHttpPrivate
operator|::
name|_q_slotDoFinished
parameter_list|()
block|{
if|if
condition|(
name|state
operator|==
name|QHttp
operator|::
name|Connected
condition|)
block|{
name|finishedWithSuccess
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|!=
name|QHttp
operator|::
name|Unconnected
condition|)
block|{
name|setState
argument_list|(
name|QHttp
operator|::
name|Unconnected
argument_list|)
expr_stmt|;
name|finishedWithSuccess
argument_list|()
expr_stmt|;
block|}
block|}
comment|/*!     Returns the current state of the object. When the state changes,     the stateChanged() signal is emitted.      \sa State stateChanged() */
DECL|function|state
name|QHttp
operator|::
name|State
name|QHttp
operator|::
name|state
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QHttp
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|state
return|;
block|}
comment|/*!     Returns the last error that occurred. This is useful to find out     what happened when receiving a requestFinished() or a done()     signal with the \c error argument \c true.      If you start a new request, the error status is reset to \c NoError. */
DECL|function|error
name|QHttp
operator|::
name|Error
name|QHttp
operator|::
name|error
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QHttp
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|error
return|;
block|}
comment|/*!     Returns a human-readable description of the last error that     occurred. This is useful to present a error message to the user     when receiving a requestFinished() or a done() signal with the \c     error argument \c true. */
DECL|function|errorString
name|QString
name|QHttp
operator|::
name|errorString
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QHttp
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|errorString
return|;
block|}
DECL|function|setState
name|void
name|QHttpPrivate
operator|::
name|setState
parameter_list|(
name|int
name|s
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QHttp
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QHTTP_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QHttp state changed %d -> %d"
argument_list|,
name|state
argument_list|,
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|state
operator|=
name|QHttp
operator|::
name|State
argument_list|(
name|s
argument_list|)
expr_stmt|;
emit|emit
name|q
operator|->
name|stateChanged
argument_list|(
name|s
argument_list|)
emit|;
block|}
DECL|function|closeConn
name|void
name|QHttpPrivate
operator|::
name|closeConn
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QHttp
argument_list|)
expr_stmt|;
comment|// If no connection is open -> ignore
if|if
condition|(
name|state
operator|==
name|QHttp
operator|::
name|Closing
operator|||
name|state
operator|==
name|QHttp
operator|::
name|Unconnected
condition|)
return|return;
name|postDevice
operator|=
literal|0
expr_stmt|;
name|setState
argument_list|(
name|QHttp
operator|::
name|Closing
argument_list|)
expr_stmt|;
comment|// Already closed ?
if|if
condition|(
operator|!
name|socket
operator|||
operator|!
name|socket
operator|->
name|isOpen
argument_list|()
condition|)
block|{
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|q
argument_list|,
literal|"_q_slotDoFinished"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Close now.
name|socket
operator|->
name|close
argument_list|()
expr_stmt|;
block|}
block|}
DECL|function|setSock
name|void
name|QHttpPrivate
operator|::
name|setSock
parameter_list|(
name|QTcpSocket
modifier|*
name|sock
parameter_list|)
block|{
name|Q_Q
argument_list|(
specifier|const
name|QHttp
argument_list|)
expr_stmt|;
comment|// disconnect all existing signals
if|if
condition|(
name|socket
condition|)
name|socket
operator|->
name|disconnect
argument_list|()
expr_stmt|;
if|if
condition|(
name|deleteSocket
condition|)
operator|delete
name|socket
expr_stmt|;
comment|// use the new QTcpSocket socket, or create one if socket is 0.
name|deleteSocket
operator|=
operator|(
name|sock
operator|==
literal|0
operator|)
expr_stmt|;
name|socket
operator|=
name|sock
expr_stmt|;
if|if
condition|(
operator|!
name|socket
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_OPENSSL
if|if
condition|(
name|QSslSocket
operator|::
name|supportsSsl
argument_list|()
condition|)
name|socket
operator|=
operator|new
name|QSslSocket
argument_list|()
expr_stmt|;
else|else
endif|#
directive|endif
name|socket
operator|=
operator|new
name|QTcpSocket
argument_list|()
expr_stmt|;
block|}
comment|// connect all signals
name|QObject
operator|::
name|connect
argument_list|(
name|socket
argument_list|,
name|SIGNAL
argument_list|(
name|connected
argument_list|()
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_slotConnected
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|socket
argument_list|,
name|SIGNAL
argument_list|(
name|disconnected
argument_list|()
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_slotClosed
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|socket
argument_list|,
name|SIGNAL
argument_list|(
name|readyRead
argument_list|()
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_slotReadyRead
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|socket
argument_list|,
name|SIGNAL
argument_list|(
name|error
argument_list|(
name|QAbstractSocket
operator|::
name|SocketError
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_slotError
argument_list|(
name|QAbstractSocket
operator|::
name|SocketError
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|socket
argument_list|,
name|SIGNAL
argument_list|(
name|bytesWritten
argument_list|(
name|qint64
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_slotBytesWritten
argument_list|(
name|qint64
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
name|QObject
operator|::
name|connect
argument_list|(
name|socket
argument_list|,
name|SIGNAL
argument_list|(
name|proxyAuthenticationRequired
argument_list|(
name|QNetworkProxy
argument_list|,
name|QAuthenticator
operator|*
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|SIGNAL
argument_list|(
name|proxyAuthenticationRequired
argument_list|(
name|QNetworkProxy
argument_list|,
name|QAuthenticator
operator|*
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_OPENSSL
if|if
condition|(
name|qobject_cast
argument_list|<
name|QSslSocket
operator|*
argument_list|>
argument_list|(
name|socket
argument_list|)
condition|)
block|{
name|QObject
operator|::
name|connect
argument_list|(
name|socket
argument_list|,
name|SIGNAL
argument_list|(
name|sslErrors
argument_list|(
name|QList
argument_list|<
name|QSslError
argument_list|>
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|SIGNAL
argument_list|(
name|sslErrors
argument_list|(
name|QList
argument_list|<
name|QSslError
argument_list|>
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|socket
argument_list|,
name|SIGNAL
argument_list|(
name|encryptedBytesWritten
argument_list|(
name|qint64
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_slotEncryptedBytesWritten
argument_list|(
name|qint64
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
comment|/*!     Tells the QSslSocket used for the Http connection to ignore the errors     reported in the sslErrors() signal.      Note that this function must be called from within a slot connected to the     sslErrors() signal to have any effect.      \sa QSslSocket QSslSocket::sslErrors() */
ifndef|#
directive|ifndef
name|QT_NO_OPENSSL
DECL|function|ignoreSslErrors
name|void
name|QHttp
operator|::
name|ignoreSslErrors
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QHttp
argument_list|)
expr_stmt|;
name|QSslSocket
modifier|*
name|sslSocket
init|=
name|qobject_cast
argument_list|<
name|QSslSocket
operator|*
argument_list|>
argument_list|(
name|d
operator|->
name|socket
argument_list|)
decl_stmt|;
if|if
condition|(
name|sslSocket
condition|)
name|sslSocket
operator|->
name|ignoreSslErrors
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
name|QT_END_NAMESPACE
end_function
begin_include
include|#
directive|include
file|"moc_qhttp.cpp"
end_include
begin_endif
endif|#
directive|endif
end_endif
end_unit
