begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the QtNetwork module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<private/qabstractsocket_p.h>
end_include
begin_include
include|#
directive|include
file|"qhttpnetworkconnection_p.h"
end_include
begin_include
include|#
directive|include
file|"qhttpnetworkconnectionchannel_p.h"
end_include
begin_include
include|#
directive|include
file|"private/qnoncontiguousbytedevice_p.h"
end_include
begin_include
include|#
directive|include
file|<private/qnetworkrequest_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qobject_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qauthenticator_p.h>
end_include
begin_include
include|#
directive|include
file|<qnetworkproxy.h>
end_include
begin_include
include|#
directive|include
file|<qauthenticator.h>
end_include
begin_include
include|#
directive|include
file|<qbuffer.h>
end_include
begin_include
include|#
directive|include
file|<qpair.h>
end_include
begin_include
include|#
directive|include
file|<qhttp.h>
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_HTTP
end_ifndef
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_OPENSSL
end_ifndef
begin_include
include|#
directive|include
file|<private/qsslsocket_p.h>
end_include
begin_include
include|#
directive|include
file|<QtNetwork/qsslkey.h>
end_include
begin_include
include|#
directive|include
file|<QtNetwork/qsslcipher.h>
end_include
begin_include
include|#
directive|include
file|<QtNetwork/qsslconfiguration.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
ifdef|#
directive|ifdef
name|Q_OS_SYMBIAN
DECL|member|defaultChannelCount
specifier|const
name|int
name|QHttpNetworkConnectionPrivate
operator|::
name|defaultChannelCount
init|=
literal|3
decl_stmt|;
end_decl_stmt
begin_else
else|#
directive|else
end_else
begin_decl_stmt
specifier|const
name|int
name|QHttpNetworkConnectionPrivate
operator|::
name|defaultChannelCount
init|=
literal|6
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// The pipeline length. So there will be 4 requests in flight.
end_comment
begin_decl_stmt
DECL|member|defaultPipelineLength
specifier|const
name|int
name|QHttpNetworkConnectionPrivate
operator|::
name|defaultPipelineLength
init|=
literal|3
decl_stmt|;
end_decl_stmt
begin_comment
comment|// Only re-fill the pipeline if there's defaultRePipelineLength slots free in the pipeline.
end_comment
begin_comment
comment|// This means that there are 2 requests in flight and 2 slots free that will be re-filled.
end_comment
begin_decl_stmt
DECL|member|defaultRePipelineLength
specifier|const
name|int
name|QHttpNetworkConnectionPrivate
operator|::
name|defaultRePipelineLength
init|=
literal|2
decl_stmt|;
end_decl_stmt
begin_constructor
DECL|function|QHttpNetworkConnectionPrivate
name|QHttpNetworkConnectionPrivate
operator|::
name|QHttpNetworkConnectionPrivate
parameter_list|(
specifier|const
name|QString
modifier|&
name|hostName
parameter_list|,
name|quint16
name|port
parameter_list|,
name|bool
name|encrypt
parameter_list|)
member_init_list|:
name|state
argument_list|(
name|RunningState
argument_list|)
member_init_list|,
name|hostName
argument_list|(
name|hostName
argument_list|)
member_init_list|,
name|port
argument_list|(
name|port
argument_list|)
member_init_list|,
name|encrypt
argument_list|(
name|encrypt
argument_list|)
member_init_list|,
name|channelCount
argument_list|(
name|defaultChannelCount
argument_list|)
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
member_init_list|,
name|networkProxy
argument_list|(
name|QNetworkProxy
operator|::
name|NoProxy
argument_list|)
endif|#
directive|endif
block|{
name|channels
operator|=
operator|new
name|QHttpNetworkConnectionChannel
index|[
name|channelCount
index|]
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QHttpNetworkConnectionPrivate
name|QHttpNetworkConnectionPrivate
operator|::
name|QHttpNetworkConnectionPrivate
parameter_list|(
name|quint16
name|channelCount
parameter_list|,
specifier|const
name|QString
modifier|&
name|hostName
parameter_list|,
name|quint16
name|port
parameter_list|,
name|bool
name|encrypt
parameter_list|)
member_init_list|:
name|state
argument_list|(
name|RunningState
argument_list|)
member_init_list|,
name|hostName
argument_list|(
name|hostName
argument_list|)
member_init_list|,
name|port
argument_list|(
name|port
argument_list|)
member_init_list|,
name|encrypt
argument_list|(
name|encrypt
argument_list|)
member_init_list|,
name|channelCount
argument_list|(
name|channelCount
argument_list|)
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
member_init_list|,
name|networkProxy
argument_list|(
name|QNetworkProxy
operator|::
name|NoProxy
argument_list|)
endif|#
directive|endif
block|{
name|channels
operator|=
operator|new
name|QHttpNetworkConnectionChannel
index|[
name|channelCount
index|]
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QHttpNetworkConnectionPrivate
name|QHttpNetworkConnectionPrivate
operator|::
name|~
name|QHttpNetworkConnectionPrivate
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|channelCount
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|channels
index|[
name|i
index|]
operator|.
name|socket
condition|)
block|{
name|channels
index|[
name|i
index|]
operator|.
name|socket
operator|->
name|close
argument_list|()
expr_stmt|;
operator|delete
name|channels
index|[
name|i
index|]
operator|.
name|socket
expr_stmt|;
block|}
block|}
operator|delete
index|[]
name|channels
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|init
name|void
name|QHttpNetworkConnectionPrivate
operator|::
name|init
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|channelCount
condition|;
name|i
operator|++
control|)
block|{
name|channels
index|[
name|i
index|]
operator|.
name|setConnection
argument_list|(
name|this
operator|->
name|q_func
argument_list|()
argument_list|)
expr_stmt|;
name|channels
index|[
name|i
index|]
operator|.
name|ssl
operator|=
name|encrypt
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_BEARERMANAGEMENT
comment|//push session down to channels
name|channels
index|[
name|i
index|]
operator|.
name|networkSession
operator|=
name|networkSession
expr_stmt|;
endif|#
directive|endif
name|channels
index|[
name|i
index|]
operator|.
name|init
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|pauseConnection
name|void
name|QHttpNetworkConnectionPrivate
operator|::
name|pauseConnection
parameter_list|()
block|{
name|state
operator|=
name|PausedState
expr_stmt|;
comment|// Disable all socket notifiers
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|channelCount
condition|;
name|i
operator|++
control|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_OPENSSL
if|if
condition|(
name|encrypt
condition|)
name|QSslSocketPrivate
operator|::
name|pauseSocketNotifiers
argument_list|(
cast|static_cast
argument_list|<
name|QSslSocket
operator|*
argument_list|>
argument_list|(
name|channels
index|[
name|i
index|]
operator|.
name|socket
argument_list|)
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|QAbstractSocketPrivate
operator|::
name|pauseSocketNotifiers
argument_list|(
name|channels
index|[
name|i
index|]
operator|.
name|socket
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|resumeConnection
name|void
name|QHttpNetworkConnectionPrivate
operator|::
name|resumeConnection
parameter_list|()
block|{
name|state
operator|=
name|RunningState
expr_stmt|;
comment|// Enable all socket notifiers
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|channelCount
condition|;
name|i
operator|++
control|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_OPENSSL
if|if
condition|(
name|encrypt
condition|)
name|QSslSocketPrivate
operator|::
name|resumeSocketNotifiers
argument_list|(
cast|static_cast
argument_list|<
name|QSslSocket
operator|*
argument_list|>
argument_list|(
name|channels
index|[
name|i
index|]
operator|.
name|socket
argument_list|)
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|QAbstractSocketPrivate
operator|::
name|resumeSocketNotifiers
argument_list|(
name|channels
index|[
name|i
index|]
operator|.
name|socket
argument_list|)
expr_stmt|;
comment|// Resume pending upload if needed
if|if
condition|(
name|channels
index|[
name|i
index|]
operator|.
name|state
operator|==
name|QHttpNetworkConnectionChannel
operator|::
name|WritingState
condition|)
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
operator|&
name|channels
index|[
name|i
index|]
argument_list|,
literal|"_q_uploadDataReadyRead"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
block|}
comment|// queue _q_startNextRequest
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|this
operator|->
name|q_func
argument_list|()
argument_list|,
literal|"_q_startNextRequest"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|indexOf
name|int
name|QHttpNetworkConnectionPrivate
operator|::
name|indexOf
parameter_list|(
name|QAbstractSocket
modifier|*
name|socket
parameter_list|)
specifier|const
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|channelCount
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|channels
index|[
name|i
index|]
operator|.
name|socket
operator|==
name|socket
condition|)
return|return
name|i
return|;
name|qFatal
argument_list|(
literal|"Called with unknown socket object."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|uncompressedBytesAvailable
name|qint64
name|QHttpNetworkConnectionPrivate
operator|::
name|uncompressedBytesAvailable
parameter_list|(
specifier|const
name|QHttpNetworkReply
modifier|&
name|reply
parameter_list|)
specifier|const
block|{
return|return
name|reply
operator|.
name|d_func
argument_list|()
operator|->
name|responseData
operator|.
name|byteAmount
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|uncompressedBytesAvailableNextBlock
name|qint64
name|QHttpNetworkConnectionPrivate
operator|::
name|uncompressedBytesAvailableNextBlock
parameter_list|(
specifier|const
name|QHttpNetworkReply
modifier|&
name|reply
parameter_list|)
specifier|const
block|{
return|return
name|reply
operator|.
name|d_func
argument_list|()
operator|->
name|responseData
operator|.
name|sizeNextBlock
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|prepareRequest
name|void
name|QHttpNetworkConnectionPrivate
operator|::
name|prepareRequest
parameter_list|(
name|HttpMessagePair
modifier|&
name|messagePair
parameter_list|)
block|{
name|QHttpNetworkRequest
modifier|&
name|request
init|=
name|messagePair
operator|.
name|first
decl_stmt|;
name|QHttpNetworkReply
modifier|*
name|reply
init|=
name|messagePair
operator|.
name|second
decl_stmt|;
comment|// add missing fields for the request
name|QByteArray
name|value
decl_stmt|;
comment|// check if Content-Length is provided
name|QNonContiguousByteDevice
modifier|*
name|uploadByteDevice
init|=
name|request
operator|.
name|uploadByteDevice
argument_list|()
decl_stmt|;
if|if
condition|(
name|uploadByteDevice
condition|)
block|{
if|if
condition|(
name|request
operator|.
name|contentLength
argument_list|()
operator|!=
operator|-
literal|1
operator|&&
name|uploadByteDevice
operator|->
name|size
argument_list|()
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// both values known, take the smaller one.
name|request
operator|.
name|setContentLength
argument_list|(
name|qMin
argument_list|(
name|uploadByteDevice
operator|->
name|size
argument_list|()
argument_list|,
name|request
operator|.
name|contentLength
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|request
operator|.
name|contentLength
argument_list|()
operator|==
operator|-
literal|1
operator|&&
name|uploadByteDevice
operator|->
name|size
argument_list|()
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// content length not supplied by user, but the upload device knows it
name|request
operator|.
name|setContentLength
argument_list|(
name|uploadByteDevice
operator|->
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|request
operator|.
name|contentLength
argument_list|()
operator|!=
operator|-
literal|1
operator|&&
name|uploadByteDevice
operator|->
name|size
argument_list|()
operator|==
operator|-
literal|1
condition|)
block|{
comment|// everything OK, the user supplied us the contentLength
block|}
elseif|else
if|if
condition|(
name|request
operator|.
name|contentLength
argument_list|()
operator|==
operator|-
literal|1
operator|&&
name|uploadByteDevice
operator|->
name|size
argument_list|()
operator|==
operator|-
literal|1
condition|)
block|{
name|qFatal
argument_list|(
literal|"QHttpNetworkConnectionPrivate: Neither content-length nor upload device size were given"
argument_list|)
expr_stmt|;
block|}
block|}
comment|// set the Connection/Proxy-Connection: Keep-Alive headers
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
if|if
condition|(
name|networkProxy
operator|.
name|type
argument_list|()
operator|==
name|QNetworkProxy
operator|::
name|HttpCachingProxy
condition|)
block|{
name|value
operator|=
name|request
operator|.
name|headerField
argument_list|(
literal|"proxy-connection"
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|.
name|isEmpty
argument_list|()
condition|)
name|request
operator|.
name|setHeaderField
argument_list|(
literal|"Proxy-Connection"
argument_list|,
literal|"Keep-Alive"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
endif|#
directive|endif
name|value
operator|=
name|request
operator|.
name|headerField
argument_list|(
literal|"connection"
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|.
name|isEmpty
argument_list|()
condition|)
name|request
operator|.
name|setHeaderField
argument_list|(
literal|"Connection"
argument_list|,
literal|"Keep-Alive"
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
block|}
endif|#
directive|endif
comment|// If the request had a accept-encoding set, we better not mess
comment|// with it. If it was not set, we announce that we understand gzip
comment|// and remember this fact in request.d->autoDecompress so that
comment|// we can later decompress the HTTP reply if it has such an
comment|// encoding.
name|value
operator|=
name|request
operator|.
name|headerField
argument_list|(
literal|"accept-encoding"
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_COMPRESS
name|request
operator|.
name|setHeaderField
argument_list|(
literal|"Accept-Encoding"
argument_list|,
literal|"gzip"
argument_list|)
expr_stmt|;
name|request
operator|.
name|d
operator|->
name|autoDecompress
operator|=
literal|true
expr_stmt|;
else|#
directive|else
comment|// if zlib is not available set this to false always
name|request
operator|.
name|d
operator|->
name|autoDecompress
operator|=
literal|false
expr_stmt|;
endif|#
directive|endif
block|}
comment|// some websites mandate an accept-language header and fail
comment|// if it is not sent. This is a problem with the website and
comment|// not with us, but we work around this by setting
comment|// one always.
name|value
operator|=
name|request
operator|.
name|headerField
argument_list|(
literal|"accept-language"
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QString
name|systemLocale
init|=
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|name
argument_list|()
operator|.
name|replace
argument_list|(
name|QChar
operator|::
name|fromAscii
argument_list|(
literal|'_'
argument_list|)
argument_list|,
name|QChar
operator|::
name|fromAscii
argument_list|(
literal|'-'
argument_list|)
argument_list|)
decl_stmt|;
name|QString
name|acceptLanguage
decl_stmt|;
if|if
condition|(
name|systemLocale
operator|==
name|QLatin1String
argument_list|(
literal|"C"
argument_list|)
condition|)
name|acceptLanguage
operator|=
name|QString
operator|::
name|fromAscii
argument_list|(
literal|"en,*"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|systemLocale
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"en-"
argument_list|)
argument_list|)
condition|)
name|acceptLanguage
operator|=
name|QString
operator|::
name|fromAscii
argument_list|(
literal|"%1,*"
argument_list|)
operator|.
name|arg
argument_list|(
name|systemLocale
argument_list|)
expr_stmt|;
else|else
name|acceptLanguage
operator|=
name|QString
operator|::
name|fromAscii
argument_list|(
literal|"%1,en,*"
argument_list|)
operator|.
name|arg
argument_list|(
name|systemLocale
argument_list|)
expr_stmt|;
name|request
operator|.
name|setHeaderField
argument_list|(
literal|"Accept-Language"
argument_list|,
name|acceptLanguage
operator|.
name|toAscii
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// set the User Agent
name|value
operator|=
name|request
operator|.
name|headerField
argument_list|(
literal|"user-agent"
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|.
name|isEmpty
argument_list|()
condition|)
name|request
operator|.
name|setHeaderField
argument_list|(
literal|"User-Agent"
argument_list|,
literal|"Mozilla/5.0"
argument_list|)
expr_stmt|;
comment|// set the host
name|value
operator|=
name|request
operator|.
name|headerField
argument_list|(
literal|"host"
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QByteArray
name|host
init|=
name|QUrl
operator|::
name|toAce
argument_list|(
name|hostName
argument_list|)
decl_stmt|;
name|int
name|port
init|=
name|request
operator|.
name|url
argument_list|()
operator|.
name|port
argument_list|()
decl_stmt|;
if|if
condition|(
name|port
operator|!=
operator|-
literal|1
condition|)
block|{
name|host
operator|+=
literal|':'
expr_stmt|;
name|host
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|port
argument_list|)
expr_stmt|;
block|}
name|request
operator|.
name|setHeaderField
argument_list|(
literal|"Host"
argument_list|,
name|host
argument_list|)
expr_stmt|;
block|}
name|reply
operator|->
name|d_func
argument_list|()
operator|->
name|requestIsPrepared
operator|=
literal|true
expr_stmt|;
block|}
end_function
begin_function
DECL|function|emitReplyError
name|void
name|QHttpNetworkConnectionPrivate
operator|::
name|emitReplyError
parameter_list|(
name|QAbstractSocket
modifier|*
name|socket
parameter_list|,
name|QHttpNetworkReply
modifier|*
name|reply
parameter_list|,
name|QNetworkReply
operator|::
name|NetworkError
name|errorCode
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QHttpNetworkConnection
argument_list|)
expr_stmt|;
if|if
condition|(
name|socket
operator|&&
name|reply
condition|)
block|{
comment|// this error matters only to this reply
name|reply
operator|->
name|d_func
argument_list|()
operator|->
name|errorString
operator|=
name|errorDetail
argument_list|(
name|errorCode
argument_list|,
name|socket
argument_list|)
expr_stmt|;
emit|emit
name|reply
operator|->
name|finishedWithError
argument_list|(
name|errorCode
argument_list|,
name|reply
operator|->
name|d_func
argument_list|()
operator|->
name|errorString
argument_list|)
emit|;
name|int
name|i
init|=
name|indexOf
argument_list|(
name|socket
argument_list|)
decl_stmt|;
comment|// remove the corrupt data if any
name|reply
operator|->
name|d_func
argument_list|()
operator|->
name|eraseData
argument_list|()
expr_stmt|;
comment|// Clean the channel
name|channels
index|[
name|i
index|]
operator|.
name|close
argument_list|()
expr_stmt|;
name|channels
index|[
name|i
index|]
operator|.
name|reply
operator|=
literal|0
expr_stmt|;
name|channels
index|[
name|i
index|]
operator|.
name|request
operator|=
name|QHttpNetworkRequest
argument_list|()
expr_stmt|;
name|channels
index|[
name|i
index|]
operator|.
name|requeueCurrentlyPipelinedRequests
argument_list|()
expr_stmt|;
comment|// send the next request
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|q
argument_list|,
literal|"_q_startNextRequest"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|copyCredentials
name|void
name|QHttpNetworkConnectionPrivate
operator|::
name|copyCredentials
parameter_list|(
name|int
name|fromChannel
parameter_list|,
name|QAuthenticator
modifier|*
name|auth
parameter_list|,
name|bool
name|isProxy
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|auth
argument_list|)
expr_stmt|;
comment|// NTLM is a multi phase authentication. Copying credentials between authenticators would mess things up.
if|if
condition|(
operator|!
name|isProxy
operator|&&
name|channels
index|[
name|fromChannel
index|]
operator|.
name|authMethod
operator|==
name|QAuthenticatorPrivate
operator|::
name|Ntlm
condition|)
return|return;
if|if
condition|(
name|isProxy
operator|&&
name|channels
index|[
name|fromChannel
index|]
operator|.
name|proxyAuthMethod
operator|==
name|QAuthenticatorPrivate
operator|::
name|Ntlm
condition|)
return|return;
comment|// select another channel
name|QAuthenticator
modifier|*
name|otherAuth
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|channelCount
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|==
name|fromChannel
condition|)
continue|continue;
if|if
condition|(
name|isProxy
condition|)
name|otherAuth
operator|=
operator|&
name|channels
index|[
name|i
index|]
operator|.
name|proxyAuthenticator
expr_stmt|;
else|else
name|otherAuth
operator|=
operator|&
name|channels
index|[
name|i
index|]
operator|.
name|authenticator
expr_stmt|;
comment|// if the credentials are different, copy them
if|if
condition|(
name|otherAuth
operator|->
name|user
argument_list|()
operator|.
name|compare
argument_list|(
name|auth
operator|->
name|user
argument_list|()
argument_list|)
condition|)
name|otherAuth
operator|->
name|setUser
argument_list|(
name|auth
operator|->
name|user
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|otherAuth
operator|->
name|password
argument_list|()
operator|.
name|compare
argument_list|(
name|auth
operator|->
name|password
argument_list|()
argument_list|)
condition|)
name|otherAuth
operator|->
name|setPassword
argument_list|(
name|auth
operator|->
name|password
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|// handles the authentication for one channel and eventually re-starts the other channels
end_comment
begin_function
DECL|function|handleAuthenticateChallenge
name|bool
name|QHttpNetworkConnectionPrivate
operator|::
name|handleAuthenticateChallenge
parameter_list|(
name|QAbstractSocket
modifier|*
name|socket
parameter_list|,
name|QHttpNetworkReply
modifier|*
name|reply
parameter_list|,
name|bool
name|isProxy
parameter_list|,
name|bool
modifier|&
name|resend
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|socket
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|reply
argument_list|)
expr_stmt|;
name|resend
operator|=
literal|false
expr_stmt|;
comment|//create the response header to be used with QAuthenticatorPrivate.
name|QList
argument_list|<
name|QPair
argument_list|<
name|QByteArray
argument_list|,
name|QByteArray
argument_list|>
argument_list|>
name|fields
init|=
name|reply
operator|->
name|header
argument_list|()
decl_stmt|;
comment|//find out the type of authentication protocol requested.
name|QAuthenticatorPrivate
operator|::
name|Method
name|authMethod
init|=
name|reply
operator|->
name|d_func
argument_list|()
operator|->
name|authenticationMethod
argument_list|(
name|isProxy
argument_list|)
decl_stmt|;
if|if
condition|(
name|authMethod
operator|!=
name|QAuthenticatorPrivate
operator|::
name|None
condition|)
block|{
name|int
name|i
init|=
name|indexOf
argument_list|(
name|socket
argument_list|)
decl_stmt|;
comment|//Use a single authenticator for all domains. ### change later to use domain/realm
name|QAuthenticator
modifier|*
name|auth
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|isProxy
condition|)
block|{
name|auth
operator|=
operator|&
name|channels
index|[
name|i
index|]
operator|.
name|proxyAuthenticator
expr_stmt|;
name|channels
index|[
name|i
index|]
operator|.
name|proxyAuthMethod
operator|=
name|authMethod
expr_stmt|;
block|}
else|else
block|{
name|auth
operator|=
operator|&
name|channels
index|[
name|i
index|]
operator|.
name|authenticator
expr_stmt|;
name|channels
index|[
name|i
index|]
operator|.
name|authMethod
operator|=
name|authMethod
expr_stmt|;
block|}
comment|//proceed with the authentication.
if|if
condition|(
name|auth
operator|->
name|isNull
argument_list|()
condition|)
name|auth
operator|->
name|detach
argument_list|()
expr_stmt|;
name|QAuthenticatorPrivate
modifier|*
name|priv
init|=
name|QAuthenticatorPrivate
operator|::
name|getPrivate
argument_list|(
operator|*
name|auth
argument_list|)
decl_stmt|;
name|priv
operator|->
name|parseHttpResponse
argument_list|(
name|fields
argument_list|,
name|isProxy
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|->
name|phase
operator|==
name|QAuthenticatorPrivate
operator|::
name|Done
condition|)
block|{
name|pauseConnection
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|isProxy
condition|)
block|{
emit|emit
name|reply
operator|->
name|authenticationRequired
argument_list|(
name|reply
operator|->
name|request
argument_list|()
argument_list|,
name|auth
argument_list|)
emit|;
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
block|}
else|else
block|{
emit|emit
name|reply
operator|->
name|proxyAuthenticationRequired
argument_list|(
name|networkProxy
argument_list|,
name|auth
argument_list|)
emit|;
endif|#
directive|endif
block|}
name|resumeConnection
argument_list|()
expr_stmt|;
if|if
condition|(
name|priv
operator|->
name|phase
operator|!=
name|QAuthenticatorPrivate
operator|::
name|Done
condition|)
block|{
comment|// send any pending requests
name|copyCredentials
argument_list|(
name|i
argument_list|,
name|auth
argument_list|,
name|isProxy
argument_list|)
expr_stmt|;
block|}
block|}
comment|// - Changing values in QAuthenticator will reset the 'phase'. Therefore if it is still "Done"
comment|//   then nothing was filled in by the user or the cache
comment|// - If withCredentials has been set to false (e.g. by QtWebKit for a cross-origin XMLHttpRequest) then
comment|//   we need to bail out if authentication is required.
if|if
condition|(
name|priv
operator|->
name|phase
operator|==
name|QAuthenticatorPrivate
operator|::
name|Done
operator|||
operator|!
name|reply
operator|->
name|request
argument_list|()
operator|.
name|withCredentials
argument_list|()
condition|)
block|{
comment|// Reset authenticator so the next request on that channel does not get messed up
name|auth
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isProxy
condition|)
name|channels
index|[
name|i
index|]
operator|.
name|proxyAuthenticator
operator|=
name|QAuthenticator
argument_list|()
expr_stmt|;
else|else
name|channels
index|[
name|i
index|]
operator|.
name|authenticator
operator|=
name|QAuthenticator
argument_list|()
expr_stmt|;
comment|// authentication is cancelled, send the current contents to the user.
emit|emit
name|channels
index|[
name|i
index|]
operator|.
name|reply
operator|->
name|headerChanged
argument_list|()
emit|;
emit|emit
name|channels
index|[
name|i
index|]
operator|.
name|reply
operator|->
name|readyRead
argument_list|()
emit|;
name|QNetworkReply
operator|::
name|NetworkError
name|errorCode
init|=
name|isProxy
condition|?
name|QNetworkReply
operator|::
name|ProxyAuthenticationRequiredError
else|:
name|QNetworkReply
operator|::
name|AuthenticationRequiredError
decl_stmt|;
name|reply
operator|->
name|d_func
argument_list|()
operator|->
name|errorString
operator|=
name|errorDetail
argument_list|(
name|errorCode
argument_list|,
name|socket
argument_list|)
expr_stmt|;
emit|emit
name|reply
operator|->
name|finishedWithError
argument_list|(
name|errorCode
argument_list|,
name|reply
operator|->
name|d_func
argument_list|()
operator|->
name|errorString
argument_list|)
emit|;
comment|// ### at this point the reply could be deleted
name|socket
operator|->
name|close
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|//resend the request
name|resend
operator|=
literal|true
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|createAuthorization
name|void
name|QHttpNetworkConnectionPrivate
operator|::
name|createAuthorization
parameter_list|(
name|QAbstractSocket
modifier|*
name|socket
parameter_list|,
name|QHttpNetworkRequest
modifier|&
name|request
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|socket
argument_list|)
expr_stmt|;
name|int
name|i
init|=
name|indexOf
argument_list|(
name|socket
argument_list|)
decl_stmt|;
comment|// Send "Authorization" header, but not if it's NTLM and the socket is already authenticated.
if|if
condition|(
name|channels
index|[
name|i
index|]
operator|.
name|authMethod
operator|!=
name|QAuthenticatorPrivate
operator|::
name|None
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|channels
index|[
name|i
index|]
operator|.
name|authMethod
operator|==
name|QAuthenticatorPrivate
operator|::
name|Ntlm
operator|&&
name|channels
index|[
name|i
index|]
operator|.
name|lastStatus
operator|!=
literal|401
operator|)
condition|)
block|{
name|QAuthenticatorPrivate
modifier|*
name|priv
init|=
name|QAuthenticatorPrivate
operator|::
name|getPrivate
argument_list|(
name|channels
index|[
name|i
index|]
operator|.
name|authenticator
argument_list|)
decl_stmt|;
if|if
condition|(
name|priv
operator|&&
name|priv
operator|->
name|method
operator|!=
name|QAuthenticatorPrivate
operator|::
name|None
condition|)
block|{
name|QByteArray
name|response
init|=
name|priv
operator|->
name|calculateResponse
argument_list|(
name|request
operator|.
name|d
operator|->
name|methodName
argument_list|()
argument_list|,
name|request
operator|.
name|d
operator|->
name|uri
argument_list|(
literal|false
argument_list|)
argument_list|)
decl_stmt|;
name|request
operator|.
name|setHeaderField
argument_list|(
literal|"Authorization"
argument_list|,
name|response
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Send "Proxy-Authorization" header, but not if it's NTLM and the socket is already authenticated.
if|if
condition|(
name|channels
index|[
name|i
index|]
operator|.
name|proxyAuthMethod
operator|!=
name|QAuthenticatorPrivate
operator|::
name|None
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|channels
index|[
name|i
index|]
operator|.
name|proxyAuthMethod
operator|==
name|QAuthenticatorPrivate
operator|::
name|Ntlm
operator|&&
name|channels
index|[
name|i
index|]
operator|.
name|lastStatus
operator|!=
literal|407
operator|)
condition|)
block|{
name|QAuthenticatorPrivate
modifier|*
name|priv
init|=
name|QAuthenticatorPrivate
operator|::
name|getPrivate
argument_list|(
name|channels
index|[
name|i
index|]
operator|.
name|proxyAuthenticator
argument_list|)
decl_stmt|;
if|if
condition|(
name|priv
operator|&&
name|priv
operator|->
name|method
operator|!=
name|QAuthenticatorPrivate
operator|::
name|None
condition|)
block|{
name|QByteArray
name|response
init|=
name|priv
operator|->
name|calculateResponse
argument_list|(
name|request
operator|.
name|d
operator|->
name|methodName
argument_list|()
argument_list|,
name|request
operator|.
name|d
operator|->
name|uri
argument_list|(
literal|false
argument_list|)
argument_list|)
decl_stmt|;
name|request
operator|.
name|setHeaderField
argument_list|(
literal|"Proxy-Authorization"
argument_list|,
name|response
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_function
DECL|function|queueRequest
name|QHttpNetworkReply
modifier|*
name|QHttpNetworkConnectionPrivate
operator|::
name|queueRequest
parameter_list|(
specifier|const
name|QHttpNetworkRequest
modifier|&
name|request
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QHttpNetworkConnection
argument_list|)
expr_stmt|;
comment|// The reply component of the pair is created initially.
name|QHttpNetworkReply
modifier|*
name|reply
init|=
operator|new
name|QHttpNetworkReply
argument_list|(
name|request
operator|.
name|url
argument_list|()
argument_list|)
decl_stmt|;
name|reply
operator|->
name|setRequest
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|reply
operator|->
name|d_func
argument_list|()
operator|->
name|connection
operator|=
name|q
expr_stmt|;
name|reply
operator|->
name|d_func
argument_list|()
operator|->
name|connectionChannel
operator|=
operator|&
name|channels
index|[
literal|0
index|]
expr_stmt|;
comment|// will have the correct one set later
name|HttpMessagePair
name|pair
init|=
name|qMakePair
argument_list|(
name|request
argument_list|,
name|reply
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|request
operator|.
name|priority
argument_list|()
condition|)
block|{
case|case
name|QHttpNetworkRequest
operator|::
name|HighPriority
case|:
name|highPriorityQueue
operator|.
name|prepend
argument_list|(
name|pair
argument_list|)
expr_stmt|;
break|break;
case|case
name|QHttpNetworkRequest
operator|::
name|NormalPriority
case|:
case|case
name|QHttpNetworkRequest
operator|::
name|LowPriority
case|:
name|lowPriorityQueue
operator|.
name|prepend
argument_list|(
name|pair
argument_list|)
expr_stmt|;
break|break;
block|}
comment|// this used to be called via invokeMethod and a QueuedConnection
comment|// It is the only place _q_startNextRequest is called directly without going
comment|// through the event loop using a QueuedConnection.
comment|// This is dangerous because of recursion that might occur when emitting
comment|// signals as DirectConnection from this code path. Therefore all signal
comment|// emissions that can come out from this code path need to
comment|// be QueuedConnection.
comment|// We are currently trying to fine-tune this.
name|_q_startNextRequest
argument_list|()
expr_stmt|;
return|return
name|reply
return|;
block|}
end_function
begin_function
DECL|function|requeueRequest
name|void
name|QHttpNetworkConnectionPrivate
operator|::
name|requeueRequest
parameter_list|(
specifier|const
name|HttpMessagePair
modifier|&
name|pair
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QHttpNetworkConnection
argument_list|)
expr_stmt|;
name|QHttpNetworkRequest
name|request
init|=
name|pair
operator|.
name|first
decl_stmt|;
switch|switch
condition|(
name|request
operator|.
name|priority
argument_list|()
condition|)
block|{
case|case
name|QHttpNetworkRequest
operator|::
name|HighPriority
case|:
name|highPriorityQueue
operator|.
name|prepend
argument_list|(
name|pair
argument_list|)
expr_stmt|;
break|break;
case|case
name|QHttpNetworkRequest
operator|::
name|NormalPriority
case|:
case|case
name|QHttpNetworkRequest
operator|::
name|LowPriority
case|:
name|lowPriorityQueue
operator|.
name|prepend
argument_list|(
name|pair
argument_list|)
expr_stmt|;
break|break;
block|}
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|q
argument_list|,
literal|"_q_startNextRequest"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|dequeueRequest
name|bool
name|QHttpNetworkConnectionPrivate
operator|::
name|dequeueRequest
parameter_list|(
name|QAbstractSocket
modifier|*
name|socket
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|socket
argument_list|)
expr_stmt|;
name|int
name|i
init|=
name|indexOf
argument_list|(
name|socket
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|highPriorityQueue
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// remove from queue before sendRequest! else we might pipeline the same request again
name|HttpMessagePair
name|messagePair
init|=
name|highPriorityQueue
operator|.
name|takeLast
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|messagePair
operator|.
name|second
operator|->
name|d_func
argument_list|()
operator|->
name|requestIsPrepared
condition|)
name|prepareRequest
argument_list|(
name|messagePair
argument_list|)
expr_stmt|;
name|channels
index|[
name|i
index|]
operator|.
name|request
operator|=
name|messagePair
operator|.
name|first
expr_stmt|;
name|channels
index|[
name|i
index|]
operator|.
name|reply
operator|=
name|messagePair
operator|.
name|second
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
name|lowPriorityQueue
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// remove from queue before sendRequest! else we might pipeline the same request again
name|HttpMessagePair
name|messagePair
init|=
name|lowPriorityQueue
operator|.
name|takeLast
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|messagePair
operator|.
name|second
operator|->
name|d_func
argument_list|()
operator|->
name|requestIsPrepared
condition|)
name|prepareRequest
argument_list|(
name|messagePair
argument_list|)
expr_stmt|;
name|channels
index|[
name|i
index|]
operator|.
name|request
operator|=
name|messagePair
operator|.
name|first
expr_stmt|;
name|channels
index|[
name|i
index|]
operator|.
name|reply
operator|=
name|messagePair
operator|.
name|second
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|predictNextRequest
name|QHttpNetworkRequest
name|QHttpNetworkConnectionPrivate
operator|::
name|predictNextRequest
parameter_list|()
block|{
if|if
condition|(
operator|!
name|highPriorityQueue
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|highPriorityQueue
operator|.
name|last
argument_list|()
operator|.
name|first
return|;
if|if
condition|(
operator|!
name|lowPriorityQueue
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|lowPriorityQueue
operator|.
name|last
argument_list|()
operator|.
name|first
return|;
return|return
name|QHttpNetworkRequest
argument_list|()
return|;
block|}
end_function
begin_comment
comment|// this is called from _q_startNextRequest and when a request has been sent down a socket from the channel
end_comment
begin_function
DECL|function|fillPipeline
name|void
name|QHttpNetworkConnectionPrivate
operator|::
name|fillPipeline
parameter_list|(
name|QAbstractSocket
modifier|*
name|socket
parameter_list|)
block|{
comment|// return fast if there is nothing to pipeline
if|if
condition|(
name|highPriorityQueue
operator|.
name|isEmpty
argument_list|()
operator|&&
name|lowPriorityQueue
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|int
name|i
init|=
name|indexOf
argument_list|(
name|socket
argument_list|)
decl_stmt|;
comment|// return fast if there was no reply right now processed
if|if
condition|(
name|channels
index|[
name|i
index|]
operator|.
name|reply
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
name|defaultPipelineLength
operator|-
name|channels
index|[
name|i
index|]
operator|.
name|alreadyPipelinedRequests
operator|.
name|length
argument_list|()
operator|>=
name|defaultRePipelineLength
operator|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|channels
index|[
name|i
index|]
operator|.
name|pipeliningSupported
operator|!=
name|QHttpNetworkConnectionChannel
operator|::
name|PipeliningProbablySupported
condition|)
return|return;
comment|// the current request that is in must already support pipelining
if|if
condition|(
operator|!
name|channels
index|[
name|i
index|]
operator|.
name|request
operator|.
name|isPipeliningAllowed
argument_list|()
condition|)
return|return;
comment|// the current request must be a idempotent (right now we only check GET)
if|if
condition|(
name|channels
index|[
name|i
index|]
operator|.
name|request
operator|.
name|operation
argument_list|()
operator|!=
name|QHttpNetworkRequest
operator|::
name|Get
condition|)
return|return;
comment|// check if socket is connected
if|if
condition|(
name|socket
operator|->
name|state
argument_list|()
operator|!=
name|QAbstractSocket
operator|::
name|ConnectedState
condition|)
return|return;
comment|// check for resendCurrent
if|if
condition|(
name|channels
index|[
name|i
index|]
operator|.
name|resendCurrent
condition|)
return|return;
comment|// we do not like authentication stuff
comment|// ### make sure to be OK with this in later releases
if|if
condition|(
operator|!
name|channels
index|[
name|i
index|]
operator|.
name|authenticator
operator|.
name|isNull
argument_list|()
operator|||
operator|!
name|channels
index|[
name|i
index|]
operator|.
name|authenticator
operator|.
name|user
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
if|if
condition|(
operator|!
name|channels
index|[
name|i
index|]
operator|.
name|proxyAuthenticator
operator|.
name|isNull
argument_list|()
operator|||
operator|!
name|channels
index|[
name|i
index|]
operator|.
name|proxyAuthenticator
operator|.
name|user
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
comment|// must be in ReadingState or WaitingState
if|if
condition|(
operator|!
operator|(
name|channels
index|[
name|i
index|]
operator|.
name|state
operator|==
name|QHttpNetworkConnectionChannel
operator|::
name|WaitingState
operator|||
name|channels
index|[
name|i
index|]
operator|.
name|state
operator|==
name|QHttpNetworkConnectionChannel
operator|::
name|ReadingState
operator|)
condition|)
return|return;
name|int
name|lengthBefore
decl_stmt|;
while|while
condition|(
operator|!
name|highPriorityQueue
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|lengthBefore
operator|=
name|channels
index|[
name|i
index|]
operator|.
name|alreadyPipelinedRequests
operator|.
name|length
argument_list|()
expr_stmt|;
name|fillPipeline
argument_list|(
name|highPriorityQueue
argument_list|,
name|channels
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|channels
index|[
name|i
index|]
operator|.
name|alreadyPipelinedRequests
operator|.
name|length
argument_list|()
operator|>=
name|defaultPipelineLength
condition|)
block|{
name|channels
index|[
name|i
index|]
operator|.
name|pipelineFlush
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|lengthBefore
operator|==
name|channels
index|[
name|i
index|]
operator|.
name|alreadyPipelinedRequests
operator|.
name|length
argument_list|()
condition|)
break|break;
comment|// did not process anything, now do the low prio queue
block|}
while|while
condition|(
operator|!
name|lowPriorityQueue
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|lengthBefore
operator|=
name|channels
index|[
name|i
index|]
operator|.
name|alreadyPipelinedRequests
operator|.
name|length
argument_list|()
expr_stmt|;
name|fillPipeline
argument_list|(
name|lowPriorityQueue
argument_list|,
name|channels
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|channels
index|[
name|i
index|]
operator|.
name|alreadyPipelinedRequests
operator|.
name|length
argument_list|()
operator|>=
name|defaultPipelineLength
condition|)
block|{
name|channels
index|[
name|i
index|]
operator|.
name|pipelineFlush
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|lengthBefore
operator|==
name|channels
index|[
name|i
index|]
operator|.
name|alreadyPipelinedRequests
operator|.
name|length
argument_list|()
condition|)
break|break;
comment|// did not process anything
block|}
name|channels
index|[
name|i
index|]
operator|.
name|pipelineFlush
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|// returns true when the processing of a queue has been done
end_comment
begin_function
DECL|function|fillPipeline
name|bool
name|QHttpNetworkConnectionPrivate
operator|::
name|fillPipeline
parameter_list|(
name|QList
argument_list|<
name|HttpMessagePair
argument_list|>
modifier|&
name|queue
parameter_list|,
name|QHttpNetworkConnectionChannel
modifier|&
name|channel
parameter_list|)
block|{
if|if
condition|(
name|queue
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|true
return|;
for|for
control|(
name|int
name|i
init|=
name|queue
operator|.
name|count
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|HttpMessagePair
name|messagePair
init|=
name|queue
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|const
name|QHttpNetworkRequest
modifier|&
name|request
init|=
name|messagePair
operator|.
name|first
decl_stmt|;
comment|// we currently do not support pipelining if HTTP authentication is used
if|if
condition|(
operator|!
name|request
operator|.
name|url
argument_list|()
operator|.
name|userInfo
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
comment|// take only GET requests
if|if
condition|(
name|request
operator|.
name|operation
argument_list|()
operator|!=
name|QHttpNetworkRequest
operator|::
name|Get
condition|)
continue|continue;
if|if
condition|(
operator|!
name|request
operator|.
name|isPipeliningAllowed
argument_list|()
condition|)
continue|continue;
comment|// remove it from the queue
name|queue
operator|.
name|takeAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|// we modify the queue we iterate over here, but since we return from the function
comment|// afterwards this is fine.
comment|// actually send it
if|if
condition|(
operator|!
name|messagePair
operator|.
name|second
operator|->
name|d_func
argument_list|()
operator|->
name|requestIsPrepared
condition|)
name|prepareRequest
argument_list|(
name|messagePair
argument_list|)
expr_stmt|;
name|channel
operator|.
name|pipelineInto
argument_list|(
name|messagePair
argument_list|)
expr_stmt|;
comment|// return false because we processed something and need to process again
return|return
literal|false
return|;
block|}
comment|// return true, the queue has been processed and not changed
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|errorDetail
name|QString
name|QHttpNetworkConnectionPrivate
operator|::
name|errorDetail
parameter_list|(
name|QNetworkReply
operator|::
name|NetworkError
name|errorCode
parameter_list|,
name|QAbstractSocket
modifier|*
name|socket
parameter_list|,
specifier|const
name|QString
modifier|&
name|extraDetail
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|socket
argument_list|)
expr_stmt|;
name|QString
name|errorString
decl_stmt|;
switch|switch
condition|(
name|errorCode
condition|)
block|{
case|case
name|QNetworkReply
operator|::
name|HostNotFoundError
case|:
name|errorString
operator|=
name|QString
operator|::
name|fromLatin1
argument_list|(
name|QT_TRANSLATE_NOOP
argument_list|(
literal|"QHttp"
argument_list|,
literal|"Host %1 not found"
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|socket
operator|->
name|peerName
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|QNetworkReply
operator|::
name|ConnectionRefusedError
case|:
name|errorString
operator|=
name|QLatin1String
argument_list|(
name|QT_TRANSLATE_NOOP
argument_list|(
literal|"QHttp"
argument_list|,
literal|"Connection refused"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QNetworkReply
operator|::
name|RemoteHostClosedError
case|:
name|errorString
operator|=
name|QLatin1String
argument_list|(
name|QT_TRANSLATE_NOOP
argument_list|(
literal|"QHttp"
argument_list|,
literal|"Connection closed"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QNetworkReply
operator|::
name|TimeoutError
case|:
name|errorString
operator|=
name|QLatin1String
argument_list|(
name|QT_TRANSLATE_NOOP
argument_list|(
literal|"QAbstractSocket"
argument_list|,
literal|"Socket operation timed out"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QNetworkReply
operator|::
name|ProxyAuthenticationRequiredError
case|:
name|errorString
operator|=
name|QLatin1String
argument_list|(
name|QT_TRANSLATE_NOOP
argument_list|(
literal|"QHttp"
argument_list|,
literal|"Proxy requires authentication"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QNetworkReply
operator|::
name|AuthenticationRequiredError
case|:
name|errorString
operator|=
name|QLatin1String
argument_list|(
name|QT_TRANSLATE_NOOP
argument_list|(
literal|"QHttp"
argument_list|,
literal|"Host requires authentication"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QNetworkReply
operator|::
name|ProtocolFailure
case|:
name|errorString
operator|=
name|QLatin1String
argument_list|(
name|QT_TRANSLATE_NOOP
argument_list|(
literal|"QHttp"
argument_list|,
literal|"Data corrupted"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QNetworkReply
operator|::
name|ProtocolUnknownError
case|:
name|errorString
operator|=
name|QLatin1String
argument_list|(
name|QT_TRANSLATE_NOOP
argument_list|(
literal|"QHttp"
argument_list|,
literal|"Unknown protocol specified"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QNetworkReply
operator|::
name|SslHandshakeFailedError
case|:
name|errorString
operator|=
name|QLatin1String
argument_list|(
name|QT_TRANSLATE_NOOP
argument_list|(
literal|"QHttp"
argument_list|,
literal|"SSL handshake failed"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|// all other errors are treated as QNetworkReply::UnknownNetworkError
name|errorString
operator|=
name|extraDetail
expr_stmt|;
break|break;
block|}
return|return
name|errorString
return|;
block|}
end_function
begin_comment
comment|// this is called from the destructor of QHttpNetworkReply. It is called when
end_comment
begin_comment
comment|// the reply was finished correctly or when it was aborted.
end_comment
begin_function
DECL|function|removeReply
name|void
name|QHttpNetworkConnectionPrivate
operator|::
name|removeReply
parameter_list|(
name|QHttpNetworkReply
modifier|*
name|reply
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QHttpNetworkConnection
argument_list|)
expr_stmt|;
comment|// check if the reply is currently being processed or it is pipelined in
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|channelCount
condition|;
operator|++
name|i
control|)
block|{
comment|// is the reply associated the currently processing of this channel?
if|if
condition|(
name|channels
index|[
name|i
index|]
operator|.
name|reply
operator|==
name|reply
condition|)
block|{
name|channels
index|[
name|i
index|]
operator|.
name|reply
operator|=
literal|0
expr_stmt|;
name|channels
index|[
name|i
index|]
operator|.
name|request
operator|=
name|QHttpNetworkRequest
argument_list|()
expr_stmt|;
name|channels
index|[
name|i
index|]
operator|.
name|resendCurrent
operator|=
literal|false
expr_stmt|;
if|if
condition|(
operator|!
name|reply
operator|->
name|isFinished
argument_list|()
operator|&&
operator|!
name|channels
index|[
name|i
index|]
operator|.
name|alreadyPipelinedRequests
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// the reply had to be prematurely removed, e.g. it was not finished
comment|// therefore we have to requeue the already pipelined requests.
name|channels
index|[
name|i
index|]
operator|.
name|requeueCurrentlyPipelinedRequests
argument_list|()
expr_stmt|;
block|}
comment|// if HTTP mandates we should close
comment|// or the reply is not finished yet, e.g. it was aborted
comment|// we have to close that connection
if|if
condition|(
name|reply
operator|->
name|d_func
argument_list|()
operator|->
name|isConnectionCloseEnabled
argument_list|()
operator|||
operator|!
name|reply
operator|->
name|isFinished
argument_list|()
condition|)
name|channels
index|[
name|i
index|]
operator|.
name|close
argument_list|()
expr_stmt|;
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|q
argument_list|,
literal|"_q_startNextRequest"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// is the reply inside the pipeline of this channel already?
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|channels
index|[
name|i
index|]
operator|.
name|alreadyPipelinedRequests
operator|.
name|length
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|channels
index|[
name|i
index|]
operator|.
name|alreadyPipelinedRequests
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|second
operator|==
name|reply
condition|)
block|{
comment|// Remove that HttpMessagePair
name|channels
index|[
name|i
index|]
operator|.
name|alreadyPipelinedRequests
operator|.
name|removeAt
argument_list|(
name|j
argument_list|)
expr_stmt|;
name|channels
index|[
name|i
index|]
operator|.
name|requeueCurrentlyPipelinedRequests
argument_list|()
expr_stmt|;
comment|// Since some requests had already been pipelined, but we removed
comment|// one and re-queued the others
comment|// we must force a connection close after the request that is
comment|// currently in processing has been finished.
if|if
condition|(
name|channels
index|[
name|i
index|]
operator|.
name|reply
condition|)
name|channels
index|[
name|i
index|]
operator|.
name|reply
operator|->
name|d_func
argument_list|()
operator|->
name|forceConnectionCloseEnabled
operator|=
literal|true
expr_stmt|;
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|q
argument_list|,
literal|"_q_startNextRequest"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
comment|// remove from the high priority queue
if|if
condition|(
operator|!
name|highPriorityQueue
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|j
init|=
name|highPriorityQueue
operator|.
name|count
argument_list|()
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
operator|--
name|j
control|)
block|{
name|HttpMessagePair
name|messagePair
init|=
name|highPriorityQueue
operator|.
name|at
argument_list|(
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|messagePair
operator|.
name|second
operator|==
name|reply
condition|)
block|{
name|highPriorityQueue
operator|.
name|removeAt
argument_list|(
name|j
argument_list|)
expr_stmt|;
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|q
argument_list|,
literal|"_q_startNextRequest"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
comment|// remove from the low priority queue
if|if
condition|(
operator|!
name|lowPriorityQueue
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|j
init|=
name|lowPriorityQueue
operator|.
name|count
argument_list|()
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
operator|--
name|j
control|)
block|{
name|HttpMessagePair
name|messagePair
init|=
name|lowPriorityQueue
operator|.
name|at
argument_list|(
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|messagePair
operator|.
name|second
operator|==
name|reply
condition|)
block|{
name|lowPriorityQueue
operator|.
name|removeAt
argument_list|(
name|j
argument_list|)
expr_stmt|;
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|q
argument_list|,
literal|"_q_startNextRequest"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
block|}
end_function
begin_comment
comment|// This function must be called from the event loop. The only
end_comment
begin_comment
comment|// exception is documented in QHttpNetworkConnectionPrivate::queueRequest
end_comment
begin_comment
comment|// although it is called _q_startNextRequest, it will actually start multiple requests when possible
end_comment
begin_function
DECL|function|_q_startNextRequest
name|void
name|QHttpNetworkConnectionPrivate
operator|::
name|_q_startNextRequest
parameter_list|()
block|{
comment|// If the QHttpNetworkConnection is currently paused then bail out immediately
if|if
condition|(
name|state
operator|==
name|PausedState
condition|)
return|return;
comment|//resend the necessary ones.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|channelCount
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|channels
index|[
name|i
index|]
operator|.
name|resendCurrent
operator|&&
operator|(
name|channels
index|[
name|i
index|]
operator|.
name|state
operator|!=
name|QHttpNetworkConnectionChannel
operator|::
name|ClosingState
operator|)
condition|)
block|{
name|channels
index|[
name|i
index|]
operator|.
name|resendCurrent
operator|=
literal|false
expr_stmt|;
name|channels
index|[
name|i
index|]
operator|.
name|state
operator|=
name|QHttpNetworkConnectionChannel
operator|::
name|IdleState
expr_stmt|;
comment|// if this is not possible, error will be emitted and connection terminated
if|if
condition|(
operator|!
name|channels
index|[
name|i
index|]
operator|.
name|resetUploadData
argument_list|()
condition|)
continue|continue;
name|channels
index|[
name|i
index|]
operator|.
name|sendRequest
argument_list|()
expr_stmt|;
block|}
block|}
comment|// dequeue new ones
comment|// return fast if there is nothing to do
if|if
condition|(
name|highPriorityQueue
operator|.
name|isEmpty
argument_list|()
operator|&&
name|lowPriorityQueue
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
comment|// try to get a free AND connected socket
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|channelCount
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|channels
index|[
name|i
index|]
operator|.
name|reply
operator|&&
operator|!
name|channels
index|[
name|i
index|]
operator|.
name|isSocketBusy
argument_list|()
operator|&&
name|channels
index|[
name|i
index|]
operator|.
name|socket
operator|->
name|state
argument_list|()
operator|==
name|QAbstractSocket
operator|::
name|ConnectedState
condition|)
block|{
if|if
condition|(
name|dequeueRequest
argument_list|(
name|channels
index|[
name|i
index|]
operator|.
name|socket
argument_list|)
condition|)
name|channels
index|[
name|i
index|]
operator|.
name|sendRequest
argument_list|()
expr_stmt|;
block|}
block|}
comment|// try to push more into all sockets
comment|// ### FIXME we should move this to the beginning of the function
comment|// as soon as QtWebkit is properly using the pipelining
comment|// (e.g. not for XMLHttpRequest or the first page load)
comment|// ### FIXME we should also divide the requests more even
comment|// on the connected sockets
comment|//tryToFillPipeline(socket);
comment|// return fast if there is nothing to pipeline
if|if
condition|(
name|highPriorityQueue
operator|.
name|isEmpty
argument_list|()
operator|&&
name|lowPriorityQueue
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|channelCount
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|channels
index|[
name|i
index|]
operator|.
name|socket
operator|->
name|state
argument_list|()
operator|==
name|QAbstractSocket
operator|::
name|ConnectedState
condition|)
name|fillPipeline
argument_list|(
name|channels
index|[
name|i
index|]
operator|.
name|socket
argument_list|)
expr_stmt|;
comment|// If there is not already any connected channels we need to connect a new one.
comment|// We do not pair the channel with the request until we know if it is
comment|// connected or not. This is to reuse connected channels before we connect new once.
name|int
name|queuedRequest
init|=
name|highPriorityQueue
operator|.
name|count
argument_list|()
operator|+
name|lowPriorityQueue
operator|.
name|count
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|channelCount
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|channels
index|[
name|i
index|]
operator|.
name|socket
operator|->
name|state
argument_list|()
operator|==
name|QAbstractSocket
operator|::
name|ConnectingState
condition|)
name|queuedRequest
operator|--
expr_stmt|;
if|if
condition|(
name|queuedRequest
operator|<=
literal|0
condition|)
break|break;
if|if
condition|(
operator|!
name|channels
index|[
name|i
index|]
operator|.
name|reply
operator|&&
operator|!
name|channels
index|[
name|i
index|]
operator|.
name|isSocketBusy
argument_list|()
operator|&&
operator|(
name|channels
index|[
name|i
index|]
operator|.
name|socket
operator|->
name|state
argument_list|()
operator|==
name|QAbstractSocket
operator|::
name|UnconnectedState
operator|)
condition|)
block|{
name|channels
index|[
name|i
index|]
operator|.
name|ensureConnection
argument_list|()
expr_stmt|;
name|queuedRequest
operator|--
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|readMoreLater
name|void
name|QHttpNetworkConnectionPrivate
operator|::
name|readMoreLater
parameter_list|(
name|QHttpNetworkReply
modifier|*
name|reply
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|channelCount
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|channels
index|[
name|i
index|]
operator|.
name|reply
operator|==
name|reply
condition|)
block|{
comment|// emulate a readyRead() from the socket
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
operator|&
name|channels
index|[
name|i
index|]
argument_list|,
literal|"_q_readyRead"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_BEARERMANAGEMENT
end_ifndef
begin_constructor
DECL|function|QHttpNetworkConnection
name|QHttpNetworkConnection
operator|::
name|QHttpNetworkConnection
parameter_list|(
specifier|const
name|QString
modifier|&
name|hostName
parameter_list|,
name|quint16
name|port
parameter_list|,
name|bool
name|encrypt
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|,
name|QSharedPointer
argument_list|<
name|QNetworkSession
argument_list|>
name|networkSession
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|(
operator|new
name|QHttpNetworkConnectionPrivate
argument_list|(
name|hostName
argument_list|,
name|port
argument_list|,
name|encrypt
argument_list|)
operator|)
argument_list|,
name|parent
argument_list|)
block|{
name|Q_D
argument_list|(
name|QHttpNetworkConnection
argument_list|)
expr_stmt|;
name|d
operator|->
name|networkSession
operator|=
name|networkSession
expr_stmt|;
name|d
operator|->
name|init
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QHttpNetworkConnection
name|QHttpNetworkConnection
operator|::
name|QHttpNetworkConnection
parameter_list|(
name|quint16
name|connectionCount
parameter_list|,
specifier|const
name|QString
modifier|&
name|hostName
parameter_list|,
name|quint16
name|port
parameter_list|,
name|bool
name|encrypt
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|,
name|QSharedPointer
argument_list|<
name|QNetworkSession
argument_list|>
name|networkSession
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|(
operator|new
name|QHttpNetworkConnectionPrivate
argument_list|(
name|connectionCount
argument_list|,
name|hostName
argument_list|,
name|port
argument_list|,
name|encrypt
argument_list|)
operator|)
argument_list|,
name|parent
argument_list|)
block|{
name|Q_D
argument_list|(
name|QHttpNetworkConnection
argument_list|)
expr_stmt|;
name|d
operator|->
name|networkSession
operator|=
name|networkSession
expr_stmt|;
name|d
operator|->
name|init
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_else
else|#
directive|else
end_else
begin_constructor
DECL|function|QHttpNetworkConnection
name|QHttpNetworkConnection
operator|::
name|QHttpNetworkConnection
parameter_list|(
specifier|const
name|QString
modifier|&
name|hostName
parameter_list|,
name|quint16
name|port
parameter_list|,
name|bool
name|encrypt
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|(
operator|new
name|QHttpNetworkConnectionPrivate
argument_list|(
name|hostName
argument_list|,
name|port
argument_list|,
name|encrypt
argument_list|)
operator|)
argument_list|,
name|parent
argument_list|)
block|{
name|Q_D
argument_list|(
name|QHttpNetworkConnection
argument_list|)
expr_stmt|;
name|d
operator|->
name|init
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QHttpNetworkConnection
name|QHttpNetworkConnection
operator|::
name|QHttpNetworkConnection
parameter_list|(
name|quint16
name|connectionCount
parameter_list|,
specifier|const
name|QString
modifier|&
name|hostName
parameter_list|,
name|quint16
name|port
parameter_list|,
name|bool
name|encrypt
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|(
operator|new
name|QHttpNetworkConnectionPrivate
argument_list|(
name|connectionCount
argument_list|,
name|hostName
argument_list|,
name|port
argument_list|,
name|encrypt
argument_list|)
operator|)
argument_list|,
name|parent
argument_list|)
block|{
name|Q_D
argument_list|(
name|QHttpNetworkConnection
argument_list|)
expr_stmt|;
name|d
operator|->
name|init
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_endif
endif|#
directive|endif
end_endif
begin_destructor
DECL|function|~QHttpNetworkConnection
name|QHttpNetworkConnection
operator|::
name|~
name|QHttpNetworkConnection
parameter_list|()
block|{ }
end_destructor
begin_function
DECL|function|hostName
name|QString
name|QHttpNetworkConnection
operator|::
name|hostName
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QHttpNetworkConnection
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|hostName
return|;
block|}
end_function
begin_function
DECL|function|port
name|quint16
name|QHttpNetworkConnection
operator|::
name|port
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QHttpNetworkConnection
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|port
return|;
block|}
end_function
begin_function
DECL|function|sendRequest
name|QHttpNetworkReply
modifier|*
name|QHttpNetworkConnection
operator|::
name|sendRequest
parameter_list|(
specifier|const
name|QHttpNetworkRequest
modifier|&
name|request
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QHttpNetworkConnection
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|queueRequest
argument_list|(
name|request
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|isSsl
name|bool
name|QHttpNetworkConnection
operator|::
name|isSsl
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QHttpNetworkConnection
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|encrypt
return|;
block|}
end_function
begin_function
DECL|function|channels
name|QHttpNetworkConnectionChannel
modifier|*
name|QHttpNetworkConnection
operator|::
name|channels
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|channels
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
end_ifndef
begin_function
DECL|function|setCacheProxy
name|void
name|QHttpNetworkConnection
operator|::
name|setCacheProxy
parameter_list|(
specifier|const
name|QNetworkProxy
modifier|&
name|networkProxy
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QHttpNetworkConnection
argument_list|)
expr_stmt|;
name|d
operator|->
name|networkProxy
operator|=
name|networkProxy
expr_stmt|;
comment|// update the authenticator
if|if
condition|(
operator|!
name|d
operator|->
name|networkProxy
operator|.
name|user
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|channelCount
condition|;
operator|++
name|i
control|)
block|{
name|d
operator|->
name|channels
index|[
name|i
index|]
operator|.
name|proxyAuthenticator
operator|.
name|setUser
argument_list|(
name|d
operator|->
name|networkProxy
operator|.
name|user
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|channels
index|[
name|i
index|]
operator|.
name|proxyAuthenticator
operator|.
name|setPassword
argument_list|(
name|d
operator|->
name|networkProxy
operator|.
name|password
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|cacheProxy
name|QNetworkProxy
name|QHttpNetworkConnection
operator|::
name|cacheProxy
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QHttpNetworkConnection
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|networkProxy
return|;
block|}
end_function
begin_function
DECL|function|setTransparentProxy
name|void
name|QHttpNetworkConnection
operator|::
name|setTransparentProxy
parameter_list|(
specifier|const
name|QNetworkProxy
modifier|&
name|networkProxy
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QHttpNetworkConnection
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|channelCount
condition|;
operator|++
name|i
control|)
name|d
operator|->
name|channels
index|[
name|i
index|]
operator|.
name|socket
operator|->
name|setProxy
argument_list|(
name|networkProxy
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|transparentProxy
name|QNetworkProxy
name|QHttpNetworkConnection
operator|::
name|transparentProxy
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QHttpNetworkConnection
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|channels
index|[
literal|0
index|]
operator|.
name|socket
operator|->
name|proxy
argument_list|()
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// SSL support below
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_OPENSSL
end_ifndef
begin_function
DECL|function|setSslConfiguration
name|void
name|QHttpNetworkConnection
operator|::
name|setSslConfiguration
parameter_list|(
specifier|const
name|QSslConfiguration
modifier|&
name|config
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QHttpNetworkConnection
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|encrypt
condition|)
return|return;
comment|// set the config on all channels
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|channelCount
condition|;
operator|++
name|i
control|)
cast|static_cast
argument_list|<
name|QSslSocket
operator|*
argument_list|>
argument_list|(
name|d
operator|->
name|channels
index|[
name|i
index|]
operator|.
name|socket
argument_list|)
operator|->
name|setSslConfiguration
argument_list|(
name|config
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|ignoreSslErrors
name|void
name|QHttpNetworkConnection
operator|::
name|ignoreSslErrors
parameter_list|(
name|int
name|channel
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QHttpNetworkConnection
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|encrypt
condition|)
return|return;
if|if
condition|(
name|channel
operator|==
operator|-
literal|1
condition|)
block|{
comment|// ignore for all channels
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|channelCount
condition|;
operator|++
name|i
control|)
block|{
cast|static_cast
argument_list|<
name|QSslSocket
operator|*
argument_list|>
argument_list|(
name|d
operator|->
name|channels
index|[
name|i
index|]
operator|.
name|socket
argument_list|)
operator|->
name|ignoreSslErrors
argument_list|()
expr_stmt|;
name|d
operator|->
name|channels
index|[
name|i
index|]
operator|.
name|ignoreAllSslErrors
operator|=
literal|true
expr_stmt|;
block|}
block|}
else|else
block|{
cast|static_cast
argument_list|<
name|QSslSocket
operator|*
argument_list|>
argument_list|(
name|d
operator|->
name|channels
index|[
name|channel
index|]
operator|.
name|socket
argument_list|)
operator|->
name|ignoreSslErrors
argument_list|()
expr_stmt|;
name|d
operator|->
name|channels
index|[
name|channel
index|]
operator|.
name|ignoreAllSslErrors
operator|=
literal|true
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|ignoreSslErrors
name|void
name|QHttpNetworkConnection
operator|::
name|ignoreSslErrors
parameter_list|(
specifier|const
name|QList
argument_list|<
name|QSslError
argument_list|>
modifier|&
name|errors
parameter_list|,
name|int
name|channel
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QHttpNetworkConnection
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|encrypt
condition|)
return|return;
if|if
condition|(
name|channel
operator|==
operator|-
literal|1
condition|)
block|{
comment|// ignore for all channels
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|channelCount
condition|;
operator|++
name|i
control|)
block|{
cast|static_cast
argument_list|<
name|QSslSocket
operator|*
argument_list|>
argument_list|(
name|d
operator|->
name|channels
index|[
name|i
index|]
operator|.
name|socket
argument_list|)
operator|->
name|ignoreSslErrors
argument_list|(
name|errors
argument_list|)
expr_stmt|;
name|d
operator|->
name|channels
index|[
name|i
index|]
operator|.
name|ignoreSslErrorsList
operator|=
name|errors
expr_stmt|;
block|}
block|}
else|else
block|{
cast|static_cast
argument_list|<
name|QSslSocket
operator|*
argument_list|>
argument_list|(
name|d
operator|->
name|channels
index|[
name|channel
index|]
operator|.
name|socket
argument_list|)
operator|->
name|ignoreSslErrors
argument_list|(
name|errors
argument_list|)
expr_stmt|;
name|d
operator|->
name|channels
index|[
name|channel
index|]
operator|.
name|ignoreSslErrorsList
operator|=
name|errors
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//QT_NO_OPENSSL
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
end_ifndef
begin_comment
comment|// only called from QHttpNetworkConnectionChannel::_q_proxyAuthenticationRequired, not
end_comment
begin_comment
comment|// from QHttpNetworkConnectionChannel::handleAuthenticationChallenge
end_comment
begin_comment
comment|// e.g. it is for SOCKS proxies which require authentication.
end_comment
begin_function
DECL|function|emitProxyAuthenticationRequired
name|void
name|QHttpNetworkConnectionPrivate
operator|::
name|emitProxyAuthenticationRequired
parameter_list|(
specifier|const
name|QHttpNetworkConnectionChannel
modifier|*
name|chan
parameter_list|,
specifier|const
name|QNetworkProxy
modifier|&
name|proxy
parameter_list|,
name|QAuthenticator
modifier|*
name|auth
parameter_list|)
block|{
comment|// Also pause the connection because socket notifiers may fire while an user
comment|// dialog is displaying
name|pauseConnection
argument_list|()
expr_stmt|;
emit|emit
name|chan
operator|->
name|reply
operator|->
name|proxyAuthenticationRequired
argument_list|(
name|proxy
argument_list|,
name|auth
argument_list|)
emit|;
name|resumeConnection
argument_list|()
expr_stmt|;
name|int
name|i
init|=
name|indexOf
argument_list|(
name|chan
operator|->
name|socket
argument_list|)
decl_stmt|;
name|copyCredentials
argument_list|(
name|i
argument_list|,
name|auth
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_include
include|#
directive|include
file|"moc_qhttpnetworkconnection_p.cpp"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_HTTP
end_comment
end_unit
