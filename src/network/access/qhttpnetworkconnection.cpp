begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtNetwork module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qhttpnetworkconnection_p.h"
end_include
begin_include
include|#
directive|include
file|<private/qabstractsocket_p.h>
end_include
begin_include
include|#
directive|include
file|"qhttpnetworkconnectionchannel_p.h"
end_include
begin_include
include|#
directive|include
file|"private/qnoncontiguousbytedevice_p.h"
end_include
begin_include
include|#
directive|include
file|<private/qnetworkrequest_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qobject_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qauthenticator_p.h>
end_include
begin_include
include|#
directive|include
file|"private/qhostinfo_p.h"
end_include
begin_include
include|#
directive|include
file|<qnetworkproxy.h>
end_include
begin_include
include|#
directive|include
file|<qauthenticator.h>
end_include
begin_include
include|#
directive|include
file|<qcoreapplication.h>
end_include
begin_include
include|#
directive|include
file|<qbuffer.h>
end_include
begin_include
include|#
directive|include
file|<qpair.h>
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_HTTP
end_ifndef
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_SSL
end_ifndef
begin_include
include|#
directive|include
file|<private/qsslsocket_p.h>
end_include
begin_include
include|#
directive|include
file|<QtNetwork/qsslkey.h>
end_include
begin_include
include|#
directive|include
file|<QtNetwork/qsslcipher.h>
end_include
begin_include
include|#
directive|include
file|<QtNetwork/qsslconfiguration.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
DECL|member|defaultChannelCount
specifier|const
name|int
name|QHttpNetworkConnectionPrivate
operator|::
name|defaultChannelCount
init|=
literal|6
decl_stmt|;
end_decl_stmt
begin_comment
comment|// The pipeline length. So there will be 4 requests in flight.
end_comment
begin_decl_stmt
DECL|member|defaultPipelineLength
specifier|const
name|int
name|QHttpNetworkConnectionPrivate
operator|::
name|defaultPipelineLength
init|=
literal|3
decl_stmt|;
end_decl_stmt
begin_comment
comment|// Only re-fill the pipeline if there's defaultRePipelineLength slots free in the pipeline.
end_comment
begin_comment
comment|// This means that there are 2 requests in flight and 2 slots free that will be re-filled.
end_comment
begin_decl_stmt
DECL|member|defaultRePipelineLength
specifier|const
name|int
name|QHttpNetworkConnectionPrivate
operator|::
name|defaultRePipelineLength
init|=
literal|2
decl_stmt|;
end_decl_stmt
begin_constructor
DECL|function|QHttpNetworkConnectionPrivate
name|QHttpNetworkConnectionPrivate
operator|::
name|QHttpNetworkConnectionPrivate
parameter_list|(
specifier|const
name|QString
modifier|&
name|hostName
parameter_list|,
name|quint16
name|port
parameter_list|,
name|bool
name|encrypt
parameter_list|)
member_init_list|:
name|state
argument_list|(
name|RunningState
argument_list|)
member_init_list|,
name|networkLayerState
argument_list|(
name|Unknown
argument_list|)
member_init_list|,
name|hostName
argument_list|(
name|hostName
argument_list|)
member_init_list|,
name|port
argument_list|(
name|port
argument_list|)
member_init_list|,
name|encrypt
argument_list|(
name|encrypt
argument_list|)
member_init_list|,
name|delayIpv4
argument_list|(
literal|true
argument_list|)
member_init_list|,
name|channelCount
argument_list|(
name|defaultChannelCount
argument_list|)
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
member_init_list|,
name|networkProxy
argument_list|(
name|QNetworkProxy
operator|::
name|NoProxy
argument_list|)
endif|#
directive|endif
member_init_list|,
name|preConnectRequests
argument_list|(
literal|0
argument_list|)
block|{
name|channels
operator|=
operator|new
name|QHttpNetworkConnectionChannel
index|[
name|channelCount
index|]
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QHttpNetworkConnectionPrivate
name|QHttpNetworkConnectionPrivate
operator|::
name|QHttpNetworkConnectionPrivate
parameter_list|(
name|quint16
name|channelCount
parameter_list|,
specifier|const
name|QString
modifier|&
name|hostName
parameter_list|,
name|quint16
name|port
parameter_list|,
name|bool
name|encrypt
parameter_list|)
member_init_list|:
name|state
argument_list|(
name|RunningState
argument_list|)
member_init_list|,
name|networkLayerState
argument_list|(
name|Unknown
argument_list|)
member_init_list|,
name|hostName
argument_list|(
name|hostName
argument_list|)
member_init_list|,
name|port
argument_list|(
name|port
argument_list|)
member_init_list|,
name|encrypt
argument_list|(
name|encrypt
argument_list|)
member_init_list|,
name|delayIpv4
argument_list|(
literal|true
argument_list|)
member_init_list|,
name|channelCount
argument_list|(
name|channelCount
argument_list|)
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
member_init_list|,
name|networkProxy
argument_list|(
name|QNetworkProxy
operator|::
name|NoProxy
argument_list|)
endif|#
directive|endif
member_init_list|,
name|preConnectRequests
argument_list|(
literal|0
argument_list|)
block|{
name|channels
operator|=
operator|new
name|QHttpNetworkConnectionChannel
index|[
name|channelCount
index|]
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QHttpNetworkConnectionPrivate
name|QHttpNetworkConnectionPrivate
operator|::
name|~
name|QHttpNetworkConnectionPrivate
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|channelCount
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|channels
index|[
name|i
index|]
operator|.
name|socket
condition|)
block|{
name|channels
index|[
name|i
index|]
operator|.
name|socket
operator|->
name|close
argument_list|()
expr_stmt|;
operator|delete
name|channels
index|[
name|i
index|]
operator|.
name|socket
expr_stmt|;
block|}
block|}
operator|delete
index|[]
name|channels
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|init
name|void
name|QHttpNetworkConnectionPrivate
operator|::
name|init
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QHttpNetworkConnection
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|channelCount
condition|;
name|i
operator|++
control|)
block|{
name|channels
index|[
name|i
index|]
operator|.
name|setConnection
argument_list|(
name|this
operator|->
name|q_func
argument_list|()
argument_list|)
expr_stmt|;
name|channels
index|[
name|i
index|]
operator|.
name|ssl
operator|=
name|encrypt
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_BEARERMANAGEMENT
comment|//push session down to channels
name|channels
index|[
name|i
index|]
operator|.
name|networkSession
operator|=
name|networkSession
expr_stmt|;
endif|#
directive|endif
block|}
name|delayedConnectionTimer
operator|.
name|setSingleShot
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
operator|&
name|delayedConnectionTimer
argument_list|,
name|SIGNAL
argument_list|(
name|timeout
argument_list|()
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_connectDelayedChannel
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|pauseConnection
name|void
name|QHttpNetworkConnectionPrivate
operator|::
name|pauseConnection
parameter_list|()
block|{
name|state
operator|=
name|PausedState
expr_stmt|;
comment|// Disable all socket notifiers
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|channelCount
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|channels
index|[
name|i
index|]
operator|.
name|socket
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_SSL
if|if
condition|(
name|encrypt
condition|)
name|QSslSocketPrivate
operator|::
name|pauseSocketNotifiers
argument_list|(
cast|static_cast
argument_list|<
name|QSslSocket
operator|*
argument_list|>
argument_list|(
name|channels
index|[
name|i
index|]
operator|.
name|socket
argument_list|)
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|QAbstractSocketPrivate
operator|::
name|pauseSocketNotifiers
argument_list|(
name|channels
index|[
name|i
index|]
operator|.
name|socket
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|resumeConnection
name|void
name|QHttpNetworkConnectionPrivate
operator|::
name|resumeConnection
parameter_list|()
block|{
name|state
operator|=
name|RunningState
expr_stmt|;
comment|// Enable all socket notifiers
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|channelCount
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|channels
index|[
name|i
index|]
operator|.
name|socket
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_SSL
if|if
condition|(
name|encrypt
condition|)
name|QSslSocketPrivate
operator|::
name|resumeSocketNotifiers
argument_list|(
cast|static_cast
argument_list|<
name|QSslSocket
operator|*
argument_list|>
argument_list|(
name|channels
index|[
name|i
index|]
operator|.
name|socket
argument_list|)
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|QAbstractSocketPrivate
operator|::
name|resumeSocketNotifiers
argument_list|(
name|channels
index|[
name|i
index|]
operator|.
name|socket
argument_list|)
expr_stmt|;
comment|// Resume pending upload if needed
if|if
condition|(
name|channels
index|[
name|i
index|]
operator|.
name|state
operator|==
name|QHttpNetworkConnectionChannel
operator|::
name|WritingState
condition|)
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
operator|&
name|channels
index|[
name|i
index|]
argument_list|,
literal|"_q_uploadDataReadyRead"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
block|}
block|}
comment|// queue _q_startNextRequest
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|this
operator|->
name|q_func
argument_list|()
argument_list|,
literal|"_q_startNextRequest"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|indexOf
name|int
name|QHttpNetworkConnectionPrivate
operator|::
name|indexOf
parameter_list|(
name|QAbstractSocket
modifier|*
name|socket
parameter_list|)
specifier|const
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|channelCount
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|channels
index|[
name|i
index|]
operator|.
name|socket
operator|==
name|socket
condition|)
return|return
name|i
return|;
name|qFatal
argument_list|(
literal|"Called with unknown socket object."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|// If the connection is in the InProgress state channel errors should not always be
end_comment
begin_comment
comment|// emitted. This function will check the status of the connection channels if we
end_comment
begin_comment
comment|// have not decided the networkLayerState and will return true if the channel error
end_comment
begin_comment
comment|// should be emitted by the channel.
end_comment
begin_function
DECL|function|shouldEmitChannelError
name|bool
name|QHttpNetworkConnectionPrivate
operator|::
name|shouldEmitChannelError
parameter_list|(
name|QAbstractSocket
modifier|*
name|socket
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QHttpNetworkConnection
argument_list|)
expr_stmt|;
name|bool
name|emitError
init|=
literal|true
decl_stmt|;
name|int
name|i
init|=
name|indexOf
argument_list|(
name|socket
argument_list|)
decl_stmt|;
name|int
name|otherSocket
init|=
operator|(
name|i
operator|==
literal|0
condition|?
literal|1
else|:
literal|0
operator|)
decl_stmt|;
comment|// If the IPv4 connection still isn't started we need to start it now.
if|if
condition|(
name|delayedConnectionTimer
operator|.
name|isActive
argument_list|()
condition|)
block|{
name|delayedConnectionTimer
operator|.
name|stop
argument_list|()
expr_stmt|;
name|channels
index|[
name|otherSocket
index|]
operator|.
name|ensureConnection
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|channelCount
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|networkLayerState
operator|==
name|QHttpNetworkConnectionPrivate
operator|::
name|InProgress
condition|)
name|networkLayerState
operator|=
name|QHttpNetworkConnectionPrivate
operator|::
name|Unknown
expr_stmt|;
name|channels
index|[
literal|0
index|]
operator|.
name|close
argument_list|()
expr_stmt|;
name|emitError
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|networkLayerState
operator|==
name|QHttpNetworkConnectionPrivate
operator|::
name|InProgress
condition|)
block|{
if|if
condition|(
name|channels
index|[
name|otherSocket
index|]
operator|.
name|isSocketBusy
argument_list|()
operator|&&
operator|(
name|channels
index|[
name|otherSocket
index|]
operator|.
name|state
operator|!=
name|QHttpNetworkConnectionChannel
operator|::
name|ClosingState
operator|)
condition|)
block|{
comment|// this was the first socket to fail.
name|channels
index|[
name|i
index|]
operator|.
name|close
argument_list|()
expr_stmt|;
name|emitError
operator|=
literal|false
expr_stmt|;
block|}
else|else
block|{
comment|// Both connection attempts has failed.
name|networkLayerState
operator|=
name|QHttpNetworkConnectionPrivate
operator|::
name|Unknown
expr_stmt|;
name|channels
index|[
name|i
index|]
operator|.
name|close
argument_list|()
expr_stmt|;
name|emitError
operator|=
literal|true
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
operator|(
name|networkLayerState
operator|==
name|QHttpNetworkConnectionPrivate
operator|::
name|IPv4
operator|)
operator|&&
operator|(
name|channels
index|[
name|i
index|]
operator|.
name|networkLayerPreference
operator|!=
name|QAbstractSocket
operator|::
name|IPv4Protocol
operator|)
operator|)
operator|||
operator|(
operator|(
name|networkLayerState
operator|==
name|QHttpNetworkConnectionPrivate
operator|::
name|IPv6
operator|)
operator|&&
operator|(
name|channels
index|[
name|i
index|]
operator|.
name|networkLayerPreference
operator|!=
name|QAbstractSocket
operator|::
name|IPv6Protocol
operator|)
operator|)
condition|)
block|{
comment|// First connection worked so this is the second one to complete and it failed.
name|channels
index|[
name|i
index|]
operator|.
name|close
argument_list|()
expr_stmt|;
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|q
argument_list|,
literal|"_q_startNextRequest"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
name|emitError
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|networkLayerState
operator|==
name|QHttpNetworkConnectionPrivate
operator|::
name|Unknown
condition|)
name|qWarning
argument_list|()
operator|<<
literal|"We got a connection error when networkLayerState is Unknown"
expr_stmt|;
block|}
block|}
return|return
name|emitError
return|;
block|}
end_function
begin_function
DECL|function|uncompressedBytesAvailable
name|qint64
name|QHttpNetworkConnectionPrivate
operator|::
name|uncompressedBytesAvailable
parameter_list|(
specifier|const
name|QHttpNetworkReply
modifier|&
name|reply
parameter_list|)
specifier|const
block|{
return|return
name|reply
operator|.
name|d_func
argument_list|()
operator|->
name|responseData
operator|.
name|byteAmount
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|uncompressedBytesAvailableNextBlock
name|qint64
name|QHttpNetworkConnectionPrivate
operator|::
name|uncompressedBytesAvailableNextBlock
parameter_list|(
specifier|const
name|QHttpNetworkReply
modifier|&
name|reply
parameter_list|)
specifier|const
block|{
return|return
name|reply
operator|.
name|d_func
argument_list|()
operator|->
name|responseData
operator|.
name|sizeNextBlock
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|prepareRequest
name|void
name|QHttpNetworkConnectionPrivate
operator|::
name|prepareRequest
parameter_list|(
name|HttpMessagePair
modifier|&
name|messagePair
parameter_list|)
block|{
name|QHttpNetworkRequest
modifier|&
name|request
init|=
name|messagePair
operator|.
name|first
decl_stmt|;
name|QHttpNetworkReply
modifier|*
name|reply
init|=
name|messagePair
operator|.
name|second
decl_stmt|;
comment|// add missing fields for the request
name|QByteArray
name|value
decl_stmt|;
comment|// check if Content-Length is provided
name|QNonContiguousByteDevice
modifier|*
name|uploadByteDevice
init|=
name|request
operator|.
name|uploadByteDevice
argument_list|()
decl_stmt|;
if|if
condition|(
name|uploadByteDevice
condition|)
block|{
if|if
condition|(
name|request
operator|.
name|contentLength
argument_list|()
operator|!=
operator|-
literal|1
operator|&&
name|uploadByteDevice
operator|->
name|size
argument_list|()
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// both values known, take the smaller one.
name|request
operator|.
name|setContentLength
argument_list|(
name|qMin
argument_list|(
name|uploadByteDevice
operator|->
name|size
argument_list|()
argument_list|,
name|request
operator|.
name|contentLength
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|request
operator|.
name|contentLength
argument_list|()
operator|==
operator|-
literal|1
operator|&&
name|uploadByteDevice
operator|->
name|size
argument_list|()
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// content length not supplied by user, but the upload device knows it
name|request
operator|.
name|setContentLength
argument_list|(
name|uploadByteDevice
operator|->
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|request
operator|.
name|contentLength
argument_list|()
operator|!=
operator|-
literal|1
operator|&&
name|uploadByteDevice
operator|->
name|size
argument_list|()
operator|==
operator|-
literal|1
condition|)
block|{
comment|// everything OK, the user supplied us the contentLength
block|}
elseif|else
if|if
condition|(
name|request
operator|.
name|contentLength
argument_list|()
operator|==
operator|-
literal|1
operator|&&
name|uploadByteDevice
operator|->
name|size
argument_list|()
operator|==
operator|-
literal|1
condition|)
block|{
name|qFatal
argument_list|(
literal|"QHttpNetworkConnectionPrivate: Neither content-length nor upload device size were given"
argument_list|)
expr_stmt|;
block|}
block|}
comment|// set the Connection/Proxy-Connection: Keep-Alive headers
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
if|if
condition|(
name|networkProxy
operator|.
name|type
argument_list|()
operator|==
name|QNetworkProxy
operator|::
name|HttpCachingProxy
condition|)
block|{
name|value
operator|=
name|request
operator|.
name|headerField
argument_list|(
literal|"proxy-connection"
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|.
name|isEmpty
argument_list|()
condition|)
name|request
operator|.
name|setHeaderField
argument_list|(
literal|"Proxy-Connection"
argument_list|,
literal|"Keep-Alive"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
endif|#
directive|endif
name|value
operator|=
name|request
operator|.
name|headerField
argument_list|(
literal|"connection"
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|.
name|isEmpty
argument_list|()
condition|)
name|request
operator|.
name|setHeaderField
argument_list|(
literal|"Connection"
argument_list|,
literal|"Keep-Alive"
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
block|}
endif|#
directive|endif
comment|// If the request had a accept-encoding set, we better not mess
comment|// with it. If it was not set, we announce that we understand gzip
comment|// and remember this fact in request.d->autoDecompress so that
comment|// we can later decompress the HTTP reply if it has such an
comment|// encoding.
name|value
operator|=
name|request
operator|.
name|headerField
argument_list|(
literal|"accept-encoding"
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_COMPRESS
name|request
operator|.
name|setHeaderField
argument_list|(
literal|"Accept-Encoding"
argument_list|,
literal|"gzip, deflate"
argument_list|)
expr_stmt|;
name|request
operator|.
name|d
operator|->
name|autoDecompress
operator|=
literal|true
expr_stmt|;
else|#
directive|else
comment|// if zlib is not available set this to false always
name|request
operator|.
name|d
operator|->
name|autoDecompress
operator|=
literal|false
expr_stmt|;
endif|#
directive|endif
block|}
comment|// some websites mandate an accept-language header and fail
comment|// if it is not sent. This is a problem with the website and
comment|// not with us, but we work around this by setting
comment|// one always.
name|value
operator|=
name|request
operator|.
name|headerField
argument_list|(
literal|"accept-language"
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QString
name|systemLocale
init|=
name|QLocale
operator|::
name|system
argument_list|()
operator|.
name|name
argument_list|()
operator|.
name|replace
argument_list|(
name|QChar
operator|::
name|fromLatin1
argument_list|(
literal|'_'
argument_list|)
argument_list|,
name|QChar
operator|::
name|fromLatin1
argument_list|(
literal|'-'
argument_list|)
argument_list|)
decl_stmt|;
name|QString
name|acceptLanguage
decl_stmt|;
if|if
condition|(
name|systemLocale
operator|==
name|QLatin1String
argument_list|(
literal|"C"
argument_list|)
condition|)
name|acceptLanguage
operator|=
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"en,*"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|systemLocale
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"en-"
argument_list|)
argument_list|)
condition|)
name|acceptLanguage
operator|=
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"%1,*"
argument_list|)
operator|.
name|arg
argument_list|(
name|systemLocale
argument_list|)
expr_stmt|;
else|else
name|acceptLanguage
operator|=
name|QString
operator|::
name|fromLatin1
argument_list|(
literal|"%1,en,*"
argument_list|)
operator|.
name|arg
argument_list|(
name|systemLocale
argument_list|)
expr_stmt|;
name|request
operator|.
name|setHeaderField
argument_list|(
literal|"Accept-Language"
argument_list|,
name|acceptLanguage
operator|.
name|toLatin1
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// set the User Agent
name|value
operator|=
name|request
operator|.
name|headerField
argument_list|(
literal|"user-agent"
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|.
name|isEmpty
argument_list|()
condition|)
name|request
operator|.
name|setHeaderField
argument_list|(
literal|"User-Agent"
argument_list|,
literal|"Mozilla/5.0"
argument_list|)
expr_stmt|;
comment|// set the host
name|value
operator|=
name|request
operator|.
name|headerField
argument_list|(
literal|"host"
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QHostAddress
name|add
decl_stmt|;
name|QByteArray
name|host
decl_stmt|;
if|if
condition|(
name|add
operator|.
name|setAddress
argument_list|(
name|hostName
argument_list|)
condition|)
block|{
if|if
condition|(
name|add
operator|.
name|protocol
argument_list|()
operator|==
name|QAbstractSocket
operator|::
name|IPv6Protocol
condition|)
name|host
operator|=
literal|"["
operator|+
name|hostName
operator|.
name|toLatin1
argument_list|()
operator|+
literal|"]"
expr_stmt|;
comment|//format the ipv6 in the standard way
else|else
name|host
operator|=
name|hostName
operator|.
name|toLatin1
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|host
operator|=
name|QUrl
operator|::
name|toAce
argument_list|(
name|hostName
argument_list|)
expr_stmt|;
block|}
name|int
name|port
init|=
name|request
operator|.
name|url
argument_list|()
operator|.
name|port
argument_list|()
decl_stmt|;
if|if
condition|(
name|port
operator|!=
operator|-
literal|1
condition|)
block|{
name|host
operator|+=
literal|':'
expr_stmt|;
name|host
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|port
argument_list|)
expr_stmt|;
block|}
name|request
operator|.
name|setHeaderField
argument_list|(
literal|"Host"
argument_list|,
name|host
argument_list|)
expr_stmt|;
block|}
name|reply
operator|->
name|d_func
argument_list|()
operator|->
name|requestIsPrepared
operator|=
literal|true
expr_stmt|;
block|}
end_function
begin_function
DECL|function|emitReplyError
name|void
name|QHttpNetworkConnectionPrivate
operator|::
name|emitReplyError
parameter_list|(
name|QAbstractSocket
modifier|*
name|socket
parameter_list|,
name|QHttpNetworkReply
modifier|*
name|reply
parameter_list|,
name|QNetworkReply
operator|::
name|NetworkError
name|errorCode
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QHttpNetworkConnection
argument_list|)
expr_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|socket
condition|)
name|i
operator|=
name|indexOf
argument_list|(
name|socket
argument_list|)
expr_stmt|;
if|if
condition|(
name|reply
condition|)
block|{
comment|// this error matters only to this reply
name|reply
operator|->
name|d_func
argument_list|()
operator|->
name|errorString
operator|=
name|errorDetail
argument_list|(
name|errorCode
argument_list|,
name|socket
argument_list|)
expr_stmt|;
emit|emit
name|reply
operator|->
name|finishedWithError
argument_list|(
name|errorCode
argument_list|,
name|reply
operator|->
name|d_func
argument_list|()
operator|->
name|errorString
argument_list|)
emit|;
comment|// remove the corrupt data if any
name|reply
operator|->
name|d_func
argument_list|()
operator|->
name|eraseData
argument_list|()
expr_stmt|;
comment|// Clean the channel
name|channels
index|[
name|i
index|]
operator|.
name|close
argument_list|()
expr_stmt|;
name|channels
index|[
name|i
index|]
operator|.
name|reply
operator|=
literal|0
expr_stmt|;
name|channels
index|[
name|i
index|]
operator|.
name|request
operator|=
name|QHttpNetworkRequest
argument_list|()
expr_stmt|;
if|if
condition|(
name|socket
condition|)
name|channels
index|[
name|i
index|]
operator|.
name|requeueCurrentlyPipelinedRequests
argument_list|()
expr_stmt|;
comment|// send the next request
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|q
argument_list|,
literal|"_q_startNextRequest"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|copyCredentials
name|void
name|QHttpNetworkConnectionPrivate
operator|::
name|copyCredentials
parameter_list|(
name|int
name|fromChannel
parameter_list|,
name|QAuthenticator
modifier|*
name|auth
parameter_list|,
name|bool
name|isProxy
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|auth
argument_list|)
expr_stmt|;
comment|// NTLM is a multi phase authentication. Copying credentials between authenticators would mess things up.
if|if
condition|(
operator|!
name|isProxy
operator|&&
name|channels
index|[
name|fromChannel
index|]
operator|.
name|authMethod
operator|==
name|QAuthenticatorPrivate
operator|::
name|Ntlm
condition|)
return|return;
if|if
condition|(
name|isProxy
operator|&&
name|channels
index|[
name|fromChannel
index|]
operator|.
name|proxyAuthMethod
operator|==
name|QAuthenticatorPrivate
operator|::
name|Ntlm
condition|)
return|return;
comment|// select another channel
name|QAuthenticator
modifier|*
name|otherAuth
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|channelCount
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|==
name|fromChannel
condition|)
continue|continue;
if|if
condition|(
name|isProxy
condition|)
name|otherAuth
operator|=
operator|&
name|channels
index|[
name|i
index|]
operator|.
name|proxyAuthenticator
expr_stmt|;
else|else
name|otherAuth
operator|=
operator|&
name|channels
index|[
name|i
index|]
operator|.
name|authenticator
expr_stmt|;
comment|// if the credentials are different, copy them
if|if
condition|(
name|otherAuth
operator|->
name|user
argument_list|()
operator|.
name|compare
argument_list|(
name|auth
operator|->
name|user
argument_list|()
argument_list|)
condition|)
name|otherAuth
operator|->
name|setUser
argument_list|(
name|auth
operator|->
name|user
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|otherAuth
operator|->
name|password
argument_list|()
operator|.
name|compare
argument_list|(
name|auth
operator|->
name|password
argument_list|()
argument_list|)
condition|)
name|otherAuth
operator|->
name|setPassword
argument_list|(
name|auth
operator|->
name|password
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|// handles the authentication for one channel and eventually re-starts the other channels
end_comment
begin_function
DECL|function|handleAuthenticateChallenge
name|bool
name|QHttpNetworkConnectionPrivate
operator|::
name|handleAuthenticateChallenge
parameter_list|(
name|QAbstractSocket
modifier|*
name|socket
parameter_list|,
name|QHttpNetworkReply
modifier|*
name|reply
parameter_list|,
name|bool
name|isProxy
parameter_list|,
name|bool
modifier|&
name|resend
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|socket
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|reply
argument_list|)
expr_stmt|;
name|resend
operator|=
literal|false
expr_stmt|;
comment|//create the response header to be used with QAuthenticatorPrivate.
name|QList
argument_list|<
name|QPair
argument_list|<
name|QByteArray
argument_list|,
name|QByteArray
argument_list|>
argument_list|>
name|fields
init|=
name|reply
operator|->
name|header
argument_list|()
decl_stmt|;
comment|//find out the type of authentication protocol requested.
name|QAuthenticatorPrivate
operator|::
name|Method
name|authMethod
init|=
name|reply
operator|->
name|d_func
argument_list|()
operator|->
name|authenticationMethod
argument_list|(
name|isProxy
argument_list|)
decl_stmt|;
if|if
condition|(
name|authMethod
operator|!=
name|QAuthenticatorPrivate
operator|::
name|None
condition|)
block|{
name|int
name|i
init|=
name|indexOf
argument_list|(
name|socket
argument_list|)
decl_stmt|;
comment|//Use a single authenticator for all domains. ### change later to use domain/realm
name|QAuthenticator
modifier|*
name|auth
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|isProxy
condition|)
block|{
name|auth
operator|=
operator|&
name|channels
index|[
name|i
index|]
operator|.
name|proxyAuthenticator
expr_stmt|;
name|channels
index|[
name|i
index|]
operator|.
name|proxyAuthMethod
operator|=
name|authMethod
expr_stmt|;
block|}
else|else
block|{
name|auth
operator|=
operator|&
name|channels
index|[
name|i
index|]
operator|.
name|authenticator
expr_stmt|;
name|channels
index|[
name|i
index|]
operator|.
name|authMethod
operator|=
name|authMethod
expr_stmt|;
block|}
comment|//proceed with the authentication.
if|if
condition|(
name|auth
operator|->
name|isNull
argument_list|()
condition|)
name|auth
operator|->
name|detach
argument_list|()
expr_stmt|;
name|QAuthenticatorPrivate
modifier|*
name|priv
init|=
name|QAuthenticatorPrivate
operator|::
name|getPrivate
argument_list|(
operator|*
name|auth
argument_list|)
decl_stmt|;
name|priv
operator|->
name|parseHttpResponse
argument_list|(
name|fields
argument_list|,
name|isProxy
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|->
name|phase
operator|==
name|QAuthenticatorPrivate
operator|::
name|Done
condition|)
block|{
name|pauseConnection
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|isProxy
condition|)
block|{
if|if
condition|(
name|channels
index|[
name|i
index|]
operator|.
name|authenticationCredentialsSent
condition|)
block|{
name|auth
operator|->
name|detach
argument_list|()
expr_stmt|;
name|priv
operator|=
name|QAuthenticatorPrivate
operator|::
name|getPrivate
argument_list|(
operator|*
name|auth
argument_list|)
expr_stmt|;
name|priv
operator|->
name|hasFailed
operator|=
literal|true
expr_stmt|;
name|priv
operator|->
name|phase
operator|=
name|QAuthenticatorPrivate
operator|::
name|Done
expr_stmt|;
name|channels
index|[
name|i
index|]
operator|.
name|authenticationCredentialsSent
operator|=
literal|false
expr_stmt|;
block|}
emit|emit
name|reply
operator|->
name|authenticationRequired
argument_list|(
name|reply
operator|->
name|request
argument_list|()
argument_list|,
name|auth
argument_list|)
emit|;
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
block|}
else|else
block|{
if|if
condition|(
name|channels
index|[
name|i
index|]
operator|.
name|proxyCredentialsSent
condition|)
block|{
name|auth
operator|->
name|detach
argument_list|()
expr_stmt|;
name|priv
operator|=
name|QAuthenticatorPrivate
operator|::
name|getPrivate
argument_list|(
operator|*
name|auth
argument_list|)
expr_stmt|;
name|priv
operator|->
name|hasFailed
operator|=
literal|true
expr_stmt|;
name|priv
operator|->
name|phase
operator|=
name|QAuthenticatorPrivate
operator|::
name|Done
expr_stmt|;
name|channels
index|[
name|i
index|]
operator|.
name|proxyCredentialsSent
operator|=
literal|false
expr_stmt|;
block|}
emit|emit
name|reply
operator|->
name|proxyAuthenticationRequired
argument_list|(
name|networkProxy
argument_list|,
name|auth
argument_list|)
emit|;
endif|#
directive|endif
block|}
name|resumeConnection
argument_list|()
expr_stmt|;
if|if
condition|(
name|priv
operator|->
name|phase
operator|!=
name|QAuthenticatorPrivate
operator|::
name|Done
condition|)
block|{
comment|// send any pending requests
name|copyCredentials
argument_list|(
name|i
argument_list|,
name|auth
argument_list|,
name|isProxy
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|priv
operator|->
name|phase
operator|==
name|QAuthenticatorPrivate
operator|::
name|Start
condition|)
block|{
comment|// If the url's authenticator has a 'user' set we will end up here (phase is only set to 'Done' by
comment|// parseHttpResponse above if 'user' is empty). So if credentials were supplied with the request,
comment|// such as in the case of an XMLHttpRequest, this is our only opportunity to cache them.
emit|emit
name|reply
operator|->
name|cacheCredentials
argument_list|(
name|reply
operator|->
name|request
argument_list|()
argument_list|,
name|auth
argument_list|)
emit|;
block|}
comment|// - Changing values in QAuthenticator will reset the 'phase'. Therefore if it is still "Done"
comment|//   then nothing was filled in by the user or the cache
comment|// - If withCredentials has been set to false (e.g. by Qt WebKit for a cross-origin XMLHttpRequest) then
comment|//   we need to bail out if authentication is required.
if|if
condition|(
name|priv
operator|->
name|phase
operator|==
name|QAuthenticatorPrivate
operator|::
name|Done
operator|||
operator|!
name|reply
operator|->
name|request
argument_list|()
operator|.
name|withCredentials
argument_list|()
condition|)
block|{
comment|// Reset authenticator so the next request on that channel does not get messed up
name|auth
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isProxy
condition|)
name|channels
index|[
name|i
index|]
operator|.
name|proxyAuthenticator
operator|=
name|QAuthenticator
argument_list|()
expr_stmt|;
else|else
name|channels
index|[
name|i
index|]
operator|.
name|authenticator
operator|=
name|QAuthenticator
argument_list|()
expr_stmt|;
comment|// authentication is cancelled, send the current contents to the user.
emit|emit
name|channels
index|[
name|i
index|]
operator|.
name|reply
operator|->
name|headerChanged
argument_list|()
emit|;
emit|emit
name|channels
index|[
name|i
index|]
operator|.
name|reply
operator|->
name|readyRead
argument_list|()
emit|;
name|QNetworkReply
operator|::
name|NetworkError
name|errorCode
init|=
name|isProxy
condition|?
name|QNetworkReply
operator|::
name|ProxyAuthenticationRequiredError
else|:
name|QNetworkReply
operator|::
name|AuthenticationRequiredError
decl_stmt|;
name|reply
operator|->
name|d_func
argument_list|()
operator|->
name|errorString
operator|=
name|errorDetail
argument_list|(
name|errorCode
argument_list|,
name|socket
argument_list|)
expr_stmt|;
emit|emit
name|reply
operator|->
name|finishedWithError
argument_list|(
name|errorCode
argument_list|,
name|reply
operator|->
name|d_func
argument_list|()
operator|->
name|errorString
argument_list|)
emit|;
comment|// ### at this point the reply could be deleted
return|return
literal|true
return|;
block|}
comment|//resend the request
name|resend
operator|=
literal|true
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|createAuthorization
name|void
name|QHttpNetworkConnectionPrivate
operator|::
name|createAuthorization
parameter_list|(
name|QAbstractSocket
modifier|*
name|socket
parameter_list|,
name|QHttpNetworkRequest
modifier|&
name|request
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|socket
argument_list|)
expr_stmt|;
name|int
name|i
init|=
name|indexOf
argument_list|(
name|socket
argument_list|)
decl_stmt|;
comment|// Send "Authorization" header, but not if it's NTLM and the socket is already authenticated.
if|if
condition|(
name|channels
index|[
name|i
index|]
operator|.
name|authMethod
operator|!=
name|QAuthenticatorPrivate
operator|::
name|None
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|channels
index|[
name|i
index|]
operator|.
name|authMethod
operator|==
name|QAuthenticatorPrivate
operator|::
name|Ntlm
operator|&&
name|channels
index|[
name|i
index|]
operator|.
name|lastStatus
operator|!=
literal|401
operator|)
condition|)
block|{
name|QAuthenticatorPrivate
modifier|*
name|priv
init|=
name|QAuthenticatorPrivate
operator|::
name|getPrivate
argument_list|(
name|channels
index|[
name|i
index|]
operator|.
name|authenticator
argument_list|)
decl_stmt|;
if|if
condition|(
name|priv
operator|&&
name|priv
operator|->
name|method
operator|!=
name|QAuthenticatorPrivate
operator|::
name|None
condition|)
block|{
name|QByteArray
name|response
init|=
name|priv
operator|->
name|calculateResponse
argument_list|(
name|request
operator|.
name|d
operator|->
name|methodName
argument_list|()
argument_list|,
name|request
operator|.
name|d
operator|->
name|uri
argument_list|(
literal|false
argument_list|)
argument_list|)
decl_stmt|;
name|request
operator|.
name|setHeaderField
argument_list|(
literal|"Authorization"
argument_list|,
name|response
argument_list|)
expr_stmt|;
name|channels
index|[
name|i
index|]
operator|.
name|authenticationCredentialsSent
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
comment|// Send "Proxy-Authorization" header, but not if it's NTLM and the socket is already authenticated.
if|if
condition|(
name|channels
index|[
name|i
index|]
operator|.
name|proxyAuthMethod
operator|!=
name|QAuthenticatorPrivate
operator|::
name|None
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|channels
index|[
name|i
index|]
operator|.
name|proxyAuthMethod
operator|==
name|QAuthenticatorPrivate
operator|::
name|Ntlm
operator|&&
name|channels
index|[
name|i
index|]
operator|.
name|lastStatus
operator|!=
literal|407
operator|)
condition|)
block|{
name|QAuthenticatorPrivate
modifier|*
name|priv
init|=
name|QAuthenticatorPrivate
operator|::
name|getPrivate
argument_list|(
name|channels
index|[
name|i
index|]
operator|.
name|proxyAuthenticator
argument_list|)
decl_stmt|;
if|if
condition|(
name|priv
operator|&&
name|priv
operator|->
name|method
operator|!=
name|QAuthenticatorPrivate
operator|::
name|None
condition|)
block|{
name|QByteArray
name|response
init|=
name|priv
operator|->
name|calculateResponse
argument_list|(
name|request
operator|.
name|d
operator|->
name|methodName
argument_list|()
argument_list|,
name|request
operator|.
name|d
operator|->
name|uri
argument_list|(
literal|false
argument_list|)
argument_list|)
decl_stmt|;
name|request
operator|.
name|setHeaderField
argument_list|(
literal|"Proxy-Authorization"
argument_list|,
name|response
argument_list|)
expr_stmt|;
name|channels
index|[
name|i
index|]
operator|.
name|proxyCredentialsSent
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
block|}
end_function
begin_function
DECL|function|queueRequest
name|QHttpNetworkReply
modifier|*
name|QHttpNetworkConnectionPrivate
operator|::
name|queueRequest
parameter_list|(
specifier|const
name|QHttpNetworkRequest
modifier|&
name|request
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QHttpNetworkConnection
argument_list|)
expr_stmt|;
comment|// The reply component of the pair is created initially.
name|QHttpNetworkReply
modifier|*
name|reply
init|=
operator|new
name|QHttpNetworkReply
argument_list|(
name|request
operator|.
name|url
argument_list|()
argument_list|)
decl_stmt|;
name|reply
operator|->
name|setRequest
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|reply
operator|->
name|d_func
argument_list|()
operator|->
name|connection
operator|=
name|q
expr_stmt|;
name|reply
operator|->
name|d_func
argument_list|()
operator|->
name|connectionChannel
operator|=
operator|&
name|channels
index|[
literal|0
index|]
expr_stmt|;
comment|// will have the correct one set later
name|HttpMessagePair
name|pair
init|=
name|qMakePair
argument_list|(
name|request
argument_list|,
name|reply
argument_list|)
decl_stmt|;
if|if
condition|(
name|request
operator|.
name|isPreConnect
argument_list|()
condition|)
name|preConnectRequests
operator|++
expr_stmt|;
switch|switch
condition|(
name|request
operator|.
name|priority
argument_list|()
condition|)
block|{
case|case
name|QHttpNetworkRequest
operator|::
name|HighPriority
case|:
name|highPriorityQueue
operator|.
name|prepend
argument_list|(
name|pair
argument_list|)
expr_stmt|;
break|break;
case|case
name|QHttpNetworkRequest
operator|::
name|NormalPriority
case|:
case|case
name|QHttpNetworkRequest
operator|::
name|LowPriority
case|:
name|lowPriorityQueue
operator|.
name|prepend
argument_list|(
name|pair
argument_list|)
expr_stmt|;
break|break;
block|}
comment|// For Happy Eyeballs the networkLayerState is set to Unknown
comment|// untill we have started the first connection attempt. So no
comment|// request will be started untill we know if IPv4 or IPv6
comment|// should be used.
if|if
condition|(
name|networkLayerState
operator|==
name|Unknown
condition|)
block|{
name|startHostInfoLookup
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|networkLayerState
operator|==
name|IPv4
operator|||
name|networkLayerState
operator|==
name|IPv6
condition|)
block|{
comment|// this used to be called via invokeMethod and a QueuedConnection
comment|// It is the only place _q_startNextRequest is called directly without going
comment|// through the event loop using a QueuedConnection.
comment|// This is dangerous because of recursion that might occur when emitting
comment|// signals as DirectConnection from this code path. Therefore all signal
comment|// emissions that can come out from this code path need to
comment|// be QueuedConnection.
comment|// We are currently trying to fine-tune this.
name|_q_startNextRequest
argument_list|()
expr_stmt|;
block|}
return|return
name|reply
return|;
block|}
end_function
begin_function
DECL|function|requeueRequest
name|void
name|QHttpNetworkConnectionPrivate
operator|::
name|requeueRequest
parameter_list|(
specifier|const
name|HttpMessagePair
modifier|&
name|pair
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QHttpNetworkConnection
argument_list|)
expr_stmt|;
name|QHttpNetworkRequest
name|request
init|=
name|pair
operator|.
name|first
decl_stmt|;
switch|switch
condition|(
name|request
operator|.
name|priority
argument_list|()
condition|)
block|{
case|case
name|QHttpNetworkRequest
operator|::
name|HighPriority
case|:
name|highPriorityQueue
operator|.
name|prepend
argument_list|(
name|pair
argument_list|)
expr_stmt|;
break|break;
case|case
name|QHttpNetworkRequest
operator|::
name|NormalPriority
case|:
case|case
name|QHttpNetworkRequest
operator|::
name|LowPriority
case|:
name|lowPriorityQueue
operator|.
name|prepend
argument_list|(
name|pair
argument_list|)
expr_stmt|;
break|break;
block|}
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|q
argument_list|,
literal|"_q_startNextRequest"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|dequeueRequest
name|bool
name|QHttpNetworkConnectionPrivate
operator|::
name|dequeueRequest
parameter_list|(
name|QAbstractSocket
modifier|*
name|socket
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|socket
condition|)
name|i
operator|=
name|indexOf
argument_list|(
name|socket
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|highPriorityQueue
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// remove from queue before sendRequest! else we might pipeline the same request again
name|HttpMessagePair
name|messagePair
init|=
name|highPriorityQueue
operator|.
name|takeLast
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|messagePair
operator|.
name|second
operator|->
name|d_func
argument_list|()
operator|->
name|requestIsPrepared
condition|)
name|prepareRequest
argument_list|(
name|messagePair
argument_list|)
expr_stmt|;
name|channels
index|[
name|i
index|]
operator|.
name|request
operator|=
name|messagePair
operator|.
name|first
expr_stmt|;
name|channels
index|[
name|i
index|]
operator|.
name|reply
operator|=
name|messagePair
operator|.
name|second
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
operator|!
name|lowPriorityQueue
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// remove from queue before sendRequest! else we might pipeline the same request again
name|HttpMessagePair
name|messagePair
init|=
name|lowPriorityQueue
operator|.
name|takeLast
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|messagePair
operator|.
name|second
operator|->
name|d_func
argument_list|()
operator|->
name|requestIsPrepared
condition|)
name|prepareRequest
argument_list|(
name|messagePair
argument_list|)
expr_stmt|;
name|channels
index|[
name|i
index|]
operator|.
name|request
operator|=
name|messagePair
operator|.
name|first
expr_stmt|;
name|channels
index|[
name|i
index|]
operator|.
name|reply
operator|=
name|messagePair
operator|.
name|second
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|predictNextRequest
name|QHttpNetworkRequest
name|QHttpNetworkConnectionPrivate
operator|::
name|predictNextRequest
parameter_list|()
block|{
if|if
condition|(
operator|!
name|highPriorityQueue
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|highPriorityQueue
operator|.
name|last
argument_list|()
operator|.
name|first
return|;
if|if
condition|(
operator|!
name|lowPriorityQueue
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|lowPriorityQueue
operator|.
name|last
argument_list|()
operator|.
name|first
return|;
return|return
name|QHttpNetworkRequest
argument_list|()
return|;
block|}
end_function
begin_comment
comment|// this is called from _q_startNextRequest and when a request has been sent down a socket from the channel
end_comment
begin_function
DECL|function|fillPipeline
name|void
name|QHttpNetworkConnectionPrivate
operator|::
name|fillPipeline
parameter_list|(
name|QAbstractSocket
modifier|*
name|socket
parameter_list|)
block|{
comment|// return fast if there is nothing to pipeline
if|if
condition|(
name|highPriorityQueue
operator|.
name|isEmpty
argument_list|()
operator|&&
name|lowPriorityQueue
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|int
name|i
init|=
name|indexOf
argument_list|(
name|socket
argument_list|)
decl_stmt|;
comment|// return fast if there was no reply right now processed
if|if
condition|(
name|channels
index|[
name|i
index|]
operator|.
name|reply
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
name|defaultPipelineLength
operator|-
name|channels
index|[
name|i
index|]
operator|.
name|alreadyPipelinedRequests
operator|.
name|length
argument_list|()
operator|>=
name|defaultRePipelineLength
operator|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|channels
index|[
name|i
index|]
operator|.
name|pipeliningSupported
operator|!=
name|QHttpNetworkConnectionChannel
operator|::
name|PipeliningProbablySupported
condition|)
return|return;
comment|// the current request that is in must already support pipelining
if|if
condition|(
operator|!
name|channels
index|[
name|i
index|]
operator|.
name|request
operator|.
name|isPipeliningAllowed
argument_list|()
condition|)
return|return;
comment|// the current request must be a idempotent (right now we only check GET)
if|if
condition|(
name|channels
index|[
name|i
index|]
operator|.
name|request
operator|.
name|operation
argument_list|()
operator|!=
name|QHttpNetworkRequest
operator|::
name|Get
condition|)
return|return;
comment|// check if socket is connected
if|if
condition|(
name|socket
operator|->
name|state
argument_list|()
operator|!=
name|QAbstractSocket
operator|::
name|ConnectedState
condition|)
return|return;
comment|// check for resendCurrent
if|if
condition|(
name|channels
index|[
name|i
index|]
operator|.
name|resendCurrent
condition|)
return|return;
comment|// we do not like authentication stuff
comment|// ### make sure to be OK with this in later releases
if|if
condition|(
operator|!
name|channels
index|[
name|i
index|]
operator|.
name|authenticator
operator|.
name|isNull
argument_list|()
operator|&&
operator|(
operator|!
name|channels
index|[
name|i
index|]
operator|.
name|authenticator
operator|.
name|user
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|channels
index|[
name|i
index|]
operator|.
name|authenticator
operator|.
name|password
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|)
condition|)
return|return;
if|if
condition|(
operator|!
name|channels
index|[
name|i
index|]
operator|.
name|proxyAuthenticator
operator|.
name|isNull
argument_list|()
operator|&&
operator|(
operator|!
name|channels
index|[
name|i
index|]
operator|.
name|proxyAuthenticator
operator|.
name|user
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|channels
index|[
name|i
index|]
operator|.
name|proxyAuthenticator
operator|.
name|password
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|)
condition|)
return|return;
comment|// must be in ReadingState or WaitingState
if|if
condition|(
operator|!
operator|(
name|channels
index|[
name|i
index|]
operator|.
name|state
operator|==
name|QHttpNetworkConnectionChannel
operator|::
name|WaitingState
operator|||
name|channels
index|[
name|i
index|]
operator|.
name|state
operator|==
name|QHttpNetworkConnectionChannel
operator|::
name|ReadingState
operator|)
condition|)
return|return;
name|int
name|lengthBefore
decl_stmt|;
while|while
condition|(
operator|!
name|highPriorityQueue
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|lengthBefore
operator|=
name|channels
index|[
name|i
index|]
operator|.
name|alreadyPipelinedRequests
operator|.
name|length
argument_list|()
expr_stmt|;
name|fillPipeline
argument_list|(
name|highPriorityQueue
argument_list|,
name|channels
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|channels
index|[
name|i
index|]
operator|.
name|alreadyPipelinedRequests
operator|.
name|length
argument_list|()
operator|>=
name|defaultPipelineLength
condition|)
block|{
name|channels
index|[
name|i
index|]
operator|.
name|pipelineFlush
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|lengthBefore
operator|==
name|channels
index|[
name|i
index|]
operator|.
name|alreadyPipelinedRequests
operator|.
name|length
argument_list|()
condition|)
break|break;
comment|// did not process anything, now do the low prio queue
block|}
while|while
condition|(
operator|!
name|lowPriorityQueue
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|lengthBefore
operator|=
name|channels
index|[
name|i
index|]
operator|.
name|alreadyPipelinedRequests
operator|.
name|length
argument_list|()
expr_stmt|;
name|fillPipeline
argument_list|(
name|lowPriorityQueue
argument_list|,
name|channels
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|channels
index|[
name|i
index|]
operator|.
name|alreadyPipelinedRequests
operator|.
name|length
argument_list|()
operator|>=
name|defaultPipelineLength
condition|)
block|{
name|channels
index|[
name|i
index|]
operator|.
name|pipelineFlush
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|lengthBefore
operator|==
name|channels
index|[
name|i
index|]
operator|.
name|alreadyPipelinedRequests
operator|.
name|length
argument_list|()
condition|)
break|break;
comment|// did not process anything
block|}
name|channels
index|[
name|i
index|]
operator|.
name|pipelineFlush
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|// returns true when the processing of a queue has been done
end_comment
begin_function
DECL|function|fillPipeline
name|bool
name|QHttpNetworkConnectionPrivate
operator|::
name|fillPipeline
parameter_list|(
name|QList
argument_list|<
name|HttpMessagePair
argument_list|>
modifier|&
name|queue
parameter_list|,
name|QHttpNetworkConnectionChannel
modifier|&
name|channel
parameter_list|)
block|{
if|if
condition|(
name|queue
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|true
return|;
for|for
control|(
name|int
name|i
init|=
name|queue
operator|.
name|count
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|HttpMessagePair
name|messagePair
init|=
name|queue
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
specifier|const
name|QHttpNetworkRequest
modifier|&
name|request
init|=
name|messagePair
operator|.
name|first
decl_stmt|;
comment|// we currently do not support pipelining if HTTP authentication is used
if|if
condition|(
operator|!
name|request
operator|.
name|url
argument_list|()
operator|.
name|userInfo
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
continue|continue;
comment|// take only GET requests
if|if
condition|(
name|request
operator|.
name|operation
argument_list|()
operator|!=
name|QHttpNetworkRequest
operator|::
name|Get
condition|)
continue|continue;
if|if
condition|(
operator|!
name|request
operator|.
name|isPipeliningAllowed
argument_list|()
condition|)
continue|continue;
comment|// remove it from the queue
name|queue
operator|.
name|takeAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|// we modify the queue we iterate over here, but since we return from the function
comment|// afterwards this is fine.
comment|// actually send it
if|if
condition|(
operator|!
name|messagePair
operator|.
name|second
operator|->
name|d_func
argument_list|()
operator|->
name|requestIsPrepared
condition|)
name|prepareRequest
argument_list|(
name|messagePair
argument_list|)
expr_stmt|;
name|channel
operator|.
name|pipelineInto
argument_list|(
name|messagePair
argument_list|)
expr_stmt|;
comment|// return false because we processed something and need to process again
return|return
literal|false
return|;
block|}
comment|// return true, the queue has been processed and not changed
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|errorDetail
name|QString
name|QHttpNetworkConnectionPrivate
operator|::
name|errorDetail
parameter_list|(
name|QNetworkReply
operator|::
name|NetworkError
name|errorCode
parameter_list|,
name|QAbstractSocket
modifier|*
name|socket
parameter_list|,
specifier|const
name|QString
modifier|&
name|extraDetail
parameter_list|)
block|{
name|QString
name|errorString
decl_stmt|;
switch|switch
condition|(
name|errorCode
condition|)
block|{
case|case
name|QNetworkReply
operator|::
name|HostNotFoundError
case|:
if|if
condition|(
name|socket
condition|)
name|errorString
operator|=
name|QCoreApplication
operator|::
name|translate
argument_list|(
literal|"QHttp"
argument_list|,
literal|"Host %1 not found"
argument_list|)
operator|.
name|arg
argument_list|(
name|socket
operator|->
name|peerName
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|errorString
operator|=
name|QCoreApplication
operator|::
name|translate
argument_list|(
literal|"QHttp"
argument_list|,
literal|"Host %1 not found"
argument_list|)
operator|.
name|arg
argument_list|(
name|hostName
argument_list|)
expr_stmt|;
break|break;
case|case
name|QNetworkReply
operator|::
name|ConnectionRefusedError
case|:
name|errorString
operator|=
name|QCoreApplication
operator|::
name|translate
argument_list|(
literal|"QHttp"
argument_list|,
literal|"Connection refused"
argument_list|)
expr_stmt|;
break|break;
case|case
name|QNetworkReply
operator|::
name|RemoteHostClosedError
case|:
name|errorString
operator|=
name|QCoreApplication
operator|::
name|translate
argument_list|(
literal|"QHttp"
argument_list|,
literal|"Connection closed"
argument_list|)
expr_stmt|;
break|break;
case|case
name|QNetworkReply
operator|::
name|TimeoutError
case|:
name|errorString
operator|=
name|QCoreApplication
operator|::
name|translate
argument_list|(
literal|"QAbstractSocket"
argument_list|,
literal|"Socket operation timed out"
argument_list|)
expr_stmt|;
break|break;
case|case
name|QNetworkReply
operator|::
name|ProxyAuthenticationRequiredError
case|:
name|errorString
operator|=
name|QCoreApplication
operator|::
name|translate
argument_list|(
literal|"QHttp"
argument_list|,
literal|"Proxy requires authentication"
argument_list|)
expr_stmt|;
break|break;
case|case
name|QNetworkReply
operator|::
name|AuthenticationRequiredError
case|:
name|errorString
operator|=
name|QCoreApplication
operator|::
name|translate
argument_list|(
literal|"QHttp"
argument_list|,
literal|"Host requires authentication"
argument_list|)
expr_stmt|;
break|break;
case|case
name|QNetworkReply
operator|::
name|ProtocolFailure
case|:
name|errorString
operator|=
name|QCoreApplication
operator|::
name|translate
argument_list|(
literal|"QHttp"
argument_list|,
literal|"Data corrupted"
argument_list|)
expr_stmt|;
break|break;
case|case
name|QNetworkReply
operator|::
name|ProtocolUnknownError
case|:
name|errorString
operator|=
name|QCoreApplication
operator|::
name|translate
argument_list|(
literal|"QHttp"
argument_list|,
literal|"Unknown protocol specified"
argument_list|)
expr_stmt|;
break|break;
case|case
name|QNetworkReply
operator|::
name|SslHandshakeFailedError
case|:
name|errorString
operator|=
name|QCoreApplication
operator|::
name|translate
argument_list|(
literal|"QHttp"
argument_list|,
literal|"SSL handshake failed"
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|// all other errors are treated as QNetworkReply::UnknownNetworkError
name|errorString
operator|=
name|extraDetail
expr_stmt|;
break|break;
block|}
return|return
name|errorString
return|;
block|}
end_function
begin_comment
comment|// this is called from the destructor of QHttpNetworkReply. It is called when
end_comment
begin_comment
comment|// the reply was finished correctly or when it was aborted.
end_comment
begin_function
DECL|function|removeReply
name|void
name|QHttpNetworkConnectionPrivate
operator|::
name|removeReply
parameter_list|(
name|QHttpNetworkReply
modifier|*
name|reply
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QHttpNetworkConnection
argument_list|)
expr_stmt|;
comment|// check if the reply is currently being processed or it is pipelined in
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|channelCount
condition|;
operator|++
name|i
control|)
block|{
comment|// is the reply associated the currently processing of this channel?
if|if
condition|(
name|channels
index|[
name|i
index|]
operator|.
name|reply
operator|==
name|reply
condition|)
block|{
name|channels
index|[
name|i
index|]
operator|.
name|reply
operator|=
literal|0
expr_stmt|;
name|channels
index|[
name|i
index|]
operator|.
name|request
operator|=
name|QHttpNetworkRequest
argument_list|()
expr_stmt|;
name|channels
index|[
name|i
index|]
operator|.
name|resendCurrent
operator|=
literal|false
expr_stmt|;
if|if
condition|(
operator|!
name|reply
operator|->
name|isFinished
argument_list|()
operator|&&
operator|!
name|channels
index|[
name|i
index|]
operator|.
name|alreadyPipelinedRequests
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// the reply had to be prematurely removed, e.g. it was not finished
comment|// therefore we have to requeue the already pipelined requests.
name|channels
index|[
name|i
index|]
operator|.
name|requeueCurrentlyPipelinedRequests
argument_list|()
expr_stmt|;
block|}
comment|// if HTTP mandates we should close
comment|// or the reply is not finished yet, e.g. it was aborted
comment|// we have to close that connection
if|if
condition|(
name|reply
operator|->
name|d_func
argument_list|()
operator|->
name|isConnectionCloseEnabled
argument_list|()
operator|||
operator|!
name|reply
operator|->
name|isFinished
argument_list|()
condition|)
name|channels
index|[
name|i
index|]
operator|.
name|close
argument_list|()
expr_stmt|;
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|q
argument_list|,
literal|"_q_startNextRequest"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// is the reply inside the pipeline of this channel already?
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|channels
index|[
name|i
index|]
operator|.
name|alreadyPipelinedRequests
operator|.
name|length
argument_list|()
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|channels
index|[
name|i
index|]
operator|.
name|alreadyPipelinedRequests
operator|.
name|at
argument_list|(
name|j
argument_list|)
operator|.
name|second
operator|==
name|reply
condition|)
block|{
comment|// Remove that HttpMessagePair
name|channels
index|[
name|i
index|]
operator|.
name|alreadyPipelinedRequests
operator|.
name|removeAt
argument_list|(
name|j
argument_list|)
expr_stmt|;
name|channels
index|[
name|i
index|]
operator|.
name|requeueCurrentlyPipelinedRequests
argument_list|()
expr_stmt|;
comment|// Since some requests had already been pipelined, but we removed
comment|// one and re-queued the others
comment|// we must force a connection close after the request that is
comment|// currently in processing has been finished.
if|if
condition|(
name|channels
index|[
name|i
index|]
operator|.
name|reply
condition|)
name|channels
index|[
name|i
index|]
operator|.
name|reply
operator|->
name|d_func
argument_list|()
operator|->
name|forceConnectionCloseEnabled
operator|=
literal|true
expr_stmt|;
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|q
argument_list|,
literal|"_q_startNextRequest"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
comment|// remove from the high priority queue
if|if
condition|(
operator|!
name|highPriorityQueue
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|j
init|=
name|highPriorityQueue
operator|.
name|count
argument_list|()
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
operator|--
name|j
control|)
block|{
name|HttpMessagePair
name|messagePair
init|=
name|highPriorityQueue
operator|.
name|at
argument_list|(
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|messagePair
operator|.
name|second
operator|==
name|reply
condition|)
block|{
name|highPriorityQueue
operator|.
name|removeAt
argument_list|(
name|j
argument_list|)
expr_stmt|;
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|q
argument_list|,
literal|"_q_startNextRequest"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
comment|// remove from the low priority queue
if|if
condition|(
operator|!
name|lowPriorityQueue
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|j
init|=
name|lowPriorityQueue
operator|.
name|count
argument_list|()
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
operator|--
name|j
control|)
block|{
name|HttpMessagePair
name|messagePair
init|=
name|lowPriorityQueue
operator|.
name|at
argument_list|(
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|messagePair
operator|.
name|second
operator|==
name|reply
condition|)
block|{
name|lowPriorityQueue
operator|.
name|removeAt
argument_list|(
name|j
argument_list|)
expr_stmt|;
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|q
argument_list|,
literal|"_q_startNextRequest"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
block|}
end_function
begin_comment
comment|// This function must be called from the event loop. The only
end_comment
begin_comment
comment|// exception is documented in QHttpNetworkConnectionPrivate::queueRequest
end_comment
begin_comment
comment|// although it is called _q_startNextRequest, it will actually start multiple requests when possible
end_comment
begin_function
DECL|function|_q_startNextRequest
name|void
name|QHttpNetworkConnectionPrivate
operator|::
name|_q_startNextRequest
parameter_list|()
block|{
comment|// If there is no network layer state decided we should not start any new requests.
if|if
condition|(
name|networkLayerState
operator|==
name|Unknown
operator|||
name|networkLayerState
operator|==
name|InProgress
condition|)
return|return;
comment|// If the QHttpNetworkConnection is currently paused then bail out immediately
if|if
condition|(
name|state
operator|==
name|PausedState
condition|)
return|return;
comment|//resend the necessary ones.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|channelCount
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|channels
index|[
name|i
index|]
operator|.
name|resendCurrent
operator|&&
operator|(
name|channels
index|[
name|i
index|]
operator|.
name|state
operator|!=
name|QHttpNetworkConnectionChannel
operator|::
name|ClosingState
operator|)
condition|)
block|{
name|channels
index|[
name|i
index|]
operator|.
name|resendCurrent
operator|=
literal|false
expr_stmt|;
name|channels
index|[
name|i
index|]
operator|.
name|state
operator|=
name|QHttpNetworkConnectionChannel
operator|::
name|IdleState
expr_stmt|;
comment|// if this is not possible, error will be emitted and connection terminated
if|if
condition|(
operator|!
name|channels
index|[
name|i
index|]
operator|.
name|resetUploadData
argument_list|()
condition|)
continue|continue;
name|channels
index|[
name|i
index|]
operator|.
name|sendRequest
argument_list|()
expr_stmt|;
block|}
block|}
comment|// dequeue new ones
comment|// return fast if there is nothing to do
if|if
condition|(
name|highPriorityQueue
operator|.
name|isEmpty
argument_list|()
operator|&&
name|lowPriorityQueue
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
comment|// try to get a free AND connected socket
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|channelCount
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|channels
index|[
name|i
index|]
operator|.
name|socket
condition|)
block|{
if|if
condition|(
operator|!
name|channels
index|[
name|i
index|]
operator|.
name|reply
operator|&&
operator|!
name|channels
index|[
name|i
index|]
operator|.
name|isSocketBusy
argument_list|()
operator|&&
name|channels
index|[
name|i
index|]
operator|.
name|socket
operator|->
name|state
argument_list|()
operator|==
name|QAbstractSocket
operator|::
name|ConnectedState
condition|)
block|{
if|if
condition|(
name|dequeueRequest
argument_list|(
name|channels
index|[
name|i
index|]
operator|.
name|socket
argument_list|)
condition|)
name|channels
index|[
name|i
index|]
operator|.
name|sendRequest
argument_list|()
expr_stmt|;
block|}
block|}
block|}
comment|// try to push more into all sockets
comment|// ### FIXME we should move this to the beginning of the function
comment|// as soon as QtWebkit is properly using the pipelining
comment|// (e.g. not for XMLHttpRequest or the first page load)
comment|// ### FIXME we should also divide the requests more even
comment|// on the connected sockets
comment|//tryToFillPipeline(socket);
comment|// return fast if there is nothing to pipeline
if|if
condition|(
name|highPriorityQueue
operator|.
name|isEmpty
argument_list|()
operator|&&
name|lowPriorityQueue
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|channelCount
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|channels
index|[
name|i
index|]
operator|.
name|socket
operator|&&
name|channels
index|[
name|i
index|]
operator|.
name|socket
operator|->
name|state
argument_list|()
operator|==
name|QAbstractSocket
operator|::
name|ConnectedState
condition|)
name|fillPipeline
argument_list|(
name|channels
index|[
name|i
index|]
operator|.
name|socket
argument_list|)
expr_stmt|;
comment|// If there is not already any connected channels we need to connect a new one.
comment|// We do not pair the channel with the request until we know if it is
comment|// connected or not. This is to reuse connected channels before we connect new once.
name|int
name|queuedRequests
init|=
name|highPriorityQueue
operator|.
name|count
argument_list|()
operator|+
name|lowPriorityQueue
operator|.
name|count
argument_list|()
decl_stmt|;
comment|// in case we have in-flight preconnect requests and normal requests,
comment|// we only need one socket for each (preconnect, normal request) pair
name|int
name|neededOpenChannels
init|=
name|queuedRequests
decl_stmt|;
if|if
condition|(
name|preConnectRequests
operator|>
literal|0
condition|)
block|{
name|int
name|normalRequests
init|=
name|queuedRequests
operator|-
name|preConnectRequests
decl_stmt|;
name|neededOpenChannels
operator|=
name|qMax
argument_list|(
name|normalRequests
argument_list|,
name|preConnectRequests
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
argument_list|<
name|channelCount
operator|&&
name|neededOpenChannels
argument_list|>
literal|0
condition|;
operator|++
name|i
control|)
block|{
name|bool
name|connectChannel
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|channels
index|[
name|i
index|]
operator|.
name|socket
condition|)
block|{
if|if
condition|(
operator|(
name|channels
index|[
name|i
index|]
operator|.
name|socket
operator|->
name|state
argument_list|()
operator|==
name|QAbstractSocket
operator|::
name|ConnectingState
operator|)
operator|||
operator|(
name|channels
index|[
name|i
index|]
operator|.
name|socket
operator|->
name|state
argument_list|()
operator|==
name|QAbstractSocket
operator|::
name|HostLookupState
operator|)
operator|||
name|channels
index|[
name|i
index|]
operator|.
name|pendingEncrypt
condition|)
comment|// pendingEncrypt == "EncryptingState"
name|neededOpenChannels
operator|--
expr_stmt|;
if|if
condition|(
name|neededOpenChannels
operator|<=
literal|0
condition|)
break|break;
if|if
condition|(
operator|!
name|channels
index|[
name|i
index|]
operator|.
name|reply
operator|&&
operator|!
name|channels
index|[
name|i
index|]
operator|.
name|isSocketBusy
argument_list|()
operator|&&
operator|(
name|channels
index|[
name|i
index|]
operator|.
name|socket
operator|->
name|state
argument_list|()
operator|==
name|QAbstractSocket
operator|::
name|UnconnectedState
operator|)
condition|)
name|connectChannel
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
comment|// not previously used channel
name|connectChannel
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|connectChannel
condition|)
block|{
if|if
condition|(
name|networkLayerState
operator|==
name|IPv4
condition|)
name|channels
index|[
name|i
index|]
operator|.
name|networkLayerPreference
operator|=
name|QAbstractSocket
operator|::
name|IPv4Protocol
expr_stmt|;
elseif|else
if|if
condition|(
name|networkLayerState
operator|==
name|IPv6
condition|)
name|channels
index|[
name|i
index|]
operator|.
name|networkLayerPreference
operator|=
name|QAbstractSocket
operator|::
name|IPv6Protocol
expr_stmt|;
name|channels
index|[
name|i
index|]
operator|.
name|ensureConnection
argument_list|()
expr_stmt|;
name|neededOpenChannels
operator|--
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|readMoreLater
name|void
name|QHttpNetworkConnectionPrivate
operator|::
name|readMoreLater
parameter_list|(
name|QHttpNetworkReply
modifier|*
name|reply
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|channelCount
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|channels
index|[
name|i
index|]
operator|.
name|reply
operator|==
name|reply
condition|)
block|{
comment|// emulate a readyRead() from the socket
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
operator|&
name|channels
index|[
name|i
index|]
argument_list|,
literal|"_q_readyRead"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function
begin_comment
comment|// The first time we start the connection is used we do not know if we
end_comment
begin_comment
comment|// should use IPv4 or IPv6. So we start a hostlookup to figure this out.
end_comment
begin_comment
comment|// Later when we do the connection the socket will not need to do another
end_comment
begin_comment
comment|// lookup as then the hostinfo will already be in the cache.
end_comment
begin_function
DECL|function|startHostInfoLookup
name|void
name|QHttpNetworkConnectionPrivate
operator|::
name|startHostInfoLookup
parameter_list|()
block|{
name|networkLayerState
operator|=
name|InProgress
expr_stmt|;
comment|// check if we already now can decide if this is IPv4 or IPv6
name|QString
name|lookupHost
init|=
name|hostName
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
if|if
condition|(
name|networkProxy
operator|.
name|capabilities
argument_list|()
operator|&
name|QNetworkProxy
operator|::
name|HostNameLookupCapability
condition|)
block|{
name|lookupHost
operator|=
name|networkProxy
operator|.
name|hostName
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|channels
index|[
literal|0
index|]
operator|.
name|proxy
operator|.
name|capabilities
argument_list|()
operator|&
name|QNetworkProxy
operator|::
name|HostNameLookupCapability
condition|)
block|{
name|lookupHost
operator|=
name|channels
index|[
literal|0
index|]
operator|.
name|proxy
operator|.
name|hostName
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
name|QHostAddress
name|temp
decl_stmt|;
if|if
condition|(
name|temp
operator|.
name|setAddress
argument_list|(
name|lookupHost
argument_list|)
condition|)
block|{
if|if
condition|(
name|temp
operator|.
name|protocol
argument_list|()
operator|==
name|QAbstractSocket
operator|::
name|IPv4Protocol
condition|)
block|{
name|networkLayerState
operator|=
name|QHttpNetworkConnectionPrivate
operator|::
name|IPv4
expr_stmt|;
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|this
operator|->
name|q_func
argument_list|()
argument_list|,
literal|"_q_startNextRequest"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|temp
operator|.
name|protocol
argument_list|()
operator|==
name|QAbstractSocket
operator|::
name|IPv6Protocol
condition|)
block|{
name|networkLayerState
operator|=
name|QHttpNetworkConnectionPrivate
operator|::
name|IPv6
expr_stmt|;
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|this
operator|->
name|q_func
argument_list|()
argument_list|,
literal|"_q_startNextRequest"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|int
name|hostLookupId
decl_stmt|;
name|bool
name|immediateResultValid
init|=
literal|false
decl_stmt|;
name|QHostInfo
name|hostInfo
init|=
name|qt_qhostinfo_lookup
argument_list|(
name|lookupHost
argument_list|,
name|this
operator|->
name|q_func
argument_list|()
argument_list|,
name|SLOT
argument_list|(
name|_q_hostLookupFinished
argument_list|(
name|QHostInfo
argument_list|)
argument_list|)
argument_list|,
operator|&
name|immediateResultValid
argument_list|,
operator|&
name|hostLookupId
argument_list|)
decl_stmt|;
if|if
condition|(
name|immediateResultValid
condition|)
block|{
name|_q_hostLookupFinished
argument_list|(
name|hostInfo
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|_q_hostLookupFinished
name|void
name|QHttpNetworkConnectionPrivate
operator|::
name|_q_hostLookupFinished
parameter_list|(
name|QHostInfo
name|info
parameter_list|)
block|{
name|bool
name|bIpv4
init|=
literal|false
decl_stmt|;
name|bool
name|bIpv6
init|=
literal|false
decl_stmt|;
name|bool
name|foundAddress
init|=
literal|false
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|QHostAddress
modifier|&
name|address
decl|,
name|info
operator|.
name|addresses
argument_list|()
control|)
block|{
if|if
condition|(
name|address
operator|.
name|protocol
argument_list|()
operator|==
name|QAbstractSocket
operator|::
name|IPv4Protocol
condition|)
block|{
if|if
condition|(
operator|!
name|foundAddress
condition|)
block|{
name|foundAddress
operator|=
literal|true
expr_stmt|;
name|delayIpv4
operator|=
literal|false
expr_stmt|;
block|}
name|bIpv4
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|address
operator|.
name|protocol
argument_list|()
operator|==
name|QAbstractSocket
operator|::
name|IPv6Protocol
condition|)
block|{
if|if
condition|(
operator|!
name|foundAddress
condition|)
block|{
name|foundAddress
operator|=
literal|true
expr_stmt|;
name|delayIpv4
operator|=
literal|true
expr_stmt|;
block|}
name|bIpv6
operator|=
literal|true
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bIpv4
operator|&&
name|bIpv6
condition|)
name|startNetworkLayerStateLookup
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|bIpv4
condition|)
block|{
name|networkLayerState
operator|=
name|QHttpNetworkConnectionPrivate
operator|::
name|IPv4
expr_stmt|;
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|this
operator|->
name|q_func
argument_list|()
argument_list|,
literal|"_q_startNextRequest"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bIpv6
condition|)
block|{
name|networkLayerState
operator|=
name|QHttpNetworkConnectionPrivate
operator|::
name|IPv6
expr_stmt|;
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|this
operator|->
name|q_func
argument_list|()
argument_list|,
literal|"_q_startNextRequest"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dequeueRequest
argument_list|(
name|channels
index|[
literal|0
index|]
operator|.
name|socket
argument_list|)
condition|)
block|{
name|emitReplyError
argument_list|(
name|channels
index|[
literal|0
index|]
operator|.
name|socket
argument_list|,
name|channels
index|[
literal|0
index|]
operator|.
name|reply
argument_list|,
name|QNetworkReply
operator|::
name|HostNotFoundError
argument_list|)
expr_stmt|;
name|networkLayerState
operator|=
name|QHttpNetworkConnectionPrivate
operator|::
name|Unknown
expr_stmt|;
block|}
else|else
block|{
comment|// Should not happen
name|qWarning
argument_list|()
operator|<<
literal|"QHttpNetworkConnectionPrivate::_q_hostLookupFinished could not dequeu request"
expr_stmt|;
name|networkLayerState
operator|=
name|QHttpNetworkConnectionPrivate
operator|::
name|Unknown
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|// This will be used if the host lookup found both and Ipv4 and
end_comment
begin_comment
comment|// Ipv6 address. Then we will start up two connections and pick
end_comment
begin_comment
comment|// the network layer of the one that finish first. The second
end_comment
begin_comment
comment|// connection will then be disconnected.
end_comment
begin_function
DECL|function|startNetworkLayerStateLookup
name|void
name|QHttpNetworkConnectionPrivate
operator|::
name|startNetworkLayerStateLookup
parameter_list|()
block|{
if|if
condition|(
name|channelCount
operator|>
literal|1
condition|)
block|{
comment|// At this time all channels should be unconnected.
name|Q_ASSERT
argument_list|(
operator|!
name|channels
index|[
literal|0
index|]
operator|.
name|isSocketBusy
argument_list|()
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
operator|!
name|channels
index|[
literal|1
index|]
operator|.
name|isSocketBusy
argument_list|()
argument_list|)
expr_stmt|;
name|networkLayerState
operator|=
name|InProgress
expr_stmt|;
name|channels
index|[
literal|0
index|]
operator|.
name|networkLayerPreference
operator|=
name|QAbstractSocket
operator|::
name|IPv4Protocol
expr_stmt|;
name|channels
index|[
literal|1
index|]
operator|.
name|networkLayerPreference
operator|=
name|QAbstractSocket
operator|::
name|IPv6Protocol
expr_stmt|;
name|int
name|timeout
init|=
literal|300
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_BEARERMANAGEMENT
if|if
condition|(
name|networkSession
condition|)
block|{
if|if
condition|(
name|networkSession
operator|->
name|configuration
argument_list|()
operator|.
name|bearerType
argument_list|()
operator|==
name|QNetworkConfiguration
operator|::
name|Bearer2G
condition|)
name|timeout
operator|=
literal|800
expr_stmt|;
elseif|else
if|if
condition|(
name|networkSession
operator|->
name|configuration
argument_list|()
operator|.
name|bearerType
argument_list|()
operator|==
name|QNetworkConfiguration
operator|::
name|BearerCDMA2000
condition|)
name|timeout
operator|=
literal|500
expr_stmt|;
elseif|else
if|if
condition|(
name|networkSession
operator|->
name|configuration
argument_list|()
operator|.
name|bearerType
argument_list|()
operator|==
name|QNetworkConfiguration
operator|::
name|BearerWCDMA
condition|)
name|timeout
operator|=
literal|500
expr_stmt|;
elseif|else
if|if
condition|(
name|networkSession
operator|->
name|configuration
argument_list|()
operator|.
name|bearerType
argument_list|()
operator|==
name|QNetworkConfiguration
operator|::
name|BearerHSPA
condition|)
name|timeout
operator|=
literal|400
expr_stmt|;
block|}
endif|#
directive|endif
name|delayedConnectionTimer
operator|.
name|start
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|delayIpv4
condition|)
name|channels
index|[
literal|1
index|]
operator|.
name|ensureConnection
argument_list|()
expr_stmt|;
else|else
name|channels
index|[
literal|0
index|]
operator|.
name|ensureConnection
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|networkLayerState
operator|=
name|InProgress
expr_stmt|;
name|channels
index|[
literal|0
index|]
operator|.
name|networkLayerPreference
operator|=
name|QAbstractSocket
operator|::
name|AnyIPProtocol
expr_stmt|;
name|channels
index|[
literal|0
index|]
operator|.
name|ensureConnection
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|networkLayerDetected
name|void
name|QHttpNetworkConnectionPrivate
operator|::
name|networkLayerDetected
parameter_list|(
name|QAbstractSocket
operator|::
name|NetworkLayerProtocol
name|protocol
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|channelCount
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|(
name|channels
index|[
name|i
index|]
operator|.
name|networkLayerPreference
operator|!=
name|protocol
operator|)
operator|&&
operator|(
name|channels
index|[
name|i
index|]
operator|.
name|state
operator|==
name|QHttpNetworkConnectionChannel
operator|::
name|ConnectingState
operator|)
condition|)
block|{
name|channels
index|[
name|i
index|]
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|_q_connectDelayedChannel
name|void
name|QHttpNetworkConnectionPrivate
operator|::
name|_q_connectDelayedChannel
parameter_list|()
block|{
if|if
condition|(
name|delayIpv4
condition|)
name|channels
index|[
literal|0
index|]
operator|.
name|ensureConnection
argument_list|()
expr_stmt|;
else|else
name|channels
index|[
literal|1
index|]
operator|.
name|ensureConnection
argument_list|()
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_BEARERMANAGEMENT
end_ifndef
begin_constructor
DECL|function|QHttpNetworkConnection
name|QHttpNetworkConnection
operator|::
name|QHttpNetworkConnection
parameter_list|(
specifier|const
name|QString
modifier|&
name|hostName
parameter_list|,
name|quint16
name|port
parameter_list|,
name|bool
name|encrypt
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|,
name|QSharedPointer
argument_list|<
name|QNetworkSession
argument_list|>
name|networkSession
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|(
operator|new
name|QHttpNetworkConnectionPrivate
argument_list|(
name|hostName
argument_list|,
name|port
argument_list|,
name|encrypt
argument_list|)
operator|)
argument_list|,
name|parent
argument_list|)
block|{
name|Q_D
argument_list|(
name|QHttpNetworkConnection
argument_list|)
expr_stmt|;
name|d
operator|->
name|networkSession
operator|=
name|networkSession
expr_stmt|;
name|d
operator|->
name|init
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QHttpNetworkConnection
name|QHttpNetworkConnection
operator|::
name|QHttpNetworkConnection
parameter_list|(
name|quint16
name|connectionCount
parameter_list|,
specifier|const
name|QString
modifier|&
name|hostName
parameter_list|,
name|quint16
name|port
parameter_list|,
name|bool
name|encrypt
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|,
name|QSharedPointer
argument_list|<
name|QNetworkSession
argument_list|>
name|networkSession
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|(
operator|new
name|QHttpNetworkConnectionPrivate
argument_list|(
name|connectionCount
argument_list|,
name|hostName
argument_list|,
name|port
argument_list|,
name|encrypt
argument_list|)
operator|)
argument_list|,
name|parent
argument_list|)
block|{
name|Q_D
argument_list|(
name|QHttpNetworkConnection
argument_list|)
expr_stmt|;
name|d
operator|->
name|networkSession
operator|=
name|networkSession
expr_stmt|;
name|d
operator|->
name|init
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_else
else|#
directive|else
end_else
begin_constructor
DECL|function|QHttpNetworkConnection
name|QHttpNetworkConnection
operator|::
name|QHttpNetworkConnection
parameter_list|(
specifier|const
name|QString
modifier|&
name|hostName
parameter_list|,
name|quint16
name|port
parameter_list|,
name|bool
name|encrypt
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|(
operator|new
name|QHttpNetworkConnectionPrivate
argument_list|(
name|hostName
argument_list|,
name|port
argument_list|,
name|encrypt
argument_list|)
operator|)
argument_list|,
name|parent
argument_list|)
block|{
name|Q_D
argument_list|(
name|QHttpNetworkConnection
argument_list|)
expr_stmt|;
name|d
operator|->
name|init
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QHttpNetworkConnection
name|QHttpNetworkConnection
operator|::
name|QHttpNetworkConnection
parameter_list|(
name|quint16
name|connectionCount
parameter_list|,
specifier|const
name|QString
modifier|&
name|hostName
parameter_list|,
name|quint16
name|port
parameter_list|,
name|bool
name|encrypt
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|(
operator|new
name|QHttpNetworkConnectionPrivate
argument_list|(
name|connectionCount
argument_list|,
name|hostName
argument_list|,
name|port
argument_list|,
name|encrypt
argument_list|)
operator|)
argument_list|,
name|parent
argument_list|)
block|{
name|Q_D
argument_list|(
name|QHttpNetworkConnection
argument_list|)
expr_stmt|;
name|d
operator|->
name|init
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_endif
endif|#
directive|endif
end_endif
begin_destructor
DECL|function|~QHttpNetworkConnection
name|QHttpNetworkConnection
operator|::
name|~
name|QHttpNetworkConnection
parameter_list|()
block|{ }
end_destructor
begin_function
DECL|function|hostName
name|QString
name|QHttpNetworkConnection
operator|::
name|hostName
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QHttpNetworkConnection
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|hostName
return|;
block|}
end_function
begin_function
DECL|function|port
name|quint16
name|QHttpNetworkConnection
operator|::
name|port
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QHttpNetworkConnection
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|port
return|;
block|}
end_function
begin_function
DECL|function|sendRequest
name|QHttpNetworkReply
modifier|*
name|QHttpNetworkConnection
operator|::
name|sendRequest
parameter_list|(
specifier|const
name|QHttpNetworkRequest
modifier|&
name|request
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QHttpNetworkConnection
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|queueRequest
argument_list|(
name|request
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|isSsl
name|bool
name|QHttpNetworkConnection
operator|::
name|isSsl
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QHttpNetworkConnection
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|encrypt
return|;
block|}
end_function
begin_function
DECL|function|channels
name|QHttpNetworkConnectionChannel
modifier|*
name|QHttpNetworkConnection
operator|::
name|channels
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|channels
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
end_ifndef
begin_function
DECL|function|setCacheProxy
name|void
name|QHttpNetworkConnection
operator|::
name|setCacheProxy
parameter_list|(
specifier|const
name|QNetworkProxy
modifier|&
name|networkProxy
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QHttpNetworkConnection
argument_list|)
expr_stmt|;
name|d
operator|->
name|networkProxy
operator|=
name|networkProxy
expr_stmt|;
comment|// update the authenticator
if|if
condition|(
operator|!
name|d
operator|->
name|networkProxy
operator|.
name|user
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|channelCount
condition|;
operator|++
name|i
control|)
block|{
name|d
operator|->
name|channels
index|[
name|i
index|]
operator|.
name|proxyAuthenticator
operator|.
name|setUser
argument_list|(
name|d
operator|->
name|networkProxy
operator|.
name|user
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|channels
index|[
name|i
index|]
operator|.
name|proxyAuthenticator
operator|.
name|setPassword
argument_list|(
name|d
operator|->
name|networkProxy
operator|.
name|password
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|cacheProxy
name|QNetworkProxy
name|QHttpNetworkConnection
operator|::
name|cacheProxy
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QHttpNetworkConnection
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|networkProxy
return|;
block|}
end_function
begin_function
DECL|function|setTransparentProxy
name|void
name|QHttpNetworkConnection
operator|::
name|setTransparentProxy
parameter_list|(
specifier|const
name|QNetworkProxy
modifier|&
name|networkProxy
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QHttpNetworkConnection
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|channelCount
condition|;
operator|++
name|i
control|)
name|d
operator|->
name|channels
index|[
name|i
index|]
operator|.
name|setProxy
argument_list|(
name|networkProxy
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|transparentProxy
name|QNetworkProxy
name|QHttpNetworkConnection
operator|::
name|transparentProxy
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QHttpNetworkConnection
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|channels
index|[
literal|0
index|]
operator|.
name|proxy
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// SSL support below
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_SSL
end_ifndef
begin_function
DECL|function|setSslConfiguration
name|void
name|QHttpNetworkConnection
operator|::
name|setSslConfiguration
parameter_list|(
specifier|const
name|QSslConfiguration
modifier|&
name|config
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QHttpNetworkConnection
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|encrypt
condition|)
return|return;
comment|// set the config on all channels
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|channelCount
condition|;
operator|++
name|i
control|)
name|d
operator|->
name|channels
index|[
name|i
index|]
operator|.
name|setSslConfiguration
argument_list|(
name|config
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|sslContext
name|QSharedPointer
argument_list|<
name|QSslContext
argument_list|>
name|QHttpNetworkConnection
operator|::
name|sslContext
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QHttpNetworkConnection
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|sslContext
return|;
block|}
end_function
begin_function
DECL|function|setSslContext
name|void
name|QHttpNetworkConnection
operator|::
name|setSslContext
parameter_list|(
name|QSharedPointer
argument_list|<
name|QSslContext
argument_list|>
name|context
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QHttpNetworkConnection
argument_list|)
expr_stmt|;
name|d
operator|->
name|sslContext
operator|=
name|context
expr_stmt|;
block|}
end_function
begin_function
DECL|function|ignoreSslErrors
name|void
name|QHttpNetworkConnection
operator|::
name|ignoreSslErrors
parameter_list|(
name|int
name|channel
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QHttpNetworkConnection
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|encrypt
condition|)
return|return;
if|if
condition|(
name|channel
operator|==
operator|-
literal|1
condition|)
block|{
comment|// ignore for all channels
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|channelCount
condition|;
operator|++
name|i
control|)
block|{
name|d
operator|->
name|channels
index|[
name|i
index|]
operator|.
name|ignoreSslErrors
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|d
operator|->
name|channels
index|[
name|channel
index|]
operator|.
name|ignoreSslErrors
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|ignoreSslErrors
name|void
name|QHttpNetworkConnection
operator|::
name|ignoreSslErrors
parameter_list|(
specifier|const
name|QList
argument_list|<
name|QSslError
argument_list|>
modifier|&
name|errors
parameter_list|,
name|int
name|channel
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QHttpNetworkConnection
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|encrypt
condition|)
return|return;
if|if
condition|(
name|channel
operator|==
operator|-
literal|1
condition|)
block|{
comment|// ignore for all channels
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|channelCount
condition|;
operator|++
name|i
control|)
block|{
name|d
operator|->
name|channels
index|[
name|i
index|]
operator|.
name|ignoreSslErrors
argument_list|(
name|errors
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|d
operator|->
name|channels
index|[
name|channel
index|]
operator|.
name|ignoreSslErrors
argument_list|(
name|errors
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//QT_NO_SSL
end_comment
begin_function
DECL|function|preConnectFinished
name|void
name|QHttpNetworkConnection
operator|::
name|preConnectFinished
parameter_list|()
block|{
name|d_func
argument_list|()
operator|->
name|preConnectRequests
operator|--
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
end_ifndef
begin_comment
comment|// only called from QHttpNetworkConnectionChannel::_q_proxyAuthenticationRequired, not
end_comment
begin_comment
comment|// from QHttpNetworkConnectionChannel::handleAuthenticationChallenge
end_comment
begin_comment
comment|// e.g. it is for SOCKS proxies which require authentication.
end_comment
begin_function
DECL|function|emitProxyAuthenticationRequired
name|void
name|QHttpNetworkConnectionPrivate
operator|::
name|emitProxyAuthenticationRequired
parameter_list|(
specifier|const
name|QHttpNetworkConnectionChannel
modifier|*
name|chan
parameter_list|,
specifier|const
name|QNetworkProxy
modifier|&
name|proxy
parameter_list|,
name|QAuthenticator
modifier|*
name|auth
parameter_list|)
block|{
comment|// Also pause the connection because socket notifiers may fire while an user
comment|// dialog is displaying
name|pauseConnection
argument_list|()
expr_stmt|;
emit|emit
name|chan
operator|->
name|reply
operator|->
name|proxyAuthenticationRequired
argument_list|(
name|proxy
argument_list|,
name|auth
argument_list|)
emit|;
name|resumeConnection
argument_list|()
expr_stmt|;
name|int
name|i
init|=
name|indexOf
argument_list|(
name|chan
operator|->
name|socket
argument_list|)
decl_stmt|;
name|copyCredentials
argument_list|(
name|i
argument_list|,
name|auth
argument_list|,
literal|true
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_include
include|#
directive|include
file|"moc_qhttpnetworkconnection_p.cpp"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_HTTP
end_comment
end_unit
