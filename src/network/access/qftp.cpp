begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtNetwork module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_comment
comment|//#define QFTPPI_DEBUG
end_comment
begin_comment
comment|//#define QFTPDTP_DEBUG
end_comment
begin_include
include|#
directive|include
file|"private/qftp_p.h"
end_include
begin_include
include|#
directive|include
file|"qabstractsocket.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_FTP
end_ifndef
begin_include
include|#
directive|include
file|"qcoreapplication.h"
end_include
begin_include
include|#
directive|include
file|"qtcpsocket.h"
end_include
begin_include
include|#
directive|include
file|"qurlinfo_p.h"
end_include
begin_include
include|#
directive|include
file|"qstringlist.h"
end_include
begin_include
include|#
directive|include
file|"qregexp.h"
end_include
begin_include
include|#
directive|include
file|"qtimer.h"
end_include
begin_include
include|#
directive|include
file|"qfileinfo.h"
end_include
begin_include
include|#
directive|include
file|"qhash.h"
end_include
begin_include
include|#
directive|include
file|"qtcpserver.h"
end_include
begin_include
include|#
directive|include
file|"qlocale.h"
end_include
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_class_decl
class_decl|class
name|QFtpPI
class_decl|;
end_class_decl
begin_comment
comment|/*     The QFtpDTP (DTP = Data Transfer Process) controls all client side     data transfer between the client and server. */
end_comment
begin_class
DECL|class|QFtpDTP
class|class
name|QFtpDTP
super|:
specifier|public
name|QObject
block|{
name|Q_OBJECT
public|public:
DECL|enum|ConnectState
enum|enum
name|ConnectState
block|{
DECL|enumerator|CsHostFound
name|CsHostFound
block|,
DECL|enumerator|CsConnected
name|CsConnected
block|,
DECL|enumerator|CsClosed
name|CsClosed
block|,
DECL|enumerator|CsHostNotFound
name|CsHostNotFound
block|,
DECL|enumerator|CsConnectionRefused
name|CsConnectionRefused
block|}
enum|;
name|QFtpDTP
parameter_list|(
name|QFtpPI
modifier|*
name|p
parameter_list|,
name|QObject
modifier|*
name|parent
init|=
literal|0
parameter_list|)
constructor_decl|;
name|void
name|setData
parameter_list|(
name|QByteArray
modifier|*
parameter_list|)
function_decl|;
name|void
name|setDevice
parameter_list|(
name|QIODevice
modifier|*
parameter_list|)
function_decl|;
name|void
name|writeData
parameter_list|()
function_decl|;
name|void
name|setBytesTotal
parameter_list|(
name|qint64
name|bytes
parameter_list|)
function_decl|;
name|bool
name|hasError
parameter_list|()
specifier|const
function_decl|;
name|QString
name|errorMessage
parameter_list|()
specifier|const
function_decl|;
name|void
name|clearError
parameter_list|()
function_decl|;
name|void
name|connectToHost
parameter_list|(
specifier|const
name|QString
modifier|&
name|host
parameter_list|,
name|quint16
name|port
parameter_list|)
function_decl|;
name|int
name|setupListener
parameter_list|(
specifier|const
name|QHostAddress
modifier|&
name|address
parameter_list|)
function_decl|;
name|void
name|waitForConnection
parameter_list|()
function_decl|;
name|QTcpSocket
operator|::
name|SocketState
name|state
parameter_list|()
specifier|const
function_decl|;
name|qint64
name|bytesAvailable
parameter_list|()
specifier|const
function_decl|;
name|qint64
name|read
parameter_list|(
name|char
modifier|*
name|data
parameter_list|,
name|qint64
name|maxlen
parameter_list|)
function_decl|;
name|QByteArray
name|readAll
parameter_list|()
function_decl|;
name|void
name|abortConnection
parameter_list|()
function_decl|;
specifier|static
name|bool
name|parseDir
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|buffer
parameter_list|,
specifier|const
name|QString
modifier|&
name|userName
parameter_list|,
name|QUrlInfo
modifier|*
name|info
parameter_list|)
function_decl|;
signals|signals:
name|void
name|listInfo
parameter_list|(
specifier|const
name|QUrlInfo
modifier|&
parameter_list|)
function_decl|;
name|void
name|readyRead
parameter_list|()
function_decl|;
name|void
name|dataTransferProgress
parameter_list|(
name|qint64
parameter_list|,
name|qint64
parameter_list|)
function_decl|;
name|void
name|connectState
parameter_list|(
name|int
parameter_list|)
function_decl|;
private|private
name|slots
private|:
name|void
name|socketConnected
parameter_list|()
function_decl|;
name|void
name|socketReadyRead
parameter_list|()
function_decl|;
name|void
name|socketError
parameter_list|(
name|QAbstractSocket
operator|::
name|SocketError
parameter_list|)
function_decl|;
name|void
name|socketConnectionClosed
parameter_list|()
function_decl|;
name|void
name|socketBytesWritten
parameter_list|(
name|qint64
parameter_list|)
function_decl|;
name|void
name|setupSocket
parameter_list|()
function_decl|;
name|void
name|dataReadyRead
parameter_list|()
function_decl|;
private|private:
name|void
name|clearData
parameter_list|()
function_decl|;
DECL|member|socket
name|QTcpSocket
modifier|*
name|socket
decl_stmt|;
DECL|member|listener
name|QTcpServer
name|listener
decl_stmt|;
DECL|member|pi
name|QFtpPI
modifier|*
name|pi
decl_stmt|;
DECL|member|err
name|QString
name|err
decl_stmt|;
DECL|member|bytesDone
name|qint64
name|bytesDone
decl_stmt|;
DECL|member|bytesTotal
name|qint64
name|bytesTotal
decl_stmt|;
DECL|member|callWriteData
name|bool
name|callWriteData
decl_stmt|;
comment|// If is_ba is true, ba is used; ba is never 0.
comment|// Otherwise dev is used; dev can be 0 or not.
union|union
block|{
DECL|member|ba
name|QByteArray
modifier|*
name|ba
decl_stmt|;
DECL|member|dev
name|QIODevice
modifier|*
name|dev
decl_stmt|;
DECL|member|data
block|}
name|data
union|;
DECL|member|is_ba
name|bool
name|is_ba
decl_stmt|;
DECL|member|bytesFromSocket
name|QByteArray
name|bytesFromSocket
decl_stmt|;
block|}
class|;
end_class
begin_comment
comment|/**********************************************************************  *  * QFtpPI - Protocol Interpreter  *  *********************************************************************/
end_comment
begin_class
DECL|class|QFtpPI
class|class
name|QFtpPI
super|:
specifier|public
name|QObject
block|{
name|Q_OBJECT
public|public:
name|QFtpPI
parameter_list|(
name|QObject
modifier|*
name|parent
init|=
literal|0
parameter_list|)
constructor_decl|;
name|void
name|connectToHost
parameter_list|(
specifier|const
name|QString
modifier|&
name|host
parameter_list|,
name|quint16
name|port
parameter_list|)
function_decl|;
name|bool
name|sendCommands
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|cmds
parameter_list|)
function_decl|;
DECL|function|sendCommand
name|bool
name|sendCommand
parameter_list|(
specifier|const
name|QString
modifier|&
name|cmd
parameter_list|)
block|{
return|return
name|sendCommands
argument_list|(
name|QStringList
argument_list|(
name|cmd
argument_list|)
argument_list|)
return|;
block|}
name|void
name|clearPendingCommands
parameter_list|()
function_decl|;
name|void
name|abort
parameter_list|()
function_decl|;
DECL|function|currentCommand
name|QString
name|currentCommand
parameter_list|()
specifier|const
block|{
return|return
name|currentCmd
return|;
block|}
DECL|member|rawCommand
name|bool
name|rawCommand
decl_stmt|;
DECL|member|transferConnectionExtended
name|bool
name|transferConnectionExtended
decl_stmt|;
DECL|member|dtp
name|QFtpDTP
name|dtp
decl_stmt|;
comment|// the PI has a DTP which is not the design of RFC 959, but it
comment|// makes the design simpler this way
signals|signals:
name|void
name|connectState
parameter_list|(
name|int
parameter_list|)
function_decl|;
name|void
name|finished
parameter_list|(
specifier|const
name|QString
modifier|&
parameter_list|)
function_decl|;
name|void
name|error
parameter_list|(
name|int
parameter_list|,
specifier|const
name|QString
modifier|&
parameter_list|)
function_decl|;
name|void
name|rawFtpReply
parameter_list|(
name|int
parameter_list|,
specifier|const
name|QString
modifier|&
parameter_list|)
function_decl|;
private|private
name|slots
private|:
name|void
name|hostFound
parameter_list|()
function_decl|;
name|void
name|connected
parameter_list|()
function_decl|;
name|void
name|connectionClosed
parameter_list|()
function_decl|;
name|void
name|delayedCloseFinished
parameter_list|()
function_decl|;
name|void
name|readyRead
parameter_list|()
function_decl|;
name|void
name|error
parameter_list|(
name|QAbstractSocket
operator|::
name|SocketError
parameter_list|)
function_decl|;
name|void
name|dtpConnectState
parameter_list|(
name|int
parameter_list|)
function_decl|;
private|private:
comment|// the states are modelled after the generalized state diagram of RFC 959,
comment|// page 58
DECL|enum|State
enum|enum
name|State
block|{
DECL|enumerator|Begin
name|Begin
block|,
DECL|enumerator|Idle
name|Idle
block|,
DECL|enumerator|Waiting
name|Waiting
block|,
DECL|enumerator|Success
name|Success
block|,
DECL|enumerator|Failure
name|Failure
block|}
enum|;
DECL|enum|AbortState
enum|enum
name|AbortState
block|{
DECL|enumerator|None
name|None
block|,
DECL|enumerator|AbortStarted
name|AbortStarted
block|,
DECL|enumerator|WaitForAbortToFinish
name|WaitForAbortToFinish
block|}
enum|;
name|bool
name|processReply
parameter_list|()
function_decl|;
name|bool
name|startNextCmd
parameter_list|()
function_decl|;
DECL|member|commandSocket
name|QTcpSocket
name|commandSocket
decl_stmt|;
DECL|member|replyText
name|QString
name|replyText
decl_stmt|;
DECL|member|replyCode
name|char
name|replyCode
index|[
literal|3
index|]
decl_stmt|;
DECL|member|state
name|State
name|state
decl_stmt|;
DECL|member|abortState
name|AbortState
name|abortState
decl_stmt|;
DECL|member|pendingCommands
name|QStringList
name|pendingCommands
decl_stmt|;
DECL|member|currentCmd
name|QString
name|currentCmd
decl_stmt|;
DECL|member|waitForDtpToConnect
name|bool
name|waitForDtpToConnect
decl_stmt|;
DECL|member|waitForDtpToClose
name|bool
name|waitForDtpToClose
decl_stmt|;
DECL|member|bytesFromSocket
name|QByteArray
name|bytesFromSocket
decl_stmt|;
friend|friend
class_decl|class
name|QFtpDTP
class_decl|;
block|}
class|;
end_class
begin_comment
comment|/**********************************************************************  *  * QFtpCommand implemenatation  *  *********************************************************************/
end_comment
begin_class
DECL|class|QFtpCommand
class|class
name|QFtpCommand
block|{
public|public:
name|QFtpCommand
parameter_list|(
name|QFtp
operator|::
name|Command
name|cmd
parameter_list|,
name|QStringList
name|raw
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|ba
parameter_list|)
constructor_decl|;
name|QFtpCommand
parameter_list|(
name|QFtp
operator|::
name|Command
name|cmd
parameter_list|,
name|QStringList
name|raw
parameter_list|,
name|QIODevice
modifier|*
name|dev
init|=
literal|0
parameter_list|)
constructor_decl|;
name|~
name|QFtpCommand
parameter_list|()
destructor_decl|;
DECL|member|id
name|int
name|id
decl_stmt|;
DECL|member|command
name|QFtp
operator|::
name|Command
name|command
decl_stmt|;
DECL|member|rawCmds
name|QStringList
name|rawCmds
decl_stmt|;
comment|// If is_ba is true, ba is used; ba is never 0.
comment|// Otherwise dev is used; dev can be 0 or not.
union|union
block|{
DECL|member|ba
name|QByteArray
modifier|*
name|ba
decl_stmt|;
DECL|member|dev
name|QIODevice
modifier|*
name|dev
decl_stmt|;
DECL|member|data
block|}
name|data
union|;
DECL|member|is_ba
name|bool
name|is_ba
decl_stmt|;
DECL|member|idCounter
specifier|static
name|QBasicAtomicInt
name|idCounter
decl_stmt|;
block|}
class|;
end_class
begin_decl_stmt
DECL|member|idCounter
name|QBasicAtomicInt
name|QFtpCommand
operator|::
name|idCounter
init|=
name|Q_BASIC_ATOMIC_INITIALIZER
argument_list|(
literal|1
argument_list|)
decl_stmt|;
end_decl_stmt
begin_constructor
DECL|function|QFtpCommand
name|QFtpCommand
operator|::
name|QFtpCommand
parameter_list|(
name|QFtp
operator|::
name|Command
name|cmd
parameter_list|,
name|QStringList
name|raw
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|ba
parameter_list|)
member_init_list|:
name|command
argument_list|(
name|cmd
argument_list|)
member_init_list|,
name|rawCmds
argument_list|(
name|raw
argument_list|)
member_init_list|,
name|is_ba
argument_list|(
literal|true
argument_list|)
block|{
name|id
operator|=
name|idCounter
operator|.
name|fetchAndAddRelaxed
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|data
operator|.
name|ba
operator|=
operator|new
name|QByteArray
argument_list|(
name|ba
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_constructor
DECL|function|QFtpCommand
name|QFtpCommand
operator|::
name|QFtpCommand
parameter_list|(
name|QFtp
operator|::
name|Command
name|cmd
parameter_list|,
name|QStringList
name|raw
parameter_list|,
name|QIODevice
modifier|*
name|dev
parameter_list|)
member_init_list|:
name|command
argument_list|(
name|cmd
argument_list|)
member_init_list|,
name|rawCmds
argument_list|(
name|raw
argument_list|)
member_init_list|,
name|is_ba
argument_list|(
literal|false
argument_list|)
block|{
name|id
operator|=
name|idCounter
operator|.
name|fetchAndAddRelaxed
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|data
operator|.
name|dev
operator|=
name|dev
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QFtpCommand
name|QFtpCommand
operator|::
name|~
name|QFtpCommand
parameter_list|()
block|{
if|if
condition|(
name|is_ba
condition|)
operator|delete
name|data
operator|.
name|ba
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/**********************************************************************  *  * QFtpDTP implemenatation  *  *********************************************************************/
end_comment
begin_constructor
DECL|function|QFtpDTP
name|QFtpDTP
operator|::
name|QFtpDTP
parameter_list|(
name|QFtpPI
modifier|*
name|p
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
name|parent
argument_list|)
member_init_list|,
name|socket
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|listener
argument_list|(
name|this
argument_list|)
member_init_list|,
name|pi
argument_list|(
name|p
argument_list|)
member_init_list|,
name|callWriteData
argument_list|(
literal|false
argument_list|)
block|{
name|clearData
argument_list|()
expr_stmt|;
name|listener
operator|.
name|setObjectName
argument_list|(
name|QLatin1String
argument_list|(
literal|"QFtpDTP active state server"
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
operator|&
name|listener
argument_list|,
name|SIGNAL
argument_list|(
name|newConnection
argument_list|()
argument_list|)
argument_list|,
name|SLOT
argument_list|(
name|setupSocket
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_function
DECL|function|setData
name|void
name|QFtpDTP
operator|::
name|setData
parameter_list|(
name|QByteArray
modifier|*
name|ba
parameter_list|)
block|{
name|is_ba
operator|=
literal|true
expr_stmt|;
name|data
operator|.
name|ba
operator|=
name|ba
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setDevice
name|void
name|QFtpDTP
operator|::
name|setDevice
parameter_list|(
name|QIODevice
modifier|*
name|dev
parameter_list|)
block|{
name|is_ba
operator|=
literal|false
expr_stmt|;
name|data
operator|.
name|dev
operator|=
name|dev
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setBytesTotal
name|void
name|QFtpDTP
operator|::
name|setBytesTotal
parameter_list|(
name|qint64
name|bytes
parameter_list|)
block|{
name|bytesTotal
operator|=
name|bytes
expr_stmt|;
name|bytesDone
operator|=
literal|0
expr_stmt|;
emit|emit
name|dataTransferProgress
argument_list|(
name|bytesDone
argument_list|,
name|bytesTotal
argument_list|)
emit|;
block|}
end_function
begin_function
DECL|function|connectToHost
name|void
name|QFtpDTP
operator|::
name|connectToHost
parameter_list|(
specifier|const
name|QString
modifier|&
name|host
parameter_list|,
name|quint16
name|port
parameter_list|)
block|{
name|bytesFromSocket
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|socket
condition|)
block|{
operator|delete
name|socket
expr_stmt|;
name|socket
operator|=
literal|0
expr_stmt|;
block|}
name|socket
operator|=
operator|new
name|QTcpSocket
argument_list|(
name|this
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_BEARERMANAGEMENT
comment|//copy network session down to the socket
name|socket
operator|->
name|setProperty
argument_list|(
literal|"_q_networksession"
argument_list|,
name|property
argument_list|(
literal|"_q_networksession"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|socket
operator|->
name|setObjectName
argument_list|(
name|QLatin1String
argument_list|(
literal|"QFtpDTP Passive state socket"
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|socket
argument_list|,
name|SIGNAL
argument_list|(
name|connected
argument_list|()
argument_list|)
argument_list|,
name|SLOT
argument_list|(
name|socketConnected
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|socket
argument_list|,
name|SIGNAL
argument_list|(
name|readyRead
argument_list|()
argument_list|)
argument_list|,
name|SLOT
argument_list|(
name|socketReadyRead
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|socket
argument_list|,
name|SIGNAL
argument_list|(
name|error
argument_list|(
name|QAbstractSocket
operator|::
name|SocketError
argument_list|)
argument_list|)
argument_list|,
name|SLOT
argument_list|(
name|socketError
argument_list|(
name|QAbstractSocket
operator|::
name|SocketError
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|socket
argument_list|,
name|SIGNAL
argument_list|(
name|disconnected
argument_list|()
argument_list|)
argument_list|,
name|SLOT
argument_list|(
name|socketConnectionClosed
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|socket
argument_list|,
name|SIGNAL
argument_list|(
name|bytesWritten
argument_list|(
name|qint64
argument_list|)
argument_list|)
argument_list|,
name|SLOT
argument_list|(
name|socketBytesWritten
argument_list|(
name|qint64
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|socket
operator|->
name|connectToHost
argument_list|(
name|host
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setupListener
name|int
name|QFtpDTP
operator|::
name|setupListener
parameter_list|(
specifier|const
name|QHostAddress
modifier|&
name|address
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_BEARERMANAGEMENT
comment|//copy network session down to the socket
name|listener
operator|.
name|setProperty
argument_list|(
literal|"_q_networksession"
argument_list|,
name|property
argument_list|(
literal|"_q_networksession"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|listener
operator|.
name|isListening
argument_list|()
operator|&&
operator|!
name|listener
operator|.
name|listen
argument_list|(
name|address
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|listener
operator|.
name|serverPort
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|waitForConnection
name|void
name|QFtpDTP
operator|::
name|waitForConnection
parameter_list|()
block|{
comment|// This function is only interesting in Active transfer mode; it works
comment|// around a limitation in QFtp's design by blocking, waiting for an
comment|// incoming connection. For the default Passive mode, it does nothing.
if|if
condition|(
name|listener
operator|.
name|isListening
argument_list|()
condition|)
name|listener
operator|.
name|waitForNewConnection
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|state
name|QTcpSocket
operator|::
name|SocketState
name|QFtpDTP
operator|::
name|state
parameter_list|()
specifier|const
block|{
return|return
name|socket
condition|?
name|socket
operator|->
name|state
argument_list|()
else|:
name|QTcpSocket
operator|::
name|UnconnectedState
return|;
block|}
end_function
begin_function
DECL|function|bytesAvailable
name|qint64
name|QFtpDTP
operator|::
name|bytesAvailable
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|socket
operator|||
name|socket
operator|->
name|state
argument_list|()
operator|!=
name|QTcpSocket
operator|::
name|ConnectedState
condition|)
return|return
operator|(
name|qint64
operator|)
name|bytesFromSocket
operator|.
name|size
argument_list|()
return|;
return|return
name|socket
operator|->
name|bytesAvailable
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|read
name|qint64
name|QFtpDTP
operator|::
name|read
parameter_list|(
name|char
modifier|*
name|data
parameter_list|,
name|qint64
name|maxlen
parameter_list|)
block|{
name|qint64
name|read
decl_stmt|;
if|if
condition|(
name|socket
operator|&&
name|socket
operator|->
name|state
argument_list|()
operator|==
name|QTcpSocket
operator|::
name|ConnectedState
condition|)
block|{
name|read
operator|=
name|socket
operator|->
name|read
argument_list|(
name|data
argument_list|,
name|maxlen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|read
operator|=
name|qMin
argument_list|(
name|maxlen
argument_list|,
name|qint64
argument_list|(
name|bytesFromSocket
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|data
argument_list|,
name|bytesFromSocket
operator|.
name|data
argument_list|()
argument_list|,
name|read
argument_list|)
expr_stmt|;
name|bytesFromSocket
operator|.
name|remove
argument_list|(
literal|0
argument_list|,
name|read
argument_list|)
expr_stmt|;
block|}
name|bytesDone
operator|+=
name|read
expr_stmt|;
return|return
name|read
return|;
block|}
end_function
begin_function
DECL|function|readAll
name|QByteArray
name|QFtpDTP
operator|::
name|readAll
parameter_list|()
block|{
name|QByteArray
name|tmp
decl_stmt|;
if|if
condition|(
name|socket
operator|&&
name|socket
operator|->
name|state
argument_list|()
operator|==
name|QTcpSocket
operator|::
name|ConnectedState
condition|)
block|{
name|tmp
operator|=
name|socket
operator|->
name|readAll
argument_list|()
expr_stmt|;
name|bytesDone
operator|+=
name|tmp
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|tmp
operator|=
name|bytesFromSocket
expr_stmt|;
name|bytesFromSocket
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
return|return
name|tmp
return|;
block|}
end_function
begin_function
DECL|function|writeData
name|void
name|QFtpDTP
operator|::
name|writeData
parameter_list|()
block|{
if|if
condition|(
operator|!
name|socket
condition|)
return|return;
if|if
condition|(
name|is_ba
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|QFTPDTP_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QFtpDTP::writeData: write %d bytes"
argument_list|,
name|data
operator|.
name|ba
operator|->
name|size
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|data
operator|.
name|ba
operator|->
name|size
argument_list|()
operator|==
literal|0
condition|)
emit|emit
name|dataTransferProgress
argument_list|(
literal|0
argument_list|,
name|bytesTotal
argument_list|)
emit|;
else|else
name|socket
operator|->
name|write
argument_list|(
name|data
operator|.
name|ba
operator|->
name|data
argument_list|()
argument_list|,
name|data
operator|.
name|ba
operator|->
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|socket
operator|->
name|close
argument_list|()
expr_stmt|;
name|clearData
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|data
operator|.
name|dev
condition|)
block|{
name|callWriteData
operator|=
literal|false
expr_stmt|;
specifier|const
name|qint64
name|blockSize
init|=
literal|16
operator|*
literal|1024
decl_stmt|;
name|char
name|buf
index|[
literal|16
operator|*
literal|1024
index|]
decl_stmt|;
name|qint64
name|read
init|=
name|data
operator|.
name|dev
operator|->
name|read
argument_list|(
name|buf
argument_list|,
name|blockSize
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QFTPDTP_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QFtpDTP::writeData: write() of size %lli bytes"
argument_list|,
name|read
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|read
operator|>
literal|0
condition|)
block|{
name|socket
operator|->
name|write
argument_list|(
name|buf
argument_list|,
name|read
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|read
operator|==
operator|-
literal|1
operator|||
operator|(
operator|!
name|data
operator|.
name|dev
operator|->
name|isSequential
argument_list|()
operator|&&
name|data
operator|.
name|dev
operator|->
name|atEnd
argument_list|()
operator|)
condition|)
block|{
comment|// error or EOF
if|if
condition|(
name|bytesDone
operator|==
literal|0
operator|&&
name|socket
operator|->
name|bytesToWrite
argument_list|()
operator|==
literal|0
condition|)
emit|emit
name|dataTransferProgress
argument_list|(
literal|0
argument_list|,
name|bytesTotal
argument_list|)
emit|;
name|socket
operator|->
name|close
argument_list|()
expr_stmt|;
name|clearData
argument_list|()
expr_stmt|;
block|}
comment|// do we continue uploading?
name|callWriteData
operator|=
name|data
operator|.
name|dev
operator|!=
literal|0
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|dataReadyRead
name|void
name|QFtpDTP
operator|::
name|dataReadyRead
parameter_list|()
block|{
name|writeData
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|hasError
specifier|inline
name|bool
name|QFtpDTP
operator|::
name|hasError
parameter_list|()
specifier|const
block|{
return|return
operator|!
name|err
operator|.
name|isNull
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|errorMessage
specifier|inline
name|QString
name|QFtpDTP
operator|::
name|errorMessage
parameter_list|()
specifier|const
block|{
return|return
name|err
return|;
block|}
end_function
begin_function
DECL|function|clearError
specifier|inline
name|void
name|QFtpDTP
operator|::
name|clearError
parameter_list|()
block|{
name|err
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|abortConnection
name|void
name|QFtpDTP
operator|::
name|abortConnection
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|QFTPDTP_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QFtpDTP::abortConnection, bytesAvailable == %lli"
argument_list|,
name|socket
condition|?
name|socket
operator|->
name|bytesAvailable
argument_list|()
else|:
operator|(
name|qint64
operator|)
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|callWriteData
operator|=
literal|false
expr_stmt|;
name|clearData
argument_list|()
expr_stmt|;
if|if
condition|(
name|socket
condition|)
name|socket
operator|->
name|abort
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|_q_fixupDateTime
specifier|static
name|void
name|_q_fixupDateTime
parameter_list|(
name|QDateTime
modifier|*
name|dateTime
parameter_list|)
block|{
comment|// Adjust for future tolerance.
specifier|const
name|int
name|futureTolerance
init|=
literal|86400
decl_stmt|;
if|if
condition|(
name|dateTime
operator|->
name|secsTo
argument_list|(
name|QDateTime
operator|::
name|currentDateTime
argument_list|()
argument_list|)
operator|<
operator|-
name|futureTolerance
condition|)
block|{
name|QDate
name|d
init|=
name|dateTime
operator|->
name|date
argument_list|()
decl_stmt|;
name|d
operator|.
name|setDate
argument_list|(
name|d
operator|.
name|year
argument_list|()
operator|-
literal|1
argument_list|,
name|d
operator|.
name|month
argument_list|()
argument_list|,
name|d
operator|.
name|day
argument_list|()
argument_list|)
expr_stmt|;
name|dateTime
operator|->
name|setDate
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|_q_parseUnixDir
specifier|static
name|void
name|_q_parseUnixDir
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|tokens
parameter_list|,
specifier|const
name|QString
modifier|&
name|userName
parameter_list|,
name|QUrlInfo
modifier|*
name|info
parameter_list|)
block|{
comment|// Unix style, 7 + 1 entries
comment|// -rw-r--r--    1 ftp      ftp      17358091 Aug 10  2004 qt-x11-free-3.3.3.tar.gz
comment|// drwxr-xr-x    3 ftp      ftp          4096 Apr 14  2000 compiled-examples
comment|// lrwxrwxrwx    1 ftp      ftp             9 Oct 29  2005 qtscape -> qtmozilla
if|if
condition|(
name|tokens
operator|.
name|size
argument_list|()
operator|!=
literal|8
condition|)
return|return;
name|char
name|first
init|=
name|tokens
operator|.
name|at
argument_list|(
literal|1
argument_list|)
operator|.
name|at
argument_list|(
literal|0
argument_list|)
operator|.
name|toLatin1
argument_list|()
decl_stmt|;
if|if
condition|(
name|first
operator|==
literal|'d'
condition|)
block|{
name|info
operator|->
name|setDir
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|info
operator|->
name|setFile
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|info
operator|->
name|setSymLink
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|first
operator|==
literal|'-'
condition|)
block|{
name|info
operator|->
name|setDir
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|info
operator|->
name|setFile
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|info
operator|->
name|setSymLink
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|first
operator|==
literal|'l'
condition|)
block|{
name|info
operator|->
name|setDir
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|info
operator|->
name|setFile
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|info
operator|->
name|setSymLink
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
comment|// Resolve filename
name|QString
name|name
init|=
name|tokens
operator|.
name|at
argument_list|(
literal|7
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|isSymLink
argument_list|()
condition|)
block|{
name|int
name|linkPos
init|=
name|name
operator|.
name|indexOf
argument_list|(
name|QLatin1String
argument_list|(
literal|" ->"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|linkPos
operator|!=
operator|-
literal|1
condition|)
name|name
operator|.
name|resize
argument_list|(
name|linkPos
argument_list|)
expr_stmt|;
block|}
name|info
operator|->
name|setName
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|// Resolve owner& group
name|info
operator|->
name|setOwner
argument_list|(
name|tokens
operator|.
name|at
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|->
name|setGroup
argument_list|(
name|tokens
operator|.
name|at
argument_list|(
literal|4
argument_list|)
argument_list|)
expr_stmt|;
comment|// Resolve size
name|info
operator|->
name|setSize
argument_list|(
name|tokens
operator|.
name|at
argument_list|(
literal|5
argument_list|)
operator|.
name|toLongLong
argument_list|()
argument_list|)
expr_stmt|;
name|QStringList
name|formats
decl_stmt|;
name|formats
operator|<<
name|QLatin1String
argument_list|(
literal|"MMM dd  yyyy"
argument_list|)
operator|<<
name|QLatin1String
argument_list|(
literal|"MMM dd hh:mm"
argument_list|)
operator|<<
name|QLatin1String
argument_list|(
literal|"MMM  d  yyyy"
argument_list|)
operator|<<
name|QLatin1String
argument_list|(
literal|"MMM  d hh:mm"
argument_list|)
operator|<<
name|QLatin1String
argument_list|(
literal|"MMM  d yyyy"
argument_list|)
operator|<<
name|QLatin1String
argument_list|(
literal|"MMM dd yyyy"
argument_list|)
expr_stmt|;
name|QString
name|dateString
init|=
name|tokens
operator|.
name|at
argument_list|(
literal|6
argument_list|)
decl_stmt|;
name|dateString
index|[
literal|0
index|]
operator|=
name|dateString
index|[
literal|0
index|]
operator|.
name|toUpper
argument_list|()
expr_stmt|;
comment|// Resolve the modification date by parsing all possible formats
name|QDateTime
name|dateTime
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_DATESTRING
do|do
block|{
name|dateTime
operator|=
name|QLocale
operator|::
name|c
argument_list|()
operator|.
name|toDateTime
argument_list|(
name|dateString
argument_list|,
name|formats
operator|.
name|at
argument_list|(
name|n
operator|++
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|n
operator|<
name|formats
operator|.
name|size
argument_list|()
operator|&&
operator|(
operator|!
name|dateTime
operator|.
name|isValid
argument_list|()
operator|)
condition|)
do|;
endif|#
directive|endif
if|if
condition|(
name|n
operator|==
literal|2
operator|||
name|n
operator|==
literal|4
condition|)
block|{
comment|// Guess the year.
name|dateTime
operator|.
name|setDate
argument_list|(
name|QDate
argument_list|(
name|QDate
operator|::
name|currentDate
argument_list|()
operator|.
name|year
argument_list|()
argument_list|,
name|dateTime
operator|.
name|date
argument_list|()
operator|.
name|month
argument_list|()
argument_list|,
name|dateTime
operator|.
name|date
argument_list|()
operator|.
name|day
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|_q_fixupDateTime
argument_list|(
operator|&
name|dateTime
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dateTime
operator|.
name|isValid
argument_list|()
condition|)
name|info
operator|->
name|setLastModified
argument_list|(
name|dateTime
argument_list|)
expr_stmt|;
comment|// Resolve permissions
name|int
name|permissions
init|=
literal|0
decl_stmt|;
name|QString
name|p
init|=
name|tokens
operator|.
name|at
argument_list|(
literal|2
argument_list|)
decl_stmt|;
name|permissions
operator||=
operator|(
name|p
index|[
literal|0
index|]
operator|==
name|QLatin1Char
argument_list|(
literal|'r'
argument_list|)
condition|?
name|QUrlInfo
operator|::
name|ReadOwner
else|:
literal|0
operator|)
expr_stmt|;
name|permissions
operator||=
operator|(
name|p
index|[
literal|1
index|]
operator|==
name|QLatin1Char
argument_list|(
literal|'w'
argument_list|)
condition|?
name|QUrlInfo
operator|::
name|WriteOwner
else|:
literal|0
operator|)
expr_stmt|;
name|permissions
operator||=
operator|(
name|p
index|[
literal|2
index|]
operator|==
name|QLatin1Char
argument_list|(
literal|'x'
argument_list|)
condition|?
name|QUrlInfo
operator|::
name|ExeOwner
else|:
literal|0
operator|)
expr_stmt|;
name|permissions
operator||=
operator|(
name|p
index|[
literal|3
index|]
operator|==
name|QLatin1Char
argument_list|(
literal|'r'
argument_list|)
condition|?
name|QUrlInfo
operator|::
name|ReadGroup
else|:
literal|0
operator|)
expr_stmt|;
name|permissions
operator||=
operator|(
name|p
index|[
literal|4
index|]
operator|==
name|QLatin1Char
argument_list|(
literal|'w'
argument_list|)
condition|?
name|QUrlInfo
operator|::
name|WriteGroup
else|:
literal|0
operator|)
expr_stmt|;
name|permissions
operator||=
operator|(
name|p
index|[
literal|5
index|]
operator|==
name|QLatin1Char
argument_list|(
literal|'x'
argument_list|)
condition|?
name|QUrlInfo
operator|::
name|ExeGroup
else|:
literal|0
operator|)
expr_stmt|;
name|permissions
operator||=
operator|(
name|p
index|[
literal|6
index|]
operator|==
name|QLatin1Char
argument_list|(
literal|'r'
argument_list|)
condition|?
name|QUrlInfo
operator|::
name|ReadOther
else|:
literal|0
operator|)
expr_stmt|;
name|permissions
operator||=
operator|(
name|p
index|[
literal|7
index|]
operator|==
name|QLatin1Char
argument_list|(
literal|'w'
argument_list|)
condition|?
name|QUrlInfo
operator|::
name|WriteOther
else|:
literal|0
operator|)
expr_stmt|;
name|permissions
operator||=
operator|(
name|p
index|[
literal|8
index|]
operator|==
name|QLatin1Char
argument_list|(
literal|'x'
argument_list|)
condition|?
name|QUrlInfo
operator|::
name|ExeOther
else|:
literal|0
operator|)
expr_stmt|;
name|info
operator|->
name|setPermissions
argument_list|(
name|permissions
argument_list|)
expr_stmt|;
name|bool
name|isOwner
init|=
name|info
operator|->
name|owner
argument_list|()
operator|==
name|userName
decl_stmt|;
name|info
operator|->
name|setReadable
argument_list|(
operator|(
name|permissions
operator|&
name|QUrlInfo
operator|::
name|ReadOther
operator|)
operator|||
operator|(
operator|(
name|permissions
operator|&
name|QUrlInfo
operator|::
name|ReadOwner
operator|)
operator|&&
name|isOwner
operator|)
argument_list|)
expr_stmt|;
name|info
operator|->
name|setWritable
argument_list|(
operator|(
name|permissions
operator|&
name|QUrlInfo
operator|::
name|WriteOther
operator|)
operator|||
operator|(
operator|(
name|permissions
operator|&
name|QUrlInfo
operator|::
name|WriteOwner
operator|)
operator|&&
name|isOwner
operator|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|_q_parseDosDir
specifier|static
name|void
name|_q_parseDosDir
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|tokens
parameter_list|,
specifier|const
name|QString
modifier|&
name|userName
parameter_list|,
name|QUrlInfo
modifier|*
name|info
parameter_list|)
block|{
comment|// DOS style, 3 + 1 entries
comment|// 01-16-02  11:14AM<DIR>          epsgroup
comment|// 06-05-03  03:19PM                 1973 readme.txt
if|if
condition|(
name|tokens
operator|.
name|size
argument_list|()
operator|!=
literal|4
condition|)
return|return;
name|Q_UNUSED
argument_list|(
name|userName
argument_list|)
expr_stmt|;
name|QString
name|name
init|=
name|tokens
operator|.
name|at
argument_list|(
literal|3
argument_list|)
decl_stmt|;
name|info
operator|->
name|setName
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|info
operator|->
name|setSymLink
argument_list|(
name|name
operator|.
name|toLower
argument_list|()
operator|.
name|endsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|".lnk"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tokens
operator|.
name|at
argument_list|(
literal|2
argument_list|)
operator|==
name|QLatin1String
argument_list|(
literal|"<DIR>"
argument_list|)
condition|)
block|{
name|info
operator|->
name|setFile
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|info
operator|->
name|setDir
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|info
operator|->
name|setFile
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|info
operator|->
name|setDir
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|info
operator|->
name|setSize
argument_list|(
name|tokens
operator|.
name|at
argument_list|(
literal|2
argument_list|)
operator|.
name|toLongLong
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Note: We cannot use QFileInfo; permissions are for the server-side
comment|// machine, and QFileInfo's behavior depends on the local platform.
name|int
name|permissions
init|=
name|QUrlInfo
operator|::
name|ReadOwner
operator||
name|QUrlInfo
operator|::
name|WriteOwner
operator||
name|QUrlInfo
operator|::
name|ReadGroup
operator||
name|QUrlInfo
operator|::
name|WriteGroup
operator||
name|QUrlInfo
operator|::
name|ReadOther
operator||
name|QUrlInfo
operator|::
name|WriteOther
decl_stmt|;
name|QString
name|ext
decl_stmt|;
name|int
name|extIndex
init|=
name|name
operator|.
name|lastIndexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|extIndex
operator|!=
operator|-
literal|1
condition|)
name|ext
operator|=
name|name
operator|.
name|mid
argument_list|(
name|extIndex
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ext
operator|==
name|QLatin1String
argument_list|(
literal|"exe"
argument_list|)
operator|||
name|ext
operator|==
name|QLatin1String
argument_list|(
literal|"bat"
argument_list|)
operator|||
name|ext
operator|==
name|QLatin1String
argument_list|(
literal|"com"
argument_list|)
condition|)
name|permissions
operator||=
name|QUrlInfo
operator|::
name|ExeOwner
operator||
name|QUrlInfo
operator|::
name|ExeGroup
operator||
name|QUrlInfo
operator|::
name|ExeOther
expr_stmt|;
name|info
operator|->
name|setPermissions
argument_list|(
name|permissions
argument_list|)
expr_stmt|;
name|info
operator|->
name|setReadable
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|info
operator|->
name|setWritable
argument_list|(
name|info
operator|->
name|isFile
argument_list|()
argument_list|)
expr_stmt|;
name|QDateTime
name|dateTime
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_DATESTRING
name|dateTime
operator|=
name|QLocale
operator|::
name|c
argument_list|()
operator|.
name|toDateTime
argument_list|(
name|tokens
operator|.
name|at
argument_list|(
literal|1
argument_list|)
argument_list|,
name|QLatin1String
argument_list|(
literal|"MM-dd-yy  hh:mmAP"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dateTime
operator|.
name|date
argument_list|()
operator|.
name|year
argument_list|()
operator|<
literal|1971
condition|)
block|{
name|dateTime
operator|.
name|setDate
argument_list|(
name|QDate
argument_list|(
name|dateTime
operator|.
name|date
argument_list|()
operator|.
name|year
argument_list|()
operator|+
literal|100
argument_list|,
name|dateTime
operator|.
name|date
argument_list|()
operator|.
name|month
argument_list|()
argument_list|,
name|dateTime
operator|.
name|date
argument_list|()
operator|.
name|day
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|info
operator|->
name|setLastModified
argument_list|(
name|dateTime
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|parseDir
name|bool
name|QFtpDTP
operator|::
name|parseDir
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|buffer
parameter_list|,
specifier|const
name|QString
modifier|&
name|userName
parameter_list|,
name|QUrlInfo
modifier|*
name|info
parameter_list|)
block|{
if|if
condition|(
name|buffer
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
name|QString
name|bufferStr
init|=
name|QString
operator|::
name|fromLatin1
argument_list|(
name|buffer
argument_list|)
operator|.
name|trimmed
argument_list|()
decl_stmt|;
comment|// Unix style FTP servers
name|QRegExp
name|unixPattern
argument_list|(
name|QLatin1String
argument_list|(
literal|"^([\\-dl])([a-zA-Z\\-]{9,9})\\s+\\d+\\s+(\\S*)\\s+"
literal|"(\\S*)\\s+(\\d+)\\s+(\\S+\\s+\\S+\\s+\\S+)\\s+(\\S.*)"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|unixPattern
operator|.
name|indexIn
argument_list|(
name|bufferStr
argument_list|)
operator|==
literal|0
condition|)
block|{
name|_q_parseUnixDir
argument_list|(
name|unixPattern
operator|.
name|capturedTexts
argument_list|()
argument_list|,
name|userName
argument_list|,
name|info
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|// DOS style FTP servers
name|QRegExp
name|dosPattern
argument_list|(
name|QLatin1String
argument_list|(
literal|"^(\\d\\d-\\d\\d-\\d\\d\\ \\ \\d\\d:\\d\\d[AP]M)\\s+"
literal|"(<DIR>|\\d+)\\s+(\\S.*)$"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|dosPattern
operator|.
name|indexIn
argument_list|(
name|bufferStr
argument_list|)
operator|==
literal|0
condition|)
block|{
name|_q_parseDosDir
argument_list|(
name|dosPattern
operator|.
name|capturedTexts
argument_list|()
argument_list|,
name|userName
argument_list|,
name|info
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
comment|// Unsupported
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|socketConnected
name|void
name|QFtpDTP
operator|::
name|socketConnected
parameter_list|()
block|{
name|bytesDone
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QFTPDTP_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QFtpDTP::connectState(CsConnected)"
argument_list|)
expr_stmt|;
endif|#
directive|endif
emit|emit
name|connectState
argument_list|(
name|QFtpDTP
operator|::
name|CsConnected
argument_list|)
emit|;
block|}
end_function
begin_function
DECL|function|socketReadyRead
name|void
name|QFtpDTP
operator|::
name|socketReadyRead
parameter_list|()
block|{
if|if
condition|(
operator|!
name|socket
condition|)
return|return;
if|if
condition|(
name|pi
operator|->
name|currentCommand
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|socket
operator|->
name|close
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QFTPDTP_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QFtpDTP::connectState(CsClosed)"
argument_list|)
expr_stmt|;
endif|#
directive|endif
emit|emit
name|connectState
argument_list|(
name|QFtpDTP
operator|::
name|CsClosed
argument_list|)
emit|;
return|return;
block|}
if|if
condition|(
name|pi
operator|->
name|abortState
operator|!=
name|QFtpPI
operator|::
name|None
condition|)
block|{
comment|// discard data
name|socket
operator|->
name|readAll
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|pi
operator|->
name|currentCommand
argument_list|()
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"LIST"
argument_list|)
argument_list|)
condition|)
block|{
while|while
condition|(
name|socket
operator|->
name|canReadLine
argument_list|()
condition|)
block|{
name|QUrlInfo
name|i
decl_stmt|;
name|QByteArray
name|line
init|=
name|socket
operator|->
name|readLine
argument_list|()
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QFTPDTP_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QFtpDTP read (list): '%s'"
argument_list|,
name|line
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|parseDir
argument_list|(
name|line
argument_list|,
name|QLatin1String
argument_list|(
literal|""
argument_list|)
argument_list|,
operator|&
name|i
argument_list|)
condition|)
block|{
emit|emit
name|listInfo
argument_list|(
name|i
argument_list|)
emit|;
block|}
else|else
block|{
comment|// some FTP servers don't return a 550 if the file or directory
comment|// does not exist, but rather write a text to the data socket
comment|// -- try to catch these cases
if|if
condition|(
name|line
operator|.
name|endsWith
argument_list|(
literal|"No such file or directory\r\n"
argument_list|)
condition|)
name|err
operator|=
name|QString
operator|::
name|fromLatin1
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|is_ba
operator|&&
name|data
operator|.
name|dev
condition|)
block|{
do|do
block|{
name|QByteArray
name|ba
decl_stmt|;
name|ba
operator|.
name|resize
argument_list|(
name|socket
operator|->
name|bytesAvailable
argument_list|()
argument_list|)
expr_stmt|;
name|qint64
name|bytesRead
init|=
name|socket
operator|->
name|read
argument_list|(
name|ba
operator|.
name|data
argument_list|()
argument_list|,
name|ba
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|bytesRead
operator|<
literal|0
condition|)
block|{
comment|// a read following a readyRead() signal will
comment|// never fail.
return|return;
block|}
name|ba
operator|.
name|resize
argument_list|(
name|bytesRead
argument_list|)
expr_stmt|;
name|bytesDone
operator|+=
name|bytesRead
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QFTPDTP_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QFtpDTP read: %lli bytes (total %lli bytes)"
argument_list|,
name|bytesRead
argument_list|,
name|bytesDone
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|data
operator|.
name|dev
condition|)
comment|// make sure it wasn't deleted in the slot
name|data
operator|.
name|dev
operator|->
name|write
argument_list|(
name|ba
argument_list|)
expr_stmt|;
emit|emit
name|dataTransferProgress
argument_list|(
name|bytesDone
argument_list|,
name|bytesTotal
argument_list|)
emit|;
comment|// Need to loop; dataTransferProgress is often connected to
comment|// slots that update the GUI (e.g., progress bar values), and
comment|// if events are processed, more data may have arrived.
block|}
do|while
condition|(
name|socket
operator|->
name|bytesAvailable
argument_list|()
condition|)
do|;
block|}
else|else
block|{
if|#
directive|if
name|defined
argument_list|(
name|QFTPDTP_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QFtpDTP readyRead: %lli bytes available (total %lli bytes read)"
argument_list|,
name|bytesAvailable
argument_list|()
argument_list|,
name|bytesDone
argument_list|)
expr_stmt|;
endif|#
directive|endif
emit|emit
name|dataTransferProgress
argument_list|(
name|bytesDone
operator|+
name|socket
operator|->
name|bytesAvailable
argument_list|()
argument_list|,
name|bytesTotal
argument_list|)
emit|;
emit|emit
name|readyRead
argument_list|()
emit|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|socketError
name|void
name|QFtpDTP
operator|::
name|socketError
parameter_list|(
name|QAbstractSocket
operator|::
name|SocketError
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|==
name|QTcpSocket
operator|::
name|HostNotFoundError
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|QFTPDTP_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QFtpDTP::connectState(CsHostNotFound)"
argument_list|)
expr_stmt|;
endif|#
directive|endif
emit|emit
name|connectState
argument_list|(
name|QFtpDTP
operator|::
name|CsHostNotFound
argument_list|)
emit|;
block|}
elseif|else
if|if
condition|(
name|e
operator|==
name|QTcpSocket
operator|::
name|ConnectionRefusedError
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|QFTPDTP_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QFtpDTP::connectState(CsConnectionRefused)"
argument_list|)
expr_stmt|;
endif|#
directive|endif
emit|emit
name|connectState
argument_list|(
name|QFtpDTP
operator|::
name|CsConnectionRefused
argument_list|)
emit|;
block|}
block|}
end_function
begin_function
DECL|function|socketConnectionClosed
name|void
name|QFtpDTP
operator|::
name|socketConnectionClosed
parameter_list|()
block|{
if|if
condition|(
operator|!
name|is_ba
operator|&&
name|data
operator|.
name|dev
condition|)
block|{
name|clearData
argument_list|()
expr_stmt|;
block|}
name|bytesFromSocket
operator|=
name|socket
operator|->
name|readAll
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QFTPDTP_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QFtpDTP::connectState(CsClosed)"
argument_list|)
expr_stmt|;
endif|#
directive|endif
emit|emit
name|connectState
argument_list|(
name|QFtpDTP
operator|::
name|CsClosed
argument_list|)
emit|;
block|}
end_function
begin_function
DECL|function|socketBytesWritten
name|void
name|QFtpDTP
operator|::
name|socketBytesWritten
parameter_list|(
name|qint64
name|bytes
parameter_list|)
block|{
name|bytesDone
operator|+=
name|bytes
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QFTPDTP_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QFtpDTP::bytesWritten(%lli)"
argument_list|,
name|bytesDone
argument_list|)
expr_stmt|;
endif|#
directive|endif
emit|emit
name|dataTransferProgress
argument_list|(
name|bytesDone
argument_list|,
name|bytesTotal
argument_list|)
emit|;
if|if
condition|(
name|callWriteData
condition|)
name|writeData
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setupSocket
name|void
name|QFtpDTP
operator|::
name|setupSocket
parameter_list|()
block|{
name|socket
operator|=
name|listener
operator|.
name|nextPendingConnection
argument_list|()
expr_stmt|;
name|socket
operator|->
name|setObjectName
argument_list|(
name|QLatin1String
argument_list|(
literal|"QFtpDTP Active state socket"
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|socket
argument_list|,
name|SIGNAL
argument_list|(
name|connected
argument_list|()
argument_list|)
argument_list|,
name|SLOT
argument_list|(
name|socketConnected
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|socket
argument_list|,
name|SIGNAL
argument_list|(
name|readyRead
argument_list|()
argument_list|)
argument_list|,
name|SLOT
argument_list|(
name|socketReadyRead
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|socket
argument_list|,
name|SIGNAL
argument_list|(
name|error
argument_list|(
name|QAbstractSocket
operator|::
name|SocketError
argument_list|)
argument_list|)
argument_list|,
name|SLOT
argument_list|(
name|socketError
argument_list|(
name|QAbstractSocket
operator|::
name|SocketError
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|socket
argument_list|,
name|SIGNAL
argument_list|(
name|disconnected
argument_list|()
argument_list|)
argument_list|,
name|SLOT
argument_list|(
name|socketConnectionClosed
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|socket
argument_list|,
name|SIGNAL
argument_list|(
name|bytesWritten
argument_list|(
name|qint64
argument_list|)
argument_list|)
argument_list|,
name|SLOT
argument_list|(
name|socketBytesWritten
argument_list|(
name|qint64
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|listener
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|clearData
name|void
name|QFtpDTP
operator|::
name|clearData
parameter_list|()
block|{
name|is_ba
operator|=
literal|false
expr_stmt|;
name|data
operator|.
name|dev
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|/**********************************************************************  *  * QFtpPI implemenatation  *  *********************************************************************/
end_comment
begin_constructor
DECL|function|QFtpPI
name|QFtpPI
operator|::
name|QFtpPI
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
name|parent
argument_list|)
member_init_list|,
name|rawCommand
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|transferConnectionExtended
argument_list|(
literal|true
argument_list|)
member_init_list|,
name|dtp
argument_list|(
name|this
argument_list|)
member_init_list|,
name|commandSocket
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|state
argument_list|(
name|Begin
argument_list|)
member_init_list|,
name|abortState
argument_list|(
name|None
argument_list|)
member_init_list|,
name|currentCmd
argument_list|(
name|QString
argument_list|()
argument_list|)
member_init_list|,
name|waitForDtpToConnect
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|waitForDtpToClose
argument_list|(
literal|false
argument_list|)
block|{
name|commandSocket
operator|.
name|setObjectName
argument_list|(
name|QLatin1String
argument_list|(
literal|"QFtpPI_socket"
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
operator|&
name|commandSocket
argument_list|,
name|SIGNAL
argument_list|(
name|hostFound
argument_list|()
argument_list|)
argument_list|,
name|SLOT
argument_list|(
name|hostFound
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
operator|&
name|commandSocket
argument_list|,
name|SIGNAL
argument_list|(
name|connected
argument_list|()
argument_list|)
argument_list|,
name|SLOT
argument_list|(
name|connected
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
operator|&
name|commandSocket
argument_list|,
name|SIGNAL
argument_list|(
name|disconnected
argument_list|()
argument_list|)
argument_list|,
name|SLOT
argument_list|(
name|connectionClosed
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
operator|&
name|commandSocket
argument_list|,
name|SIGNAL
argument_list|(
name|readyRead
argument_list|()
argument_list|)
argument_list|,
name|SLOT
argument_list|(
name|readyRead
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
operator|&
name|commandSocket
argument_list|,
name|SIGNAL
argument_list|(
name|error
argument_list|(
name|QAbstractSocket
operator|::
name|SocketError
argument_list|)
argument_list|)
argument_list|,
name|SLOT
argument_list|(
name|error
argument_list|(
name|QAbstractSocket
operator|::
name|SocketError
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
operator|&
name|dtp
argument_list|,
name|SIGNAL
argument_list|(
name|connectState
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|,
name|SLOT
argument_list|(
name|dtpConnectState
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_function
DECL|function|connectToHost
name|void
name|QFtpPI
operator|::
name|connectToHost
parameter_list|(
specifier|const
name|QString
modifier|&
name|host
parameter_list|,
name|quint16
name|port
parameter_list|)
block|{
emit|emit
name|connectState
argument_list|(
name|QFtp
operator|::
name|HostLookup
argument_list|)
emit|;
ifndef|#
directive|ifndef
name|QT_NO_BEARERMANAGEMENT
comment|//copy network session down to the socket& DTP
name|commandSocket
operator|.
name|setProperty
argument_list|(
literal|"_q_networksession"
argument_list|,
name|property
argument_list|(
literal|"_q_networksession"
argument_list|)
argument_list|)
expr_stmt|;
name|dtp
operator|.
name|setProperty
argument_list|(
literal|"_q_networksession"
argument_list|,
name|property
argument_list|(
literal|"_q_networksession"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|commandSocket
operator|.
name|connectToHost
argument_list|(
name|host
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*   \internal    Sends the sequence of commands \a cmds to the FTP server. When the commands   are all done the finished() signal is emitted. When an error occurs, the   error() signal is emitted.    If there are pending commands in the queue this functions returns false and   the \a cmds are not added to the queue; otherwise it returns true. */
end_comment
begin_function
DECL|function|sendCommands
name|bool
name|QFtpPI
operator|::
name|sendCommands
parameter_list|(
specifier|const
name|QStringList
modifier|&
name|cmds
parameter_list|)
block|{
if|if
condition|(
operator|!
name|pendingCommands
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|commandSocket
operator|.
name|state
argument_list|()
operator|!=
name|QTcpSocket
operator|::
name|ConnectedState
operator|||
name|state
operator|!=
name|Idle
condition|)
block|{
emit|emit
name|error
argument_list|(
name|QFtp
operator|::
name|NotConnected
argument_list|,
name|QFtp
operator|::
name|tr
argument_list|(
literal|"Not connected"
argument_list|)
argument_list|)
emit|;
return|return
literal|true
return|;
comment|// there are no pending commands
block|}
name|pendingCommands
operator|=
name|cmds
expr_stmt|;
name|startNextCmd
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|clearPendingCommands
name|void
name|QFtpPI
operator|::
name|clearPendingCommands
parameter_list|()
block|{
name|pendingCommands
operator|.
name|clear
argument_list|()
expr_stmt|;
name|dtp
operator|.
name|abortConnection
argument_list|()
expr_stmt|;
name|currentCmd
operator|.
name|clear
argument_list|()
expr_stmt|;
name|state
operator|=
name|Idle
expr_stmt|;
block|}
end_function
begin_function
DECL|function|abort
name|void
name|QFtpPI
operator|::
name|abort
parameter_list|()
block|{
name|pendingCommands
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|abortState
operator|!=
name|None
condition|)
comment|// ABOR already sent
return|return;
if|if
condition|(
name|currentCmd
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
comment|//no command in progress
if|if
condition|(
name|currentCmd
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"STOR "
argument_list|)
argument_list|)
condition|)
block|{
name|abortState
operator|=
name|AbortStarted
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QFTPPI_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QFtpPI send: ABOR"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|commandSocket
operator|.
name|write
argument_list|(
literal|"ABOR\r\n"
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|dtp
operator|.
name|abortConnection
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|//Deviation from RFC 959:
comment|//Most FTP servers do not support ABOR, or require the telnet
comment|//IP& synch sequence (TCP urgent data) which is not supported by QTcpSocket.
comment|//Following what most FTP clients do, just reset the data connection and wait for 426
name|abortState
operator|=
name|WaitForAbortToFinish
expr_stmt|;
name|dtp
operator|.
name|abortConnection
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|hostFound
name|void
name|QFtpPI
operator|::
name|hostFound
parameter_list|()
block|{
emit|emit
name|connectState
argument_list|(
name|QFtp
operator|::
name|Connecting
argument_list|)
emit|;
block|}
end_function
begin_function
DECL|function|connected
name|void
name|QFtpPI
operator|::
name|connected
parameter_list|()
block|{
name|state
operator|=
name|Begin
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QFTPPI_DEBUG
argument_list|)
comment|//    qDebug("QFtpPI state: %d [connected()]", state);
endif|#
directive|endif
comment|// try to improve performance by setting TCP_NODELAY
name|commandSocket
operator|.
name|setSocketOption
argument_list|(
name|QAbstractSocket
operator|::
name|LowDelayOption
argument_list|,
literal|1
argument_list|)
expr_stmt|;
emit|emit
name|connectState
argument_list|(
name|QFtp
operator|::
name|Connected
argument_list|)
emit|;
block|}
end_function
begin_function
DECL|function|connectionClosed
name|void
name|QFtpPI
operator|::
name|connectionClosed
parameter_list|()
block|{
name|commandSocket
operator|.
name|close
argument_list|()
expr_stmt|;
emit|emit
name|connectState
argument_list|(
name|QFtp
operator|::
name|Unconnected
argument_list|)
emit|;
block|}
end_function
begin_function
DECL|function|delayedCloseFinished
name|void
name|QFtpPI
operator|::
name|delayedCloseFinished
parameter_list|()
block|{
emit|emit
name|connectState
argument_list|(
name|QFtp
operator|::
name|Unconnected
argument_list|)
emit|;
block|}
end_function
begin_function
DECL|function|error
name|void
name|QFtpPI
operator|::
name|error
parameter_list|(
name|QAbstractSocket
operator|::
name|SocketError
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|==
name|QTcpSocket
operator|::
name|HostNotFoundError
condition|)
block|{
emit|emit
name|connectState
argument_list|(
name|QFtp
operator|::
name|Unconnected
argument_list|)
emit|;
emit|emit
name|error
argument_list|(
name|QFtp
operator|::
name|HostNotFound
argument_list|,
name|QFtp
operator|::
name|tr
argument_list|(
literal|"Host %1 not found"
argument_list|)
operator|.
name|arg
argument_list|(
name|commandSocket
operator|.
name|peerName
argument_list|()
argument_list|)
argument_list|)
emit|;
block|}
elseif|else
if|if
condition|(
name|e
operator|==
name|QTcpSocket
operator|::
name|ConnectionRefusedError
condition|)
block|{
emit|emit
name|connectState
argument_list|(
name|QFtp
operator|::
name|Unconnected
argument_list|)
emit|;
emit|emit
name|error
argument_list|(
name|QFtp
operator|::
name|ConnectionRefused
argument_list|,
name|QFtp
operator|::
name|tr
argument_list|(
literal|"Connection refused to host %1"
argument_list|)
operator|.
name|arg
argument_list|(
name|commandSocket
operator|.
name|peerName
argument_list|()
argument_list|)
argument_list|)
emit|;
block|}
elseif|else
if|if
condition|(
name|e
operator|==
name|QTcpSocket
operator|::
name|SocketTimeoutError
condition|)
block|{
emit|emit
name|connectState
argument_list|(
name|QFtp
operator|::
name|Unconnected
argument_list|)
emit|;
emit|emit
name|error
argument_list|(
name|QFtp
operator|::
name|ConnectionRefused
argument_list|,
name|QFtp
operator|::
name|tr
argument_list|(
literal|"Connection timed out to host %1"
argument_list|)
operator|.
name|arg
argument_list|(
name|commandSocket
operator|.
name|peerName
argument_list|()
argument_list|)
argument_list|)
emit|;
block|}
block|}
end_function
begin_function
DECL|function|readyRead
name|void
name|QFtpPI
operator|::
name|readyRead
parameter_list|()
block|{
if|if
condition|(
name|waitForDtpToClose
condition|)
return|return;
while|while
condition|(
name|commandSocket
operator|.
name|canReadLine
argument_list|()
condition|)
block|{
comment|// read line with respect to line continuation
name|QString
name|line
init|=
name|QString
operator|::
name|fromLatin1
argument_list|(
name|commandSocket
operator|.
name|readLine
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|replyText
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|line
operator|.
name|length
argument_list|()
operator|<
literal|3
condition|)
block|{
comment|// protocol error
return|return;
block|}
specifier|const
name|int
name|lowerLimit
index|[
literal|3
index|]
init|=
block|{
literal|1
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
specifier|const
name|int
name|upperLimit
index|[
literal|3
index|]
init|=
block|{
literal|5
block|,
literal|5
block|,
literal|9
block|}
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|replyCode
index|[
name|i
index|]
operator|=
name|line
index|[
name|i
index|]
operator|.
name|digitValue
argument_list|()
expr_stmt|;
if|if
condition|(
name|replyCode
index|[
name|i
index|]
operator|<
name|lowerLimit
index|[
name|i
index|]
operator|||
name|replyCode
index|[
name|i
index|]
operator|>
name|upperLimit
index|[
name|i
index|]
condition|)
block|{
comment|// protocol error
return|return;
block|}
block|}
block|}
name|QString
name|endOfMultiLine
decl_stmt|;
name|endOfMultiLine
index|[
literal|0
index|]
operator|=
literal|'0'
operator|+
name|replyCode
index|[
literal|0
index|]
expr_stmt|;
name|endOfMultiLine
index|[
literal|1
index|]
operator|=
literal|'0'
operator|+
name|replyCode
index|[
literal|1
index|]
expr_stmt|;
name|endOfMultiLine
index|[
literal|2
index|]
operator|=
literal|'0'
operator|+
name|replyCode
index|[
literal|2
index|]
expr_stmt|;
name|endOfMultiLine
index|[
literal|3
index|]
operator|=
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|QString
name|lineCont
argument_list|(
name|endOfMultiLine
argument_list|)
decl_stmt|;
name|lineCont
index|[
literal|3
index|]
operator|=
name|QLatin1Char
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
name|QString
name|lineLeft4
init|=
name|line
operator|.
name|left
argument_list|(
literal|4
argument_list|)
decl_stmt|;
while|while
condition|(
name|lineLeft4
operator|!=
name|endOfMultiLine
condition|)
block|{
if|if
condition|(
name|lineLeft4
operator|==
name|lineCont
condition|)
name|replyText
operator|+=
name|line
operator|.
name|mid
argument_list|(
literal|4
argument_list|)
expr_stmt|;
comment|// strip 'xyz-'
else|else
name|replyText
operator|+=
name|line
expr_stmt|;
if|if
condition|(
operator|!
name|commandSocket
operator|.
name|canReadLine
argument_list|()
condition|)
return|return;
name|line
operator|=
name|QString
operator|::
name|fromLatin1
argument_list|(
name|commandSocket
operator|.
name|readLine
argument_list|()
argument_list|)
expr_stmt|;
name|lineLeft4
operator|=
name|line
operator|.
name|left
argument_list|(
literal|4
argument_list|)
expr_stmt|;
block|}
name|replyText
operator|+=
name|line
operator|.
name|mid
argument_list|(
literal|4
argument_list|)
expr_stmt|;
comment|// strip reply code 'xyz '
if|if
condition|(
name|replyText
operator|.
name|endsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"\r\n"
argument_list|)
argument_list|)
condition|)
name|replyText
operator|.
name|chop
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|processReply
argument_list|()
condition|)
name|replyText
operator|=
name|QLatin1String
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*   \internal    Process a reply from the FTP server.    Returns true if the reply was processed or false if the reply has to be   processed at a later point. */
end_comment
begin_function
DECL|function|processReply
name|bool
name|QFtpPI
operator|::
name|processReply
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|QFTPPI_DEBUG
argument_list|)
comment|//    qDebug("QFtpPI state: %d [processReply() begin]", state);
if|if
condition|(
name|replyText
operator|.
name|length
argument_list|()
operator|<
literal|400
condition|)
name|qDebug
argument_list|(
literal|"QFtpPI recv: %d %s"
argument_list|,
literal|100
operator|*
name|replyCode
index|[
literal|0
index|]
operator|+
literal|10
operator|*
name|replyCode
index|[
literal|1
index|]
operator|+
name|replyCode
index|[
literal|2
index|]
argument_list|,
name|replyText
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|qDebug
argument_list|(
literal|"QFtpPI recv: %d (text skipped)"
argument_list|,
literal|100
operator|*
name|replyCode
index|[
literal|0
index|]
operator|+
literal|10
operator|*
name|replyCode
index|[
literal|1
index|]
operator|+
name|replyCode
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|int
name|replyCodeInt
init|=
literal|100
operator|*
name|replyCode
index|[
literal|0
index|]
operator|+
literal|10
operator|*
name|replyCode
index|[
literal|1
index|]
operator|+
name|replyCode
index|[
literal|2
index|]
decl_stmt|;
comment|// process 226 replies ("Closing Data Connection") only when the data
comment|// connection is really closed to avoid short reads of the DTP
if|if
condition|(
name|replyCodeInt
operator|==
literal|226
operator|||
operator|(
name|replyCodeInt
operator|==
literal|250
operator|&&
name|currentCmd
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"RETR"
argument_list|)
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|dtp
operator|.
name|state
argument_list|()
operator|!=
name|QTcpSocket
operator|::
name|UnconnectedState
condition|)
block|{
name|waitForDtpToClose
operator|=
literal|true
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
switch|switch
condition|(
name|abortState
condition|)
block|{
case|case
name|AbortStarted
case|:
name|abortState
operator|=
name|WaitForAbortToFinish
expr_stmt|;
break|break;
case|case
name|WaitForAbortToFinish
case|:
name|abortState
operator|=
name|None
expr_stmt|;
return|return
literal|true
return|;
default|default:
break|break;
block|}
comment|// get new state
specifier|static
specifier|const
name|State
name|table
index|[
literal|5
index|]
init|=
block|{
comment|/* 1yz   2yz      3yz   4yz      5yz */
name|Waiting
block|,
name|Success
block|,
name|Idle
block|,
name|Failure
block|,
name|Failure
block|}
decl_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|Begin
case|:
if|if
condition|(
name|replyCode
index|[
literal|0
index|]
operator|==
literal|1
condition|)
block|{
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|replyCode
index|[
literal|0
index|]
operator|==
literal|2
condition|)
block|{
name|state
operator|=
name|Idle
expr_stmt|;
emit|emit
name|finished
argument_list|(
name|QFtp
operator|::
name|tr
argument_list|(
literal|"Connected to host %1"
argument_list|)
operator|.
name|arg
argument_list|(
name|commandSocket
operator|.
name|peerName
argument_list|()
argument_list|)
argument_list|)
emit|;
break|break;
block|}
comment|// reply codes not starting with 1 or 2 are not handled.
return|return
literal|true
return|;
case|case
name|Waiting
case|:
if|if
condition|(
cast|static_cast
argument_list|<
name|signed
name|char
argument_list|>
argument_list|(
name|replyCode
index|[
literal|0
index|]
argument_list|)
operator|<
literal|0
operator|||
name|replyCode
index|[
literal|0
index|]
operator|>
literal|5
condition|)
name|state
operator|=
name|Failure
expr_stmt|;
elseif|else
if|if
condition|(
name|replyCodeInt
operator|==
literal|202
condition|)
name|state
operator|=
name|Failure
expr_stmt|;
else|else
name|state
operator|=
name|table
index|[
name|replyCode
index|[
literal|0
index|]
operator|-
literal|1
index|]
expr_stmt|;
break|break;
default|default:
comment|// ignore unrequested message
return|return
literal|true
return|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|QFTPPI_DEBUG
argument_list|)
comment|//    qDebug("QFtpPI state: %d [processReply() intermediate]", state);
endif|#
directive|endif
comment|// special actions on certain replies
emit|emit
name|rawFtpReply
argument_list|(
name|replyCodeInt
argument_list|,
name|replyText
argument_list|)
emit|;
if|if
condition|(
name|rawCommand
condition|)
block|{
name|rawCommand
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|replyCodeInt
operator|==
literal|227
condition|)
block|{
comment|// 227 Entering Passive Mode (h1,h2,h3,h4,p1,p2)
comment|// rfc959 does not define this response precisely, and gives
comment|// both examples where the parenthesis are used, and where
comment|// they are missing. We need to scan for the address and host
comment|// info.
name|QRegExp
name|addrPortPattern
argument_list|(
name|QLatin1String
argument_list|(
literal|"(\\d+),(\\d+),(\\d+),(\\d+),(\\d+),(\\d+)"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|addrPortPattern
operator|.
name|indexIn
argument_list|(
name|replyText
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|QFTPPI_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QFtp: bad 227 response -- address and port information missing"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// this error should be reported
block|}
else|else
block|{
name|QStringList
name|lst
init|=
name|addrPortPattern
operator|.
name|capturedTexts
argument_list|()
decl_stmt|;
name|QString
name|host
init|=
name|lst
index|[
literal|1
index|]
operator|+
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
operator|+
name|lst
index|[
literal|2
index|]
operator|+
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
operator|+
name|lst
index|[
literal|3
index|]
operator|+
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
operator|+
name|lst
index|[
literal|4
index|]
decl_stmt|;
name|quint16
name|port
init|=
operator|(
name|lst
index|[
literal|5
index|]
operator|.
name|toUInt
argument_list|()
operator|<<
literal|8
operator|)
operator|+
name|lst
index|[
literal|6
index|]
operator|.
name|toUInt
argument_list|()
decl_stmt|;
name|waitForDtpToConnect
operator|=
literal|true
expr_stmt|;
name|dtp
operator|.
name|connectToHost
argument_list|(
name|host
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|replyCodeInt
operator|==
literal|229
condition|)
block|{
comment|// 229 Extended Passive mode OK (|||10982|)
name|int
name|portPos
init|=
name|replyText
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'('
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|portPos
operator|==
operator|-
literal|1
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|QFTPPI_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QFtp: bad 229 response -- port information missing"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// this error should be reported
block|}
else|else
block|{
operator|++
name|portPos
expr_stmt|;
name|QChar
name|delimiter
init|=
name|replyText
operator|.
name|at
argument_list|(
name|portPos
argument_list|)
decl_stmt|;
name|QStringList
name|epsvParameters
init|=
name|replyText
operator|.
name|mid
argument_list|(
name|portPos
argument_list|)
operator|.
name|split
argument_list|(
name|delimiter
argument_list|)
decl_stmt|;
name|waitForDtpToConnect
operator|=
literal|true
expr_stmt|;
name|dtp
operator|.
name|connectToHost
argument_list|(
name|commandSocket
operator|.
name|peerAddress
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|epsvParameters
operator|.
name|at
argument_list|(
literal|3
argument_list|)
operator|.
name|toInt
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|replyCodeInt
operator|==
literal|230
condition|)
block|{
if|if
condition|(
name|currentCmd
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"USER "
argument_list|)
argument_list|)
operator|&&
name|pendingCommands
operator|.
name|count
argument_list|()
operator|>
literal|0
operator|&&
name|pendingCommands
operator|.
name|first
argument_list|()
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"PASS "
argument_list|)
argument_list|)
condition|)
block|{
comment|// no need to send the PASS -- we are already logged in
name|pendingCommands
operator|.
name|pop_front
argument_list|()
expr_stmt|;
block|}
comment|// 230 User logged in, proceed.
emit|emit
name|connectState
argument_list|(
name|QFtp
operator|::
name|LoggedIn
argument_list|)
emit|;
block|}
elseif|else
if|if
condition|(
name|replyCodeInt
operator|==
literal|213
condition|)
block|{
comment|// 213 File status.
if|if
condition|(
name|currentCmd
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"SIZE "
argument_list|)
argument_list|)
condition|)
name|dtp
operator|.
name|setBytesTotal
argument_list|(
name|replyText
operator|.
name|simplified
argument_list|()
operator|.
name|toLongLong
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|replyCode
index|[
literal|0
index|]
operator|==
literal|1
operator|&&
name|currentCmd
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"STOR "
argument_list|)
argument_list|)
condition|)
block|{
name|dtp
operator|.
name|waitForConnection
argument_list|()
expr_stmt|;
name|dtp
operator|.
name|writeData
argument_list|()
expr_stmt|;
block|}
comment|// react on new state
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|Begin
case|:
comment|// should never happen
break|break;
case|case
name|Success
case|:
comment|// success handling
name|state
operator|=
name|Idle
expr_stmt|;
comment|// no break!
case|case
name|Idle
case|:
if|if
condition|(
name|dtp
operator|.
name|hasError
argument_list|()
condition|)
block|{
emit|emit
name|error
argument_list|(
name|QFtp
operator|::
name|UnknownError
argument_list|,
name|dtp
operator|.
name|errorMessage
argument_list|()
argument_list|)
emit|;
name|dtp
operator|.
name|clearError
argument_list|()
expr_stmt|;
block|}
name|startNextCmd
argument_list|()
expr_stmt|;
break|break;
case|case
name|Waiting
case|:
comment|// do nothing
break|break;
case|case
name|Failure
case|:
comment|// If the EPSV or EPRT commands fail, replace them with
comment|// the old PASV and PORT instead and try again.
if|if
condition|(
name|currentCmd
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"EPSV"
argument_list|)
argument_list|)
condition|)
block|{
name|transferConnectionExtended
operator|=
literal|false
expr_stmt|;
name|pendingCommands
operator|.
name|prepend
argument_list|(
name|QLatin1String
argument_list|(
literal|"PASV\r\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|currentCmd
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"EPRT"
argument_list|)
argument_list|)
condition|)
block|{
name|transferConnectionExtended
operator|=
literal|false
expr_stmt|;
name|pendingCommands
operator|.
name|prepend
argument_list|(
name|QLatin1String
argument_list|(
literal|"PORT\r\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
emit|emit
name|error
argument_list|(
name|QFtp
operator|::
name|UnknownError
argument_list|,
name|replyText
argument_list|)
emit|;
block|}
if|if
condition|(
name|state
operator|!=
name|Waiting
condition|)
block|{
name|state
operator|=
name|Idle
expr_stmt|;
name|startNextCmd
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
if|#
directive|if
name|defined
argument_list|(
name|QFTPPI_DEBUG
argument_list|)
comment|//    qDebug("QFtpPI state: %d [processReply() end]", state);
endif|#
directive|endif
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*   \internal    Starts next pending command. Returns false if there are no pending commands,   otherwise it returns true. */
end_comment
begin_function
DECL|function|startNextCmd
name|bool
name|QFtpPI
operator|::
name|startNextCmd
parameter_list|()
block|{
if|if
condition|(
name|waitForDtpToConnect
condition|)
comment|// don't process any new commands until we are connected
return|return
literal|true
return|;
if|#
directive|if
name|defined
argument_list|(
name|QFTPPI_DEBUG
argument_list|)
if|if
condition|(
name|state
operator|!=
name|Idle
condition|)
name|qDebug
argument_list|(
literal|"QFtpPI startNextCmd: Internal error! QFtpPI called in non-Idle state %d"
argument_list|,
name|state
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pendingCommands
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|currentCmd
operator|.
name|clear
argument_list|()
expr_stmt|;
emit|emit
name|finished
argument_list|(
name|replyText
argument_list|)
emit|;
return|return
literal|false
return|;
block|}
name|currentCmd
operator|=
name|pendingCommands
operator|.
name|first
argument_list|()
expr_stmt|;
comment|// PORT and PASV are edited in-place, depending on whether we
comment|// should try the extended transfer connection commands EPRT and
comment|// EPSV. The PORT command also triggers setting up a listener, and
comment|// the address/port arguments are edited in.
name|QHostAddress
name|address
init|=
name|commandSocket
operator|.
name|localAddress
argument_list|()
decl_stmt|;
if|if
condition|(
name|currentCmd
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"PORT"
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|address
operator|.
name|protocol
argument_list|()
operator|==
name|QTcpSocket
operator|::
name|IPv6Protocol
operator|)
operator|&&
name|transferConnectionExtended
condition|)
block|{
name|int
name|port
init|=
name|dtp
operator|.
name|setupListener
argument_list|(
name|address
argument_list|)
decl_stmt|;
name|currentCmd
operator|=
name|QLatin1String
argument_list|(
literal|"EPRT |"
argument_list|)
expr_stmt|;
name|currentCmd
operator|+=
operator|(
name|address
operator|.
name|protocol
argument_list|()
operator|==
name|QTcpSocket
operator|::
name|IPv4Protocol
operator|)
condition|?
name|QLatin1Char
argument_list|(
literal|'1'
argument_list|)
else|:
name|QLatin1Char
argument_list|(
literal|'2'
argument_list|)
expr_stmt|;
name|currentCmd
operator|+=
name|QLatin1Char
argument_list|(
literal|'|'
argument_list|)
operator|+
name|address
operator|.
name|toString
argument_list|()
operator|+
name|QLatin1Char
argument_list|(
literal|'|'
argument_list|)
operator|+
name|QString
operator|::
name|number
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|currentCmd
operator|+=
name|QLatin1Char
argument_list|(
literal|'|'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|address
operator|.
name|protocol
argument_list|()
operator|==
name|QTcpSocket
operator|::
name|IPv4Protocol
condition|)
block|{
name|int
name|port
init|=
name|dtp
operator|.
name|setupListener
argument_list|(
name|address
argument_list|)
decl_stmt|;
name|QString
name|portArg
decl_stmt|;
name|quint32
name|ip
init|=
name|address
operator|.
name|toIPv4Address
argument_list|()
decl_stmt|;
name|portArg
operator|+=
name|QString
operator|::
name|number
argument_list|(
operator|(
name|ip
operator|&
literal|0xff000000
operator|)
operator|>>
literal|24
argument_list|)
expr_stmt|;
name|portArg
operator|+=
name|QLatin1Char
argument_list|(
literal|','
argument_list|)
operator|+
name|QString
operator|::
name|number
argument_list|(
operator|(
name|ip
operator|&
literal|0xff0000
operator|)
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|portArg
operator|+=
name|QLatin1Char
argument_list|(
literal|','
argument_list|)
operator|+
name|QString
operator|::
name|number
argument_list|(
operator|(
name|ip
operator|&
literal|0xff00
operator|)
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|portArg
operator|+=
name|QLatin1Char
argument_list|(
literal|','
argument_list|)
operator|+
name|QString
operator|::
name|number
argument_list|(
name|ip
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|portArg
operator|+=
name|QLatin1Char
argument_list|(
literal|','
argument_list|)
operator|+
name|QString
operator|::
name|number
argument_list|(
operator|(
name|port
operator|&
literal|0xff00
operator|)
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|portArg
operator|+=
name|QLatin1Char
argument_list|(
literal|','
argument_list|)
operator|+
name|QString
operator|::
name|number
argument_list|(
name|port
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|currentCmd
operator|=
name|QLatin1String
argument_list|(
literal|"PORT "
argument_list|)
expr_stmt|;
name|currentCmd
operator|+=
name|portArg
expr_stmt|;
block|}
else|else
block|{
comment|// No IPv6 connection can be set up with the PORT
comment|// command.
return|return
literal|false
return|;
block|}
name|currentCmd
operator|+=
name|QLatin1String
argument_list|(
literal|"\r\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|currentCmd
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"PASV"
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|address
operator|.
name|protocol
argument_list|()
operator|==
name|QTcpSocket
operator|::
name|IPv6Protocol
operator|)
operator|&&
name|transferConnectionExtended
condition|)
name|currentCmd
operator|=
name|QLatin1String
argument_list|(
literal|"EPSV\r\n"
argument_list|)
expr_stmt|;
block|}
name|pendingCommands
operator|.
name|pop_front
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QFTPPI_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QFtpPI send: %s"
argument_list|,
name|currentCmd
operator|.
name|left
argument_list|(
name|currentCmd
operator|.
name|length
argument_list|()
operator|-
literal|2
argument_list|)
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|state
operator|=
name|Waiting
expr_stmt|;
name|commandSocket
operator|.
name|write
argument_list|(
name|currentCmd
operator|.
name|toLatin1
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|dtpConnectState
name|void
name|QFtpPI
operator|::
name|dtpConnectState
parameter_list|(
name|int
name|s
parameter_list|)
block|{
switch|switch
condition|(
name|s
condition|)
block|{
case|case
name|QFtpDTP
operator|::
name|CsClosed
case|:
if|if
condition|(
name|waitForDtpToClose
condition|)
block|{
comment|// there is an unprocessed reply
if|if
condition|(
name|processReply
argument_list|()
condition|)
name|replyText
operator|=
name|QLatin1String
argument_list|(
literal|""
argument_list|)
expr_stmt|;
else|else
return|return;
block|}
name|waitForDtpToClose
operator|=
literal|false
expr_stmt|;
name|readyRead
argument_list|()
expr_stmt|;
return|return;
case|case
name|QFtpDTP
operator|::
name|CsConnected
case|:
name|waitForDtpToConnect
operator|=
literal|false
expr_stmt|;
name|startNextCmd
argument_list|()
expr_stmt|;
return|return;
case|case
name|QFtpDTP
operator|::
name|CsHostNotFound
case|:
case|case
name|QFtpDTP
operator|::
name|CsConnectionRefused
case|:
emit|emit
name|error
argument_list|(
name|QFtp
operator|::
name|ConnectionRefused
argument_list|,
name|QFtp
operator|::
name|tr
argument_list|(
literal|"Data Connection refused"
argument_list|)
argument_list|)
emit|;
name|startNextCmd
argument_list|()
expr_stmt|;
return|return;
default|default:
return|return;
block|}
block|}
end_function
begin_comment
comment|/**********************************************************************  *  * QFtpPrivate  *  *********************************************************************/
end_comment
begin_expr_stmt
name|QT_BEGIN_INCLUDE_NAMESPACE
include|#
directive|include
file|<private/qobject_p.h>
name|QT_END_INCLUDE_NAMESPACE
DECL|class|QFtpPrivate
name|class
name|QFtpPrivate
operator|:
specifier|public
name|QObjectPrivate
block|{
name|Q_DECLARE_PUBLIC
argument_list|(
argument|QFtp
argument_list|)
specifier|public
operator|:
DECL|function|QFtpPrivate
specifier|inline
name|QFtpPrivate
argument_list|()
operator|:
name|close_waitForStateChange
argument_list|(
literal|false
argument_list|)
block|,
name|state
argument_list|(
name|QFtp
operator|::
name|Unconnected
argument_list|)
block|,
name|transferMode
argument_list|(
name|QFtp
operator|::
name|Passive
argument_list|)
block|,
name|error
argument_list|(
argument|QFtp::NoError
argument_list|)
block|{ }
DECL|function|~QFtpPrivate
operator|~
name|QFtpPrivate
argument_list|()
block|{
while|while
condition|(
operator|!
name|pending
operator|.
name|isEmpty
argument_list|()
condition|)
operator|delete
name|pending
operator|.
name|takeFirst
argument_list|()
expr_stmt|;
block|}
comment|// private slots
name|void
name|_q_startNextCommand
argument_list|()
expr_stmt|;
end_expr_stmt
begin_function_decl
name|void
name|_q_piFinished
parameter_list|(
specifier|const
name|QString
modifier|&
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|void
name|_q_piError
parameter_list|(
name|int
parameter_list|,
specifier|const
name|QString
modifier|&
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|void
name|_q_piConnectState
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|void
name|_q_piFtpReply
parameter_list|(
name|int
parameter_list|,
specifier|const
name|QString
modifier|&
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
name|int
name|addCommand
parameter_list|(
name|QFtpCommand
modifier|*
name|cmd
parameter_list|)
function_decl|;
end_function_decl
begin_decl_stmt
DECL|member|pi
name|QFtpPI
name|pi
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|pending
name|QList
argument_list|<
name|QFtpCommand
modifier|*
argument_list|>
name|pending
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|close_waitForStateChange
name|bool
name|close_waitForStateChange
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|state
name|QFtp
operator|::
name|State
name|state
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|transferMode
name|QFtp
operator|::
name|TransferMode
name|transferMode
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|error
name|QFtp
operator|::
name|Error
name|error
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|errorString
name|QString
name|errorString
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|host
name|QString
name|host
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|port
name|quint16
name|port
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|proxyHost
name|QString
name|proxyHost
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|proxyPort
name|quint16
name|proxyPort
decl_stmt|;
end_decl_stmt
begin_function
DECL|member|proxyPort
unit|};
DECL|function|addCommand
name|int
name|QFtpPrivate
operator|::
name|addCommand
parameter_list|(
name|QFtpCommand
modifier|*
name|cmd
parameter_list|)
block|{
name|pending
operator|.
name|append
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|pending
operator|.
name|count
argument_list|()
operator|==
literal|1
condition|)
block|{
comment|// don't emit the commandStarted() signal before the ID is returned
name|QTimer
operator|::
name|singleShot
argument_list|(
literal|0
argument_list|,
name|q_func
argument_list|()
argument_list|,
name|SLOT
argument_list|(
name|_q_startNextCommand
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|cmd
operator|->
name|id
return|;
block|}
end_function
begin_comment
comment|/**********************************************************************  *  * QFtp implementation  *  *********************************************************************/
end_comment
begin_comment
comment|/*!     \internal     \class QFtp     \brief The QFtp class provides an implementation of the client side of FTP protocol.      \ingroup network     \inmodule QtNetwork       This class provides a direct interface to FTP that allows you to     have more control over the requests. However, for new     applications, it is recommended to use QNetworkAccessManager and     QNetworkReply, as those classes possess a simpler, yet more     powerful API.      The class works asynchronously, so there are no blocking     functions. If an operation cannot be executed immediately, the     function will still return straight away and the operation will be     scheduled for later execution. The results of scheduled operations     are reported via signals. This approach depends on the event loop     being in operation.      The operations that can be scheduled (they are called "commands"     in the rest of the documentation) are the following:     connectToHost(), login(), close(), list(), cd(), get(), put(),     remove(), mkdir(), rmdir(), rename() and rawCommand().      All of these commands return a unique identifier that allows you     to keep track of the command that is currently being executed.     When the execution of a command starts, the commandStarted()     signal with the command's identifier is emitted. When the command     is finished, the commandFinished() signal is emitted with the     command's identifier and a bool that indicates whether the command     finished with an error.      In some cases, you might want to execute a sequence of commands,     e.g. if you want to connect and login to a FTP server. This is     simply achieved:      \snippet code/src_network_access_qftp.cpp 0      In this case two FTP commands have been scheduled. When the last     scheduled command has finished, a done() signal is emitted with     a bool argument that tells you whether the sequence finished with     an error.      If an error occurs during the execution of one of the commands in     a sequence of commands, all the pending commands (i.e. scheduled,     but not yet executed commands) are cleared and no signals are     emitted for them.      Some commands, e.g. list(), emit additional signals to report     their results.      Example: If you want to download the INSTALL file from the Qt     FTP server, you would write this:      \snippet code/src_network_access_qftp.cpp 1      For this example the following sequence of signals is emitted     (with small variations, depending on network traffic, etc.):      \snippet code/src_network_access_qftp.cpp 2      The dataTransferProgress() signal in the above example is useful     if you want to show a \l{QProgressBar}{progress bar} to     inform the user about the progress of the download. The     readyRead() signal tells you that there is data ready to be read.     The amount of data can be queried then with the bytesAvailable()     function and it can be read with the read() or readAll()     function.      If the login fails for the above example, the signals would look     like this:      \snippet code/src_network_access_qftp.cpp 3      You can then get details about the error with the error() and     errorString() functions.      For file transfer, QFtp can use both active or passive mode, and     it uses passive file transfer mode by default; see the     documentation for setTransferMode() for more details about this.      Call setProxy() to make QFtp connect via an FTP proxy server.      The functions currentId() and currentCommand() provide more     information about the currently executing command.      The functions hasPendingCommands() and clearPendingCommands()     allow you to query and clear the list of pending commands.      If you are an experienced network programmer and want to have     complete control you can use rawCommand() to execute arbitrary FTP     commands.      \warning The current version of QFtp doesn't fully support     non-Unix FTP servers.      \sa QNetworkAccessManager, QNetworkRequest, QNetworkReply,         {FTP Example} */
end_comment
begin_comment
comment|/*!     \internal     Constructs a QFtp object with the given \a parent. */
end_comment
begin_constructor
DECL|function|QFtp
name|QFtp
operator|::
name|QFtp
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|new
name|QFtpPrivate
argument_list|,
name|parent
argument_list|)
block|{
name|Q_D
argument_list|(
name|QFtp
argument_list|)
expr_stmt|;
name|d
operator|->
name|errorString
operator|=
name|tr
argument_list|(
literal|"Unknown error"
argument_list|)
expr_stmt|;
name|connect
argument_list|(
operator|&
name|d
operator|->
name|pi
argument_list|,
name|SIGNAL
argument_list|(
name|connectState
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|,
name|SLOT
argument_list|(
name|_q_piConnectState
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
operator|&
name|d
operator|->
name|pi
argument_list|,
name|SIGNAL
argument_list|(
name|finished
argument_list|(
name|QString
argument_list|)
argument_list|)
argument_list|,
name|SLOT
argument_list|(
name|_q_piFinished
argument_list|(
name|QString
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
operator|&
name|d
operator|->
name|pi
argument_list|,
name|SIGNAL
argument_list|(
name|error
argument_list|(
name|int
argument_list|,
name|QString
argument_list|)
argument_list|)
argument_list|,
name|SLOT
argument_list|(
name|_q_piError
argument_list|(
name|int
argument_list|,
name|QString
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
operator|&
name|d
operator|->
name|pi
argument_list|,
name|SIGNAL
argument_list|(
name|rawFtpReply
argument_list|(
name|int
argument_list|,
name|QString
argument_list|)
argument_list|)
argument_list|,
name|SLOT
argument_list|(
name|_q_piFtpReply
argument_list|(
name|int
argument_list|,
name|QString
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
operator|&
name|d
operator|->
name|pi
operator|.
name|dtp
argument_list|,
name|SIGNAL
argument_list|(
name|readyRead
argument_list|()
argument_list|)
argument_list|,
name|SIGNAL
argument_list|(
name|readyRead
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
operator|&
name|d
operator|->
name|pi
operator|.
name|dtp
argument_list|,
name|SIGNAL
argument_list|(
name|dataTransferProgress
argument_list|(
name|qint64
argument_list|,
name|qint64
argument_list|)
argument_list|)
argument_list|,
name|SIGNAL
argument_list|(
name|dataTransferProgress
argument_list|(
name|qint64
argument_list|,
name|qint64
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
operator|&
name|d
operator|->
name|pi
operator|.
name|dtp
argument_list|,
name|SIGNAL
argument_list|(
name|listInfo
argument_list|(
name|QUrlInfo
argument_list|)
argument_list|)
argument_list|,
name|SIGNAL
argument_list|(
name|listInfo
argument_list|(
name|QUrlInfo
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     \internal     \enum QFtp::State      This enum defines the connection state:      \value Unconnected There is no connection to the host.     \value HostLookup A host name lookup is in progress.     \value Connecting An attempt to connect to the host is in progress.     \value Connected Connection to the host has been achieved.     \value LoggedIn Connection and user login have been achieved.     \value Closing The connection is closing down, but it is not yet     closed. (The state will be \c Unconnected when the connection is     closed.)      \sa stateChanged(), state() */
end_comment
begin_comment
comment|/*!     \internal     \enum QFtp::TransferMode      FTP works with two socket connections; one for commands and     another for transmitting data. While the command connection is     always initiated by the client, the second connection can be     initiated by either the client or the server.      This enum defines whether the client (Passive mode) or the server     (Active mode) should set up the data connection.      \value Passive The client connects to the server to transmit its     data.      \value Active The server connects to the client to transmit its     data. */
end_comment
begin_comment
comment|/*!     \internal     \enum QFtp::TransferType      This enum identifies the data transfer type used with get and     put commands.      \value Binary The data will be transferred in Binary mode.      \value Ascii The data will be transferred in Ascii mode and new line     characters will be converted to the local format. */
end_comment
begin_comment
comment|/*!     \internal     \enum QFtp::Error      This enum identifies the error that occurred.      \value NoError No error occurred.     \value HostNotFound The host name lookup failed.     \value ConnectionRefused The server refused the connection.     \value NotConnected Tried to send a command, but there is no connection to     a server.     \value UnknownError An error other than those specified above     occurred.      \sa error() */
end_comment
begin_comment
comment|/*!     \internal     \enum QFtp::Command      This enum is used as the return value for the currentCommand() function.     This allows you to perform specific actions for particular     commands, e.g. in a FTP client, you might want to clear the     directory view when a list() command is started; in this case you     can simply check in the slot connected to the start() signal if     the currentCommand() is \c List.      \value None No command is being executed.     \value SetTransferMode set the \l{TransferMode}{transfer} mode.     \value SetProxy switch proxying on or off.     \value ConnectToHost connectToHost() is being executed.     \value Login login() is being executed.     \value Close close() is being executed.     \value List list() is being executed.     \value Cd cd() is being executed.     \value Get get() is being executed.     \value Put put() is being executed.     \value Remove remove() is being executed.     \value Mkdir mkdir() is being executed.     \value Rmdir rmdir() is being executed.     \value Rename rename() is being executed.     \value RawCommand rawCommand() is being executed.      \sa currentCommand() */
end_comment
begin_comment
comment|/*!     \internal     \fn void QFtp::stateChanged(int state)      This signal is emitted when the state of the connection changes.     The argument \a state is the new state of the connection; it is     one of the \l State values.      It is usually emitted in response to a connectToHost() or close()     command, but it can also be emitted "spontaneously", e.g. when the     server closes the connection unexpectedly.      \sa connectToHost(), close(), state(), State */
end_comment
begin_comment
comment|/*!     \internal     \fn void QFtp::listInfo(const QUrlInfo&i);      This signal is emitted for each directory entry the list() command     finds. The details of the entry are stored in \a i.      \sa list() */
end_comment
begin_comment
comment|/*!     \internal     \fn void QFtp::commandStarted(int id)      This signal is emitted when processing the command identified by     \a id starts.      \sa commandFinished(), done() */
end_comment
begin_comment
comment|/*!     \internal     \fn void QFtp::commandFinished(int id, bool error)      This signal is emitted when processing the command identified by     \a id has finished. \a error is true if an error occurred during     the processing; otherwise \a error is false.      \sa commandStarted(), done(), error(), errorString() */
end_comment
begin_comment
comment|/*!     \internal     \fn void QFtp::done(bool error)      This signal is emitted when the last pending command has finished;     (it is emitted after the last command's commandFinished() signal).     \a error is true if an error occurred during the processing;     otherwise \a error is false.      \sa commandFinished(), error(), errorString() */
end_comment
begin_comment
comment|/*!     \internal     \fn void QFtp::readyRead()      This signal is emitted in response to a get() command when there     is new data to read.      If you specify a device as the second argument in the get()     command, this signal is \e not emitted; instead the data is     written directly to the device.      You can read the data with the readAll() or read() functions.      This signal is useful if you want to process the data in chunks as     soon as it becomes available. If you are only interested in the     complete data, just connect to the commandFinished() signal and     read the data then instead.      \sa get(), read(), readAll(), bytesAvailable() */
end_comment
begin_comment
comment|/*!     \internal     \fn void QFtp::dataTransferProgress(qint64 done, qint64 total)      This signal is emitted in response to a get() or put() request to     indicate the current progress of the download or upload.      \a done is the amount of data that has already been transferred     and \a total is the total amount of data to be read or written. It     is possible that the QFtp class is not able to determine the total     amount of data that should be transferred, in which case \a total     is 0. (If you connect this signal to a QProgressBar, the progress     bar shows a busy indicator if the total is 0).      \warning \a done and \a total are not necessarily the size in     bytes, since for large files these values might need to be     "scaled" to avoid overflow.      \sa get(), put(), QProgressBar */
end_comment
begin_comment
comment|/*!     \internal     \fn void QFtp::rawCommandReply(int replyCode, const QString&detail);      This signal is emitted in response to the rawCommand() function.     \a replyCode is the 3 digit reply code and \a detail is the text     that follows the reply code.      \sa rawCommand() */
end_comment
begin_comment
comment|/*!     \internal     Connects to the FTP server \a host using port \a port.      The stateChanged() signal is emitted when the state of the     connecting process changes, e.g. to \c HostLookup, then \c     Connecting, then \c Connected.      The function does not block and returns immediately. The command     is scheduled, and its execution is performed asynchronously. The     function returns a unique identifier which is passed by     commandStarted() and commandFinished().      When the command is started the commandStarted() signal is     emitted. When it is finished the commandFinished() signal is     emitted.      \sa stateChanged(), commandStarted(), commandFinished() */
end_comment
begin_function
DECL|function|connectToHost
name|int
name|QFtp
operator|::
name|connectToHost
parameter_list|(
specifier|const
name|QString
modifier|&
name|host
parameter_list|,
name|quint16
name|port
parameter_list|)
block|{
name|QStringList
name|cmds
decl_stmt|;
name|cmds
operator|<<
name|host
expr_stmt|;
name|cmds
operator|<<
name|QString
operator|::
name|number
argument_list|(
operator|(
name|uint
operator|)
name|port
argument_list|)
expr_stmt|;
name|int
name|id
init|=
name|d_func
argument_list|()
operator|->
name|addCommand
argument_list|(
operator|new
name|QFtpCommand
argument_list|(
name|ConnectToHost
argument_list|,
name|cmds
argument_list|)
argument_list|)
decl_stmt|;
name|d_func
argument_list|()
operator|->
name|pi
operator|.
name|transferConnectionExtended
operator|=
literal|true
expr_stmt|;
return|return
name|id
return|;
block|}
end_function
begin_comment
comment|/*!     \internal     Logs in to the FTP server with the username \a user and the     password \a password.      The stateChanged() signal is emitted when the state of the     connecting process changes, e.g. to \c LoggedIn.      The function does not block and returns immediately. The command     is scheduled, and its execution is performed asynchronously. The     function returns a unique identifier which is passed by     commandStarted() and commandFinished().      When the command is started the commandStarted() signal is     emitted. When it is finished the commandFinished() signal is     emitted.      \sa commandStarted(), commandFinished() */
end_comment
begin_function
DECL|function|login
name|int
name|QFtp
operator|::
name|login
parameter_list|(
specifier|const
name|QString
modifier|&
name|user
parameter_list|,
specifier|const
name|QString
modifier|&
name|password
parameter_list|)
block|{
name|QStringList
name|cmds
decl_stmt|;
name|cmds
operator|<<
operator|(
name|QLatin1String
argument_list|(
literal|"USER "
argument_list|)
operator|+
operator|(
name|user
operator|.
name|isNull
argument_list|()
condition|?
name|QLatin1String
argument_list|(
literal|"anonymous"
argument_list|)
else|:
name|user
operator|)
operator|+
name|QLatin1String
argument_list|(
literal|"\r\n"
argument_list|)
operator|)
expr_stmt|;
name|cmds
operator|<<
operator|(
name|QLatin1String
argument_list|(
literal|"PASS "
argument_list|)
operator|+
operator|(
name|password
operator|.
name|isNull
argument_list|()
condition|?
name|QLatin1String
argument_list|(
literal|"anonymous@"
argument_list|)
else|:
name|password
operator|)
operator|+
name|QLatin1String
argument_list|(
literal|"\r\n"
argument_list|)
operator|)
expr_stmt|;
return|return
name|d_func
argument_list|()
operator|->
name|addCommand
argument_list|(
operator|new
name|QFtpCommand
argument_list|(
name|Login
argument_list|,
name|cmds
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal     Closes the connection to the FTP server.      The stateChanged() signal is emitted when the state of the     connecting process changes, e.g. to \c Closing, then \c     Unconnected.      The function does not block and returns immediately. The command     is scheduled, and its execution is performed asynchronously. The     function returns a unique identifier which is passed by     commandStarted() and commandFinished().      When the command is started the commandStarted() signal is     emitted. When it is finished the commandFinished() signal is     emitted.      \sa stateChanged(), commandStarted(), commandFinished() */
end_comment
begin_function
DECL|function|close
name|int
name|QFtp
operator|::
name|close
parameter_list|()
block|{
return|return
name|d_func
argument_list|()
operator|->
name|addCommand
argument_list|(
operator|new
name|QFtpCommand
argument_list|(
name|Close
argument_list|,
name|QStringList
argument_list|(
name|QLatin1String
argument_list|(
literal|"QUIT\r\n"
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal     Sets the current FTP transfer mode to \a mode. The default is QFtp::Passive.      \sa QFtp::TransferMode */
end_comment
begin_function
DECL|function|setTransferMode
name|int
name|QFtp
operator|::
name|setTransferMode
parameter_list|(
name|TransferMode
name|mode
parameter_list|)
block|{
name|int
name|id
init|=
name|d_func
argument_list|()
operator|->
name|addCommand
argument_list|(
operator|new
name|QFtpCommand
argument_list|(
name|SetTransferMode
argument_list|,
name|QStringList
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
name|d_func
argument_list|()
operator|->
name|pi
operator|.
name|transferConnectionExtended
operator|=
literal|true
expr_stmt|;
name|d_func
argument_list|()
operator|->
name|transferMode
operator|=
name|mode
expr_stmt|;
return|return
name|id
return|;
block|}
end_function
begin_comment
comment|/*!     \internal     Enables use of the FTP proxy on host \a host and port \a     port. Calling this function with \a host empty disables proxying.      QFtp does not support FTP-over-HTTP proxy servers. Use     QNetworkAccessManager for this. */
end_comment
begin_function
DECL|function|setProxy
name|int
name|QFtp
operator|::
name|setProxy
parameter_list|(
specifier|const
name|QString
modifier|&
name|host
parameter_list|,
name|quint16
name|port
parameter_list|)
block|{
name|QStringList
name|args
decl_stmt|;
name|args
operator|<<
name|host
operator|<<
name|QString
operator|::
name|number
argument_list|(
name|port
argument_list|)
expr_stmt|;
return|return
name|d_func
argument_list|()
operator|->
name|addCommand
argument_list|(
operator|new
name|QFtpCommand
argument_list|(
name|SetProxy
argument_list|,
name|args
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal     Lists the contents of directory \a dir on the FTP server. If \a     dir is empty, it lists the contents of the current directory.      The listInfo() signal is emitted for each directory entry found.      The function does not block and returns immediately. The command     is scheduled, and its execution is performed asynchronously. The     function returns a unique identifier which is passed by     commandStarted() and commandFinished().      When the command is started the commandStarted() signal is     emitted. When it is finished the commandFinished() signal is     emitted.      \sa listInfo(), commandStarted(), commandFinished() */
end_comment
begin_function
DECL|function|list
name|int
name|QFtp
operator|::
name|list
parameter_list|(
specifier|const
name|QString
modifier|&
name|dir
parameter_list|)
block|{
name|QStringList
name|cmds
decl_stmt|;
name|cmds
operator|<<
name|QLatin1String
argument_list|(
literal|"TYPE A\r\n"
argument_list|)
expr_stmt|;
name|cmds
operator|<<
name|QLatin1String
argument_list|(
name|d_func
argument_list|()
operator|->
name|transferMode
operator|==
name|Passive
condition|?
literal|"PASV\r\n"
else|:
literal|"PORT\r\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
operator|.
name|isEmpty
argument_list|()
condition|)
name|cmds
operator|<<
name|QLatin1String
argument_list|(
literal|"LIST\r\n"
argument_list|)
expr_stmt|;
else|else
name|cmds
operator|<<
operator|(
name|QLatin1String
argument_list|(
literal|"LIST "
argument_list|)
operator|+
name|dir
operator|+
name|QLatin1String
argument_list|(
literal|"\r\n"
argument_list|)
operator|)
expr_stmt|;
return|return
name|d_func
argument_list|()
operator|->
name|addCommand
argument_list|(
operator|new
name|QFtpCommand
argument_list|(
name|List
argument_list|,
name|cmds
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal     Changes the working directory of the server to \a dir.      The function does not block and returns immediately. The command     is scheduled, and its execution is performed asynchronously. The     function returns a unique identifier which is passed by     commandStarted() and commandFinished().      When the command is started the commandStarted() signal is     emitted. When it is finished the commandFinished() signal is     emitted.      \sa commandStarted(), commandFinished() */
end_comment
begin_function
DECL|function|cd
name|int
name|QFtp
operator|::
name|cd
parameter_list|(
specifier|const
name|QString
modifier|&
name|dir
parameter_list|)
block|{
return|return
name|d_func
argument_list|()
operator|->
name|addCommand
argument_list|(
operator|new
name|QFtpCommand
argument_list|(
name|Cd
argument_list|,
name|QStringList
argument_list|(
name|QLatin1String
argument_list|(
literal|"CWD "
argument_list|)
operator|+
name|dir
operator|+
name|QLatin1String
argument_list|(
literal|"\r\n"
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal     Downloads the file \a file from the server.      If \a dev is 0, then the readyRead() signal is emitted when there     is data available to read. You can then read the data with the     read() or readAll() functions.      If \a dev is not 0, the data is written directly to the device \a     dev. Make sure that the \a dev pointer is valid for the duration     of the operation (it is safe to delete it when the     commandFinished() signal is emitted). In this case the readyRead()     signal is \e not emitted and you cannot read data with the     read() or readAll() functions.      If you don't read the data immediately it becomes available, i.e.     when the readyRead() signal is emitted, it is still available     until the next command is started.      For example, if you want to present the data to the user as soon     as there is something available, connect to the readyRead() signal     and read the data immediately. On the other hand, if you only want     to work with the complete data, you can connect to the     commandFinished() signal and read the data when the get() command     is finished.      The data is transferred as Binary or Ascii depending on the value     of \a type.      The function does not block and returns immediately. The command     is scheduled, and its execution is performed asynchronously. The     function returns a unique identifier which is passed by     commandStarted() and commandFinished().      When the command is started the commandStarted() signal is     emitted. When it is finished the commandFinished() signal is     emitted.      \sa readyRead(), dataTransferProgress(), commandStarted(),     commandFinished() */
end_comment
begin_function
DECL|function|get
name|int
name|QFtp
operator|::
name|get
parameter_list|(
specifier|const
name|QString
modifier|&
name|file
parameter_list|,
name|QIODevice
modifier|*
name|dev
parameter_list|,
name|TransferType
name|type
parameter_list|)
block|{
name|QStringList
name|cmds
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|Binary
condition|)
name|cmds
operator|<<
name|QLatin1String
argument_list|(
literal|"TYPE I\r\n"
argument_list|)
expr_stmt|;
else|else
name|cmds
operator|<<
name|QLatin1String
argument_list|(
literal|"TYPE A\r\n"
argument_list|)
expr_stmt|;
name|cmds
operator|<<
name|QLatin1String
argument_list|(
literal|"SIZE "
argument_list|)
operator|+
name|file
operator|+
name|QLatin1String
argument_list|(
literal|"\r\n"
argument_list|)
expr_stmt|;
name|cmds
operator|<<
name|QLatin1String
argument_list|(
name|d_func
argument_list|()
operator|->
name|transferMode
operator|==
name|Passive
condition|?
literal|"PASV\r\n"
else|:
literal|"PORT\r\n"
argument_list|)
expr_stmt|;
name|cmds
operator|<<
name|QLatin1String
argument_list|(
literal|"RETR "
argument_list|)
operator|+
name|file
operator|+
name|QLatin1String
argument_list|(
literal|"\r\n"
argument_list|)
expr_stmt|;
return|return
name|d_func
argument_list|()
operator|->
name|addCommand
argument_list|(
operator|new
name|QFtpCommand
argument_list|(
name|Get
argument_list|,
name|cmds
argument_list|,
name|dev
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal     \overload      Writes a copy of the given \a data to the file called \a file on     the server. The progress of the upload is reported by the     dataTransferProgress() signal.      The data is transferred as Binary or Ascii depending on the value     of \a type.      The function does not block and returns immediately. The command     is scheduled, and its execution is performed asynchronously. The     function returns a unique identifier which is passed by     commandStarted() and commandFinished().      When the command is started the commandStarted() signal is     emitted. When it is finished the commandFinished() signal is     emitted.      Since this function takes a copy of the \a data, you can discard     your own copy when this function returns.      \sa dataTransferProgress(), commandStarted(), commandFinished() */
end_comment
begin_function
DECL|function|put
name|int
name|QFtp
operator|::
name|put
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|data
parameter_list|,
specifier|const
name|QString
modifier|&
name|file
parameter_list|,
name|TransferType
name|type
parameter_list|)
block|{
name|QStringList
name|cmds
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|Binary
condition|)
name|cmds
operator|<<
name|QLatin1String
argument_list|(
literal|"TYPE I\r\n"
argument_list|)
expr_stmt|;
else|else
name|cmds
operator|<<
name|QLatin1String
argument_list|(
literal|"TYPE A\r\n"
argument_list|)
expr_stmt|;
name|cmds
operator|<<
name|QLatin1String
argument_list|(
name|d_func
argument_list|()
operator|->
name|transferMode
operator|==
name|Passive
condition|?
literal|"PASV\r\n"
else|:
literal|"PORT\r\n"
argument_list|)
expr_stmt|;
name|cmds
operator|<<
name|QLatin1String
argument_list|(
literal|"ALLO "
argument_list|)
operator|+
name|QString
operator|::
name|number
argument_list|(
name|data
operator|.
name|size
argument_list|()
argument_list|)
operator|+
name|QLatin1String
argument_list|(
literal|"\r\n"
argument_list|)
expr_stmt|;
name|cmds
operator|<<
name|QLatin1String
argument_list|(
literal|"STOR "
argument_list|)
operator|+
name|file
operator|+
name|QLatin1String
argument_list|(
literal|"\r\n"
argument_list|)
expr_stmt|;
return|return
name|d_func
argument_list|()
operator|->
name|addCommand
argument_list|(
operator|new
name|QFtpCommand
argument_list|(
name|Put
argument_list|,
name|cmds
argument_list|,
name|data
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal     Reads the data from the IO device \a dev, and writes it to the     file called \a file on the server. The data is read in chunks from     the IO device, so this overload allows you to transmit large     amounts of data without the need to read all the data into memory     at once.      The data is transferred as Binary or Ascii depending on the value     of \a type.      Make sure that the \a dev pointer is valid for the duration of the     operation (it is safe to delete it when the commandFinished() is     emitted). */
end_comment
begin_function
DECL|function|put
name|int
name|QFtp
operator|::
name|put
parameter_list|(
name|QIODevice
modifier|*
name|dev
parameter_list|,
specifier|const
name|QString
modifier|&
name|file
parameter_list|,
name|TransferType
name|type
parameter_list|)
block|{
name|QStringList
name|cmds
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|Binary
condition|)
name|cmds
operator|<<
name|QLatin1String
argument_list|(
literal|"TYPE I\r\n"
argument_list|)
expr_stmt|;
else|else
name|cmds
operator|<<
name|QLatin1String
argument_list|(
literal|"TYPE A\r\n"
argument_list|)
expr_stmt|;
name|cmds
operator|<<
name|QLatin1String
argument_list|(
name|d_func
argument_list|()
operator|->
name|transferMode
operator|==
name|Passive
condition|?
literal|"PASV\r\n"
else|:
literal|"PORT\r\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev
operator|->
name|isSequential
argument_list|()
condition|)
name|cmds
operator|<<
name|QLatin1String
argument_list|(
literal|"ALLO "
argument_list|)
operator|+
name|QString
operator|::
name|number
argument_list|(
name|dev
operator|->
name|size
argument_list|()
argument_list|)
operator|+
name|QLatin1String
argument_list|(
literal|"\r\n"
argument_list|)
expr_stmt|;
name|cmds
operator|<<
name|QLatin1String
argument_list|(
literal|"STOR "
argument_list|)
operator|+
name|file
operator|+
name|QLatin1String
argument_list|(
literal|"\r\n"
argument_list|)
expr_stmt|;
return|return
name|d_func
argument_list|()
operator|->
name|addCommand
argument_list|(
operator|new
name|QFtpCommand
argument_list|(
name|Put
argument_list|,
name|cmds
argument_list|,
name|dev
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal     Deletes the file called \a file from the server.      The function does not block and returns immediately. The command     is scheduled, and its execution is performed asynchronously. The     function returns a unique identifier which is passed by     commandStarted() and commandFinished().      When the command is started the commandStarted() signal is     emitted. When it is finished the commandFinished() signal is     emitted.      \sa commandStarted(), commandFinished() */
end_comment
begin_function
DECL|function|remove
name|int
name|QFtp
operator|::
name|remove
parameter_list|(
specifier|const
name|QString
modifier|&
name|file
parameter_list|)
block|{
return|return
name|d_func
argument_list|()
operator|->
name|addCommand
argument_list|(
operator|new
name|QFtpCommand
argument_list|(
name|Remove
argument_list|,
name|QStringList
argument_list|(
name|QLatin1String
argument_list|(
literal|"DELE "
argument_list|)
operator|+
name|file
operator|+
name|QLatin1String
argument_list|(
literal|"\r\n"
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal     Creates a directory called \a dir on the server.      The function does not block and returns immediately. The command     is scheduled, and its execution is performed asynchronously. The     function returns a unique identifier which is passed by     commandStarted() and commandFinished().      When the command is started the commandStarted() signal is     emitted. When it is finished the commandFinished() signal is     emitted.      \sa commandStarted(), commandFinished() */
end_comment
begin_function
DECL|function|mkdir
name|int
name|QFtp
operator|::
name|mkdir
parameter_list|(
specifier|const
name|QString
modifier|&
name|dir
parameter_list|)
block|{
return|return
name|d_func
argument_list|()
operator|->
name|addCommand
argument_list|(
operator|new
name|QFtpCommand
argument_list|(
name|Mkdir
argument_list|,
name|QStringList
argument_list|(
name|QLatin1String
argument_list|(
literal|"MKD "
argument_list|)
operator|+
name|dir
operator|+
name|QLatin1String
argument_list|(
literal|"\r\n"
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal     Removes the directory called \a dir from the server.      The function does not block and returns immediately. The command     is scheduled, and its execution is performed asynchronously. The     function returns a unique identifier which is passed by     commandStarted() and commandFinished().      When the command is started the commandStarted() signal is     emitted. When it is finished the commandFinished() signal is     emitted.      \sa commandStarted(), commandFinished() */
end_comment
begin_function
DECL|function|rmdir
name|int
name|QFtp
operator|::
name|rmdir
parameter_list|(
specifier|const
name|QString
modifier|&
name|dir
parameter_list|)
block|{
return|return
name|d_func
argument_list|()
operator|->
name|addCommand
argument_list|(
operator|new
name|QFtpCommand
argument_list|(
name|Rmdir
argument_list|,
name|QStringList
argument_list|(
name|QLatin1String
argument_list|(
literal|"RMD "
argument_list|)
operator|+
name|dir
operator|+
name|QLatin1String
argument_list|(
literal|"\r\n"
argument_list|)
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal     Renames the file called \a oldname to \a newname on the server.      The function does not block and returns immediately. The command     is scheduled, and its execution is performed asynchronously. The     function returns a unique identifier which is passed by     commandStarted() and commandFinished().      When the command is started the commandStarted() signal is     emitted. When it is finished the commandFinished() signal is     emitted.      \sa commandStarted(), commandFinished() */
end_comment
begin_function
DECL|function|rename
name|int
name|QFtp
operator|::
name|rename
parameter_list|(
specifier|const
name|QString
modifier|&
name|oldname
parameter_list|,
specifier|const
name|QString
modifier|&
name|newname
parameter_list|)
block|{
name|QStringList
name|cmds
decl_stmt|;
name|cmds
operator|<<
name|QLatin1String
argument_list|(
literal|"RNFR "
argument_list|)
operator|+
name|oldname
operator|+
name|QLatin1String
argument_list|(
literal|"\r\n"
argument_list|)
expr_stmt|;
name|cmds
operator|<<
name|QLatin1String
argument_list|(
literal|"RNTO "
argument_list|)
operator|+
name|newname
operator|+
name|QLatin1String
argument_list|(
literal|"\r\n"
argument_list|)
expr_stmt|;
return|return
name|d_func
argument_list|()
operator|->
name|addCommand
argument_list|(
operator|new
name|QFtpCommand
argument_list|(
name|Rename
argument_list|,
name|cmds
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal     Sends the raw FTP command \a command to the FTP server. This is     useful for low-level FTP access. If the operation you wish to     perform has an equivalent QFtp function, we recommend using the     function instead of raw FTP commands since the functions are     easier and safer.      The function does not block and returns immediately. The command     is scheduled, and its execution is performed asynchronously. The     function returns a unique identifier which is passed by     commandStarted() and commandFinished().      When the command is started the commandStarted() signal is     emitted. When it is finished the commandFinished() signal is     emitted.      \sa rawCommandReply(), commandStarted(), commandFinished() */
end_comment
begin_function
DECL|function|rawCommand
name|int
name|QFtp
operator|::
name|rawCommand
parameter_list|(
specifier|const
name|QString
modifier|&
name|command
parameter_list|)
block|{
name|QString
name|cmd
init|=
name|command
operator|.
name|trimmed
argument_list|()
operator|+
name|QLatin1String
argument_list|(
literal|"\r\n"
argument_list|)
decl_stmt|;
return|return
name|d_func
argument_list|()
operator|->
name|addCommand
argument_list|(
operator|new
name|QFtpCommand
argument_list|(
name|RawCommand
argument_list|,
name|QStringList
argument_list|(
name|cmd
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal     Returns the number of bytes that can be read from the data socket     at the moment.      \sa get(), readyRead(), read(), readAll() */
end_comment
begin_function
DECL|function|bytesAvailable
name|qint64
name|QFtp
operator|::
name|bytesAvailable
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|pi
operator|.
name|dtp
operator|.
name|bytesAvailable
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \internal     Reads \a maxlen bytes from the data socket into \a data and     returns the number of bytes read. Returns -1 if an error occurred.      \sa get(), readyRead(), bytesAvailable(), readAll() */
end_comment
begin_function
DECL|function|read
name|qint64
name|QFtp
operator|::
name|read
parameter_list|(
name|char
modifier|*
name|data
parameter_list|,
name|qint64
name|maxlen
parameter_list|)
block|{
return|return
name|d_func
argument_list|()
operator|->
name|pi
operator|.
name|dtp
operator|.
name|read
argument_list|(
name|data
argument_list|,
name|maxlen
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal     Reads all the bytes available from the data socket and returns     them.      \sa get(), readyRead(), bytesAvailable(), read() */
end_comment
begin_function
DECL|function|readAll
name|QByteArray
name|QFtp
operator|::
name|readAll
parameter_list|()
block|{
return|return
name|d_func
argument_list|()
operator|->
name|pi
operator|.
name|dtp
operator|.
name|readAll
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \internal     Aborts the current command and deletes all scheduled commands.      If there is an unfinished command (i.e. a command for which the     commandStarted() signal has been emitted, but for which the     commandFinished() signal has not been emitted), this function     sends an \c ABORT command to the server. When the server replies     that the command is aborted, the commandFinished() signal with the     \c error argument set to \c true is emitted for the command. Due     to timing issues, it is possible that the command had already     finished before the abort request reached the server, in which     case, the commandFinished() signal is emitted with the \c error     argument set to \c false.      For all other commands that are affected by the abort(), no     signals are emitted.      If you don't start further FTP commands directly after the     abort(), there won't be any scheduled commands and the done()     signal is emitted.      \warning Some FTP servers, for example the BSD FTP daemon (version     0.3), wrongly return a positive reply even when an abort has     occurred. For these servers the commandFinished() signal has its     error flag set to \c false, even though the command did not     complete successfully.      \sa clearPendingCommands() */
end_comment
begin_function
DECL|function|abort
name|void
name|QFtp
operator|::
name|abort
parameter_list|()
block|{
if|if
condition|(
name|d_func
argument_list|()
operator|->
name|pending
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|clearPendingCommands
argument_list|()
expr_stmt|;
name|d_func
argument_list|()
operator|->
name|pi
operator|.
name|abort
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal     Returns the identifier of the FTP command that is being executed     or 0 if there is no command being executed.      \sa currentCommand() */
end_comment
begin_function
DECL|function|currentId
name|int
name|QFtp
operator|::
name|currentId
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|d_func
argument_list|()
operator|->
name|pending
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|0
return|;
return|return
name|d_func
argument_list|()
operator|->
name|pending
operator|.
name|first
argument_list|()
operator|->
name|id
return|;
block|}
end_function
begin_comment
comment|/*!     \internal     Returns the command type of the FTP command being executed or \c     None if there is no command being executed.      \sa currentId() */
end_comment
begin_function
DECL|function|currentCommand
name|QFtp
operator|::
name|Command
name|QFtp
operator|::
name|currentCommand
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|d_func
argument_list|()
operator|->
name|pending
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|None
return|;
return|return
name|d_func
argument_list|()
operator|->
name|pending
operator|.
name|first
argument_list|()
operator|->
name|command
return|;
block|}
end_function
begin_comment
comment|/*!     \internal     Returns the QIODevice pointer that is used by the FTP command to read data     from or store data to. If there is no current FTP command being executed or     if the command does not use an IO device, this function returns 0.      This function can be used to delete the QIODevice in the slot connected to     the commandFinished() signal.      \sa get(), put() */
end_comment
begin_function
DECL|function|currentDevice
name|QIODevice
modifier|*
name|QFtp
operator|::
name|currentDevice
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|d_func
argument_list|()
operator|->
name|pending
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|0
return|;
name|QFtpCommand
modifier|*
name|c
init|=
name|d_func
argument_list|()
operator|->
name|pending
operator|.
name|first
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|is_ba
condition|)
return|return
literal|0
return|;
return|return
name|c
operator|->
name|data
operator|.
name|dev
return|;
block|}
end_function
begin_comment
comment|/*!     \internal     Returns true if there are any commands scheduled that have not yet     been executed; otherwise returns false.      The command that is being executed is \e not considered as a     scheduled command.      \sa clearPendingCommands(), currentId(), currentCommand() */
end_comment
begin_function
DECL|function|hasPendingCommands
name|bool
name|QFtp
operator|::
name|hasPendingCommands
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|pending
operator|.
name|count
argument_list|()
operator|>
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!     \internal     Deletes all pending commands from the list of scheduled commands.     This does not affect the command that is being executed. If you     want to stop this as well, use abort().      \sa hasPendingCommands(), abort() */
end_comment
begin_function
DECL|function|clearPendingCommands
name|void
name|QFtp
operator|::
name|clearPendingCommands
parameter_list|()
block|{
comment|// delete all entires except the first one
while|while
condition|(
name|d_func
argument_list|()
operator|->
name|pending
operator|.
name|count
argument_list|()
operator|>
literal|1
condition|)
operator|delete
name|d_func
argument_list|()
operator|->
name|pending
operator|.
name|takeLast
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal     Returns the current state of the object. When the state changes,     the stateChanged() signal is emitted.      \sa State, stateChanged() */
end_comment
begin_function
DECL|function|state
name|QFtp
operator|::
name|State
name|QFtp
operator|::
name|state
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|state
return|;
block|}
end_function
begin_comment
comment|/*!     \internal     Returns the last error that occurred. This is useful to find out     what went wrong when receiving a commandFinished() or a done()     signal with the \c error argument set to \c true.      If you start a new command, the error status is reset to \c NoError. */
end_comment
begin_function
DECL|function|error
name|QFtp
operator|::
name|Error
name|QFtp
operator|::
name|error
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|error
return|;
block|}
end_function
begin_comment
comment|/*!     \internal     Returns a human-readable description of the last error that     occurred. This is useful for presenting a error message to the     user when receiving a commandFinished() or a done() signal with     the \c error argument set to \c true.      The error string is often (but not always) the reply from the     server, so it is not always possible to translate the string. If     the message comes from Qt, the string has already passed through     tr(). */
end_comment
begin_function
DECL|function|errorString
name|QString
name|QFtp
operator|::
name|errorString
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|errorString
return|;
block|}
end_function
begin_comment
comment|/*! \internal */
end_comment
begin_function
DECL|function|_q_startNextCommand
name|void
name|QFtpPrivate
operator|::
name|_q_startNextCommand
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QFtp
argument_list|)
expr_stmt|;
if|if
condition|(
name|pending
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|QFtpCommand
modifier|*
name|c
init|=
name|pending
operator|.
name|first
argument_list|()
decl_stmt|;
name|error
operator|=
name|QFtp
operator|::
name|NoError
expr_stmt|;
name|errorString
operator|=
name|QT_TRANSLATE_NOOP
argument_list|(
name|QFtp
argument_list|,
name|QLatin1String
argument_list|(
literal|"Unknown error"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|bytesAvailable
argument_list|()
condition|)
name|q
operator|->
name|readAll
argument_list|()
expr_stmt|;
comment|// clear the data
emit|emit
name|q
operator|->
name|commandStarted
argument_list|(
name|c
operator|->
name|id
argument_list|)
emit|;
comment|// Proxy support, replace the Login argument in place, then fall
comment|// through.
if|if
condition|(
name|c
operator|->
name|command
operator|==
name|QFtp
operator|::
name|Login
operator|&&
operator|!
name|proxyHost
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QString
name|loginString
init|=
name|c
operator|->
name|rawCmds
operator|.
name|first
argument_list|()
operator|.
name|trimmed
argument_list|()
decl_stmt|;
name|loginString
operator|+=
name|QLatin1Char
argument_list|(
literal|'@'
argument_list|)
operator|+
name|host
expr_stmt|;
if|if
condition|(
name|port
operator|&&
name|port
operator|!=
literal|21
condition|)
name|loginString
operator|+=
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
operator|+
name|QString
operator|::
name|number
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|loginString
operator|+=
name|QLatin1String
argument_list|(
literal|"\r\n"
argument_list|)
expr_stmt|;
name|c
operator|->
name|rawCmds
index|[
literal|0
index|]
operator|=
name|loginString
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|->
name|command
operator|==
name|QFtp
operator|::
name|SetTransferMode
condition|)
block|{
name|_q_piFinished
argument_list|(
name|QLatin1String
argument_list|(
literal|"Transfer mode set"
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|->
name|command
operator|==
name|QFtp
operator|::
name|SetProxy
condition|)
block|{
name|proxyHost
operator|=
name|c
operator|->
name|rawCmds
index|[
literal|0
index|]
expr_stmt|;
name|proxyPort
operator|=
name|c
operator|->
name|rawCmds
index|[
literal|1
index|]
operator|.
name|toUInt
argument_list|()
expr_stmt|;
name|c
operator|->
name|rawCmds
operator|.
name|clear
argument_list|()
expr_stmt|;
name|_q_piFinished
argument_list|(
name|QLatin1String
argument_list|(
literal|"Proxy set to "
argument_list|)
operator|+
name|proxyHost
operator|+
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
operator|+
name|QString
operator|::
name|number
argument_list|(
name|proxyPort
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|->
name|command
operator|==
name|QFtp
operator|::
name|ConnectToHost
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_BEARERMANAGEMENT
comment|//copy network session down to the PI
name|pi
operator|.
name|setProperty
argument_list|(
literal|"_q_networksession"
argument_list|,
name|q
operator|->
name|property
argument_list|(
literal|"_q_networksession"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|proxyHost
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|host
operator|=
name|c
operator|->
name|rawCmds
index|[
literal|0
index|]
expr_stmt|;
name|port
operator|=
name|c
operator|->
name|rawCmds
index|[
literal|1
index|]
operator|.
name|toUInt
argument_list|()
expr_stmt|;
name|pi
operator|.
name|connectToHost
argument_list|(
name|proxyHost
argument_list|,
name|proxyPort
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pi
operator|.
name|connectToHost
argument_list|(
name|c
operator|->
name|rawCmds
index|[
literal|0
index|]
argument_list|,
name|c
operator|->
name|rawCmds
index|[
literal|1
index|]
operator|.
name|toUInt
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|c
operator|->
name|command
operator|==
name|QFtp
operator|::
name|Put
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|is_ba
condition|)
block|{
name|pi
operator|.
name|dtp
operator|.
name|setData
argument_list|(
name|c
operator|->
name|data
operator|.
name|ba
argument_list|)
expr_stmt|;
name|pi
operator|.
name|dtp
operator|.
name|setBytesTotal
argument_list|(
name|c
operator|->
name|data
operator|.
name|ba
operator|->
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|->
name|data
operator|.
name|dev
operator|&&
operator|(
name|c
operator|->
name|data
operator|.
name|dev
operator|->
name|isOpen
argument_list|()
operator|||
name|c
operator|->
name|data
operator|.
name|dev
operator|->
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
operator|)
condition|)
block|{
name|pi
operator|.
name|dtp
operator|.
name|setDevice
argument_list|(
name|c
operator|->
name|data
operator|.
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|data
operator|.
name|dev
operator|->
name|isSequential
argument_list|()
condition|)
block|{
name|pi
operator|.
name|dtp
operator|.
name|setBytesTotal
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|pi
operator|.
name|dtp
operator|.
name|connect
argument_list|(
name|c
operator|->
name|data
operator|.
name|dev
argument_list|,
name|SIGNAL
argument_list|(
name|readyRead
argument_list|()
argument_list|)
argument_list|,
name|SLOT
argument_list|(
name|dataReadyRead
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|pi
operator|.
name|dtp
operator|.
name|connect
argument_list|(
name|c
operator|->
name|data
operator|.
name|dev
argument_list|,
name|SIGNAL
argument_list|(
name|readChannelFinished
argument_list|()
argument_list|)
argument_list|,
name|SLOT
argument_list|(
name|dataReadyRead
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pi
operator|.
name|dtp
operator|.
name|setBytesTotal
argument_list|(
name|c
operator|->
name|data
operator|.
name|dev
operator|->
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|->
name|command
operator|==
name|QFtp
operator|::
name|Get
condition|)
block|{
if|if
condition|(
operator|!
name|c
operator|->
name|is_ba
operator|&&
name|c
operator|->
name|data
operator|.
name|dev
condition|)
block|{
name|pi
operator|.
name|dtp
operator|.
name|setDevice
argument_list|(
name|c
operator|->
name|data
operator|.
name|dev
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|->
name|command
operator|==
name|QFtp
operator|::
name|Close
condition|)
block|{
name|state
operator|=
name|QFtp
operator|::
name|Closing
expr_stmt|;
emit|emit
name|q
operator|->
name|stateChanged
argument_list|(
name|state
argument_list|)
emit|;
block|}
name|pi
operator|.
name|sendCommands
argument_list|(
name|c
operator|->
name|rawCmds
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*! \internal */
end_comment
begin_function
DECL|function|_q_piFinished
name|void
name|QFtpPrivate
operator|::
name|_q_piFinished
parameter_list|(
specifier|const
name|QString
modifier|&
parameter_list|)
block|{
if|if
condition|(
name|pending
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
name|QFtpCommand
modifier|*
name|c
init|=
name|pending
operator|.
name|first
argument_list|()
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|command
operator|==
name|QFtp
operator|::
name|Close
condition|)
block|{
comment|// The order of in which the slots are called is arbitrary, so
comment|// disconnect the SIGNAL-SIGNAL temporary to make sure that we
comment|// don't get the commandFinished() signal before the stateChanged()
comment|// signal.
if|if
condition|(
name|state
operator|!=
name|QFtp
operator|::
name|Unconnected
condition|)
block|{
name|close_waitForStateChange
operator|=
literal|true
expr_stmt|;
return|return;
block|}
block|}
emit|emit
name|q_func
argument_list|()
operator|->
name|commandFinished
argument_list|(
name|c
operator|->
name|id
argument_list|,
literal|false
argument_list|)
emit|;
name|pending
operator|.
name|removeFirst
argument_list|()
expr_stmt|;
operator|delete
name|c
expr_stmt|;
if|if
condition|(
name|pending
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
emit|emit
name|q_func
argument_list|()
operator|->
name|done
argument_list|(
literal|false
argument_list|)
emit|;
block|}
else|else
block|{
name|_q_startNextCommand
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*! \internal */
end_comment
begin_function
DECL|function|_q_piError
name|void
name|QFtpPrivate
operator|::
name|_q_piError
parameter_list|(
name|int
name|errorCode
parameter_list|,
specifier|const
name|QString
modifier|&
name|text
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QFtp
argument_list|)
expr_stmt|;
if|if
condition|(
name|pending
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QFtpPrivate::_q_piError was called without pending command!"
argument_list|)
expr_stmt|;
return|return;
block|}
name|QFtpCommand
modifier|*
name|c
init|=
name|pending
operator|.
name|first
argument_list|()
decl_stmt|;
comment|// non-fatal errors
if|if
condition|(
name|c
operator|->
name|command
operator|==
name|QFtp
operator|::
name|Get
operator|&&
name|pi
operator|.
name|currentCommand
argument_list|()
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"SIZE "
argument_list|)
argument_list|)
condition|)
block|{
name|pi
operator|.
name|dtp
operator|.
name|setBytesTotal
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|c
operator|->
name|command
operator|==
name|QFtp
operator|::
name|Put
operator|&&
name|pi
operator|.
name|currentCommand
argument_list|()
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"ALLO "
argument_list|)
argument_list|)
condition|)
block|{
return|return;
block|}
name|error
operator|=
name|QFtp
operator|::
name|Error
argument_list|(
name|errorCode
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|q
operator|->
name|currentCommand
argument_list|()
condition|)
block|{
case|case
name|QFtp
operator|::
name|ConnectToHost
case|:
name|errorString
operator|=
name|QString
operator|::
name|fromLatin1
argument_list|(
name|QT_TRANSLATE_NOOP
argument_list|(
literal|"QFtp"
argument_list|,
literal|"Connecting to host failed:\n%1"
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|text
argument_list|)
expr_stmt|;
break|break;
case|case
name|QFtp
operator|::
name|Login
case|:
name|errorString
operator|=
name|QString
operator|::
name|fromLatin1
argument_list|(
name|QT_TRANSLATE_NOOP
argument_list|(
literal|"QFtp"
argument_list|,
literal|"Login failed:\n%1"
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|text
argument_list|)
expr_stmt|;
break|break;
case|case
name|QFtp
operator|::
name|List
case|:
name|errorString
operator|=
name|QString
operator|::
name|fromLatin1
argument_list|(
name|QT_TRANSLATE_NOOP
argument_list|(
literal|"QFtp"
argument_list|,
literal|"Listing directory failed:\n%1"
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|text
argument_list|)
expr_stmt|;
break|break;
case|case
name|QFtp
operator|::
name|Cd
case|:
name|errorString
operator|=
name|QString
operator|::
name|fromLatin1
argument_list|(
name|QT_TRANSLATE_NOOP
argument_list|(
literal|"QFtp"
argument_list|,
literal|"Changing directory failed:\n%1"
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|text
argument_list|)
expr_stmt|;
break|break;
case|case
name|QFtp
operator|::
name|Get
case|:
name|errorString
operator|=
name|QString
operator|::
name|fromLatin1
argument_list|(
name|QT_TRANSLATE_NOOP
argument_list|(
literal|"QFtp"
argument_list|,
literal|"Downloading file failed:\n%1"
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|text
argument_list|)
expr_stmt|;
break|break;
case|case
name|QFtp
operator|::
name|Put
case|:
name|errorString
operator|=
name|QString
operator|::
name|fromLatin1
argument_list|(
name|QT_TRANSLATE_NOOP
argument_list|(
literal|"QFtp"
argument_list|,
literal|"Uploading file failed:\n%1"
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|text
argument_list|)
expr_stmt|;
break|break;
case|case
name|QFtp
operator|::
name|Remove
case|:
name|errorString
operator|=
name|QString
operator|::
name|fromLatin1
argument_list|(
name|QT_TRANSLATE_NOOP
argument_list|(
literal|"QFtp"
argument_list|,
literal|"Removing file failed:\n%1"
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|text
argument_list|)
expr_stmt|;
break|break;
case|case
name|QFtp
operator|::
name|Mkdir
case|:
name|errorString
operator|=
name|QString
operator|::
name|fromLatin1
argument_list|(
name|QT_TRANSLATE_NOOP
argument_list|(
literal|"QFtp"
argument_list|,
literal|"Creating directory failed:\n%1"
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|text
argument_list|)
expr_stmt|;
break|break;
case|case
name|QFtp
operator|::
name|Rmdir
case|:
name|errorString
operator|=
name|QString
operator|::
name|fromLatin1
argument_list|(
name|QT_TRANSLATE_NOOP
argument_list|(
literal|"QFtp"
argument_list|,
literal|"Removing directory failed:\n%1"
argument_list|)
argument_list|)
operator|.
name|arg
argument_list|(
name|text
argument_list|)
expr_stmt|;
break|break;
default|default:
name|errorString
operator|=
name|text
expr_stmt|;
break|break;
block|}
name|pi
operator|.
name|clearPendingCommands
argument_list|()
expr_stmt|;
name|q
operator|->
name|clearPendingCommands
argument_list|()
expr_stmt|;
emit|emit
name|q
operator|->
name|commandFinished
argument_list|(
name|c
operator|->
name|id
argument_list|,
literal|true
argument_list|)
emit|;
name|pending
operator|.
name|removeFirst
argument_list|()
expr_stmt|;
operator|delete
name|c
expr_stmt|;
if|if
condition|(
name|pending
operator|.
name|isEmpty
argument_list|()
condition|)
emit|emit
name|q
operator|->
name|done
argument_list|(
literal|true
argument_list|)
emit|;
else|else
name|_q_startNextCommand
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \internal */
end_comment
begin_function
DECL|function|_q_piConnectState
name|void
name|QFtpPrivate
operator|::
name|_q_piConnectState
parameter_list|(
name|int
name|connectState
parameter_list|)
block|{
name|state
operator|=
name|QFtp
operator|::
name|State
argument_list|(
name|connectState
argument_list|)
expr_stmt|;
emit|emit
name|q_func
argument_list|()
operator|->
name|stateChanged
argument_list|(
name|state
argument_list|)
emit|;
if|if
condition|(
name|close_waitForStateChange
condition|)
block|{
name|close_waitForStateChange
operator|=
literal|false
expr_stmt|;
name|_q_piFinished
argument_list|(
name|QLatin1String
argument_list|(
name|QT_TRANSLATE_NOOP
argument_list|(
literal|"QFtp"
argument_list|,
literal|"Connection closed"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*! \internal */
end_comment
begin_function
DECL|function|_q_piFtpReply
name|void
name|QFtpPrivate
operator|::
name|_q_piFtpReply
parameter_list|(
name|int
name|code
parameter_list|,
specifier|const
name|QString
modifier|&
name|text
parameter_list|)
block|{
if|if
condition|(
name|q_func
argument_list|()
operator|->
name|currentCommand
argument_list|()
operator|==
name|QFtp
operator|::
name|RawCommand
condition|)
block|{
name|pi
operator|.
name|rawCommand
operator|=
literal|true
expr_stmt|;
emit|emit
name|q_func
argument_list|()
operator|->
name|rawCommandReply
argument_list|(
name|code
argument_list|,
name|text
argument_list|)
emit|;
block|}
block|}
end_function
begin_comment
comment|/*!     \internal     Destructor. */
end_comment
begin_destructor
DECL|function|~QFtp
name|QFtp
operator|::
name|~
name|QFtp
parameter_list|()
block|{
name|abort
argument_list|()
expr_stmt|;
name|close
argument_list|()
expr_stmt|;
block|}
end_destructor
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_include
include|#
directive|include
file|"qftp.moc"
end_include
begin_include
include|#
directive|include
file|"moc_qftp_p.cpp"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_FTP
end_comment
end_unit
