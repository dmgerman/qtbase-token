begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2014 Digia Plc and/or its subsidiary(-ies). ** Copyright (C) 2014 BlackBerry Limited. All rights reserved. ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtNetwork module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL21$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia. For licensing terms and ** conditions see http://qt.digia.com/licensing. For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 or version 3 as published by the Free ** Software Foundation and appearing in the file LICENSE.LGPLv21 and ** LICENSE.LGPLv3 included in the packaging of this file. Please review the ** following information to ensure the GNU Lesser General Public License ** requirements will be met: https://www.gnu.org/licenses/lgpl.html and ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights. These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qhttpnetworkconnectionchannel_p.h"
end_include
begin_include
include|#
directive|include
file|"qhttpnetworkconnection_p.h"
end_include
begin_include
include|#
directive|include
file|"private/qnoncontiguousbytedevice_p.h"
end_include
begin_include
include|#
directive|include
file|<qpair.h>
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_HTTP
end_ifndef
begin_include
include|#
directive|include
file|<private/qhttpprotocolhandler_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qspdyprotocolhandler_p.h>
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_SSL
end_ifndef
begin_include
include|#
directive|include
file|<QtNetwork/qsslkey.h>
end_include
begin_include
include|#
directive|include
file|<QtNetwork/qsslcipher.h>
end_include
begin_include
include|#
directive|include
file|<QtNetwork/qsslconfiguration.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_BEARERMANAGEMENT
end_ifndef
begin_include
include|#
directive|include
file|"private/qnetworksession_p.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_comment
comment|// TODO: Put channel specific stuff here so it does not polute qhttpnetworkconnection.cpp
end_comment
begin_constructor
DECL|function|QHttpNetworkConnectionChannel
name|QHttpNetworkConnectionChannel
operator|::
name|QHttpNetworkConnectionChannel
parameter_list|()
member_init_list|:
name|socket
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|ssl
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|isInitialized
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|state
argument_list|(
name|IdleState
argument_list|)
member_init_list|,
name|reply
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|written
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|bytesTotal
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|resendCurrent
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|lastStatus
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|pendingEncrypt
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|reconnectAttempts
argument_list|(
literal|2
argument_list|)
member_init_list|,
name|authMethod
argument_list|(
name|QAuthenticatorPrivate
operator|::
name|None
argument_list|)
member_init_list|,
name|proxyAuthMethod
argument_list|(
name|QAuthenticatorPrivate
operator|::
name|None
argument_list|)
member_init_list|,
name|authenticationCredentialsSent
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|proxyCredentialsSent
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|protocolHandler
argument_list|(
literal|0
argument_list|)
ifndef|#
directive|ifndef
name|QT_NO_SSL
member_init_list|,
name|ignoreAllSslErrors
argument_list|(
literal|false
argument_list|)
endif|#
directive|endif
member_init_list|,
name|pipeliningSupported
argument_list|(
name|PipeliningSupportUnknown
argument_list|)
member_init_list|,
name|networkLayerPreference
argument_list|(
name|QAbstractSocket
operator|::
name|AnyIPProtocol
argument_list|)
member_init_list|,
name|connection
argument_list|(
literal|0
argument_list|)
block|{
comment|// Inlining this function in the header leads to compiler error on
comment|// release-armv5, on at least timebox 9.2 and 10.1.
block|}
end_constructor
begin_function
DECL|function|init
name|void
name|QHttpNetworkConnectionChannel
operator|::
name|init
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|QT_NO_SSL
if|if
condition|(
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|encrypt
condition|)
name|socket
operator|=
operator|new
name|QSslSocket
expr_stmt|;
else|else
name|socket
operator|=
operator|new
name|QTcpSocket
expr_stmt|;
else|#
directive|else
name|socket
operator|=
operator|new
name|QTcpSocket
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_BEARERMANAGEMENT
comment|//push session down to socket
if|if
condition|(
name|networkSession
condition|)
name|socket
operator|->
name|setProperty
argument_list|(
literal|"_q_networksession"
argument_list|,
name|QVariant
operator|::
name|fromValue
argument_list|(
name|networkSession
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
comment|// Set by QNAM anyway, but let's be safe here
name|socket
operator|->
name|setProxy
argument_list|(
name|QNetworkProxy
operator|::
name|NoProxy
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|QObject
operator|::
name|connect
argument_list|(
name|socket
argument_list|,
name|SIGNAL
argument_list|(
name|bytesWritten
argument_list|(
name|qint64
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|_q_bytesWritten
argument_list|(
name|qint64
argument_list|)
argument_list|)
argument_list|,
name|Qt
operator|::
name|DirectConnection
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|socket
argument_list|,
name|SIGNAL
argument_list|(
name|connected
argument_list|()
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|_q_connected
argument_list|()
argument_list|)
argument_list|,
name|Qt
operator|::
name|DirectConnection
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|socket
argument_list|,
name|SIGNAL
argument_list|(
name|readyRead
argument_list|()
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|_q_readyRead
argument_list|()
argument_list|)
argument_list|,
name|Qt
operator|::
name|DirectConnection
argument_list|)
expr_stmt|;
comment|// The disconnected() and error() signals may already come
comment|// while calling connectToHost().
comment|// In case of a cached hostname or an IP this
comment|// will then emit a signal to the user of QNetworkReply
comment|// but cannot be caught because the user did not have a chance yet
comment|// to connect to QNetworkReply's signals.
name|qRegisterMetaType
argument_list|<
name|QAbstractSocket
operator|::
name|SocketError
argument_list|>
argument_list|()
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|socket
argument_list|,
name|SIGNAL
argument_list|(
name|disconnected
argument_list|()
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|_q_disconnected
argument_list|()
argument_list|)
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|socket
argument_list|,
name|SIGNAL
argument_list|(
name|error
argument_list|(
name|QAbstractSocket
operator|::
name|SocketError
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|_q_error
argument_list|(
name|QAbstractSocket
operator|::
name|SocketError
argument_list|)
argument_list|)
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
name|QObject
operator|::
name|connect
argument_list|(
name|socket
argument_list|,
name|SIGNAL
argument_list|(
name|proxyAuthenticationRequired
argument_list|(
name|QNetworkProxy
argument_list|,
name|QAuthenticator
operator|*
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|_q_proxyAuthenticationRequired
argument_list|(
name|QNetworkProxy
argument_list|,
name|QAuthenticator
operator|*
argument_list|)
argument_list|)
argument_list|,
name|Qt
operator|::
name|DirectConnection
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_SSL
name|QSslSocket
modifier|*
name|sslSocket
init|=
name|qobject_cast
argument_list|<
name|QSslSocket
operator|*
argument_list|>
argument_list|(
name|socket
argument_list|)
decl_stmt|;
if|if
condition|(
name|sslSocket
condition|)
block|{
comment|// won't be a sslSocket if encrypt is false
name|QObject
operator|::
name|connect
argument_list|(
name|sslSocket
argument_list|,
name|SIGNAL
argument_list|(
name|encrypted
argument_list|()
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|_q_encrypted
argument_list|()
argument_list|)
argument_list|,
name|Qt
operator|::
name|DirectConnection
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|sslSocket
argument_list|,
name|SIGNAL
argument_list|(
name|sslErrors
argument_list|(
name|QList
argument_list|<
name|QSslError
argument_list|>
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|_q_sslErrors
argument_list|(
name|QList
argument_list|<
name|QSslError
argument_list|>
argument_list|)
argument_list|)
argument_list|,
name|Qt
operator|::
name|DirectConnection
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|sslSocket
argument_list|,
name|SIGNAL
argument_list|(
name|encryptedBytesWritten
argument_list|(
name|qint64
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|_q_encryptedBytesWritten
argument_list|(
name|qint64
argument_list|)
argument_list|)
argument_list|,
name|Qt
operator|::
name|DirectConnection
argument_list|)
expr_stmt|;
if|if
condition|(
name|ignoreAllSslErrors
condition|)
name|sslSocket
operator|->
name|ignoreSslErrors
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ignoreSslErrorsList
operator|.
name|isEmpty
argument_list|()
condition|)
name|sslSocket
operator|->
name|ignoreSslErrors
argument_list|(
name|ignoreSslErrorsList
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sslConfiguration
operator|.
name|isNull
argument_list|()
condition|)
name|sslSocket
operator|->
name|setSslConfiguration
argument_list|(
name|sslConfiguration
argument_list|)
expr_stmt|;
block|}
else|else
block|{
endif|#
directive|endif
comment|// QT_NO_SSL
name|protocolHandler
operator|.
name|reset
argument_list|(
operator|new
name|QHttpProtocolHandler
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_SSL
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
if|if
condition|(
name|proxy
operator|.
name|type
argument_list|()
operator|!=
name|QNetworkProxy
operator|::
name|NoProxy
condition|)
name|socket
operator|->
name|setProxy
argument_list|(
name|proxy
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|isInitialized
operator|=
literal|true
expr_stmt|;
block|}
end_function
begin_function
DECL|function|close
name|void
name|QHttpNetworkConnectionChannel
operator|::
name|close
parameter_list|()
block|{
if|if
condition|(
operator|!
name|socket
condition|)
name|state
operator|=
name|QHttpNetworkConnectionChannel
operator|::
name|IdleState
expr_stmt|;
elseif|else
if|if
condition|(
name|socket
operator|->
name|state
argument_list|()
operator|==
name|QAbstractSocket
operator|::
name|UnconnectedState
condition|)
name|state
operator|=
name|QHttpNetworkConnectionChannel
operator|::
name|IdleState
expr_stmt|;
else|else
name|state
operator|=
name|QHttpNetworkConnectionChannel
operator|::
name|ClosingState
expr_stmt|;
comment|// pendingEncrypt must only be true in between connected and encrypted states
name|pendingEncrypt
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|socket
condition|)
name|socket
operator|->
name|close
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|sendRequest
name|bool
name|QHttpNetworkConnectionChannel
operator|::
name|sendRequest
parameter_list|()
block|{
name|Q_ASSERT
argument_list|(
operator|!
name|protocolHandler
operator|.
name|isNull
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|protocolHandler
operator|->
name|sendRequest
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|_q_receiveReply
name|void
name|QHttpNetworkConnectionChannel
operator|::
name|_q_receiveReply
parameter_list|()
block|{
name|Q_ASSERT
argument_list|(
operator|!
name|protocolHandler
operator|.
name|isNull
argument_list|()
argument_list|)
expr_stmt|;
name|protocolHandler
operator|->
name|_q_receiveReply
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|_q_readyRead
name|void
name|QHttpNetworkConnectionChannel
operator|::
name|_q_readyRead
parameter_list|()
block|{
name|Q_ASSERT
argument_list|(
operator|!
name|protocolHandler
operator|.
name|isNull
argument_list|()
argument_list|)
expr_stmt|;
name|protocolHandler
operator|->
name|_q_readyRead
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|// called when unexpectedly reading a -1 or when data is expected but socket is closed
end_comment
begin_function
DECL|function|handleUnexpectedEOF
name|void
name|QHttpNetworkConnectionChannel
operator|::
name|handleUnexpectedEOF
parameter_list|()
block|{
name|Q_ASSERT
argument_list|(
name|reply
argument_list|)
expr_stmt|;
if|if
condition|(
name|reconnectAttempts
operator|<=
literal|0
condition|)
block|{
comment|// too many errors reading/receiving/parsing the status, close the socket and emit error
name|requeueCurrentlyPipelinedRequests
argument_list|()
expr_stmt|;
name|close
argument_list|()
expr_stmt|;
name|reply
operator|->
name|d_func
argument_list|()
operator|->
name|errorString
operator|=
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|errorDetail
argument_list|(
name|QNetworkReply
operator|::
name|RemoteHostClosedError
argument_list|,
name|socket
argument_list|)
expr_stmt|;
emit|emit
name|reply
operator|->
name|finishedWithError
argument_list|(
name|QNetworkReply
operator|::
name|RemoteHostClosedError
argument_list|,
name|reply
operator|->
name|d_func
argument_list|()
operator|->
name|errorString
argument_list|)
emit|;
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|connection
argument_list|,
literal|"_q_startNextRequest"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|reconnectAttempts
operator|--
expr_stmt|;
name|reply
operator|->
name|d_func
argument_list|()
operator|->
name|clear
argument_list|()
expr_stmt|;
name|reply
operator|->
name|d_func
argument_list|()
operator|->
name|connection
operator|=
name|connection
expr_stmt|;
name|reply
operator|->
name|d_func
argument_list|()
operator|->
name|connectionChannel
operator|=
name|this
expr_stmt|;
name|closeAndResendCurrentRequest
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|ensureConnection
name|bool
name|QHttpNetworkConnectionChannel
operator|::
name|ensureConnection
parameter_list|()
block|{
if|if
condition|(
operator|!
name|isInitialized
condition|)
name|init
argument_list|()
expr_stmt|;
name|QAbstractSocket
operator|::
name|SocketState
name|socketState
init|=
name|socket
operator|->
name|state
argument_list|()
decl_stmt|;
comment|// resend this request after we receive the disconnected signal
if|if
condition|(
name|socketState
operator|==
name|QAbstractSocket
operator|::
name|ClosingState
condition|)
block|{
if|if
condition|(
name|reply
condition|)
name|resendCurrent
operator|=
literal|true
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// already trying to connect?
if|if
condition|(
name|socketState
operator|==
name|QAbstractSocket
operator|::
name|HostLookupState
operator|||
name|socketState
operator|==
name|QAbstractSocket
operator|::
name|ConnectingState
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// make sure that this socket is in a connected state, if not initiate
comment|// connection to the host.
if|if
condition|(
name|socketState
operator|!=
name|QAbstractSocket
operator|::
name|ConnectedState
condition|)
block|{
comment|// connect to the host if not already connected.
name|state
operator|=
name|QHttpNetworkConnectionChannel
operator|::
name|ConnectingState
expr_stmt|;
name|pendingEncrypt
operator|=
name|ssl
expr_stmt|;
comment|// reset state
name|pipeliningSupported
operator|=
name|PipeliningSupportUnknown
expr_stmt|;
name|authenticationCredentialsSent
operator|=
literal|false
expr_stmt|;
name|proxyCredentialsSent
operator|=
literal|false
expr_stmt|;
name|authenticator
operator|.
name|detach
argument_list|()
expr_stmt|;
name|QAuthenticatorPrivate
modifier|*
name|priv
init|=
name|QAuthenticatorPrivate
operator|::
name|getPrivate
argument_list|(
name|authenticator
argument_list|)
decl_stmt|;
name|priv
operator|->
name|hasFailed
operator|=
literal|false
expr_stmt|;
name|proxyAuthenticator
operator|.
name|detach
argument_list|()
expr_stmt|;
name|priv
operator|=
name|QAuthenticatorPrivate
operator|::
name|getPrivate
argument_list|(
name|proxyAuthenticator
argument_list|)
expr_stmt|;
name|priv
operator|->
name|hasFailed
operator|=
literal|false
expr_stmt|;
comment|// This workaround is needed since we use QAuthenticator for NTLM authentication. The "phase == Done"
comment|// is the usual criteria for emitting authentication signals. The "phase" is set to "Done" when the
comment|// last header for Authorization is generated by the QAuthenticator. Basic& Digest logic does not
comment|// check the "phase" for generating the Authorization header. NTLM authentication is a two stage
comment|// process& needs the "phase". To make sure the QAuthenticator uses the current username/password
comment|// the phase is reset to Start.
name|priv
operator|=
name|QAuthenticatorPrivate
operator|::
name|getPrivate
argument_list|(
name|authenticator
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|&&
name|priv
operator|->
name|phase
operator|==
name|QAuthenticatorPrivate
operator|::
name|Done
condition|)
name|priv
operator|->
name|phase
operator|=
name|QAuthenticatorPrivate
operator|::
name|Start
expr_stmt|;
name|priv
operator|=
name|QAuthenticatorPrivate
operator|::
name|getPrivate
argument_list|(
name|proxyAuthenticator
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|&&
name|priv
operator|->
name|phase
operator|==
name|QAuthenticatorPrivate
operator|::
name|Done
condition|)
name|priv
operator|->
name|phase
operator|=
name|QAuthenticatorPrivate
operator|::
name|Start
expr_stmt|;
name|QString
name|connectHost
init|=
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|hostName
decl_stmt|;
name|qint16
name|connectPort
init|=
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|port
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
comment|// HTTPS always use transparent proxy.
if|if
condition|(
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|networkProxy
operator|.
name|type
argument_list|()
operator|!=
name|QNetworkProxy
operator|::
name|NoProxy
operator|&&
operator|!
name|ssl
condition|)
block|{
name|connectHost
operator|=
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|networkProxy
operator|.
name|hostName
argument_list|()
expr_stmt|;
name|connectPort
operator|=
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|networkProxy
operator|.
name|port
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|socket
operator|->
name|proxy
argument_list|()
operator|.
name|type
argument_list|()
operator|==
name|QNetworkProxy
operator|::
name|HttpProxy
condition|)
block|{
comment|// Make user-agent field available to HTTP proxy socket engine (QTBUG-17223)
name|QByteArray
name|value
decl_stmt|;
comment|// ensureConnection is called before any request has been assigned, but can also be called again if reconnecting
if|if
condition|(
name|request
operator|.
name|url
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|value
operator|=
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|predictNextRequest
argument_list|()
operator|.
name|headerField
argument_list|(
literal|"user-agent"
argument_list|)
expr_stmt|;
else|else
name|value
operator|=
name|request
operator|.
name|headerField
argument_list|(
literal|"user-agent"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|value
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QNetworkProxy
name|proxy
argument_list|(
name|socket
operator|->
name|proxy
argument_list|()
argument_list|)
decl_stmt|;
name|proxy
operator|.
name|setRawHeader
argument_list|(
literal|"User-Agent"
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|//detaches
name|socket
operator|->
name|setProxy
argument_list|(
name|proxy
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|ssl
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_SSL
name|QSslSocket
modifier|*
name|sslSocket
init|=
name|qobject_cast
argument_list|<
name|QSslSocket
operator|*
argument_list|>
argument_list|(
name|socket
argument_list|)
decl_stmt|;
comment|// check whether we can re-use an existing SSL session
comment|// (meaning another socket in this connection has already
comment|// performed a full handshake)
if|if
condition|(
operator|!
name|connection
operator|->
name|sslContext
argument_list|()
operator|.
name|isNull
argument_list|()
condition|)
name|QSslSocketPrivate
operator|::
name|checkSettingSslContext
argument_list|(
name|sslSocket
argument_list|,
name|connection
operator|->
name|sslContext
argument_list|()
argument_list|)
expr_stmt|;
name|sslSocket
operator|->
name|connectToHostEncrypted
argument_list|(
name|connectHost
argument_list|,
name|connectPort
argument_list|,
name|QIODevice
operator|::
name|ReadWrite
argument_list|,
name|networkLayerPreference
argument_list|)
expr_stmt|;
if|if
condition|(
name|ignoreAllSslErrors
condition|)
name|sslSocket
operator|->
name|ignoreSslErrors
argument_list|()
expr_stmt|;
name|sslSocket
operator|->
name|ignoreSslErrors
argument_list|(
name|ignoreSslErrorsList
argument_list|)
expr_stmt|;
comment|// limit the socket read buffer size. we will read everything into
comment|// the QHttpNetworkReply anyway, so let's grow only that and not
comment|// here and there.
name|socket
operator|->
name|setReadBufferSize
argument_list|(
literal|64
operator|*
literal|1024
argument_list|)
expr_stmt|;
else|#
directive|else
comment|// Need to dequeue the request so that we can emit the error.
if|if
condition|(
operator|!
name|reply
condition|)
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|dequeueRequest
argument_list|(
name|socket
argument_list|)
expr_stmt|;
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|emitReplyError
argument_list|(
name|socket
argument_list|,
name|reply
argument_list|,
name|QNetworkReply
operator|::
name|ProtocolUnknownError
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|// In case of no proxy we can use the Unbuffered QTcpSocket
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
if|if
condition|(
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|networkProxy
operator|.
name|type
argument_list|()
operator|==
name|QNetworkProxy
operator|::
name|NoProxy
operator|&&
name|connection
operator|->
name|cacheProxy
argument_list|()
operator|.
name|type
argument_list|()
operator|==
name|QNetworkProxy
operator|::
name|NoProxy
operator|&&
name|connection
operator|->
name|transparentProxy
argument_list|()
operator|.
name|type
argument_list|()
operator|==
name|QNetworkProxy
operator|::
name|NoProxy
condition|)
block|{
endif|#
directive|endif
name|socket
operator|->
name|connectToHost
argument_list|(
name|connectHost
argument_list|,
name|connectPort
argument_list|,
name|QIODevice
operator|::
name|ReadWrite
operator||
name|QIODevice
operator|::
name|Unbuffered
argument_list|,
name|networkLayerPreference
argument_list|)
expr_stmt|;
comment|// For an Unbuffered QTcpSocket, the read buffer size has a special meaning.
name|socket
operator|->
name|setReadBufferSize
argument_list|(
literal|1
operator|*
literal|1024
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
block|}
else|else
block|{
name|socket
operator|->
name|connectToHost
argument_list|(
name|connectHost
argument_list|,
name|connectPort
argument_list|,
name|QIODevice
operator|::
name|ReadWrite
argument_list|,
name|networkLayerPreference
argument_list|)
expr_stmt|;
comment|// limit the socket read buffer size. we will read everything into
comment|// the QHttpNetworkReply anyway, so let's grow only that and not
comment|// here and there.
name|socket
operator|->
name|setReadBufferSize
argument_list|(
literal|64
operator|*
literal|1024
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|allDone
name|void
name|QHttpNetworkConnectionChannel
operator|::
name|allDone
parameter_list|()
block|{
name|Q_ASSERT
argument_list|(
name|reply
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reply
condition|)
block|{
name|qWarning
argument_list|()
operator|<<
literal|"QHttpNetworkConnectionChannel::allDone() called without reply. Please report at http://bugreports.qt.io/"
expr_stmt|;
return|return;
block|}
comment|// while handling 401& 407, we might reset the status code, so save this.
name|bool
name|emitFinished
init|=
name|reply
operator|->
name|d_func
argument_list|()
operator|->
name|shouldEmitSignals
argument_list|()
decl_stmt|;
name|bool
name|connectionCloseEnabled
init|=
name|reply
operator|->
name|d_func
argument_list|()
operator|->
name|isConnectionCloseEnabled
argument_list|()
decl_stmt|;
name|detectPipeliningSupport
argument_list|()
expr_stmt|;
name|handleStatus
argument_list|()
expr_stmt|;
comment|// handleStatus() might have removed the reply because it already called connection->emitReplyError()
comment|// queue the finished signal, this is required since we might send new requests from
comment|// slot connected to it. The socket will not fire readyRead signal, if we are already
comment|// in the slot connected to readyRead
if|if
condition|(
name|reply
operator|&&
name|emitFinished
condition|)
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|reply
argument_list|,
literal|"finished"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
comment|// reset the reconnection attempts after we receive a complete reply.
comment|// in case of failures, each channel will attempt two reconnects before emitting error.
name|reconnectAttempts
operator|=
literal|2
expr_stmt|;
comment|// now the channel can be seen as free/idle again, all signal emissions for the reply have been done
if|if
condition|(
name|state
operator|!=
name|QHttpNetworkConnectionChannel
operator|::
name|ClosingState
condition|)
name|state
operator|=
name|QHttpNetworkConnectionChannel
operator|::
name|IdleState
expr_stmt|;
comment|// if it does not need to be sent again we can set it to 0
comment|// the previous code did not do that and we had problems with accidental re-sending of a
comment|// finished request.
comment|// Note that this may trigger a segfault at some other point. But then we can fix the underlying
comment|// problem.
if|if
condition|(
operator|!
name|resendCurrent
condition|)
block|{
name|request
operator|=
name|QHttpNetworkRequest
argument_list|()
expr_stmt|;
name|reply
operator|=
literal|0
expr_stmt|;
name|protocolHandler
operator|->
name|setReply
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|// move next from pipeline to current request
if|if
condition|(
operator|!
name|alreadyPipelinedRequests
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|resendCurrent
operator|||
name|connectionCloseEnabled
operator|||
name|socket
operator|->
name|state
argument_list|()
operator|!=
name|QAbstractSocket
operator|::
name|ConnectedState
condition|)
block|{
comment|// move the pipelined ones back to the main queue
name|requeueCurrentlyPipelinedRequests
argument_list|()
expr_stmt|;
name|close
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// there were requests pipelined in and we can continue
name|HttpMessagePair
name|messagePair
init|=
name|alreadyPipelinedRequests
operator|.
name|takeFirst
argument_list|()
decl_stmt|;
name|request
operator|=
name|messagePair
operator|.
name|first
expr_stmt|;
name|reply
operator|=
name|messagePair
operator|.
name|second
expr_stmt|;
name|protocolHandler
operator|->
name|setReply
argument_list|(
name|messagePair
operator|.
name|second
argument_list|)
expr_stmt|;
name|state
operator|=
name|QHttpNetworkConnectionChannel
operator|::
name|ReadingState
expr_stmt|;
name|resendCurrent
operator|=
literal|false
expr_stmt|;
name|written
operator|=
literal|0
expr_stmt|;
comment|// message body, excluding the header, irrelevant here
name|bytesTotal
operator|=
literal|0
expr_stmt|;
comment|// message body total, excluding the header, irrelevant here
comment|// pipeline even more
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|fillPipeline
argument_list|(
name|socket
argument_list|)
expr_stmt|;
comment|// continue reading
comment|//_q_receiveReply();
comment|// this was wrong, allDone gets called from that function anyway.
block|}
block|}
elseif|else
if|if
condition|(
name|alreadyPipelinedRequests
operator|.
name|isEmpty
argument_list|()
operator|&&
name|socket
operator|->
name|bytesAvailable
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// this is weird. we had nothing pipelined but still bytes available. better close it.
name|close
argument_list|()
expr_stmt|;
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|connection
argument_list|,
literal|"_q_startNextRequest"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|alreadyPipelinedRequests
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|connectionCloseEnabled
condition|)
if|if
condition|(
name|socket
operator|->
name|state
argument_list|()
operator|!=
name|QAbstractSocket
operator|::
name|UnconnectedState
condition|)
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|qobject_cast
argument_list|<
name|QHttpNetworkConnection
operator|*
argument_list|>
argument_list|(
name|connection
argument_list|)
condition|)
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|connection
argument_list|,
literal|"_q_startNextRequest"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|detectPipeliningSupport
name|void
name|QHttpNetworkConnectionChannel
operator|::
name|detectPipeliningSupport
parameter_list|()
block|{
name|Q_ASSERT
argument_list|(
name|reply
argument_list|)
expr_stmt|;
comment|// detect HTTP Pipelining support
name|QByteArray
name|serverHeaderField
decl_stmt|;
if|if
condition|(
comment|// check for HTTP/1.1
operator|(
name|reply
operator|->
name|d_func
argument_list|()
operator|->
name|majorVersion
operator|==
literal|1
operator|&&
name|reply
operator|->
name|d_func
argument_list|()
operator|->
name|minorVersion
operator|==
literal|1
operator|)
comment|// check for not having connection close
operator|&&
operator|(
operator|!
name|reply
operator|->
name|d_func
argument_list|()
operator|->
name|isConnectionCloseEnabled
argument_list|()
operator|)
comment|// check if it is still connected
operator|&&
operator|(
name|socket
operator|->
name|state
argument_list|()
operator|==
name|QAbstractSocket
operator|::
name|ConnectedState
operator|)
comment|// check for broken servers in server reply header
comment|// this is adapted from http://mxr.mozilla.org/firefox/ident?i=SupportsPipelining
operator|&&
operator|(
name|serverHeaderField
operator|=
name|reply
operator|->
name|headerField
argument_list|(
literal|"Server"
argument_list|)
operator|,
operator|!
name|serverHeaderField
operator|.
name|contains
argument_list|(
literal|"Microsoft-IIS/4."
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|serverHeaderField
operator|.
name|contains
argument_list|(
literal|"Microsoft-IIS/5."
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|serverHeaderField
operator|.
name|contains
argument_list|(
literal|"Netscape-Enterprise/3."
argument_list|)
operator|)
comment|// this is adpoted from the knowledge of the Nokia 7.x browser team (DEF143319)
operator|&&
operator|(
operator|!
name|serverHeaderField
operator|.
name|contains
argument_list|(
literal|"WebLogic"
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|serverHeaderField
operator|.
name|startsWith
argument_list|(
literal|"Rocket"
argument_list|)
operator|)
comment|// a Python Web Server, see Web2py.com
condition|)
block|{
name|pipeliningSupported
operator|=
name|QHttpNetworkConnectionChannel
operator|::
name|PipeliningProbablySupported
expr_stmt|;
block|}
else|else
block|{
name|pipeliningSupported
operator|=
name|QHttpNetworkConnectionChannel
operator|::
name|PipeliningSupportUnknown
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|// called when the connection broke and we need to queue some pipelined requests again
end_comment
begin_function
DECL|function|requeueCurrentlyPipelinedRequests
name|void
name|QHttpNetworkConnectionChannel
operator|::
name|requeueCurrentlyPipelinedRequests
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|alreadyPipelinedRequests
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|requeueRequest
argument_list|(
name|alreadyPipelinedRequests
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|alreadyPipelinedRequests
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// only run when the QHttpNetworkConnection is not currently being destructed, e.g.
comment|// this function is called from _q_disconnected which is called because
comment|// of ~QHttpNetworkConnectionPrivate
if|if
condition|(
name|qobject_cast
argument_list|<
name|QHttpNetworkConnection
operator|*
argument_list|>
argument_list|(
name|connection
argument_list|)
condition|)
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|connection
argument_list|,
literal|"_q_startNextRequest"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|handleStatus
name|void
name|QHttpNetworkConnectionChannel
operator|::
name|handleStatus
parameter_list|()
block|{
name|Q_ASSERT
argument_list|(
name|socket
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|reply
argument_list|)
expr_stmt|;
name|int
name|statusCode
init|=
name|reply
operator|->
name|statusCode
argument_list|()
decl_stmt|;
name|bool
name|resend
init|=
literal|false
decl_stmt|;
switch|switch
condition|(
name|statusCode
condition|)
block|{
case|case
literal|401
case|:
comment|// auth required
case|case
literal|407
case|:
comment|// proxy auth required
if|if
condition|(
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|handleAuthenticateChallenge
argument_list|(
name|socket
argument_list|,
name|reply
argument_list|,
operator|(
name|statusCode
operator|==
literal|407
operator|)
argument_list|,
name|resend
argument_list|)
condition|)
block|{
if|if
condition|(
name|resend
condition|)
block|{
if|if
condition|(
operator|!
name|resetUploadData
argument_list|()
condition|)
break|break;
name|reply
operator|->
name|d_func
argument_list|()
operator|->
name|eraseData
argument_list|()
expr_stmt|;
if|if
condition|(
name|alreadyPipelinedRequests
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// this does a re-send without closing the connection
name|resendCurrent
operator|=
literal|true
expr_stmt|;
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|connection
argument_list|,
literal|"_q_startNextRequest"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// we had requests pipelined.. better close the connection in closeAndResendCurrentRequest
name|closeAndResendCurrentRequest
argument_list|()
expr_stmt|;
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|connection
argument_list|,
literal|"_q_startNextRequest"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|//authentication cancelled, close the channel.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
emit|emit
name|reply
operator|->
name|headerChanged
argument_list|()
emit|;
emit|emit
name|reply
operator|->
name|readyRead
argument_list|()
emit|;
name|QNetworkReply
operator|::
name|NetworkError
name|errorCode
init|=
operator|(
name|statusCode
operator|==
literal|407
operator|)
condition|?
name|QNetworkReply
operator|::
name|ProxyAuthenticationRequiredError
else|:
name|QNetworkReply
operator|::
name|AuthenticationRequiredError
decl_stmt|;
name|reply
operator|->
name|d_func
argument_list|()
operator|->
name|errorString
operator|=
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|errorDetail
argument_list|(
name|errorCode
argument_list|,
name|socket
argument_list|)
expr_stmt|;
emit|emit
name|reply
operator|->
name|finishedWithError
argument_list|(
name|errorCode
argument_list|,
name|reply
operator|->
name|d_func
argument_list|()
operator|->
name|errorString
argument_list|)
emit|;
block|}
break|break;
default|default:
if|if
condition|(
name|qobject_cast
argument_list|<
name|QHttpNetworkConnection
operator|*
argument_list|>
argument_list|(
name|connection
argument_list|)
condition|)
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|connection
argument_list|,
literal|"_q_startNextRequest"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|resetUploadData
name|bool
name|QHttpNetworkConnectionChannel
operator|::
name|resetUploadData
parameter_list|()
block|{
if|if
condition|(
operator|!
name|reply
condition|)
block|{
comment|//this happens if server closes connection while QHttpNetworkConnectionPrivate::_q_startNextRequest is pending
return|return
literal|false
return|;
block|}
name|QNonContiguousByteDevice
modifier|*
name|uploadByteDevice
init|=
name|request
operator|.
name|uploadByteDevice
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|uploadByteDevice
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|uploadByteDevice
operator|->
name|reset
argument_list|()
condition|)
block|{
name|written
operator|=
literal|0
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|emitReplyError
argument_list|(
name|socket
argument_list|,
name|reply
argument_list|,
name|QNetworkReply
operator|::
name|ContentReSendError
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
end_ifndef
begin_function
DECL|function|setProxy
name|void
name|QHttpNetworkConnectionChannel
operator|::
name|setProxy
parameter_list|(
specifier|const
name|QNetworkProxy
modifier|&
name|networkProxy
parameter_list|)
block|{
if|if
condition|(
name|socket
condition|)
name|socket
operator|->
name|setProxy
argument_list|(
name|networkProxy
argument_list|)
expr_stmt|;
name|proxy
operator|=
name|networkProxy
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_SSL
end_ifndef
begin_function
DECL|function|ignoreSslErrors
name|void
name|QHttpNetworkConnectionChannel
operator|::
name|ignoreSslErrors
parameter_list|()
block|{
if|if
condition|(
name|socket
condition|)
cast|static_cast
argument_list|<
name|QSslSocket
operator|*
argument_list|>
argument_list|(
name|socket
argument_list|)
operator|->
name|ignoreSslErrors
argument_list|()
expr_stmt|;
name|ignoreAllSslErrors
operator|=
literal|true
expr_stmt|;
block|}
end_function
begin_function
DECL|function|ignoreSslErrors
name|void
name|QHttpNetworkConnectionChannel
operator|::
name|ignoreSslErrors
parameter_list|(
specifier|const
name|QList
argument_list|<
name|QSslError
argument_list|>
modifier|&
name|errors
parameter_list|)
block|{
if|if
condition|(
name|socket
condition|)
cast|static_cast
argument_list|<
name|QSslSocket
operator|*
argument_list|>
argument_list|(
name|socket
argument_list|)
operator|->
name|ignoreSslErrors
argument_list|(
name|errors
argument_list|)
expr_stmt|;
name|ignoreSslErrorsList
operator|=
name|errors
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setSslConfiguration
name|void
name|QHttpNetworkConnectionChannel
operator|::
name|setSslConfiguration
parameter_list|(
specifier|const
name|QSslConfiguration
modifier|&
name|config
parameter_list|)
block|{
if|if
condition|(
name|socket
condition|)
cast|static_cast
argument_list|<
name|QSslSocket
operator|*
argument_list|>
argument_list|(
name|socket
argument_list|)
operator|->
name|setSslConfiguration
argument_list|(
name|config
argument_list|)
expr_stmt|;
name|sslConfiguration
operator|=
name|config
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|pipelineInto
name|void
name|QHttpNetworkConnectionChannel
operator|::
name|pipelineInto
parameter_list|(
name|HttpMessagePair
modifier|&
name|pair
parameter_list|)
block|{
comment|// this is only called for simple GET
name|QHttpNetworkRequest
modifier|&
name|request
init|=
name|pair
operator|.
name|first
decl_stmt|;
name|QHttpNetworkReply
modifier|*
name|reply
init|=
name|pair
operator|.
name|second
decl_stmt|;
name|reply
operator|->
name|d_func
argument_list|()
operator|->
name|clear
argument_list|()
expr_stmt|;
name|reply
operator|->
name|d_func
argument_list|()
operator|->
name|connection
operator|=
name|connection
expr_stmt|;
name|reply
operator|->
name|d_func
argument_list|()
operator|->
name|connectionChannel
operator|=
name|this
expr_stmt|;
name|reply
operator|->
name|d_func
argument_list|()
operator|->
name|autoDecompress
operator|=
name|request
operator|.
name|d
operator|->
name|autoDecompress
expr_stmt|;
name|reply
operator|->
name|d_func
argument_list|()
operator|->
name|pipeliningUsed
operator|=
literal|true
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
name|pipeline
operator|.
name|append
argument_list|(
name|QHttpNetworkRequestPrivate
operator|::
name|header
argument_list|(
name|request
argument_list|,
operator|(
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|networkProxy
operator|.
name|type
argument_list|()
operator|!=
name|QNetworkProxy
operator|::
name|NoProxy
operator|)
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|pipeline
operator|.
name|append
argument_list|(
name|QHttpNetworkRequestPrivate
operator|::
name|header
argument_list|(
name|request
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|alreadyPipelinedRequests
operator|.
name|append
argument_list|(
name|pair
argument_list|)
expr_stmt|;
comment|// pipelineFlush() needs to be called at some point afterwards
block|}
end_function
begin_function
DECL|function|pipelineFlush
name|void
name|QHttpNetworkConnectionChannel
operator|::
name|pipelineFlush
parameter_list|()
block|{
if|if
condition|(
name|pipeline
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
comment|// The goal of this is so that we have everything in one TCP packet.
comment|// For the Unbuffered QTcpSocket this is manually needed, the buffered
comment|// QTcpSocket does it automatically.
comment|// Also, sometimes the OS does it for us (Nagle's algorithm) but that
comment|// happens only sometimes.
name|socket
operator|->
name|write
argument_list|(
name|pipeline
argument_list|)
expr_stmt|;
name|pipeline
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|closeAndResendCurrentRequest
name|void
name|QHttpNetworkConnectionChannel
operator|::
name|closeAndResendCurrentRequest
parameter_list|()
block|{
name|requeueCurrentlyPipelinedRequests
argument_list|()
expr_stmt|;
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|reply
condition|)
name|resendCurrent
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|qobject_cast
argument_list|<
name|QHttpNetworkConnection
operator|*
argument_list|>
argument_list|(
name|connection
argument_list|)
condition|)
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|connection
argument_list|,
literal|"_q_startNextRequest"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|isSocketBusy
name|bool
name|QHttpNetworkConnectionChannel
operator|::
name|isSocketBusy
parameter_list|()
specifier|const
block|{
return|return
operator|(
name|state
operator|&
name|QHttpNetworkConnectionChannel
operator|::
name|BusyState
operator|)
return|;
block|}
end_function
begin_function
DECL|function|isSocketWriting
name|bool
name|QHttpNetworkConnectionChannel
operator|::
name|isSocketWriting
parameter_list|()
specifier|const
block|{
return|return
operator|(
name|state
operator|&
name|QHttpNetworkConnectionChannel
operator|::
name|WritingState
operator|)
return|;
block|}
end_function
begin_function
DECL|function|isSocketWaiting
name|bool
name|QHttpNetworkConnectionChannel
operator|::
name|isSocketWaiting
parameter_list|()
specifier|const
block|{
return|return
operator|(
name|state
operator|&
name|QHttpNetworkConnectionChannel
operator|::
name|WaitingState
operator|)
return|;
block|}
end_function
begin_function
DECL|function|isSocketReading
name|bool
name|QHttpNetworkConnectionChannel
operator|::
name|isSocketReading
parameter_list|()
specifier|const
block|{
return|return
operator|(
name|state
operator|&
name|QHttpNetworkConnectionChannel
operator|::
name|ReadingState
operator|)
return|;
block|}
end_function
begin_function
DECL|function|_q_bytesWritten
name|void
name|QHttpNetworkConnectionChannel
operator|::
name|_q_bytesWritten
parameter_list|(
name|qint64
name|bytes
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
comment|// bytes have been written to the socket. write even more of them :)
if|if
condition|(
name|isSocketWriting
argument_list|()
condition|)
name|sendRequest
argument_list|()
expr_stmt|;
comment|// otherwise we do nothing
block|}
end_function
begin_function
DECL|function|_q_disconnected
name|void
name|QHttpNetworkConnectionChannel
operator|::
name|_q_disconnected
parameter_list|()
block|{
if|if
condition|(
name|state
operator|==
name|QHttpNetworkConnectionChannel
operator|::
name|ClosingState
condition|)
block|{
name|state
operator|=
name|QHttpNetworkConnectionChannel
operator|::
name|IdleState
expr_stmt|;
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|connection
argument_list|,
literal|"_q_startNextRequest"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// read the available data before closing
if|if
condition|(
name|isSocketWaiting
argument_list|()
operator|||
name|isSocketReading
argument_list|()
condition|)
block|{
if|if
condition|(
name|reply
condition|)
block|{
name|state
operator|=
name|QHttpNetworkConnectionChannel
operator|::
name|ReadingState
expr_stmt|;
name|_q_receiveReply
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|state
operator|==
name|QHttpNetworkConnectionChannel
operator|::
name|IdleState
operator|&&
name|resendCurrent
condition|)
block|{
comment|// re-sending request because the socket was in ClosingState
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|connection
argument_list|,
literal|"_q_startNextRequest"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
block|}
name|state
operator|=
name|QHttpNetworkConnectionChannel
operator|::
name|IdleState
expr_stmt|;
name|requeueCurrentlyPipelinedRequests
argument_list|()
expr_stmt|;
name|close
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|_q_connected
name|void
name|QHttpNetworkConnectionChannel
operator|::
name|_q_connected
parameter_list|()
block|{
comment|// For the Happy Eyeballs we need to check if this is the first channel to connect.
if|if
condition|(
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|networkLayerState
operator|==
name|QHttpNetworkConnectionPrivate
operator|::
name|HostLookupPending
operator|||
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|networkLayerState
operator|==
name|QHttpNetworkConnectionPrivate
operator|::
name|IPv4or6
condition|)
block|{
if|if
condition|(
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|delayedConnectionTimer
operator|.
name|isActive
argument_list|()
condition|)
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|delayedConnectionTimer
operator|.
name|stop
argument_list|()
expr_stmt|;
if|if
condition|(
name|networkLayerPreference
operator|==
name|QAbstractSocket
operator|::
name|IPv4Protocol
condition|)
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|networkLayerState
operator|=
name|QHttpNetworkConnectionPrivate
operator|::
name|IPv4
expr_stmt|;
elseif|else
if|if
condition|(
name|networkLayerPreference
operator|==
name|QAbstractSocket
operator|::
name|IPv6Protocol
condition|)
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|networkLayerState
operator|=
name|QHttpNetworkConnectionPrivate
operator|::
name|IPv6
expr_stmt|;
else|else
block|{
if|if
condition|(
name|socket
operator|->
name|peerAddress
argument_list|()
operator|.
name|protocol
argument_list|()
operator|==
name|QAbstractSocket
operator|::
name|IPv4Protocol
condition|)
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|networkLayerState
operator|=
name|QHttpNetworkConnectionPrivate
operator|::
name|IPv4
expr_stmt|;
else|else
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|networkLayerState
operator|=
name|QHttpNetworkConnectionPrivate
operator|::
name|IPv6
expr_stmt|;
block|}
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|networkLayerDetected
argument_list|(
name|networkLayerPreference
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
operator|(
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|networkLayerState
operator|==
name|QHttpNetworkConnectionPrivate
operator|::
name|IPv4
operator|)
operator|&&
operator|(
name|networkLayerPreference
operator|!=
name|QAbstractSocket
operator|::
name|IPv4Protocol
operator|)
operator|)
operator|||
operator|(
operator|(
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|networkLayerState
operator|==
name|QHttpNetworkConnectionPrivate
operator|::
name|IPv6
operator|)
operator|&&
operator|(
name|networkLayerPreference
operator|!=
name|QAbstractSocket
operator|::
name|IPv6Protocol
operator|)
operator|)
condition|)
block|{
name|close
argument_list|()
expr_stmt|;
comment|// This is the second connection so it has to be closed and we can schedule it for another request.
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|connection
argument_list|,
literal|"_q_startNextRequest"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
return|return;
block|}
comment|//The connections networkLayerState had already been decided.
block|}
comment|// improve performance since we get the request sent by the kernel ASAP
comment|//socket->setSocketOption(QAbstractSocket::LowDelayOption, 1);
comment|// We have this commented out now. It did not have the effect we wanted. If we want to
comment|// do this properly, Qt has to combine multiple HTTP requests into one buffer
comment|// and send this to the kernel in one syscall and then the kernel immediately sends
comment|// it as one TCP packet because of TCP_NODELAY.
comment|// However, this code is currently not in Qt, so we rely on the kernel combining
comment|// the requests into one TCP packet.
comment|// not sure yet if it helps, but it makes sense
name|socket
operator|->
name|setSocketOption
argument_list|(
name|QAbstractSocket
operator|::
name|KeepAliveOption
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pipeliningSupported
operator|=
name|QHttpNetworkConnectionChannel
operator|::
name|PipeliningSupportUnknown
expr_stmt|;
comment|// ### FIXME: if the server closes the connection unexpectedly, we shouldn't send the same broken request again!
comment|//channels[i].reconnectAttempts = 2;
if|if
condition|(
name|pendingEncrypt
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_SSL
if|if
condition|(
name|connection
operator|->
name|sslContext
argument_list|()
operator|.
name|isNull
argument_list|()
condition|)
block|{
comment|// this socket is making the 1st handshake for this connection,
comment|// we need to set the SSL context so new sockets can reuse it
name|QSharedPointer
argument_list|<
name|QSslContext
argument_list|>
name|socketSslContext
init|=
name|QSslSocketPrivate
operator|::
name|sslContext
argument_list|(
cast|static_cast
argument_list|<
name|QSslSocket
operator|*
argument_list|>
argument_list|(
name|socket
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|socketSslContext
operator|.
name|isNull
argument_list|()
condition|)
name|connection
operator|->
name|setSslContext
argument_list|(
name|socketSslContext
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
block|{
name|state
operator|=
name|QHttpNetworkConnectionChannel
operator|::
name|IdleState
expr_stmt|;
if|if
condition|(
operator|!
name|reply
condition|)
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|dequeueRequest
argument_list|(
name|socket
argument_list|)
expr_stmt|;
if|if
condition|(
name|reply
condition|)
name|sendRequest
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|_q_error
name|void
name|QHttpNetworkConnectionChannel
operator|::
name|_q_error
parameter_list|(
name|QAbstractSocket
operator|::
name|SocketError
name|socketError
parameter_list|)
block|{
if|if
condition|(
operator|!
name|socket
condition|)
return|return;
name|QNetworkReply
operator|::
name|NetworkError
name|errorCode
init|=
name|QNetworkReply
operator|::
name|UnknownNetworkError
decl_stmt|;
switch|switch
condition|(
name|socketError
condition|)
block|{
case|case
name|QAbstractSocket
operator|::
name|HostNotFoundError
case|:
name|errorCode
operator|=
name|QNetworkReply
operator|::
name|HostNotFoundError
expr_stmt|;
break|break;
case|case
name|QAbstractSocket
operator|::
name|ConnectionRefusedError
case|:
name|errorCode
operator|=
name|QNetworkReply
operator|::
name|ConnectionRefusedError
expr_stmt|;
break|break;
case|case
name|QAbstractSocket
operator|::
name|RemoteHostClosedError
case|:
comment|// try to reconnect/resend before sending an error.
comment|// while "Reading" the _q_disconnected() will handle this.
if|if
condition|(
name|state
operator|!=
name|QHttpNetworkConnectionChannel
operator|::
name|IdleState
operator|&&
name|state
operator|!=
name|QHttpNetworkConnectionChannel
operator|::
name|ReadingState
condition|)
block|{
if|if
condition|(
name|reconnectAttempts
operator|--
operator|>
literal|0
condition|)
block|{
name|closeAndResendCurrentRequest
argument_list|()
expr_stmt|;
return|return;
block|}
else|else
block|{
name|errorCode
operator|=
name|QNetworkReply
operator|::
name|RemoteHostClosedError
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|state
operator|==
name|QHttpNetworkConnectionChannel
operator|::
name|ReadingState
condition|)
block|{
if|if
condition|(
operator|!
name|reply
condition|)
break|break;
if|if
condition|(
operator|!
name|reply
operator|->
name|d_func
argument_list|()
operator|->
name|expectContent
argument_list|()
condition|)
block|{
comment|// No content expected, this is a valid way to have the connection closed by the server
return|return;
block|}
if|if
condition|(
name|reply
operator|->
name|contentLength
argument_list|()
operator|==
operator|-
literal|1
operator|&&
operator|!
name|reply
operator|->
name|d_func
argument_list|()
operator|->
name|isChunked
argument_list|()
condition|)
block|{
comment|// There was no content-length header and it's not chunked encoding,
comment|// so this is a valid way to have the connection closed by the server
return|return;
block|}
comment|// ok, we got a disconnect even though we did not expect it
comment|// Try to read everything from the socket before we emit the error.
if|if
condition|(
name|socket
operator|->
name|bytesAvailable
argument_list|()
condition|)
block|{
comment|// Read everything from the socket into the reply buffer.
comment|// we can ignore the readbuffersize as the data is already
comment|// in memory and we will not receive more data on the socket.
name|reply
operator|->
name|setReadBufferSize
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|_q_receiveReply
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_SSL
if|if
condition|(
name|ssl
condition|)
block|{
comment|// QT_NO_OPENSSL. The QSslSocket can still have encrypted bytes in the plainsocket.
comment|// So we need to check this if the socket is a QSslSocket. When the socket is flushed
comment|// it will force a decrypt of the encrypted data in the plainsocket.
name|QSslSocket
modifier|*
name|sslSocket
init|=
cast|static_cast
argument_list|<
name|QSslSocket
operator|*
argument_list|>
argument_list|(
name|socket
argument_list|)
decl_stmt|;
name|qint64
name|beforeFlush
init|=
name|sslSocket
operator|->
name|encryptedBytesAvailable
argument_list|()
decl_stmt|;
while|while
condition|(
name|sslSocket
operator|->
name|encryptedBytesAvailable
argument_list|()
condition|)
block|{
name|sslSocket
operator|->
name|flush
argument_list|()
expr_stmt|;
name|_q_receiveReply
argument_list|()
expr_stmt|;
name|qint64
name|afterFlush
init|=
name|sslSocket
operator|->
name|encryptedBytesAvailable
argument_list|()
decl_stmt|;
if|if
condition|(
name|afterFlush
operator|==
name|beforeFlush
condition|)
break|break;
name|beforeFlush
operator|=
name|afterFlush
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
name|errorCode
operator|=
name|QNetworkReply
operator|::
name|RemoteHostClosedError
expr_stmt|;
block|}
else|else
block|{
name|errorCode
operator|=
name|QNetworkReply
operator|::
name|RemoteHostClosedError
expr_stmt|;
block|}
break|break;
case|case
name|QAbstractSocket
operator|::
name|SocketTimeoutError
case|:
comment|// try to reconnect/resend before sending an error.
if|if
condition|(
name|state
operator|==
name|QHttpNetworkConnectionChannel
operator|::
name|WritingState
operator|&&
operator|(
name|reconnectAttempts
operator|--
operator|>
literal|0
operator|)
condition|)
block|{
name|closeAndResendCurrentRequest
argument_list|()
expr_stmt|;
return|return;
block|}
name|errorCode
operator|=
name|QNetworkReply
operator|::
name|TimeoutError
expr_stmt|;
break|break;
case|case
name|QAbstractSocket
operator|::
name|ProxyAuthenticationRequiredError
case|:
name|errorCode
operator|=
name|QNetworkReply
operator|::
name|ProxyAuthenticationRequiredError
expr_stmt|;
break|break;
case|case
name|QAbstractSocket
operator|::
name|SslHandshakeFailedError
case|:
name|errorCode
operator|=
name|QNetworkReply
operator|::
name|SslHandshakeFailedError
expr_stmt|;
break|break;
case|case
name|QAbstractSocket
operator|::
name|ProxyConnectionClosedError
case|:
comment|// try to reconnect/resend before sending an error.
if|if
condition|(
name|reconnectAttempts
operator|--
operator|>
literal|0
condition|)
block|{
name|closeAndResendCurrentRequest
argument_list|()
expr_stmt|;
return|return;
block|}
name|errorCode
operator|=
name|QNetworkReply
operator|::
name|ProxyConnectionClosedError
expr_stmt|;
break|break;
case|case
name|QAbstractSocket
operator|::
name|ProxyConnectionTimeoutError
case|:
comment|// try to reconnect/resend before sending an error.
if|if
condition|(
name|reconnectAttempts
operator|--
operator|>
literal|0
condition|)
block|{
name|closeAndResendCurrentRequest
argument_list|()
expr_stmt|;
return|return;
block|}
name|errorCode
operator|=
name|QNetworkReply
operator|::
name|ProxyTimeoutError
expr_stmt|;
break|break;
default|default:
comment|// all other errors are treated as NetworkError
name|errorCode
operator|=
name|QNetworkReply
operator|::
name|UnknownNetworkError
expr_stmt|;
break|break;
block|}
name|QPointer
argument_list|<
name|QHttpNetworkConnection
argument_list|>
name|that
init|=
name|connection
decl_stmt|;
name|QString
name|errorString
init|=
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|errorDetail
argument_list|(
name|errorCode
argument_list|,
name|socket
argument_list|,
name|socket
operator|->
name|errorString
argument_list|()
argument_list|)
decl_stmt|;
comment|// In the HostLookupPending state the channel should not emit the error.
comment|// This will instead be handled by the connection.
if|if
condition|(
operator|!
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|shouldEmitChannelError
argument_list|(
name|socket
argument_list|)
condition|)
return|return;
comment|// emit error for all waiting replies
do|do
block|{
comment|// Need to dequeu the request so that we can emit the error.
if|if
condition|(
operator|!
name|reply
condition|)
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|dequeueRequest
argument_list|(
name|socket
argument_list|)
expr_stmt|;
if|if
condition|(
name|reply
condition|)
block|{
name|reply
operator|->
name|d_func
argument_list|()
operator|->
name|errorString
operator|=
name|errorString
expr_stmt|;
emit|emit
name|reply
operator|->
name|finishedWithError
argument_list|(
name|errorCode
argument_list|,
name|errorString
argument_list|)
emit|;
name|reply
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|protocolHandler
condition|)
name|protocolHandler
operator|->
name|setReply
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|!
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|highPriorityQueue
operator|.
name|isEmpty
argument_list|()
operator|||
operator|!
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|lowPriorityQueue
operator|.
name|isEmpty
argument_list|()
condition|)
do|;
ifndef|#
directive|ifndef
name|QT_NO_SSL
if|if
condition|(
name|connection
operator|->
name|connectionType
argument_list|()
operator|==
name|QHttpNetworkConnection
operator|::
name|ConnectionTypeSPDY
condition|)
block|{
name|QList
argument_list|<
name|HttpMessagePair
argument_list|>
name|spdyPairs
init|=
name|spdyRequestsToSend
operator|.
name|values
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|a
init|=
literal|0
init|;
name|a
operator|<
name|spdyPairs
operator|.
name|count
argument_list|()
condition|;
operator|++
name|a
control|)
block|{
comment|// emit error for all replies
name|QHttpNetworkReply
modifier|*
name|currentReply
init|=
name|spdyPairs
operator|.
name|at
argument_list|(
name|a
argument_list|)
operator|.
name|second
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|currentReply
argument_list|)
expr_stmt|;
emit|emit
name|currentReply
operator|->
name|finishedWithError
argument_list|(
name|errorCode
argument_list|,
name|errorString
argument_list|)
emit|;
block|}
block|}
endif|#
directive|endif
comment|// QT_NO_SSL
comment|// send the next request
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|that
argument_list|,
literal|"_q_startNextRequest"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
if|if
condition|(
name|that
condition|)
comment|//signal emission triggered event loop
name|close
argument_list|()
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
end_ifndef
begin_function
DECL|function|_q_proxyAuthenticationRequired
name|void
name|QHttpNetworkConnectionChannel
operator|::
name|_q_proxyAuthenticationRequired
parameter_list|(
specifier|const
name|QNetworkProxy
modifier|&
name|proxy
parameter_list|,
name|QAuthenticator
modifier|*
name|auth
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_SSL
if|if
condition|(
name|connection
operator|->
name|connectionType
argument_list|()
operator|==
name|QHttpNetworkConnection
operator|::
name|ConnectionTypeSPDY
condition|)
block|{
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|emitProxyAuthenticationRequired
argument_list|(
name|this
argument_list|,
name|proxy
argument_list|,
name|auth
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// HTTP
endif|#
directive|endif
comment|// QT_NO_SSL
comment|// Need to dequeue the request before we can emit the error.
if|if
condition|(
operator|!
name|reply
condition|)
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|dequeueRequest
argument_list|(
name|socket
argument_list|)
expr_stmt|;
if|if
condition|(
name|reply
condition|)
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|emitProxyAuthenticationRequired
argument_list|(
name|this
argument_list|,
name|proxy
argument_list|,
name|auth
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_SSL
block|}
endif|#
directive|endif
comment|// QT_NO_SSL
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|_q_uploadDataReadyRead
name|void
name|QHttpNetworkConnectionChannel
operator|::
name|_q_uploadDataReadyRead
parameter_list|()
block|{
name|sendRequest
argument_list|()
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_SSL
end_ifndef
begin_function
DECL|function|_q_encrypted
name|void
name|QHttpNetworkConnectionChannel
operator|::
name|_q_encrypted
parameter_list|()
block|{
name|QSslSocket
modifier|*
name|sslSocket
init|=
name|qobject_cast
argument_list|<
name|QSslSocket
operator|*
argument_list|>
argument_list|(
name|socket
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|sslSocket
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|protocolHandler
condition|)
block|{
switch|switch
condition|(
name|sslSocket
operator|->
name|sslConfiguration
argument_list|()
operator|.
name|nextProtocolNegotiationStatus
argument_list|()
condition|)
block|{
case|case
name|QSslConfiguration
operator|::
name|NextProtocolNegotiationNegotiated
case|:
block|{
name|QByteArray
name|nextProtocol
init|=
name|sslSocket
operator|->
name|sslConfiguration
argument_list|()
operator|.
name|nextNegotiatedProtocol
argument_list|()
decl_stmt|;
if|if
condition|(
name|nextProtocol
operator|==
name|QSslConfiguration
operator|::
name|NextProtocolHttp1_1
condition|)
block|{
comment|// fall through to create a QHttpProtocolHandler
block|}
elseif|else
if|if
condition|(
name|nextProtocol
operator|==
name|QSslConfiguration
operator|::
name|NextProtocolSpdy3_0
condition|)
block|{
name|protocolHandler
operator|.
name|reset
argument_list|(
operator|new
name|QSpdyProtocolHandler
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
name|connection
operator|->
name|setConnectionType
argument_list|(
name|QHttpNetworkConnection
operator|::
name|ConnectionTypeSPDY
argument_list|)
expr_stmt|;
comment|// no need to re-queue requests, if SPDY was enabled on the request it
comment|// has gone to the SPDY queue already
break|break;
block|}
else|else
block|{
name|emitFinishedWithError
argument_list|(
name|QNetworkReply
operator|::
name|SslHandshakeFailedError
argument_list|,
literal|"detected unknown Next Protocol Negotiation protocol"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
case|case
name|QSslConfiguration
operator|::
name|NextProtocolNegotiationNone
case|:
name|protocolHandler
operator|.
name|reset
argument_list|(
operator|new
name|QHttpProtocolHandler
argument_list|(
name|this
argument_list|)
argument_list|)
expr_stmt|;
name|connection
operator|->
name|setConnectionType
argument_list|(
name|QHttpNetworkConnection
operator|::
name|ConnectionTypeHTTP
argument_list|)
expr_stmt|;
comment|// re-queue requests from SPDY queue to HTTP queue, if any
name|requeueSpdyRequests
argument_list|()
expr_stmt|;
break|break;
case|case
name|QSslConfiguration
operator|::
name|NextProtocolNegotiationUnsupported
case|:
name|emitFinishedWithError
argument_list|(
name|QNetworkReply
operator|::
name|SslHandshakeFailedError
argument_list|,
literal|"chosen Next Protocol Negotiation value unsupported"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|emitFinishedWithError
argument_list|(
name|QNetworkReply
operator|::
name|SslHandshakeFailedError
argument_list|,
literal|"detected unknown Next Protocol Negotiation protocol"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|socket
condition|)
return|return;
comment|// ### error
name|state
operator|=
name|QHttpNetworkConnectionChannel
operator|::
name|IdleState
expr_stmt|;
name|pendingEncrypt
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|connection
operator|->
name|connectionType
argument_list|()
operator|==
name|QHttpNetworkConnection
operator|::
name|ConnectionTypeSPDY
condition|)
block|{
comment|// we call setSpdyWasUsed(true) on the replies in the SPDY handler when the request is sent
if|if
condition|(
name|spdyRequestsToSend
operator|.
name|count
argument_list|()
operator|>
literal|0
condition|)
comment|// wait for data from the server first (e.g. initial window, max concurrent requests)
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|connection
argument_list|,
literal|"_q_startNextRequest"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// HTTP
if|if
condition|(
operator|!
name|reply
condition|)
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|dequeueRequest
argument_list|(
name|socket
argument_list|)
expr_stmt|;
if|if
condition|(
name|reply
condition|)
block|{
name|reply
operator|->
name|setSpdyWasUsed
argument_list|(
literal|false
argument_list|)
expr_stmt|;
emit|emit
name|reply
operator|->
name|encrypted
argument_list|()
emit|;
block|}
if|if
condition|(
name|reply
condition|)
name|sendRequest
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|requeueSpdyRequests
name|void
name|QHttpNetworkConnectionChannel
operator|::
name|requeueSpdyRequests
parameter_list|()
block|{
name|QList
argument_list|<
name|HttpMessagePair
argument_list|>
name|spdyPairs
init|=
name|spdyRequestsToSend
operator|.
name|values
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|a
init|=
literal|0
init|;
name|a
operator|<
name|spdyPairs
operator|.
name|count
argument_list|()
condition|;
operator|++
name|a
control|)
block|{
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|requeueRequest
argument_list|(
name|spdyPairs
operator|.
name|at
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|spdyRequestsToSend
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|emitFinishedWithError
name|void
name|QHttpNetworkConnectionChannel
operator|::
name|emitFinishedWithError
parameter_list|(
name|QNetworkReply
operator|::
name|NetworkError
name|error
parameter_list|,
specifier|const
name|char
modifier|*
name|message
parameter_list|)
block|{
if|if
condition|(
name|reply
condition|)
emit|emit
name|reply
operator|->
name|finishedWithError
argument_list|(
name|error
argument_list|,
name|QHttpNetworkConnectionChannel
operator|::
name|tr
argument_list|(
name|message
argument_list|)
argument_list|)
emit|;
name|QList
argument_list|<
name|HttpMessagePair
argument_list|>
name|spdyPairs
init|=
name|spdyRequestsToSend
operator|.
name|values
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|a
init|=
literal|0
init|;
name|a
operator|<
name|spdyPairs
operator|.
name|count
argument_list|()
condition|;
operator|++
name|a
control|)
block|{
name|QHttpNetworkReply
modifier|*
name|currentReply
init|=
name|spdyPairs
operator|.
name|at
argument_list|(
name|a
argument_list|)
operator|.
name|second
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|currentReply
argument_list|)
expr_stmt|;
emit|emit
name|currentReply
operator|->
name|finishedWithError
argument_list|(
name|error
argument_list|,
name|QHttpNetworkConnectionChannel
operator|::
name|tr
argument_list|(
name|message
argument_list|)
argument_list|)
emit|;
block|}
block|}
end_function
begin_function
DECL|function|_q_sslErrors
name|void
name|QHttpNetworkConnectionChannel
operator|::
name|_q_sslErrors
parameter_list|(
specifier|const
name|QList
argument_list|<
name|QSslError
argument_list|>
modifier|&
name|errors
parameter_list|)
block|{
if|if
condition|(
operator|!
name|socket
condition|)
return|return;
comment|//QNetworkReply::NetworkError errorCode = QNetworkReply::ProtocolFailure;
comment|// Also pause the connection because socket notifiers may fire while an user
comment|// dialog is displaying
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|pauseConnection
argument_list|()
expr_stmt|;
if|if
condition|(
name|pendingEncrypt
operator|&&
operator|!
name|reply
condition|)
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|dequeueRequest
argument_list|(
name|socket
argument_list|)
expr_stmt|;
if|if
condition|(
name|connection
operator|->
name|connectionType
argument_list|()
operator|==
name|QHttpNetworkConnection
operator|::
name|ConnectionTypeHTTP
condition|)
block|{
if|if
condition|(
name|reply
condition|)
emit|emit
name|reply
operator|->
name|sslErrors
argument_list|(
name|errors
argument_list|)
emit|;
block|}
ifndef|#
directive|ifndef
name|QT_NO_SSL
else|else
block|{
comment|// SPDY
name|QList
argument_list|<
name|HttpMessagePair
argument_list|>
name|spdyPairs
init|=
name|spdyRequestsToSend
operator|.
name|values
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|a
init|=
literal|0
init|;
name|a
operator|<
name|spdyPairs
operator|.
name|count
argument_list|()
condition|;
operator|++
name|a
control|)
block|{
comment|// emit SSL errors for all replies
name|QHttpNetworkReply
modifier|*
name|currentReply
init|=
name|spdyPairs
operator|.
name|at
argument_list|(
name|a
argument_list|)
operator|.
name|second
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|currentReply
argument_list|)
expr_stmt|;
emit|emit
name|currentReply
operator|->
name|sslErrors
argument_list|(
name|errors
argument_list|)
emit|;
block|}
block|}
endif|#
directive|endif
comment|// QT_NO_SSL
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|resumeConnection
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|_q_encryptedBytesWritten
name|void
name|QHttpNetworkConnectionChannel
operator|::
name|_q_encryptedBytesWritten
parameter_list|(
name|qint64
name|bytes
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
comment|// bytes have been written to the socket. write even more of them :)
if|if
condition|(
name|isSocketWriting
argument_list|()
condition|)
name|sendRequest
argument_list|()
expr_stmt|;
comment|// otherwise we do nothing
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|setConnection
name|void
name|QHttpNetworkConnectionChannel
operator|::
name|setConnection
parameter_list|(
name|QHttpNetworkConnection
modifier|*
name|c
parameter_list|)
block|{
comment|// Inlining this function in the header leads to compiler error on
comment|// release-armv5, on at least timebox 9.2 and 10.1.
name|connection
operator|=
name|c
expr_stmt|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_include
include|#
directive|include
file|"moc_qhttpnetworkconnectionchannel_p.cpp"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_HTTP
end_comment
end_unit
