begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtNetwork module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qhttpnetworkconnectionchannel_p.h"
end_include
begin_include
include|#
directive|include
file|"qhttpnetworkconnection_p.h"
end_include
begin_include
include|#
directive|include
file|"private/qnoncontiguousbytedevice_p.h"
end_include
begin_include
include|#
directive|include
file|<qpair.h>
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_HTTP
end_ifndef
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_SSL
end_ifndef
begin_include
include|#
directive|include
file|<QtNetwork/qsslkey.h>
end_include
begin_include
include|#
directive|include
file|<QtNetwork/qsslcipher.h>
end_include
begin_include
include|#
directive|include
file|<QtNetwork/qsslconfiguration.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_BEARERMANAGEMENT
end_ifndef
begin_include
include|#
directive|include
file|"private/qnetworksession_p.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_comment
comment|// TODO: Put channel specific stuff here so it does not polute qhttpnetworkconnection.cpp
end_comment
begin_constructor
DECL|function|QHttpNetworkConnectionChannel
name|QHttpNetworkConnectionChannel
operator|::
name|QHttpNetworkConnectionChannel
parameter_list|()
member_init_list|:
name|socket
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|ssl
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|isInitialized
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|state
argument_list|(
name|IdleState
argument_list|)
member_init_list|,
name|reply
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|written
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|bytesTotal
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|resendCurrent
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|lastStatus
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|pendingEncrypt
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|reconnectAttempts
argument_list|(
literal|2
argument_list|)
member_init_list|,
name|authMethod
argument_list|(
name|QAuthenticatorPrivate
operator|::
name|None
argument_list|)
member_init_list|,
name|proxyAuthMethod
argument_list|(
name|QAuthenticatorPrivate
operator|::
name|None
argument_list|)
member_init_list|,
name|authenticationCredentialsSent
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|proxyCredentialsSent
argument_list|(
literal|false
argument_list|)
ifndef|#
directive|ifndef
name|QT_NO_SSL
member_init_list|,
name|ignoreAllSslErrors
argument_list|(
literal|false
argument_list|)
endif|#
directive|endif
member_init_list|,
name|pipeliningSupported
argument_list|(
name|PipeliningSupportUnknown
argument_list|)
member_init_list|,
name|networkLayerPreference
argument_list|(
name|QAbstractSocket
operator|::
name|AnyIPProtocol
argument_list|)
member_init_list|,
name|connection
argument_list|(
literal|0
argument_list|)
block|{
comment|// Inlining this function in the header leads to compiler error on
comment|// release-armv5, on at least timebox 9.2 and 10.1.
block|}
end_constructor
begin_function
DECL|function|init
name|void
name|QHttpNetworkConnectionChannel
operator|::
name|init
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|QT_NO_SSL
if|if
condition|(
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|encrypt
condition|)
name|socket
operator|=
operator|new
name|QSslSocket
expr_stmt|;
else|else
name|socket
operator|=
operator|new
name|QTcpSocket
expr_stmt|;
else|#
directive|else
name|socket
operator|=
operator|new
name|QTcpSocket
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_BEARERMANAGEMENT
comment|//push session down to socket
if|if
condition|(
name|networkSession
condition|)
name|socket
operator|->
name|setProperty
argument_list|(
literal|"_q_networksession"
argument_list|,
name|QVariant
operator|::
name|fromValue
argument_list|(
name|networkSession
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
comment|// Set by QNAM anyway, but let's be safe here
name|socket
operator|->
name|setProxy
argument_list|(
name|QNetworkProxy
operator|::
name|NoProxy
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|QObject
operator|::
name|connect
argument_list|(
name|socket
argument_list|,
name|SIGNAL
argument_list|(
name|bytesWritten
argument_list|(
name|qint64
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|_q_bytesWritten
argument_list|(
name|qint64
argument_list|)
argument_list|)
argument_list|,
name|Qt
operator|::
name|DirectConnection
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|socket
argument_list|,
name|SIGNAL
argument_list|(
name|connected
argument_list|()
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|_q_connected
argument_list|()
argument_list|)
argument_list|,
name|Qt
operator|::
name|DirectConnection
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|socket
argument_list|,
name|SIGNAL
argument_list|(
name|readyRead
argument_list|()
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|_q_readyRead
argument_list|()
argument_list|)
argument_list|,
name|Qt
operator|::
name|DirectConnection
argument_list|)
expr_stmt|;
comment|// The disconnected() and error() signals may already come
comment|// while calling connectToHost().
comment|// In case of a cached hostname or an IP this
comment|// will then emit a signal to the user of QNetworkReply
comment|// but cannot be caught because the user did not have a chance yet
comment|// to connect to QNetworkReply's signals.
name|qRegisterMetaType
argument_list|<
name|QAbstractSocket
operator|::
name|SocketError
argument_list|>
argument_list|()
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|socket
argument_list|,
name|SIGNAL
argument_list|(
name|disconnected
argument_list|()
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|_q_disconnected
argument_list|()
argument_list|)
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|socket
argument_list|,
name|SIGNAL
argument_list|(
name|error
argument_list|(
name|QAbstractSocket
operator|::
name|SocketError
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|_q_error
argument_list|(
name|QAbstractSocket
operator|::
name|SocketError
argument_list|)
argument_list|)
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
name|QObject
operator|::
name|connect
argument_list|(
name|socket
argument_list|,
name|SIGNAL
argument_list|(
name|proxyAuthenticationRequired
argument_list|(
name|QNetworkProxy
argument_list|,
name|QAuthenticator
operator|*
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|_q_proxyAuthenticationRequired
argument_list|(
name|QNetworkProxy
argument_list|,
name|QAuthenticator
operator|*
argument_list|)
argument_list|)
argument_list|,
name|Qt
operator|::
name|DirectConnection
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_SSL
name|QSslSocket
modifier|*
name|sslSocket
init|=
name|qobject_cast
argument_list|<
name|QSslSocket
operator|*
argument_list|>
argument_list|(
name|socket
argument_list|)
decl_stmt|;
if|if
condition|(
name|sslSocket
condition|)
block|{
comment|// won't be a sslSocket if encrypt is false
name|QObject
operator|::
name|connect
argument_list|(
name|sslSocket
argument_list|,
name|SIGNAL
argument_list|(
name|encrypted
argument_list|()
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|_q_encrypted
argument_list|()
argument_list|)
argument_list|,
name|Qt
operator|::
name|DirectConnection
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|sslSocket
argument_list|,
name|SIGNAL
argument_list|(
name|sslErrors
argument_list|(
name|QList
argument_list|<
name|QSslError
argument_list|>
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|_q_sslErrors
argument_list|(
name|QList
argument_list|<
name|QSslError
argument_list|>
argument_list|)
argument_list|)
argument_list|,
name|Qt
operator|::
name|DirectConnection
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|sslSocket
argument_list|,
name|SIGNAL
argument_list|(
name|encryptedBytesWritten
argument_list|(
name|qint64
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|_q_encryptedBytesWritten
argument_list|(
name|qint64
argument_list|)
argument_list|)
argument_list|,
name|Qt
operator|::
name|DirectConnection
argument_list|)
expr_stmt|;
if|if
condition|(
name|ignoreAllSslErrors
condition|)
name|sslSocket
operator|->
name|ignoreSslErrors
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ignoreSslErrorsList
operator|.
name|isEmpty
argument_list|()
condition|)
name|sslSocket
operator|->
name|ignoreSslErrors
argument_list|(
name|ignoreSslErrorsList
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sslConfiguration
operator|.
name|isNull
argument_list|()
condition|)
name|sslSocket
operator|->
name|setSslConfiguration
argument_list|(
name|sslConfiguration
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
if|if
condition|(
name|proxy
operator|.
name|type
argument_list|()
operator|!=
name|QNetworkProxy
operator|::
name|NoProxy
condition|)
name|socket
operator|->
name|setProxy
argument_list|(
name|proxy
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|isInitialized
operator|=
literal|true
expr_stmt|;
block|}
end_function
begin_function
DECL|function|close
name|void
name|QHttpNetworkConnectionChannel
operator|::
name|close
parameter_list|()
block|{
if|if
condition|(
operator|!
name|socket
condition|)
name|state
operator|=
name|QHttpNetworkConnectionChannel
operator|::
name|IdleState
expr_stmt|;
elseif|else
if|if
condition|(
name|socket
operator|->
name|state
argument_list|()
operator|==
name|QAbstractSocket
operator|::
name|UnconnectedState
condition|)
name|state
operator|=
name|QHttpNetworkConnectionChannel
operator|::
name|IdleState
expr_stmt|;
else|else
name|state
operator|=
name|QHttpNetworkConnectionChannel
operator|::
name|ClosingState
expr_stmt|;
if|if
condition|(
name|socket
condition|)
name|socket
operator|->
name|close
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|sendRequest
name|bool
name|QHttpNetworkConnectionChannel
operator|::
name|sendRequest
parameter_list|()
block|{
if|if
condition|(
operator|!
name|reply
condition|)
block|{
comment|// heh, how should that happen!
name|qWarning
argument_list|()
operator|<<
literal|"QHttpNetworkConnectionChannel::sendRequest() called without QHttpNetworkReply"
expr_stmt|;
name|state
operator|=
name|QHttpNetworkConnectionChannel
operator|::
name|IdleState
expr_stmt|;
return|return
literal|false
return|;
block|}
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|QHttpNetworkConnectionChannel
operator|::
name|IdleState
case|:
block|{
comment|// write the header
if|if
condition|(
operator|!
name|ensureConnection
argument_list|()
condition|)
block|{
comment|// wait for the connection (and encryption) to be done
comment|// sendRequest will be called again from either
comment|// _q_connected or _q_encrypted
return|return
literal|false
return|;
block|}
name|written
operator|=
literal|0
expr_stmt|;
comment|// excluding the header
name|bytesTotal
operator|=
literal|0
expr_stmt|;
name|QHttpNetworkReplyPrivate
modifier|*
name|replyPrivate
init|=
name|reply
operator|->
name|d_func
argument_list|()
decl_stmt|;
name|replyPrivate
operator|->
name|clear
argument_list|()
expr_stmt|;
name|replyPrivate
operator|->
name|connection
operator|=
name|connection
expr_stmt|;
name|replyPrivate
operator|->
name|connectionChannel
operator|=
name|this
expr_stmt|;
name|replyPrivate
operator|->
name|autoDecompress
operator|=
name|request
operator|.
name|d
operator|->
name|autoDecompress
expr_stmt|;
name|replyPrivate
operator|->
name|pipeliningUsed
operator|=
literal|false
expr_stmt|;
comment|// if the url contains authentication parameters, use the new ones
comment|// both channels will use the new authentication parameters
if|if
condition|(
operator|!
name|request
operator|.
name|url
argument_list|()
operator|.
name|userInfo
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
name|request
operator|.
name|withCredentials
argument_list|()
condition|)
block|{
name|QUrl
name|url
init|=
name|request
operator|.
name|url
argument_list|()
decl_stmt|;
name|QAuthenticator
modifier|&
name|auth
init|=
name|authenticator
decl_stmt|;
if|if
condition|(
name|url
operator|.
name|userName
argument_list|()
operator|!=
name|auth
operator|.
name|user
argument_list|()
operator|||
operator|(
operator|!
name|url
operator|.
name|password
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
name|url
operator|.
name|password
argument_list|()
operator|!=
name|auth
operator|.
name|password
argument_list|()
operator|)
condition|)
block|{
name|auth
operator|.
name|setUser
argument_list|(
name|url
operator|.
name|userName
argument_list|()
argument_list|)
expr_stmt|;
name|auth
operator|.
name|setPassword
argument_list|(
name|url
operator|.
name|password
argument_list|()
argument_list|)
expr_stmt|;
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|copyCredentials
argument_list|(
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|indexOf
argument_list|(
name|socket
argument_list|)
argument_list|,
operator|&
name|auth
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
comment|// clear the userinfo,  since we use the same request for resending
comment|// userinfo in url can conflict with the one in the authenticator
name|url
operator|.
name|setUserInfo
argument_list|(
name|QString
argument_list|()
argument_list|)
expr_stmt|;
name|request
operator|.
name|setUrl
argument_list|(
name|url
argument_list|)
expr_stmt|;
block|}
comment|// Will only be false if QtWebKit is performing a cross-origin XMLHttpRequest
comment|// and withCredentials has not been set to true.
if|if
condition|(
name|request
operator|.
name|withCredentials
argument_list|()
condition|)
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|createAuthorization
argument_list|(
name|socket
argument_list|,
name|request
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
name|QByteArray
name|header
init|=
name|QHttpNetworkRequestPrivate
operator|::
name|header
argument_list|(
name|request
argument_list|,
operator|(
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|networkProxy
operator|.
name|type
argument_list|()
operator|!=
name|QNetworkProxy
operator|::
name|NoProxy
operator|)
argument_list|)
decl_stmt|;
else|#
directive|else
name|QByteArray
name|header
init|=
name|QHttpNetworkRequestPrivate
operator|::
name|header
argument_list|(
name|request
argument_list|,
literal|false
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|socket
operator|->
name|write
argument_list|(
name|header
argument_list|)
expr_stmt|;
comment|// flushing is dangerous (QSslSocket calls transmit which might read or error)
comment|//        socket->flush();
name|QNonContiguousByteDevice
modifier|*
name|uploadByteDevice
init|=
name|request
operator|.
name|uploadByteDevice
argument_list|()
decl_stmt|;
if|if
condition|(
name|uploadByteDevice
condition|)
block|{
comment|// connect the signals so this function gets called again
name|QObject
operator|::
name|connect
argument_list|(
name|uploadByteDevice
argument_list|,
name|SIGNAL
argument_list|(
name|readyRead
argument_list|()
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|_q_uploadDataReadyRead
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|bytesTotal
operator|=
name|request
operator|.
name|contentLength
argument_list|()
expr_stmt|;
name|state
operator|=
name|QHttpNetworkConnectionChannel
operator|::
name|WritingState
expr_stmt|;
comment|// start writing data
name|sendRequest
argument_list|()
expr_stmt|;
comment|//recurse
block|}
else|else
block|{
name|state
operator|=
name|QHttpNetworkConnectionChannel
operator|::
name|WaitingState
expr_stmt|;
comment|// now wait for response
name|sendRequest
argument_list|()
expr_stmt|;
comment|//recurse
block|}
break|break;
block|}
case|case
name|QHttpNetworkConnectionChannel
operator|::
name|WritingState
case|:
block|{
comment|// write the data
name|QNonContiguousByteDevice
modifier|*
name|uploadByteDevice
init|=
name|request
operator|.
name|uploadByteDevice
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|uploadByteDevice
operator|||
name|bytesTotal
operator|==
name|written
condition|)
block|{
if|if
condition|(
name|uploadByteDevice
condition|)
emit|emit
name|reply
operator|->
name|dataSendProgress
argument_list|(
name|written
argument_list|,
name|bytesTotal
argument_list|)
emit|;
name|state
operator|=
name|QHttpNetworkConnectionChannel
operator|::
name|WaitingState
expr_stmt|;
comment|// now wait for response
name|sendRequest
argument_list|()
expr_stmt|;
comment|// recurse
break|break;
block|}
comment|// only feed the QTcpSocket buffer when there is less than 32 kB in it
specifier|const
name|qint64
name|socketBufferFill
init|=
literal|32
operator|*
literal|1024
decl_stmt|;
specifier|const
name|qint64
name|socketWriteMaxSize
init|=
literal|16
operator|*
literal|1024
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_SSL
name|QSslSocket
modifier|*
name|sslSocket
init|=
name|qobject_cast
argument_list|<
name|QSslSocket
operator|*
argument_list|>
argument_list|(
name|socket
argument_list|)
decl_stmt|;
comment|// if it is really an ssl socket, check more than just bytesToWrite()
while|while
condition|(
operator|(
name|socket
operator|->
name|bytesToWrite
argument_list|()
operator|+
operator|(
name|sslSocket
condition|?
name|sslSocket
operator|->
name|encryptedBytesToWrite
argument_list|()
else|:
literal|0
operator|)
operator|)
operator|<=
name|socketBufferFill
operator|&&
name|bytesTotal
operator|!=
name|written
condition|)
else|#
directive|else
while|while
condition|(
name|socket
operator|->
name|bytesToWrite
argument_list|()
operator|<=
name|socketBufferFill
operator|&&
name|bytesTotal
operator|!=
name|written
condition|)
endif|#
directive|endif
block|{
comment|// get pointer to upload data
name|qint64
name|currentReadSize
init|=
literal|0
decl_stmt|;
name|qint64
name|desiredReadSize
init|=
name|qMin
argument_list|(
name|socketWriteMaxSize
argument_list|,
name|bytesTotal
operator|-
name|written
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|readPointer
init|=
name|uploadByteDevice
operator|->
name|readPointer
argument_list|(
name|desiredReadSize
argument_list|,
name|currentReadSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|currentReadSize
operator|==
operator|-
literal|1
condition|)
block|{
comment|// premature eof happened
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|emitReplyError
argument_list|(
name|socket
argument_list|,
name|reply
argument_list|,
name|QNetworkReply
operator|::
name|UnknownNetworkError
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|readPointer
operator|==
literal|0
operator|||
name|currentReadSize
operator|==
literal|0
condition|)
block|{
comment|// nothing to read currently, break the loop
break|break;
block|}
else|else
block|{
name|qint64
name|currentWriteSize
init|=
name|socket
operator|->
name|write
argument_list|(
name|readPointer
argument_list|,
name|currentReadSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|currentWriteSize
operator|==
operator|-
literal|1
operator|||
name|currentWriteSize
operator|!=
name|currentReadSize
condition|)
block|{
comment|// socket broke down
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|emitReplyError
argument_list|(
name|socket
argument_list|,
name|reply
argument_list|,
name|QNetworkReply
operator|::
name|UnknownNetworkError
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
else|else
block|{
name|written
operator|+=
name|currentWriteSize
expr_stmt|;
name|uploadByteDevice
operator|->
name|advanceReadPointer
argument_list|(
name|currentWriteSize
argument_list|)
expr_stmt|;
emit|emit
name|reply
operator|->
name|dataSendProgress
argument_list|(
name|written
argument_list|,
name|bytesTotal
argument_list|)
emit|;
if|if
condition|(
name|written
operator|==
name|bytesTotal
condition|)
block|{
comment|// make sure this function is called once again
name|state
operator|=
name|QHttpNetworkConnectionChannel
operator|::
name|WaitingState
expr_stmt|;
name|sendRequest
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
break|break;
block|}
case|case
name|QHttpNetworkConnectionChannel
operator|::
name|WaitingState
case|:
block|{
name|QNonContiguousByteDevice
modifier|*
name|uploadByteDevice
init|=
name|request
operator|.
name|uploadByteDevice
argument_list|()
decl_stmt|;
if|if
condition|(
name|uploadByteDevice
condition|)
block|{
name|QObject
operator|::
name|disconnect
argument_list|(
name|uploadByteDevice
argument_list|,
name|SIGNAL
argument_list|(
name|readyRead
argument_list|()
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|_q_uploadDataReadyRead
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// HTTP pipelining
comment|//connection->d_func()->fillPipeline(socket);
comment|//socket->flush();
comment|// ensure we try to receive a reply in all cases, even if _q_readyRead_ hat not been called
comment|// this is needed if the sends an reply before we have finished sending the request. In that
comment|// case receiveReply had been called before but ignored the server reply
if|if
condition|(
name|socket
operator|->
name|bytesAvailable
argument_list|()
condition|)
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|this
argument_list|,
literal|"_q_receiveReply"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|QHttpNetworkConnectionChannel
operator|::
name|ReadingState
case|:
comment|// ignore _q_bytesWritten in these states
comment|// fall through
default|default:
break|break;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|_q_receiveReply
name|void
name|QHttpNetworkConnectionChannel
operator|::
name|_q_receiveReply
parameter_list|()
block|{
name|Q_ASSERT
argument_list|(
name|socket
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reply
condition|)
block|{
if|if
condition|(
name|socket
operator|->
name|bytesAvailable
argument_list|()
operator|>
literal|0
condition|)
name|qWarning
argument_list|()
operator|<<
literal|"QHttpNetworkConnectionChannel::_q_receiveReply() called without QHttpNetworkReply,"
operator|<<
name|socket
operator|->
name|bytesAvailable
argument_list|()
operator|<<
literal|"bytes on socket."
expr_stmt|;
name|close
argument_list|()
expr_stmt|;
return|return;
block|}
comment|// only run when the QHttpNetworkConnection is not currently being destructed, e.g.
comment|// this function is called from _q_disconnected which is called because
comment|// of ~QHttpNetworkConnectionPrivate
if|if
condition|(
operator|!
name|qobject_cast
argument_list|<
name|QHttpNetworkConnection
operator|*
argument_list|>
argument_list|(
name|connection
argument_list|)
condition|)
block|{
return|return;
block|}
name|QAbstractSocket
operator|::
name|SocketState
name|socketState
init|=
name|socket
operator|->
name|state
argument_list|()
decl_stmt|;
comment|// connection might be closed to signal the end of data
if|if
condition|(
name|socketState
operator|==
name|QAbstractSocket
operator|::
name|UnconnectedState
condition|)
block|{
if|if
condition|(
name|socket
operator|->
name|bytesAvailable
argument_list|()
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|reply
operator|->
name|d_func
argument_list|()
operator|->
name|state
operator|==
name|QHttpNetworkReplyPrivate
operator|::
name|ReadingDataState
condition|)
block|{
comment|// finish this reply. this case happens when the server did not send a content length
name|reply
operator|->
name|d_func
argument_list|()
operator|->
name|state
operator|=
name|QHttpNetworkReplyPrivate
operator|::
name|AllDoneState
expr_stmt|;
name|allDone
argument_list|()
expr_stmt|;
return|return;
block|}
else|else
block|{
name|handleUnexpectedEOF
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
comment|// socket not connected but still bytes for reading.. just continue in this function
block|}
block|}
comment|// read loop for the response
name|qint64
name|bytes
init|=
literal|0
decl_stmt|;
name|qint64
name|lastBytes
init|=
name|bytes
decl_stmt|;
do|do
block|{
name|lastBytes
operator|=
name|bytes
expr_stmt|;
name|QHttpNetworkReplyPrivate
operator|::
name|ReplyState
name|state
init|=
name|reply
operator|->
name|d_func
argument_list|()
operator|->
name|state
decl_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|QHttpNetworkReplyPrivate
operator|::
name|NothingDoneState
case|:
block|{
name|state
operator|=
name|reply
operator|->
name|d_func
argument_list|()
operator|->
name|state
operator|=
name|QHttpNetworkReplyPrivate
operator|::
name|ReadingStatusState
expr_stmt|;
comment|// fallthrough
block|}
case|case
name|QHttpNetworkReplyPrivate
operator|::
name|ReadingStatusState
case|:
block|{
name|qint64
name|statusBytes
init|=
name|reply
operator|->
name|d_func
argument_list|()
operator|->
name|readStatus
argument_list|(
name|socket
argument_list|)
decl_stmt|;
if|if
condition|(
name|statusBytes
operator|==
operator|-
literal|1
condition|)
block|{
comment|// connection broke while reading status. also handled if later _q_disconnected is called
name|handleUnexpectedEOF
argument_list|()
expr_stmt|;
return|return;
block|}
name|bytes
operator|+=
name|statusBytes
expr_stmt|;
name|lastStatus
operator|=
name|reply
operator|->
name|d_func
argument_list|()
operator|->
name|statusCode
expr_stmt|;
break|break;
block|}
case|case
name|QHttpNetworkReplyPrivate
operator|::
name|ReadingHeaderState
case|:
block|{
name|QHttpNetworkReplyPrivate
modifier|*
name|replyPrivate
init|=
name|reply
operator|->
name|d_func
argument_list|()
decl_stmt|;
name|qint64
name|headerBytes
init|=
name|replyPrivate
operator|->
name|readHeader
argument_list|(
name|socket
argument_list|)
decl_stmt|;
if|if
condition|(
name|headerBytes
operator|==
operator|-
literal|1
condition|)
block|{
comment|// connection broke while reading headers. also handled if later _q_disconnected is called
name|handleUnexpectedEOF
argument_list|()
expr_stmt|;
return|return;
block|}
name|bytes
operator|+=
name|headerBytes
expr_stmt|;
comment|// If headers were parsed successfully now it is the ReadingDataState
if|if
condition|(
name|replyPrivate
operator|->
name|state
operator|==
name|QHttpNetworkReplyPrivate
operator|::
name|ReadingDataState
condition|)
block|{
if|if
condition|(
name|replyPrivate
operator|->
name|isCompressed
argument_list|()
operator|&&
name|replyPrivate
operator|->
name|autoDecompress
condition|)
block|{
comment|// remove the Content-Length from header
name|replyPrivate
operator|->
name|removeAutoDecompressHeader
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|replyPrivate
operator|->
name|autoDecompress
operator|=
literal|false
expr_stmt|;
block|}
if|if
condition|(
name|replyPrivate
operator|->
name|statusCode
operator|==
literal|100
condition|)
block|{
name|replyPrivate
operator|->
name|clearHttpLayerInformation
argument_list|()
expr_stmt|;
name|replyPrivate
operator|->
name|state
operator|=
name|QHttpNetworkReplyPrivate
operator|::
name|ReadingStatusState
expr_stmt|;
break|break;
comment|// ignore
block|}
if|if
condition|(
name|replyPrivate
operator|->
name|shouldEmitSignals
argument_list|()
condition|)
emit|emit
name|reply
operator|->
name|headerChanged
argument_list|()
emit|;
comment|// After headerChanged had been emitted
comment|// we can suddenly have a replyPrivate->userProvidedDownloadBuffer
comment|// this is handled in the ReadingDataState however
if|if
condition|(
operator|!
name|replyPrivate
operator|->
name|expectContent
argument_list|()
condition|)
block|{
name|replyPrivate
operator|->
name|state
operator|=
name|QHttpNetworkReplyPrivate
operator|::
name|AllDoneState
expr_stmt|;
name|allDone
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
break|break;
block|}
case|case
name|QHttpNetworkReplyPrivate
operator|::
name|ReadingDataState
case|:
block|{
name|QHttpNetworkReplyPrivate
modifier|*
name|replyPrivate
init|=
name|reply
operator|->
name|d_func
argument_list|()
decl_stmt|;
if|if
condition|(
name|socket
operator|->
name|state
argument_list|()
operator|==
name|QAbstractSocket
operator|::
name|ConnectedState
operator|&&
name|replyPrivate
operator|->
name|downstreamLimited
operator|&&
operator|!
name|replyPrivate
operator|->
name|responseData
operator|.
name|isEmpty
argument_list|()
operator|&&
name|replyPrivate
operator|->
name|shouldEmitSignals
argument_list|()
condition|)
block|{
comment|// (only do the following when still connected, not when we have already been disconnected and there is still data)
comment|// We already have some HTTP body data. We don't read more from the socket until
comment|// this is fetched by QHttpNetworkAccessHttpBackend. If we would read more,
comment|// we could not limit our read buffer usage.
comment|// We only do this when shouldEmitSignals==true because our HTTP parsing
comment|// always needs to parse the 401/407 replies. Therefore they don't really obey
comment|// to the read buffer maximum size, but we don't care since they should be small.
return|return;
block|}
if|if
condition|(
name|replyPrivate
operator|->
name|userProvidedDownloadBuffer
condition|)
block|{
comment|// the user provided a direct buffer where we should put all our data in.
comment|// this only works when we can tell the user the content length and he/she can allocate
comment|// the buffer in that size.
comment|// note that this call will read only from the still buffered data
name|qint64
name|haveRead
init|=
name|replyPrivate
operator|->
name|readBodyVeryFast
argument_list|(
name|socket
argument_list|,
name|replyPrivate
operator|->
name|userProvidedDownloadBuffer
operator|+
name|replyPrivate
operator|->
name|totalProgress
argument_list|)
decl_stmt|;
if|if
condition|(
name|haveRead
operator|>
literal|0
condition|)
block|{
name|bytes
operator|+=
name|haveRead
expr_stmt|;
name|replyPrivate
operator|->
name|totalProgress
operator|+=
name|haveRead
expr_stmt|;
comment|// the user will get notified of it via progress signal
emit|emit
name|reply
operator|->
name|dataReadProgress
argument_list|(
name|replyPrivate
operator|->
name|totalProgress
argument_list|,
name|replyPrivate
operator|->
name|bodyLength
argument_list|)
emit|;
block|}
elseif|else
if|if
condition|(
name|haveRead
operator|==
literal|0
condition|)
block|{
comment|// Happens since this called in a loop. Currently no bytes available.
block|}
elseif|else
if|if
condition|(
name|haveRead
operator|<
literal|0
condition|)
block|{
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|emitReplyError
argument_list|(
name|socket
argument_list|,
name|reply
argument_list|,
name|QNetworkReply
operator|::
name|RemoteHostClosedError
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|replyPrivate
operator|->
name|isChunked
argument_list|()
operator|&&
operator|!
name|replyPrivate
operator|->
name|autoDecompress
operator|&&
name|replyPrivate
operator|->
name|bodyLength
operator|>
literal|0
condition|)
block|{
comment|// bulk files like images should fulfill these properties and
comment|// we can therefore save on memory copying
name|qint64
name|haveRead
init|=
name|replyPrivate
operator|->
name|readBodyFast
argument_list|(
name|socket
argument_list|,
operator|&
name|replyPrivate
operator|->
name|responseData
argument_list|)
decl_stmt|;
name|bytes
operator|+=
name|haveRead
expr_stmt|;
name|replyPrivate
operator|->
name|totalProgress
operator|+=
name|haveRead
expr_stmt|;
if|if
condition|(
name|replyPrivate
operator|->
name|shouldEmitSignals
argument_list|()
condition|)
block|{
emit|emit
name|reply
operator|->
name|readyRead
argument_list|()
emit|;
emit|emit
name|reply
operator|->
name|dataReadProgress
argument_list|(
name|replyPrivate
operator|->
name|totalProgress
argument_list|,
name|replyPrivate
operator|->
name|bodyLength
argument_list|)
emit|;
block|}
block|}
else|else
block|{
comment|// use the traditional slower reading (for compressed encoding, chunked encoding,
comment|// no content-length etc)
name|qint64
name|haveRead
init|=
name|replyPrivate
operator|->
name|readBody
argument_list|(
name|socket
argument_list|,
operator|&
name|replyPrivate
operator|->
name|responseData
argument_list|)
decl_stmt|;
if|if
condition|(
name|haveRead
operator|>
literal|0
condition|)
block|{
name|bytes
operator|+=
name|haveRead
expr_stmt|;
name|replyPrivate
operator|->
name|totalProgress
operator|+=
name|haveRead
expr_stmt|;
if|if
condition|(
name|replyPrivate
operator|->
name|shouldEmitSignals
argument_list|()
condition|)
block|{
emit|emit
name|reply
operator|->
name|readyRead
argument_list|()
emit|;
emit|emit
name|reply
operator|->
name|dataReadProgress
argument_list|(
name|replyPrivate
operator|->
name|totalProgress
argument_list|,
name|replyPrivate
operator|->
name|bodyLength
argument_list|)
emit|;
block|}
block|}
elseif|else
if|if
condition|(
name|haveRead
operator|==
operator|-
literal|1
condition|)
block|{
comment|// Some error occurred
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|emitReplyError
argument_list|(
name|socket
argument_list|,
name|reply
argument_list|,
name|QNetworkReply
operator|::
name|ProtocolFailure
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|// still in ReadingDataState? This function will be called again by the socket's readyRead
if|if
condition|(
name|replyPrivate
operator|->
name|state
operator|==
name|QHttpNetworkReplyPrivate
operator|::
name|ReadingDataState
condition|)
break|break;
comment|// everything done, fall through
block|}
case|case
name|QHttpNetworkReplyPrivate
operator|::
name|AllDoneState
case|:
name|allDone
argument_list|()
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
do|while
condition|(
name|bytes
operator|!=
name|lastBytes
operator|&&
name|reply
condition|)
do|;
block|}
end_function
begin_comment
comment|// called when unexpectedly reading a -1 or when data is expected but socket is closed
end_comment
begin_function
DECL|function|handleUnexpectedEOF
name|void
name|QHttpNetworkConnectionChannel
operator|::
name|handleUnexpectedEOF
parameter_list|()
block|{
name|Q_ASSERT
argument_list|(
name|reply
argument_list|)
expr_stmt|;
if|if
condition|(
name|reconnectAttempts
operator|<=
literal|0
condition|)
block|{
comment|// too many errors reading/receiving/parsing the status, close the socket and emit error
name|requeueCurrentlyPipelinedRequests
argument_list|()
expr_stmt|;
name|close
argument_list|()
expr_stmt|;
name|reply
operator|->
name|d_func
argument_list|()
operator|->
name|errorString
operator|=
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|errorDetail
argument_list|(
name|QNetworkReply
operator|::
name|RemoteHostClosedError
argument_list|,
name|socket
argument_list|)
expr_stmt|;
emit|emit
name|reply
operator|->
name|finishedWithError
argument_list|(
name|QNetworkReply
operator|::
name|RemoteHostClosedError
argument_list|,
name|reply
operator|->
name|d_func
argument_list|()
operator|->
name|errorString
argument_list|)
emit|;
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|connection
argument_list|,
literal|"_q_startNextRequest"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|reconnectAttempts
operator|--
expr_stmt|;
name|reply
operator|->
name|d_func
argument_list|()
operator|->
name|clear
argument_list|()
expr_stmt|;
name|reply
operator|->
name|d_func
argument_list|()
operator|->
name|connection
operator|=
name|connection
expr_stmt|;
name|reply
operator|->
name|d_func
argument_list|()
operator|->
name|connectionChannel
operator|=
name|this
expr_stmt|;
name|closeAndResendCurrentRequest
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|ensureConnection
name|bool
name|QHttpNetworkConnectionChannel
operator|::
name|ensureConnection
parameter_list|()
block|{
if|if
condition|(
operator|!
name|isInitialized
condition|)
name|init
argument_list|()
expr_stmt|;
name|QAbstractSocket
operator|::
name|SocketState
name|socketState
init|=
name|socket
operator|->
name|state
argument_list|()
decl_stmt|;
comment|// resend this request after we receive the disconnected signal
if|if
condition|(
name|socketState
operator|==
name|QAbstractSocket
operator|::
name|ClosingState
condition|)
block|{
if|if
condition|(
name|reply
condition|)
name|resendCurrent
operator|=
literal|true
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// already trying to connect?
if|if
condition|(
name|socketState
operator|==
name|QAbstractSocket
operator|::
name|HostLookupState
operator|||
name|socketState
operator|==
name|QAbstractSocket
operator|::
name|ConnectingState
condition|)
block|{
return|return
literal|false
return|;
block|}
comment|// make sure that this socket is in a connected state, if not initiate
comment|// connection to the host.
if|if
condition|(
name|socketState
operator|!=
name|QAbstractSocket
operator|::
name|ConnectedState
condition|)
block|{
comment|// connect to the host if not already connected.
name|state
operator|=
name|QHttpNetworkConnectionChannel
operator|::
name|ConnectingState
expr_stmt|;
name|pendingEncrypt
operator|=
name|ssl
expr_stmt|;
comment|// reset state
name|pipeliningSupported
operator|=
name|PipeliningSupportUnknown
expr_stmt|;
name|authenticationCredentialsSent
operator|=
literal|false
expr_stmt|;
name|proxyCredentialsSent
operator|=
literal|false
expr_stmt|;
name|authenticator
operator|.
name|detach
argument_list|()
expr_stmt|;
name|QAuthenticatorPrivate
modifier|*
name|priv
init|=
name|QAuthenticatorPrivate
operator|::
name|getPrivate
argument_list|(
name|authenticator
argument_list|)
decl_stmt|;
name|priv
operator|->
name|hasFailed
operator|=
literal|false
expr_stmt|;
name|proxyAuthenticator
operator|.
name|detach
argument_list|()
expr_stmt|;
name|priv
operator|=
name|QAuthenticatorPrivate
operator|::
name|getPrivate
argument_list|(
name|proxyAuthenticator
argument_list|)
expr_stmt|;
name|priv
operator|->
name|hasFailed
operator|=
literal|false
expr_stmt|;
comment|// This workaround is needed since we use QAuthenticator for NTLM authentication. The "phase == Done"
comment|// is the usual criteria for emitting authentication signals. The "phase" is set to "Done" when the
comment|// last header for Authorization is generated by the QAuthenticator. Basic& Digest logic does not
comment|// check the "phase" for generating the Authorization header. NTLM authentication is a two stage
comment|// process& needs the "phase". To make sure the QAuthenticator uses the current username/password
comment|// the phase is reset to Start.
name|priv
operator|=
name|QAuthenticatorPrivate
operator|::
name|getPrivate
argument_list|(
name|authenticator
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|&&
name|priv
operator|->
name|phase
operator|==
name|QAuthenticatorPrivate
operator|::
name|Done
condition|)
name|priv
operator|->
name|phase
operator|=
name|QAuthenticatorPrivate
operator|::
name|Start
expr_stmt|;
name|priv
operator|=
name|QAuthenticatorPrivate
operator|::
name|getPrivate
argument_list|(
name|proxyAuthenticator
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|&&
name|priv
operator|->
name|phase
operator|==
name|QAuthenticatorPrivate
operator|::
name|Done
condition|)
name|priv
operator|->
name|phase
operator|=
name|QAuthenticatorPrivate
operator|::
name|Start
expr_stmt|;
name|QString
name|connectHost
init|=
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|hostName
decl_stmt|;
name|qint16
name|connectPort
init|=
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|port
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
comment|// HTTPS always use transparent proxy.
if|if
condition|(
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|networkProxy
operator|.
name|type
argument_list|()
operator|!=
name|QNetworkProxy
operator|::
name|NoProxy
operator|&&
operator|!
name|ssl
condition|)
block|{
name|connectHost
operator|=
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|networkProxy
operator|.
name|hostName
argument_list|()
expr_stmt|;
name|connectPort
operator|=
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|networkProxy
operator|.
name|port
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|socket
operator|->
name|proxy
argument_list|()
operator|.
name|type
argument_list|()
operator|==
name|QNetworkProxy
operator|::
name|HttpProxy
condition|)
block|{
comment|// Make user-agent field available to HTTP proxy socket engine (QTBUG-17223)
name|QByteArray
name|value
decl_stmt|;
comment|// ensureConnection is called before any request has been assigned, but can also be called again if reconnecting
if|if
condition|(
name|request
operator|.
name|url
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|value
operator|=
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|predictNextRequest
argument_list|()
operator|.
name|headerField
argument_list|(
literal|"user-agent"
argument_list|)
expr_stmt|;
else|else
name|value
operator|=
name|request
operator|.
name|headerField
argument_list|(
literal|"user-agent"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|value
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QNetworkProxy
name|proxy
argument_list|(
name|socket
operator|->
name|proxy
argument_list|()
argument_list|)
decl_stmt|;
name|proxy
operator|.
name|setRawHeader
argument_list|(
literal|"User-Agent"
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|//detaches
name|socket
operator|->
name|setProxy
argument_list|(
name|proxy
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|ssl
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_SSL
name|QSslSocket
modifier|*
name|sslSocket
init|=
name|qobject_cast
argument_list|<
name|QSslSocket
operator|*
argument_list|>
argument_list|(
name|socket
argument_list|)
decl_stmt|;
name|sslSocket
operator|->
name|connectToHostEncrypted
argument_list|(
name|connectHost
argument_list|,
name|connectPort
argument_list|,
name|QIODevice
operator|::
name|ReadWrite
argument_list|,
name|networkLayerPreference
argument_list|)
expr_stmt|;
if|if
condition|(
name|ignoreAllSslErrors
condition|)
name|sslSocket
operator|->
name|ignoreSslErrors
argument_list|()
expr_stmt|;
name|sslSocket
operator|->
name|ignoreSslErrors
argument_list|(
name|ignoreSslErrorsList
argument_list|)
expr_stmt|;
comment|// limit the socket read buffer size. we will read everything into
comment|// the QHttpNetworkReply anyway, so let's grow only that and not
comment|// here and there.
name|socket
operator|->
name|setReadBufferSize
argument_list|(
literal|64
operator|*
literal|1024
argument_list|)
expr_stmt|;
else|#
directive|else
comment|// Need to dequeue the request so that we can emit the error.
if|if
condition|(
operator|!
name|reply
condition|)
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|dequeueRequest
argument_list|(
name|socket
argument_list|)
expr_stmt|;
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|emitReplyError
argument_list|(
name|socket
argument_list|,
name|reply
argument_list|,
name|QNetworkReply
operator|::
name|ProtocolUnknownError
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|// In case of no proxy we can use the Unbuffered QTcpSocket
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
if|if
condition|(
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|networkProxy
operator|.
name|type
argument_list|()
operator|==
name|QNetworkProxy
operator|::
name|NoProxy
operator|&&
name|connection
operator|->
name|cacheProxy
argument_list|()
operator|.
name|type
argument_list|()
operator|==
name|QNetworkProxy
operator|::
name|NoProxy
operator|&&
name|connection
operator|->
name|transparentProxy
argument_list|()
operator|.
name|type
argument_list|()
operator|==
name|QNetworkProxy
operator|::
name|NoProxy
condition|)
block|{
endif|#
directive|endif
name|socket
operator|->
name|connectToHost
argument_list|(
name|connectHost
argument_list|,
name|connectPort
argument_list|,
name|QIODevice
operator|::
name|ReadWrite
operator||
name|QIODevice
operator|::
name|Unbuffered
argument_list|,
name|networkLayerPreference
argument_list|)
expr_stmt|;
comment|// For an Unbuffered QTcpSocket, the read buffer size has a special meaning.
name|socket
operator|->
name|setReadBufferSize
argument_list|(
literal|1
operator|*
literal|1024
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
block|}
else|else
block|{
name|socket
operator|->
name|connectToHost
argument_list|(
name|connectHost
argument_list|,
name|connectPort
argument_list|,
name|QIODevice
operator|::
name|ReadWrite
argument_list|,
name|networkLayerPreference
argument_list|)
expr_stmt|;
comment|// limit the socket read buffer size. we will read everything into
comment|// the QHttpNetworkReply anyway, so let's grow only that and not
comment|// here and there.
name|socket
operator|->
name|setReadBufferSize
argument_list|(
literal|64
operator|*
literal|1024
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|allDone
name|void
name|QHttpNetworkConnectionChannel
operator|::
name|allDone
parameter_list|()
block|{
name|Q_ASSERT
argument_list|(
name|reply
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reply
condition|)
block|{
name|qWarning
argument_list|()
operator|<<
literal|"QHttpNetworkConnectionChannel::allDone() called without reply. Please report at http://bugreports.qt-project.org/"
expr_stmt|;
return|return;
block|}
comment|// while handling 401& 407, we might reset the status code, so save this.
name|bool
name|emitFinished
init|=
name|reply
operator|->
name|d_func
argument_list|()
operator|->
name|shouldEmitSignals
argument_list|()
decl_stmt|;
name|bool
name|connectionCloseEnabled
init|=
name|reply
operator|->
name|d_func
argument_list|()
operator|->
name|isConnectionCloseEnabled
argument_list|()
decl_stmt|;
name|detectPipeliningSupport
argument_list|()
expr_stmt|;
name|handleStatus
argument_list|()
expr_stmt|;
comment|// handleStatus() might have removed the reply because it already called connection->emitReplyError()
comment|// queue the finished signal, this is required since we might send new requests from
comment|// slot connected to it. The socket will not fire readyRead signal, if we are already
comment|// in the slot connected to readyRead
if|if
condition|(
name|reply
operator|&&
name|emitFinished
condition|)
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|reply
argument_list|,
literal|"finished"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
comment|// reset the reconnection attempts after we receive a complete reply.
comment|// in case of failures, each channel will attempt two reconnects before emitting error.
name|reconnectAttempts
operator|=
literal|2
expr_stmt|;
comment|// now the channel can be seen as free/idle again, all signal emissions for the reply have been done
if|if
condition|(
name|state
operator|!=
name|QHttpNetworkConnectionChannel
operator|::
name|ClosingState
condition|)
name|state
operator|=
name|QHttpNetworkConnectionChannel
operator|::
name|IdleState
expr_stmt|;
comment|// if it does not need to be sent again we can set it to 0
comment|// the previous code did not do that and we had problems with accidental re-sending of a
comment|// finished request.
comment|// Note that this may trigger a segfault at some other point. But then we can fix the underlying
comment|// problem.
if|if
condition|(
operator|!
name|resendCurrent
condition|)
block|{
name|request
operator|=
name|QHttpNetworkRequest
argument_list|()
expr_stmt|;
name|reply
operator|=
literal|0
expr_stmt|;
block|}
comment|// move next from pipeline to current request
if|if
condition|(
operator|!
name|alreadyPipelinedRequests
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|resendCurrent
operator|||
name|connectionCloseEnabled
operator|||
name|socket
operator|->
name|state
argument_list|()
operator|!=
name|QAbstractSocket
operator|::
name|ConnectedState
condition|)
block|{
comment|// move the pipelined ones back to the main queue
name|requeueCurrentlyPipelinedRequests
argument_list|()
expr_stmt|;
name|close
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// there were requests pipelined in and we can continue
name|HttpMessagePair
name|messagePair
init|=
name|alreadyPipelinedRequests
operator|.
name|takeFirst
argument_list|()
decl_stmt|;
name|request
operator|=
name|messagePair
operator|.
name|first
expr_stmt|;
name|reply
operator|=
name|messagePair
operator|.
name|second
expr_stmt|;
name|state
operator|=
name|QHttpNetworkConnectionChannel
operator|::
name|ReadingState
expr_stmt|;
name|resendCurrent
operator|=
literal|false
expr_stmt|;
name|written
operator|=
literal|0
expr_stmt|;
comment|// message body, excluding the header, irrelevant here
name|bytesTotal
operator|=
literal|0
expr_stmt|;
comment|// message body total, excluding the header, irrelevant here
comment|// pipeline even more
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|fillPipeline
argument_list|(
name|socket
argument_list|)
expr_stmt|;
comment|// continue reading
comment|//_q_receiveReply();
comment|// this was wrong, allDone gets called from that function anyway.
block|}
block|}
elseif|else
if|if
condition|(
name|alreadyPipelinedRequests
operator|.
name|isEmpty
argument_list|()
operator|&&
name|socket
operator|->
name|bytesAvailable
argument_list|()
operator|>
literal|0
condition|)
block|{
comment|// this is weird. we had nothing pipelined but still bytes available. better close it.
name|close
argument_list|()
expr_stmt|;
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|connection
argument_list|,
literal|"_q_startNextRequest"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|alreadyPipelinedRequests
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|connectionCloseEnabled
condition|)
if|if
condition|(
name|socket
operator|->
name|state
argument_list|()
operator|!=
name|QAbstractSocket
operator|::
name|UnconnectedState
condition|)
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|qobject_cast
argument_list|<
name|QHttpNetworkConnection
operator|*
argument_list|>
argument_list|(
name|connection
argument_list|)
condition|)
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|connection
argument_list|,
literal|"_q_startNextRequest"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|detectPipeliningSupport
name|void
name|QHttpNetworkConnectionChannel
operator|::
name|detectPipeliningSupport
parameter_list|()
block|{
name|Q_ASSERT
argument_list|(
name|reply
argument_list|)
expr_stmt|;
comment|// detect HTTP Pipelining support
name|QByteArray
name|serverHeaderField
decl_stmt|;
if|if
condition|(
comment|// check for HTTP/1.1
operator|(
name|reply
operator|->
name|d_func
argument_list|()
operator|->
name|majorVersion
operator|==
literal|1
operator|&&
name|reply
operator|->
name|d_func
argument_list|()
operator|->
name|minorVersion
operator|==
literal|1
operator|)
comment|// check for not having connection close
operator|&&
operator|(
operator|!
name|reply
operator|->
name|d_func
argument_list|()
operator|->
name|isConnectionCloseEnabled
argument_list|()
operator|)
comment|// check if it is still connected
operator|&&
operator|(
name|socket
operator|->
name|state
argument_list|()
operator|==
name|QAbstractSocket
operator|::
name|ConnectedState
operator|)
comment|// check for broken servers in server reply header
comment|// this is adapted from http://mxr.mozilla.org/firefox/ident?i=SupportsPipelining
operator|&&
operator|(
name|serverHeaderField
operator|=
name|reply
operator|->
name|headerField
argument_list|(
literal|"Server"
argument_list|)
operator|,
operator|!
name|serverHeaderField
operator|.
name|contains
argument_list|(
literal|"Microsoft-IIS/4."
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|serverHeaderField
operator|.
name|contains
argument_list|(
literal|"Microsoft-IIS/5."
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|serverHeaderField
operator|.
name|contains
argument_list|(
literal|"Netscape-Enterprise/3."
argument_list|)
operator|)
comment|// this is adpoted from the knowledge of the Nokia 7.x browser team (DEF143319)
operator|&&
operator|(
operator|!
name|serverHeaderField
operator|.
name|contains
argument_list|(
literal|"WebLogic"
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|serverHeaderField
operator|.
name|startsWith
argument_list|(
literal|"Rocket"
argument_list|)
operator|)
comment|// a Python Web Server, see Web2py.com
condition|)
block|{
name|pipeliningSupported
operator|=
name|QHttpNetworkConnectionChannel
operator|::
name|PipeliningProbablySupported
expr_stmt|;
block|}
else|else
block|{
name|pipeliningSupported
operator|=
name|QHttpNetworkConnectionChannel
operator|::
name|PipeliningSupportUnknown
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|// called when the connection broke and we need to queue some pipelined requests again
end_comment
begin_function
DECL|function|requeueCurrentlyPipelinedRequests
name|void
name|QHttpNetworkConnectionChannel
operator|::
name|requeueCurrentlyPipelinedRequests
parameter_list|()
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|alreadyPipelinedRequests
operator|.
name|length
argument_list|()
condition|;
name|i
operator|++
control|)
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|requeueRequest
argument_list|(
name|alreadyPipelinedRequests
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|alreadyPipelinedRequests
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// only run when the QHttpNetworkConnection is not currently being destructed, e.g.
comment|// this function is called from _q_disconnected which is called because
comment|// of ~QHttpNetworkConnectionPrivate
if|if
condition|(
name|qobject_cast
argument_list|<
name|QHttpNetworkConnection
operator|*
argument_list|>
argument_list|(
name|connection
argument_list|)
condition|)
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|connection
argument_list|,
literal|"_q_startNextRequest"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|handleStatus
name|void
name|QHttpNetworkConnectionChannel
operator|::
name|handleStatus
parameter_list|()
block|{
name|Q_ASSERT
argument_list|(
name|socket
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|reply
argument_list|)
expr_stmt|;
name|int
name|statusCode
init|=
name|reply
operator|->
name|statusCode
argument_list|()
decl_stmt|;
name|bool
name|resend
init|=
literal|false
decl_stmt|;
switch|switch
condition|(
name|statusCode
condition|)
block|{
case|case
literal|401
case|:
comment|// auth required
case|case
literal|407
case|:
comment|// proxy auth required
if|if
condition|(
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|handleAuthenticateChallenge
argument_list|(
name|socket
argument_list|,
name|reply
argument_list|,
operator|(
name|statusCode
operator|==
literal|407
operator|)
argument_list|,
name|resend
argument_list|)
condition|)
block|{
if|if
condition|(
name|resend
condition|)
block|{
if|if
condition|(
operator|!
name|resetUploadData
argument_list|()
condition|)
break|break;
name|reply
operator|->
name|d_func
argument_list|()
operator|->
name|eraseData
argument_list|()
expr_stmt|;
if|if
condition|(
name|alreadyPipelinedRequests
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// this does a re-send without closing the connection
name|resendCurrent
operator|=
literal|true
expr_stmt|;
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|connection
argument_list|,
literal|"_q_startNextRequest"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// we had requests pipelined.. better close the connection in closeAndResendCurrentRequest
name|closeAndResendCurrentRequest
argument_list|()
expr_stmt|;
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|connection
argument_list|,
literal|"_q_startNextRequest"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|//authentication cancelled, close the channel.
name|close
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
emit|emit
name|reply
operator|->
name|headerChanged
argument_list|()
emit|;
emit|emit
name|reply
operator|->
name|readyRead
argument_list|()
emit|;
name|QNetworkReply
operator|::
name|NetworkError
name|errorCode
init|=
operator|(
name|statusCode
operator|==
literal|407
operator|)
condition|?
name|QNetworkReply
operator|::
name|ProxyAuthenticationRequiredError
else|:
name|QNetworkReply
operator|::
name|AuthenticationRequiredError
decl_stmt|;
name|reply
operator|->
name|d_func
argument_list|()
operator|->
name|errorString
operator|=
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|errorDetail
argument_list|(
name|errorCode
argument_list|,
name|socket
argument_list|)
expr_stmt|;
emit|emit
name|reply
operator|->
name|finishedWithError
argument_list|(
name|errorCode
argument_list|,
name|reply
operator|->
name|d_func
argument_list|()
operator|->
name|errorString
argument_list|)
emit|;
block|}
break|break;
default|default:
if|if
condition|(
name|qobject_cast
argument_list|<
name|QHttpNetworkConnection
operator|*
argument_list|>
argument_list|(
name|connection
argument_list|)
condition|)
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|connection
argument_list|,
literal|"_q_startNextRequest"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|resetUploadData
name|bool
name|QHttpNetworkConnectionChannel
operator|::
name|resetUploadData
parameter_list|()
block|{
if|if
condition|(
operator|!
name|reply
condition|)
block|{
comment|//this happens if server closes connection while QHttpNetworkConnectionPrivate::_q_startNextRequest is pending
return|return
literal|false
return|;
block|}
name|QNonContiguousByteDevice
modifier|*
name|uploadByteDevice
init|=
name|request
operator|.
name|uploadByteDevice
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|uploadByteDevice
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|uploadByteDevice
operator|->
name|reset
argument_list|()
condition|)
block|{
name|written
operator|=
literal|0
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|emitReplyError
argument_list|(
name|socket
argument_list|,
name|reply
argument_list|,
name|QNetworkReply
operator|::
name|ContentReSendError
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
end_ifndef
begin_function
DECL|function|setProxy
name|void
name|QHttpNetworkConnectionChannel
operator|::
name|setProxy
parameter_list|(
specifier|const
name|QNetworkProxy
modifier|&
name|networkProxy
parameter_list|)
block|{
if|if
condition|(
name|socket
condition|)
name|socket
operator|->
name|setProxy
argument_list|(
name|networkProxy
argument_list|)
expr_stmt|;
name|proxy
operator|=
name|networkProxy
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_SSL
end_ifndef
begin_function
DECL|function|ignoreSslErrors
name|void
name|QHttpNetworkConnectionChannel
operator|::
name|ignoreSslErrors
parameter_list|()
block|{
if|if
condition|(
name|socket
condition|)
cast|static_cast
argument_list|<
name|QSslSocket
operator|*
argument_list|>
argument_list|(
name|socket
argument_list|)
operator|->
name|ignoreSslErrors
argument_list|()
expr_stmt|;
name|ignoreAllSslErrors
operator|=
literal|true
expr_stmt|;
block|}
end_function
begin_function
DECL|function|ignoreSslErrors
name|void
name|QHttpNetworkConnectionChannel
operator|::
name|ignoreSslErrors
parameter_list|(
specifier|const
name|QList
argument_list|<
name|QSslError
argument_list|>
modifier|&
name|errors
parameter_list|)
block|{
if|if
condition|(
name|socket
condition|)
cast|static_cast
argument_list|<
name|QSslSocket
operator|*
argument_list|>
argument_list|(
name|socket
argument_list|)
operator|->
name|ignoreSslErrors
argument_list|(
name|errors
argument_list|)
expr_stmt|;
name|ignoreSslErrorsList
operator|=
name|errors
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setSslConfiguration
name|void
name|QHttpNetworkConnectionChannel
operator|::
name|setSslConfiguration
parameter_list|(
specifier|const
name|QSslConfiguration
modifier|&
name|config
parameter_list|)
block|{
if|if
condition|(
name|socket
condition|)
cast|static_cast
argument_list|<
name|QSslSocket
operator|*
argument_list|>
argument_list|(
name|socket
argument_list|)
operator|->
name|setSslConfiguration
argument_list|(
name|config
argument_list|)
expr_stmt|;
name|sslConfiguration
operator|=
name|config
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|pipelineInto
name|void
name|QHttpNetworkConnectionChannel
operator|::
name|pipelineInto
parameter_list|(
name|HttpMessagePair
modifier|&
name|pair
parameter_list|)
block|{
comment|// this is only called for simple GET
name|QHttpNetworkRequest
modifier|&
name|request
init|=
name|pair
operator|.
name|first
decl_stmt|;
name|QHttpNetworkReply
modifier|*
name|reply
init|=
name|pair
operator|.
name|second
decl_stmt|;
name|reply
operator|->
name|d_func
argument_list|()
operator|->
name|clear
argument_list|()
expr_stmt|;
name|reply
operator|->
name|d_func
argument_list|()
operator|->
name|connection
operator|=
name|connection
expr_stmt|;
name|reply
operator|->
name|d_func
argument_list|()
operator|->
name|connectionChannel
operator|=
name|this
expr_stmt|;
name|reply
operator|->
name|d_func
argument_list|()
operator|->
name|autoDecompress
operator|=
name|request
operator|.
name|d
operator|->
name|autoDecompress
expr_stmt|;
name|reply
operator|->
name|d_func
argument_list|()
operator|->
name|pipeliningUsed
operator|=
literal|true
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
name|pipeline
operator|.
name|append
argument_list|(
name|QHttpNetworkRequestPrivate
operator|::
name|header
argument_list|(
name|request
argument_list|,
operator|(
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|networkProxy
operator|.
name|type
argument_list|()
operator|!=
name|QNetworkProxy
operator|::
name|NoProxy
operator|)
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|pipeline
operator|.
name|append
argument_list|(
name|QHttpNetworkRequestPrivate
operator|::
name|header
argument_list|(
name|request
argument_list|,
literal|false
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|alreadyPipelinedRequests
operator|.
name|append
argument_list|(
name|pair
argument_list|)
expr_stmt|;
comment|// pipelineFlush() needs to be called at some point afterwards
block|}
end_function
begin_function
DECL|function|pipelineFlush
name|void
name|QHttpNetworkConnectionChannel
operator|::
name|pipelineFlush
parameter_list|()
block|{
if|if
condition|(
name|pipeline
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
comment|// The goal of this is so that we have everything in one TCP packet.
comment|// For the Unbuffered QTcpSocket this is manually needed, the buffered
comment|// QTcpSocket does it automatically.
comment|// Also, sometimes the OS does it for us (Nagle's algorithm) but that
comment|// happens only sometimes.
name|socket
operator|->
name|write
argument_list|(
name|pipeline
argument_list|)
expr_stmt|;
name|pipeline
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|closeAndResendCurrentRequest
name|void
name|QHttpNetworkConnectionChannel
operator|::
name|closeAndResendCurrentRequest
parameter_list|()
block|{
name|requeueCurrentlyPipelinedRequests
argument_list|()
expr_stmt|;
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|reply
condition|)
name|resendCurrent
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|qobject_cast
argument_list|<
name|QHttpNetworkConnection
operator|*
argument_list|>
argument_list|(
name|connection
argument_list|)
condition|)
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|connection
argument_list|,
literal|"_q_startNextRequest"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|isSocketBusy
name|bool
name|QHttpNetworkConnectionChannel
operator|::
name|isSocketBusy
parameter_list|()
specifier|const
block|{
return|return
operator|(
name|state
operator|&
name|QHttpNetworkConnectionChannel
operator|::
name|BusyState
operator|)
return|;
block|}
end_function
begin_function
DECL|function|isSocketWriting
name|bool
name|QHttpNetworkConnectionChannel
operator|::
name|isSocketWriting
parameter_list|()
specifier|const
block|{
return|return
operator|(
name|state
operator|&
name|QHttpNetworkConnectionChannel
operator|::
name|WritingState
operator|)
return|;
block|}
end_function
begin_function
DECL|function|isSocketWaiting
name|bool
name|QHttpNetworkConnectionChannel
operator|::
name|isSocketWaiting
parameter_list|()
specifier|const
block|{
return|return
operator|(
name|state
operator|&
name|QHttpNetworkConnectionChannel
operator|::
name|WaitingState
operator|)
return|;
block|}
end_function
begin_function
DECL|function|isSocketReading
name|bool
name|QHttpNetworkConnectionChannel
operator|::
name|isSocketReading
parameter_list|()
specifier|const
block|{
return|return
operator|(
name|state
operator|&
name|QHttpNetworkConnectionChannel
operator|::
name|ReadingState
operator|)
return|;
block|}
end_function
begin_comment
comment|//private slots
end_comment
begin_function
DECL|function|_q_readyRead
name|void
name|QHttpNetworkConnectionChannel
operator|::
name|_q_readyRead
parameter_list|()
block|{
if|if
condition|(
name|socket
operator|->
name|state
argument_list|()
operator|==
name|QAbstractSocket
operator|::
name|ConnectedState
operator|&&
name|socket
operator|->
name|bytesAvailable
argument_list|()
operator|==
literal|0
condition|)
block|{
comment|// We got a readyRead but no bytes are available..
comment|// This happens for the Unbuffered QTcpSocket
comment|// Also check if socket is in ConnectedState since
comment|// this function may also be invoked via the event loop.
name|char
name|c
decl_stmt|;
name|qint64
name|ret
init|=
name|socket
operator|->
name|peek
argument_list|(
operator|&
name|c
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|_q_error
argument_list|(
name|socket
operator|->
name|error
argument_list|()
argument_list|)
expr_stmt|;
comment|// We still need to handle the reply so it emits its signals etc.
if|if
condition|(
name|reply
condition|)
name|_q_receiveReply
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|isSocketWaiting
argument_list|()
operator|||
name|isSocketReading
argument_list|()
condition|)
block|{
name|state
operator|=
name|QHttpNetworkConnectionChannel
operator|::
name|ReadingState
expr_stmt|;
if|if
condition|(
name|reply
condition|)
name|_q_receiveReply
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|_q_bytesWritten
name|void
name|QHttpNetworkConnectionChannel
operator|::
name|_q_bytesWritten
parameter_list|(
name|qint64
name|bytes
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
comment|// bytes have been written to the socket. write even more of them :)
if|if
condition|(
name|isSocketWriting
argument_list|()
condition|)
name|sendRequest
argument_list|()
expr_stmt|;
comment|// otherwise we do nothing
block|}
end_function
begin_function
DECL|function|_q_disconnected
name|void
name|QHttpNetworkConnectionChannel
operator|::
name|_q_disconnected
parameter_list|()
block|{
if|if
condition|(
name|state
operator|==
name|QHttpNetworkConnectionChannel
operator|::
name|ClosingState
condition|)
block|{
name|state
operator|=
name|QHttpNetworkConnectionChannel
operator|::
name|IdleState
expr_stmt|;
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|connection
argument_list|,
literal|"_q_startNextRequest"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// read the available data before closing
if|if
condition|(
name|isSocketWaiting
argument_list|()
operator|||
name|isSocketReading
argument_list|()
condition|)
block|{
if|if
condition|(
name|reply
condition|)
block|{
name|state
operator|=
name|QHttpNetworkConnectionChannel
operator|::
name|ReadingState
expr_stmt|;
name|_q_receiveReply
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|state
operator|==
name|QHttpNetworkConnectionChannel
operator|::
name|IdleState
operator|&&
name|resendCurrent
condition|)
block|{
comment|// re-sending request because the socket was in ClosingState
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|connection
argument_list|,
literal|"_q_startNextRequest"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
block|}
name|state
operator|=
name|QHttpNetworkConnectionChannel
operator|::
name|IdleState
expr_stmt|;
name|requeueCurrentlyPipelinedRequests
argument_list|()
expr_stmt|;
name|close
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|_q_connected
name|void
name|QHttpNetworkConnectionChannel
operator|::
name|_q_connected
parameter_list|()
block|{
comment|// For the Happy Eyeballs we need to check if this is the first channel to connect.
if|if
condition|(
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|networkLayerState
operator|==
name|QHttpNetworkConnectionPrivate
operator|::
name|InProgress
condition|)
block|{
if|if
condition|(
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|delayedConnectionTimer
operator|.
name|isActive
argument_list|()
condition|)
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|delayedConnectionTimer
operator|.
name|stop
argument_list|()
expr_stmt|;
if|if
condition|(
name|networkLayerPreference
operator|==
name|QAbstractSocket
operator|::
name|IPv4Protocol
condition|)
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|networkLayerState
operator|=
name|QHttpNetworkConnectionPrivate
operator|::
name|IPv4
expr_stmt|;
elseif|else
if|if
condition|(
name|networkLayerPreference
operator|==
name|QAbstractSocket
operator|::
name|IPv6Protocol
condition|)
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|networkLayerState
operator|=
name|QHttpNetworkConnectionPrivate
operator|::
name|IPv6
expr_stmt|;
else|else
block|{
if|if
condition|(
name|socket
operator|->
name|peerAddress
argument_list|()
operator|.
name|protocol
argument_list|()
operator|==
name|QAbstractSocket
operator|::
name|IPv4Protocol
condition|)
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|networkLayerState
operator|=
name|QHttpNetworkConnectionPrivate
operator|::
name|IPv4
expr_stmt|;
else|else
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|networkLayerState
operator|=
name|QHttpNetworkConnectionPrivate
operator|::
name|IPv6
expr_stmt|;
block|}
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|networkLayerDetected
argument_list|(
name|networkLayerPreference
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
operator|(
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|networkLayerState
operator|==
name|QHttpNetworkConnectionPrivate
operator|::
name|IPv4
operator|)
operator|&&
operator|(
name|networkLayerPreference
operator|!=
name|QAbstractSocket
operator|::
name|IPv4Protocol
operator|)
operator|)
operator|||
operator|(
operator|(
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|networkLayerState
operator|==
name|QHttpNetworkConnectionPrivate
operator|::
name|IPv6
operator|)
operator|&&
operator|(
name|networkLayerPreference
operator|!=
name|QAbstractSocket
operator|::
name|IPv6Protocol
operator|)
operator|)
condition|)
block|{
name|close
argument_list|()
expr_stmt|;
comment|// This is the second connection so it has to be closed and we can schedule it for another request.
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|connection
argument_list|,
literal|"_q_startNextRequest"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
return|return;
block|}
comment|//The connections networkLayerState had already been decided.
block|}
comment|// improve performance since we get the request sent by the kernel ASAP
comment|//socket->setSocketOption(QAbstractSocket::LowDelayOption, 1);
comment|// We have this commented out now. It did not have the effect we wanted. If we want to
comment|// do this properly, Qt has to combine multiple HTTP requests into one buffer
comment|// and send this to the kernel in one syscall and then the kernel immediately sends
comment|// it as one TCP packet because of TCP_NODELAY.
comment|// However, this code is currently not in Qt, so we rely on the kernel combining
comment|// the requests into one TCP packet.
comment|// not sure yet if it helps, but it makes sense
name|socket
operator|->
name|setSocketOption
argument_list|(
name|QAbstractSocket
operator|::
name|KeepAliveOption
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pipeliningSupported
operator|=
name|QHttpNetworkConnectionChannel
operator|::
name|PipeliningSupportUnknown
expr_stmt|;
comment|// ### FIXME: if the server closes the connection unexpectedly, we shouldn't send the same broken request again!
comment|//channels[i].reconnectAttempts = 2;
if|if
condition|(
operator|!
name|pendingEncrypt
condition|)
block|{
name|state
operator|=
name|QHttpNetworkConnectionChannel
operator|::
name|IdleState
expr_stmt|;
if|if
condition|(
operator|!
name|reply
condition|)
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|dequeueRequest
argument_list|(
name|socket
argument_list|)
expr_stmt|;
if|if
condition|(
name|reply
condition|)
name|sendRequest
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|_q_error
name|void
name|QHttpNetworkConnectionChannel
operator|::
name|_q_error
parameter_list|(
name|QAbstractSocket
operator|::
name|SocketError
name|socketError
parameter_list|)
block|{
if|if
condition|(
operator|!
name|socket
condition|)
return|return;
name|QNetworkReply
operator|::
name|NetworkError
name|errorCode
init|=
name|QNetworkReply
operator|::
name|UnknownNetworkError
decl_stmt|;
switch|switch
condition|(
name|socketError
condition|)
block|{
case|case
name|QAbstractSocket
operator|::
name|HostNotFoundError
case|:
name|errorCode
operator|=
name|QNetworkReply
operator|::
name|HostNotFoundError
expr_stmt|;
break|break;
case|case
name|QAbstractSocket
operator|::
name|ConnectionRefusedError
case|:
name|errorCode
operator|=
name|QNetworkReply
operator|::
name|ConnectionRefusedError
expr_stmt|;
break|break;
case|case
name|QAbstractSocket
operator|::
name|RemoteHostClosedError
case|:
comment|// try to reconnect/resend before sending an error.
comment|// while "Reading" the _q_disconnected() will handle this.
if|if
condition|(
name|state
operator|!=
name|QHttpNetworkConnectionChannel
operator|::
name|IdleState
operator|&&
name|state
operator|!=
name|QHttpNetworkConnectionChannel
operator|::
name|ReadingState
condition|)
block|{
if|if
condition|(
name|reconnectAttempts
operator|--
operator|>
literal|0
condition|)
block|{
name|closeAndResendCurrentRequest
argument_list|()
expr_stmt|;
return|return;
block|}
else|else
block|{
name|errorCode
operator|=
name|QNetworkReply
operator|::
name|RemoteHostClosedError
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|state
operator|==
name|QHttpNetworkConnectionChannel
operator|::
name|ReadingState
condition|)
block|{
if|if
condition|(
operator|!
name|reply
operator|->
name|d_func
argument_list|()
operator|->
name|expectContent
argument_list|()
condition|)
block|{
comment|// No content expected, this is a valid way to have the connection closed by the server
return|return;
block|}
if|if
condition|(
name|reply
operator|->
name|contentLength
argument_list|()
operator|==
operator|-
literal|1
operator|&&
operator|!
name|reply
operator|->
name|d_func
argument_list|()
operator|->
name|isChunked
argument_list|()
condition|)
block|{
comment|// There was no content-length header and it's not chunked encoding,
comment|// so this is a valid way to have the connection closed by the server
return|return;
block|}
comment|// ok, we got a disconnect even though we did not expect it
comment|// Try to read everything from the socket before we emit the error.
if|if
condition|(
name|socket
operator|->
name|bytesAvailable
argument_list|()
condition|)
block|{
comment|// Read everything from the socket into the reply buffer.
comment|// we can ignore the readbuffersize as the data is already
comment|// in memory and we will not receive more data on the socket.
name|reply
operator|->
name|setReadBufferSize
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|_q_receiveReply
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_SSL
if|if
condition|(
name|ssl
condition|)
block|{
comment|// QT_NO_OPENSSL. The QSslSocket can still have encrypted bytes in the plainsocket.
comment|// So we need to check this if the socket is a QSslSocket. When the socket is flushed
comment|// it will force a decrypt of the encrypted data in the plainsocket.
name|QSslSocket
modifier|*
name|sslSocket
init|=
cast|static_cast
argument_list|<
name|QSslSocket
operator|*
argument_list|>
argument_list|(
name|socket
argument_list|)
decl_stmt|;
name|qint64
name|beforeFlush
init|=
name|sslSocket
operator|->
name|encryptedBytesAvailable
argument_list|()
decl_stmt|;
while|while
condition|(
name|sslSocket
operator|->
name|encryptedBytesAvailable
argument_list|()
condition|)
block|{
name|sslSocket
operator|->
name|flush
argument_list|()
expr_stmt|;
name|_q_receiveReply
argument_list|()
expr_stmt|;
name|qint64
name|afterFlush
init|=
name|sslSocket
operator|->
name|encryptedBytesAvailable
argument_list|()
decl_stmt|;
if|if
condition|(
name|afterFlush
operator|==
name|beforeFlush
condition|)
break|break;
name|beforeFlush
operator|=
name|afterFlush
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
name|errorCode
operator|=
name|QNetworkReply
operator|::
name|RemoteHostClosedError
expr_stmt|;
block|}
else|else
block|{
name|errorCode
operator|=
name|QNetworkReply
operator|::
name|RemoteHostClosedError
expr_stmt|;
block|}
break|break;
case|case
name|QAbstractSocket
operator|::
name|SocketTimeoutError
case|:
comment|// try to reconnect/resend before sending an error.
if|if
condition|(
name|state
operator|==
name|QHttpNetworkConnectionChannel
operator|::
name|WritingState
operator|&&
operator|(
name|reconnectAttempts
operator|--
operator|>
literal|0
operator|)
condition|)
block|{
name|closeAndResendCurrentRequest
argument_list|()
expr_stmt|;
return|return;
block|}
name|errorCode
operator|=
name|QNetworkReply
operator|::
name|TimeoutError
expr_stmt|;
break|break;
case|case
name|QAbstractSocket
operator|::
name|ProxyAuthenticationRequiredError
case|:
name|errorCode
operator|=
name|QNetworkReply
operator|::
name|ProxyAuthenticationRequiredError
expr_stmt|;
break|break;
case|case
name|QAbstractSocket
operator|::
name|SslHandshakeFailedError
case|:
name|errorCode
operator|=
name|QNetworkReply
operator|::
name|SslHandshakeFailedError
expr_stmt|;
break|break;
default|default:
comment|// all other errors are treated as NetworkError
name|errorCode
operator|=
name|QNetworkReply
operator|::
name|UnknownNetworkError
expr_stmt|;
break|break;
block|}
name|QPointer
argument_list|<
name|QHttpNetworkConnection
argument_list|>
name|that
init|=
name|connection
decl_stmt|;
name|QString
name|errorString
init|=
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|errorDetail
argument_list|(
name|errorCode
argument_list|,
name|socket
argument_list|,
name|socket
operator|->
name|errorString
argument_list|()
argument_list|)
decl_stmt|;
comment|// In the InProgress state the channel should not emit the error.
comment|// This will instead be handled by the connection.
if|if
condition|(
operator|!
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|shouldEmitChannelError
argument_list|(
name|socket
argument_list|)
condition|)
return|return;
comment|// Need to dequeu the request so that we can emit the error.
if|if
condition|(
operator|!
name|reply
condition|)
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|dequeueRequest
argument_list|(
name|socket
argument_list|)
expr_stmt|;
if|if
condition|(
name|reply
condition|)
block|{
name|reply
operator|->
name|d_func
argument_list|()
operator|->
name|errorString
operator|=
name|errorString
expr_stmt|;
emit|emit
name|reply
operator|->
name|finishedWithError
argument_list|(
name|errorCode
argument_list|,
name|errorString
argument_list|)
emit|;
name|reply
operator|=
literal|0
expr_stmt|;
block|}
comment|// send the next request
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|that
argument_list|,
literal|"_q_startNextRequest"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
if|if
condition|(
name|that
condition|)
comment|//signal emission triggered event loop
name|close
argument_list|()
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
end_ifndef
begin_function
DECL|function|_q_proxyAuthenticationRequired
name|void
name|QHttpNetworkConnectionChannel
operator|::
name|_q_proxyAuthenticationRequired
parameter_list|(
specifier|const
name|QNetworkProxy
modifier|&
name|proxy
parameter_list|,
name|QAuthenticator
modifier|*
name|auth
parameter_list|)
block|{
comment|// Need to dequeue the request before we can emit the error.
if|if
condition|(
operator|!
name|reply
condition|)
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|dequeueRequest
argument_list|(
name|socket
argument_list|)
expr_stmt|;
if|if
condition|(
name|reply
condition|)
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|emitProxyAuthenticationRequired
argument_list|(
name|this
argument_list|,
name|proxy
argument_list|,
name|auth
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|_q_uploadDataReadyRead
name|void
name|QHttpNetworkConnectionChannel
operator|::
name|_q_uploadDataReadyRead
parameter_list|()
block|{
name|sendRequest
argument_list|()
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_SSL
end_ifndef
begin_function
DECL|function|_q_encrypted
name|void
name|QHttpNetworkConnectionChannel
operator|::
name|_q_encrypted
parameter_list|()
block|{
if|if
condition|(
operator|!
name|socket
condition|)
return|return;
comment|// ### error
name|state
operator|=
name|QHttpNetworkConnectionChannel
operator|::
name|IdleState
expr_stmt|;
name|pendingEncrypt
operator|=
literal|false
expr_stmt|;
if|if
condition|(
operator|!
name|reply
condition|)
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|dequeueRequest
argument_list|(
name|socket
argument_list|)
expr_stmt|;
if|if
condition|(
name|reply
condition|)
name|sendRequest
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|_q_sslErrors
name|void
name|QHttpNetworkConnectionChannel
operator|::
name|_q_sslErrors
parameter_list|(
specifier|const
name|QList
argument_list|<
name|QSslError
argument_list|>
modifier|&
name|errors
parameter_list|)
block|{
if|if
condition|(
operator|!
name|socket
condition|)
return|return;
comment|//QNetworkReply::NetworkError errorCode = QNetworkReply::ProtocolFailure;
comment|// Also pause the connection because socket notifiers may fire while an user
comment|// dialog is displaying
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|pauseConnection
argument_list|()
expr_stmt|;
if|if
condition|(
name|pendingEncrypt
operator|&&
operator|!
name|reply
condition|)
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|dequeueRequest
argument_list|(
name|socket
argument_list|)
expr_stmt|;
if|if
condition|(
name|reply
condition|)
emit|emit
name|reply
operator|->
name|sslErrors
argument_list|(
name|errors
argument_list|)
emit|;
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|resumeConnection
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|_q_encryptedBytesWritten
name|void
name|QHttpNetworkConnectionChannel
operator|::
name|_q_encryptedBytesWritten
parameter_list|(
name|qint64
name|bytes
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
comment|// bytes have been written to the socket. write even more of them :)
if|if
condition|(
name|isSocketWriting
argument_list|()
condition|)
name|sendRequest
argument_list|()
expr_stmt|;
comment|// otherwise we do nothing
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|setConnection
name|void
name|QHttpNetworkConnectionChannel
operator|::
name|setConnection
parameter_list|(
name|QHttpNetworkConnection
modifier|*
name|c
parameter_list|)
block|{
comment|// Inlining this function in the header leads to compiler error on
comment|// release-armv5, on at least timebox 9.2 and 10.1.
name|connection
operator|=
name|c
expr_stmt|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_include
include|#
directive|include
file|"moc_qhttpnetworkconnectionchannel_p.cpp"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_HTTP
end_comment
end_unit
