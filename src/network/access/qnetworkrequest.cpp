begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtNetwork module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qnetworkrequest.h"
end_include
begin_include
include|#
directive|include
file|"qnetworkrequest_p.h"
end_include
begin_include
include|#
directive|include
file|"qplatformdefs.h"
end_include
begin_include
include|#
directive|include
file|"qnetworkcookie.h"
end_include
begin_include
include|#
directive|include
file|"qsslconfiguration.h"
end_include
begin_include
include|#
directive|include
file|"QtCore/qshareddata.h"
end_include
begin_include
include|#
directive|include
file|"QtCore/qlocale.h"
end_include
begin_include
include|#
directive|include
file|"QtCore/qdatetime.h"
end_include
begin_include
include|#
directive|include
file|<ctype.h>
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATESTRING
end_ifndef
begin_include
include|#
directive|include
file|<stdio.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_comment
comment|/*!     \class QNetworkRequest     \since 4.4     \ingroup network     \ingroup shared     \inmodule QtNetwork      \brief The QNetworkRequest class holds a request to be sent with QNetworkAccessManager.      QNetworkRequest is part of the Network Access API and is the class     holding the information necessary to send a request over the     network. It contains a URL and some ancillary information that can     be used to modify the request.      \sa QNetworkReply, QNetworkAccessManager */
end_comment
begin_comment
comment|/*!     \enum QNetworkRequest::KnownHeaders      List of known header types that QNetworkRequest parses. Each known     header is also represented in raw form with its full HTTP name.      \value ContentDispositionHeader  Corresponds to the HTTP     Content-Disposition header and contains a string containing the     disposition type (for instance, attachment) and a parameter (for     instance, filename).      \value ContentTypeHeader    Corresponds to the HTTP Content-Type     header and contains a string containing the media (MIME) type and     any auxiliary data (for instance, charset).      \value ContentLengthHeader  Corresponds to the HTTP Content-Length     header and contains the length in bytes of the data transmitted.      \value LocationHeader       Corresponds to the HTTP Location     header and contains a URL representing the actual location of the     data, including the destination URL in case of redirections.      \value LastModifiedHeader   Corresponds to the HTTP Last-Modified     header and contains a QDateTime representing the last modification     date of the contents.      \value CookieHeader         Corresponds to the HTTP Cookie header     and contains a QList<QNetworkCookie> representing the cookies to     be sent back to the server.      \value SetCookieHeader      Corresponds to the HTTP Set-Cookie     header and contains a QList<QNetworkCookie> representing the     cookies sent by the server to be stored locally.      \value UserAgentHeader      The User-Agent header sent by HTTP clients.      \value ServerHeader         The Server header received by HTTP clients.      \sa header(), setHeader(), rawHeader(), setRawHeader() */
end_comment
begin_comment
comment|/*!     \enum QNetworkRequest::Attribute     \since 4.7      Attribute codes for the QNetworkRequest and QNetworkReply.      Attributes are extra meta-data that are used to control the     behavior of the request and to pass further information from the     reply back to the application. Attributes are also extensible,     allowing custom implementations to pass custom values.      The following table explains what the default attribute codes are,     the QVariant types associated, the default value if said attribute     is missing and whether it's used in requests or replies.      \value HttpStatusCodeAttribute         Replies only, type: QMetaType::Int (no default)         Indicates the HTTP status code received from the HTTP server         (like 200, 304, 404, 401, etc.). If the connection was not         HTTP-based, this attribute will not be present.      \value HttpReasonPhraseAttribute         Replies only, type: QMetaType::QByteArray (no default)         Indicates the HTTP reason phrase as received from the HTTP         server (like "Ok", "Found", "Not Found", "Access Denied",         etc.) This is the human-readable representation of the status         code (see above). If the connection was not HTTP-based, this         attribute will not be present.      \value RedirectionTargetAttribute         Replies only, type: QMetaType::QUrl (no default)         If present, it indicates that the server is redirecting the         request to a different URL. The Network Access API does not by         default follow redirections: it's up to the application to         determine if the requested redirection should be allowed,         according to its security policies.         The returned URL might be relative. Use QUrl::resolved()         to create an absolute URL out of it.      \value ConnectionEncryptedAttribute         Replies only, type: QMetaType::Bool (default: false)         Indicates whether the data was obtained through an encrypted         (secure) connection.      \value CacheLoadControlAttribute         Requests only, type: QMetaType::Int (default: QNetworkRequest::PreferNetwork)         Controls how the cache should be accessed. The possible values         are those of QNetworkRequest::CacheLoadControl. Note that the         default QNetworkAccessManager implementation does not support         caching. However, this attribute may be used by certain         backends to modify their requests (for example, for caching proxies).      \value CacheSaveControlAttribute         Requests only, type: QMetaType::Bool (default: true)         Controls if the data obtained should be saved to cache for         future uses. If the value is false, the data obtained will not         be automatically cached. If true, data may be cached, provided         it is cacheable (what is cacheable depends on the protocol         being used).      \value SourceIsFromCacheAttribute         Replies only, type: QMetaType::Bool (default: false)         Indicates whether the data was obtained from cache         or not.      \value DoNotBufferUploadDataAttribute         Requests only, type: QMetaType::Bool (default: false)         Indicates whether the QNetworkAccessManager code is         allowed to buffer the upload data, e.g. when doing a HTTP POST.         When using this flag with sequential upload data, the ContentLengthHeader         header must be set.      \value HttpPipeliningAllowedAttribute         Requests only, type: QMetaType::Bool (default: false)         Indicates whether the QNetworkAccessManager code is         allowed to use HTTP pipelining with this request.      \value HttpPipeliningWasUsedAttribute         Replies only, type: QMetaType::Bool         Indicates whether the HTTP pipelining was used for receiving         this reply.      \value CustomVerbAttribute        Requests only, type: QMetaType::QByteArray        Holds the value for the custom HTTP verb to send (destined for usage        of other verbs than GET, POST, PUT and DELETE). This verb is set        when calling QNetworkAccessManager::sendCustomRequest().      \value CookieLoadControlAttribute         Requests only, type: QMetaType::Int (default: QNetworkRequest::Automatic)         Indicates whether to send 'Cookie' headers in the request.         This attribute is set to false by Qt WebKit when creating a cross-origin         XMLHttpRequest where withCredentials has not been set explicitly to true by the         Javascript that created the request.         See \l{http://www.w3.org/TR/XMLHttpRequest2/#credentials-flag}{here} for more information.         (This value was introduced in 4.7.)      \value CookieSaveControlAttribute         Requests only, type: QMetaType::Int (default: QNetworkRequest::Automatic)         Indicates whether to save 'Cookie' headers received from the server in reply         to the request.         This attribute is set to false by Qt WebKit when creating a cross-origin         XMLHttpRequest where withCredentials has not been set explicitly to true by the         Javascript that created the request.         See \l{http://www.w3.org/TR/XMLHttpRequest2/#credentials-flag} {here} for more information.         (This value was introduced in 4.7.)      \value AuthenticationReuseAttribute         Requests only, type: QMetaType::Int (default: QNetworkRequest::Automatic)         Indicates whether to use cached authorization credentials in the request,         if available. If this is set to QNetworkRequest::Manual and the authentication         mechanism is 'Basic' or 'Digest', Qt will not send an an 'Authorization' HTTP         header with any cached credentials it may have for the request's URL.         This attribute is set to QNetworkRequest::Manual by Qt WebKit when creating a cross-origin         XMLHttpRequest where withCredentials has not been set explicitly to true by the         Javascript that created the request.         See \l{http://www.w3.org/TR/XMLHttpRequest2/#credentials-flag} {here} for more information.         (This value was introduced in 4.7.)      \omitvalue MaximumDownloadBufferSizeAttribute      \omitvalue DownloadBufferAttribute      \omitvalue SynchronousRequestAttribute      \value BackgroundRequestAttribute         Type: QMetaType::Bool (default: false)         Indicates that this is a background transfer, rather than a user initiated         transfer. Depending on the platform, background transfers may be subject         to different policies.         The QNetworkSession ConnectInBackground property will be set according to         this attribute.      \value User         Special type. Additional information can be passed in         QVariants with types ranging from User to UserMax. The default         implementation of Network Access will ignore any request         attributes in this range and it will not produce any         attributes in this range in replies. The range is reserved for         extensions of QNetworkAccessManager.      \value UserMax         Special type. See User. */
end_comment
begin_comment
comment|/*!     \enum QNetworkRequest::CacheLoadControl      Controls the caching mechanism of QNetworkAccessManager.      \value AlwaysNetwork        always load from network and do not     check if the cache has a valid entry (similar to the     "Reload" feature in browsers); in addition, force intermediate     caches to re-validate.      \value PreferNetwork        default value; load from the network     if the cached entry is older than the network entry. This will never     return stale data from the cache, but revalidate resources that     have become stale.      \value PreferCache          load from cache if available,     otherwise load from network. Note that this can return possibly     stale (but not expired) items from cache.      \value AlwaysCache          only load from cache, indicating error     if the item was not cached (i.e., off-line mode) */
end_comment
begin_comment
comment|/*!     \enum QNetworkRequest::LoadControl     \since 4.7      Indicates if an aspect of the request's loading mechanism has been     manually overridden, e.g. by Qt WebKit.      \value Automatic            default value: indicates default behaviour.      \value Manual               indicates behaviour has been manually overridden. */
end_comment
begin_class
DECL|class|QNetworkRequestPrivate
class|class
name|QNetworkRequestPrivate
super|:
specifier|public
name|QSharedData
super|,
specifier|public
name|QNetworkHeadersPrivate
block|{
public|public:
DECL|function|QNetworkRequestPrivate
specifier|inline
name|QNetworkRequestPrivate
parameter_list|()
member_init_list|:
name|priority
argument_list|(
name|QNetworkRequest
operator|::
name|NormalPriority
argument_list|)
ifndef|#
directive|ifndef
name|QT_NO_SSL
member_init_list|,
name|sslConfiguration
argument_list|(
literal|0
argument_list|)
endif|#
directive|endif
block|{
name|qRegisterMetaType
argument_list|<
name|QNetworkRequest
argument_list|>
argument_list|()
expr_stmt|;
block|}
DECL|function|~QNetworkRequestPrivate
name|~
name|QNetworkRequestPrivate
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|QT_NO_SSL
operator|delete
name|sslConfiguration
expr_stmt|;
endif|#
directive|endif
block|}
DECL|function|QNetworkRequestPrivate
name|QNetworkRequestPrivate
parameter_list|(
specifier|const
name|QNetworkRequestPrivate
modifier|&
name|other
parameter_list|)
member_init_list|:
name|QSharedData
argument_list|(
name|other
argument_list|)
member_init_list|,
name|QNetworkHeadersPrivate
argument_list|(
name|other
argument_list|)
block|{
name|url
operator|=
name|other
operator|.
name|url
expr_stmt|;
name|priority
operator|=
name|other
operator|.
name|priority
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_SSL
name|sslConfiguration
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|other
operator|.
name|sslConfiguration
condition|)
name|sslConfiguration
operator|=
operator|new
name|QSslConfiguration
argument_list|(
operator|*
name|other
operator|.
name|sslConfiguration
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
DECL|function|operator ==
specifier|inline
name|bool
name|operator
name|==
parameter_list|(
specifier|const
name|QNetworkRequestPrivate
modifier|&
name|other
parameter_list|)
specifier|const
block|{
return|return
name|url
operator|==
name|other
operator|.
name|url
operator|&&
name|priority
operator|==
name|other
operator|.
name|priority
operator|&&
name|rawHeaders
operator|==
name|other
operator|.
name|rawHeaders
operator|&&
name|attributes
operator|==
name|other
operator|.
name|attributes
return|;
comment|// don't compare cookedHeaders
block|}
DECL|member|url
name|QUrl
name|url
decl_stmt|;
DECL|member|priority
name|QNetworkRequest
operator|::
name|Priority
name|priority
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_SSL
DECL|member|sslConfiguration
specifier|mutable
name|QSslConfiguration
modifier|*
name|sslConfiguration
decl_stmt|;
endif|#
directive|endif
block|}
class|;
end_class
begin_comment
comment|/*!     Constructs a QNetworkRequest object with \a url as the URL to be     requested.      \sa url(), setUrl() */
end_comment
begin_constructor
DECL|function|QNetworkRequest
name|QNetworkRequest
operator|::
name|QNetworkRequest
parameter_list|(
specifier|const
name|QUrl
modifier|&
name|url
parameter_list|)
member_init_list|:
name|d
argument_list|(
operator|new
name|QNetworkRequestPrivate
argument_list|)
block|{
name|d
operator|->
name|url
operator|=
name|url
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Creates a copy of \a other. */
end_comment
begin_constructor
DECL|function|QNetworkRequest
name|QNetworkRequest
operator|::
name|QNetworkRequest
parameter_list|(
specifier|const
name|QNetworkRequest
modifier|&
name|other
parameter_list|)
member_init_list|:
name|d
argument_list|(
name|other
operator|.
name|d
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Disposes of the QNetworkRequest object. */
end_comment
begin_destructor
DECL|function|~QNetworkRequest
name|QNetworkRequest
operator|::
name|~
name|QNetworkRequest
parameter_list|()
block|{
comment|// QSharedDataPointer auto deletes
name|d
operator|=
literal|0
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     Returns true if this object is the same as \a other (i.e., if they     have the same URL, same headers and same meta-data settings).      \sa operator!=() */
end_comment
begin_function
DECL|function|operator ==
name|bool
name|QNetworkRequest
operator|::
name|operator
name|==
parameter_list|(
specifier|const
name|QNetworkRequest
modifier|&
name|other
parameter_list|)
specifier|const
block|{
return|return
name|d
operator|==
name|other
operator|.
name|d
operator|||
operator|*
name|d
operator|==
operator|*
name|other
operator|.
name|d
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QNetworkRequest::operator!=(const QNetworkRequest&other) const      Returns false if this object is not the same as \a other.      \sa operator==() */
end_comment
begin_comment
comment|/*!     Creates a copy of \a other */
end_comment
begin_function
DECL|function|operator =
name|QNetworkRequest
modifier|&
name|QNetworkRequest
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QNetworkRequest
modifier|&
name|other
parameter_list|)
block|{
name|d
operator|=
name|other
operator|.
name|d
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QNetworkRequest::swap(QNetworkRequest&other)     \since 5.0      Swaps this network request with \a other. This function is very     fast and never fails. */
end_comment
begin_comment
comment|/*!     Returns the URL this network request is referring to.      \sa setUrl() */
end_comment
begin_function
DECL|function|url
name|QUrl
name|QNetworkRequest
operator|::
name|url
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|url
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the URL this network request is referring to be \a url.      \sa url() */
end_comment
begin_function
DECL|function|setUrl
name|void
name|QNetworkRequest
operator|::
name|setUrl
parameter_list|(
specifier|const
name|QUrl
modifier|&
name|url
parameter_list|)
block|{
name|d
operator|->
name|url
operator|=
name|url
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the value of the known network header \a header if it is     present in this request. If it is not present, returns QVariant()     (i.e., an invalid variant).      \sa KnownHeaders, rawHeader(), setHeader() */
end_comment
begin_function
DECL|function|header
name|QVariant
name|QNetworkRequest
operator|::
name|header
parameter_list|(
name|KnownHeaders
name|header
parameter_list|)
specifier|const
block|{
return|return
name|d
operator|->
name|cookedHeaders
operator|.
name|value
argument_list|(
name|header
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the value of the known header \a header to be \a value,     overriding any previously set headers. This operation also sets     the equivalent raw HTTP header.      \sa KnownHeaders, setRawHeader(), header() */
end_comment
begin_function
DECL|function|setHeader
name|void
name|QNetworkRequest
operator|::
name|setHeader
parameter_list|(
name|KnownHeaders
name|header
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|value
parameter_list|)
block|{
name|d
operator|->
name|setCookedHeader
argument_list|(
name|header
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the raw header \a headerName is present in this     network request.      \sa rawHeader(), setRawHeader() */
end_comment
begin_function
DECL|function|hasRawHeader
name|bool
name|QNetworkRequest
operator|::
name|hasRawHeader
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|headerName
parameter_list|)
specifier|const
block|{
return|return
name|d
operator|->
name|findRawHeader
argument_list|(
name|headerName
argument_list|)
operator|!=
name|d
operator|->
name|rawHeaders
operator|.
name|constEnd
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the raw form of header \a headerName. If no such header is     present, an empty QByteArray is returned, which may be     indistinguishable from a header that is present but has no content     (use hasRawHeader() to find out if the header exists or not).      Raw headers can be set with setRawHeader() or with setHeader().      \sa header(), setRawHeader() */
end_comment
begin_function
DECL|function|rawHeader
name|QByteArray
name|QNetworkRequest
operator|::
name|rawHeader
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|headerName
parameter_list|)
specifier|const
block|{
name|QNetworkHeadersPrivate
operator|::
name|RawHeadersList
operator|::
name|ConstIterator
name|it
init|=
name|d
operator|->
name|findRawHeader
argument_list|(
name|headerName
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|!=
name|d
operator|->
name|rawHeaders
operator|.
name|constEnd
argument_list|()
condition|)
return|return
name|it
operator|->
name|second
return|;
return|return
name|QByteArray
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a list of all raw headers that are set in this network     request. The list is in the order that the headers were set.      \sa hasRawHeader(), rawHeader() */
end_comment
begin_function
DECL|function|rawHeaderList
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|QNetworkRequest
operator|::
name|rawHeaderList
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|rawHeadersKeys
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the header \a headerName to be of value \a headerValue. If \a     headerName corresponds to a known header (see     QNetworkRequest::KnownHeaders), the raw format will be parsed and     the corresponding "cooked" header will be set as well.      For example:     \snippet code/src_network_access_qnetworkrequest.cpp 0      will also set the known header LastModifiedHeader to be the     QDateTime object of the parsed date.      Note: setting the same header twice overrides the previous     setting. To accomplish the behaviour of multiple HTTP headers of     the same name, you should concatenate the two values, separating     them with a comma (",") and set one single raw header.      \sa KnownHeaders, setHeader(), hasRawHeader(), rawHeader() */
end_comment
begin_function
DECL|function|setRawHeader
name|void
name|QNetworkRequest
operator|::
name|setRawHeader
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|headerName
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|headerValue
parameter_list|)
block|{
name|d
operator|->
name|setRawHeader
argument_list|(
name|headerName
argument_list|,
name|headerValue
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the attribute associated with the code \a code. If the     attribute has not been set, it returns \a defaultValue.      Note: this function does not apply the defaults listed in     QNetworkRequest::Attribute.      \sa setAttribute(), QNetworkRequest::Attribute */
end_comment
begin_function
DECL|function|attribute
name|QVariant
name|QNetworkRequest
operator|::
name|attribute
parameter_list|(
name|Attribute
name|code
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|defaultValue
parameter_list|)
specifier|const
block|{
return|return
name|d
operator|->
name|attributes
operator|.
name|value
argument_list|(
name|code
argument_list|,
name|defaultValue
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the attribute associated with code \a code to be value \a     value. If the attribute is already set, the previous value is     discarded. In special, if \a value is an invalid QVariant, the     attribute is unset.      \sa attribute(), QNetworkRequest::Attribute */
end_comment
begin_function
DECL|function|setAttribute
name|void
name|QNetworkRequest
operator|::
name|setAttribute
parameter_list|(
name|Attribute
name|code
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|value
parameter_list|)
block|{
if|if
condition|(
name|value
operator|.
name|isValid
argument_list|()
condition|)
name|d
operator|->
name|attributes
operator|.
name|insert
argument_list|(
name|code
argument_list|,
name|value
argument_list|)
expr_stmt|;
else|else
name|d
operator|->
name|attributes
operator|.
name|remove
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_SSL
end_ifndef
begin_comment
comment|/*!     Returns this network request's SSL configuration. By default, no     SSL settings are specified.      \sa setSslConfiguration() */
end_comment
begin_function
DECL|function|sslConfiguration
name|QSslConfiguration
name|QNetworkRequest
operator|::
name|sslConfiguration
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|sslConfiguration
condition|)
name|d
operator|->
name|sslConfiguration
operator|=
operator|new
name|QSslConfiguration
argument_list|(
name|QSslConfiguration
operator|::
name|defaultConfiguration
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|*
name|d
operator|->
name|sslConfiguration
return|;
block|}
end_function
begin_comment
comment|/*!     Sets this network request's SSL configuration to be \a config. The     settings that apply are the private key, the local certificate,     the SSL protocol (SSLv2, SSLv3, TLSv1.0 where applicable), the CA     certificates and the ciphers that the SSL backend is allowed to     use.      By default, no SSL configuration is set, which allows the backends     to choose freely what configuration is best for them.      \sa sslConfiguration(), QSslConfiguration::defaultConfiguration() */
end_comment
begin_function
DECL|function|setSslConfiguration
name|void
name|QNetworkRequest
operator|::
name|setSslConfiguration
parameter_list|(
specifier|const
name|QSslConfiguration
modifier|&
name|config
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|sslConfiguration
condition|)
name|d
operator|->
name|sslConfiguration
operator|=
operator|new
name|QSslConfiguration
argument_list|(
name|config
argument_list|)
expr_stmt|;
else|else
operator|*
name|d
operator|->
name|sslConfiguration
operator|=
name|config
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \since 4.6      Allows setting a reference to the \a object initiating     the request.      For example Qt WebKit sets the originating object to the     QWebFrame that initiated the request.      \sa originatingObject() */
end_comment
begin_function
DECL|function|setOriginatingObject
name|void
name|QNetworkRequest
operator|::
name|setOriginatingObject
parameter_list|(
name|QObject
modifier|*
name|object
parameter_list|)
block|{
name|d
operator|->
name|originatingObject
operator|=
name|object
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.6      Returns a reference to the object that initiated this     network request; returns 0 if not set or the object has     been destroyed.      \sa setOriginatingObject() */
end_comment
begin_function
DECL|function|originatingObject
name|QObject
modifier|*
name|QNetworkRequest
operator|::
name|originatingObject
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|originatingObject
operator|.
name|data
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.7      Return the priority of this request.      \sa setPriority() */
end_comment
begin_function
DECL|function|priority
name|QNetworkRequest
operator|::
name|Priority
name|QNetworkRequest
operator|::
name|priority
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|priority
return|;
block|}
end_function
begin_comment
comment|/*! \enum QNetworkRequest::Priority    \since 4.7    This enum lists the possible network request priorities.    \value HighPriority   High priority   \value NormalPriority Normal priority   \value LowPriority    Low priority  */
end_comment
begin_comment
comment|/*!     \since 4.7      Set the priority of this request to \a priority.      \note The \a priority is only a hint to the network access     manager.  It can use it or not. Currently it is used for HTTP to     decide which request should be sent first to a server.      \sa priority() */
end_comment
begin_function
DECL|function|setPriority
name|void
name|QNetworkRequest
operator|::
name|setPriority
parameter_list|(
name|Priority
name|priority
parameter_list|)
block|{
name|d
operator|->
name|priority
operator|=
name|priority
expr_stmt|;
block|}
end_function
begin_function
DECL|function|headerName
specifier|static
name|QByteArray
name|headerName
parameter_list|(
name|QNetworkRequest
operator|::
name|KnownHeaders
name|header
parameter_list|)
block|{
switch|switch
condition|(
name|header
condition|)
block|{
case|case
name|QNetworkRequest
operator|::
name|ContentTypeHeader
case|:
return|return
literal|"Content-Type"
return|;
case|case
name|QNetworkRequest
operator|::
name|ContentLengthHeader
case|:
return|return
literal|"Content-Length"
return|;
case|case
name|QNetworkRequest
operator|::
name|LocationHeader
case|:
return|return
literal|"Location"
return|;
case|case
name|QNetworkRequest
operator|::
name|LastModifiedHeader
case|:
return|return
literal|"Last-Modified"
return|;
case|case
name|QNetworkRequest
operator|::
name|CookieHeader
case|:
return|return
literal|"Cookie"
return|;
case|case
name|QNetworkRequest
operator|::
name|SetCookieHeader
case|:
return|return
literal|"Set-Cookie"
return|;
case|case
name|QNetworkRequest
operator|::
name|ContentDispositionHeader
case|:
return|return
literal|"Content-Disposition"
return|;
case|case
name|QNetworkRequest
operator|::
name|UserAgentHeader
case|:
return|return
literal|"User-Agent"
return|;
case|case
name|QNetworkRequest
operator|::
name|ServerHeader
case|:
return|return
literal|"Server"
return|;
comment|// no default:
comment|// if new values are added, this will generate a compiler warning
block|}
return|return
name|QByteArray
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|headerValue
specifier|static
name|QByteArray
name|headerValue
parameter_list|(
name|QNetworkRequest
operator|::
name|KnownHeaders
name|header
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|value
parameter_list|)
block|{
switch|switch
condition|(
name|header
condition|)
block|{
case|case
name|QNetworkRequest
operator|::
name|ContentTypeHeader
case|:
case|case
name|QNetworkRequest
operator|::
name|ContentLengthHeader
case|:
case|case
name|QNetworkRequest
operator|::
name|ContentDispositionHeader
case|:
case|case
name|QNetworkRequest
operator|::
name|UserAgentHeader
case|:
case|case
name|QNetworkRequest
operator|::
name|ServerHeader
case|:
return|return
name|value
operator|.
name|toByteArray
argument_list|()
return|;
case|case
name|QNetworkRequest
operator|::
name|LocationHeader
case|:
switch|switch
condition|(
name|value
operator|.
name|userType
argument_list|()
condition|)
block|{
case|case
name|QMetaType
operator|::
name|QUrl
case|:
return|return
name|value
operator|.
name|toUrl
argument_list|()
operator|.
name|toEncoded
argument_list|()
return|;
default|default:
return|return
name|value
operator|.
name|toByteArray
argument_list|()
return|;
block|}
case|case
name|QNetworkRequest
operator|::
name|LastModifiedHeader
case|:
switch|switch
condition|(
name|value
operator|.
name|userType
argument_list|()
condition|)
block|{
case|case
name|QMetaType
operator|::
name|QDate
case|:
case|case
name|QMetaType
operator|::
name|QDateTime
case|:
comment|// generate RFC 1123/822 dates:
return|return
name|QNetworkHeadersPrivate
operator|::
name|toHttpDate
argument_list|(
name|value
operator|.
name|toDateTime
argument_list|()
argument_list|)
return|;
default|default:
return|return
name|value
operator|.
name|toByteArray
argument_list|()
return|;
block|}
case|case
name|QNetworkRequest
operator|::
name|CookieHeader
case|:
block|{
name|QList
argument_list|<
name|QNetworkCookie
argument_list|>
name|cookies
init|=
name|qvariant_cast
argument_list|<
name|QList
argument_list|<
name|QNetworkCookie
argument_list|>
argument_list|>
argument_list|(
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|cookies
operator|.
name|isEmpty
argument_list|()
operator|&&
name|value
operator|.
name|userType
argument_list|()
operator|==
name|qMetaTypeId
argument_list|<
name|QNetworkCookie
argument_list|>
argument_list|()
condition|)
name|cookies
operator|<<
name|qvariant_cast
argument_list|<
name|QNetworkCookie
argument_list|>
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|QByteArray
name|result
decl_stmt|;
name|bool
name|first
init|=
literal|true
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|QNetworkCookie
modifier|&
name|cookie
decl|,
name|cookies
control|)
block|{
if|if
condition|(
operator|!
name|first
condition|)
name|result
operator|+=
literal|"; "
expr_stmt|;
name|first
operator|=
literal|false
expr_stmt|;
name|result
operator|+=
name|cookie
operator|.
name|toRawForm
argument_list|(
name|QNetworkCookie
operator|::
name|NameAndValueOnly
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
case|case
name|QNetworkRequest
operator|::
name|SetCookieHeader
case|:
block|{
name|QList
argument_list|<
name|QNetworkCookie
argument_list|>
name|cookies
init|=
name|qvariant_cast
argument_list|<
name|QList
argument_list|<
name|QNetworkCookie
argument_list|>
argument_list|>
argument_list|(
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|cookies
operator|.
name|isEmpty
argument_list|()
operator|&&
name|value
operator|.
name|userType
argument_list|()
operator|==
name|qMetaTypeId
argument_list|<
name|QNetworkCookie
argument_list|>
argument_list|()
condition|)
name|cookies
operator|<<
name|qvariant_cast
argument_list|<
name|QNetworkCookie
argument_list|>
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|QByteArray
name|result
decl_stmt|;
name|bool
name|first
init|=
literal|true
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|QNetworkCookie
modifier|&
name|cookie
decl|,
name|cookies
control|)
block|{
if|if
condition|(
operator|!
name|first
condition|)
name|result
operator|+=
literal|", "
expr_stmt|;
name|first
operator|=
literal|false
expr_stmt|;
name|result
operator|+=
name|cookie
operator|.
name|toRawForm
argument_list|(
name|QNetworkCookie
operator|::
name|Full
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
block|}
return|return
name|QByteArray
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|parseHeaderName
specifier|static
name|QNetworkRequest
operator|::
name|KnownHeaders
name|parseHeaderName
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|headerName
parameter_list|)
block|{
comment|// headerName is not empty here
switch|switch
condition|(
name|tolower
argument_list|(
name|headerName
operator|.
name|at
argument_list|(
literal|0
argument_list|)
argument_list|)
condition|)
block|{
case|case
literal|'c'
case|:
if|if
condition|(
name|qstricmp
argument_list|(
name|headerName
operator|.
name|constData
argument_list|()
argument_list|,
literal|"content-type"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|QNetworkRequest
operator|::
name|ContentTypeHeader
return|;
elseif|else
if|if
condition|(
name|qstricmp
argument_list|(
name|headerName
operator|.
name|constData
argument_list|()
argument_list|,
literal|"content-length"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|QNetworkRequest
operator|::
name|ContentLengthHeader
return|;
elseif|else
if|if
condition|(
name|qstricmp
argument_list|(
name|headerName
operator|.
name|constData
argument_list|()
argument_list|,
literal|"cookie"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|QNetworkRequest
operator|::
name|CookieHeader
return|;
break|break;
case|case
literal|'l'
case|:
if|if
condition|(
name|qstricmp
argument_list|(
name|headerName
operator|.
name|constData
argument_list|()
argument_list|,
literal|"location"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|QNetworkRequest
operator|::
name|LocationHeader
return|;
elseif|else
if|if
condition|(
name|qstricmp
argument_list|(
name|headerName
operator|.
name|constData
argument_list|()
argument_list|,
literal|"last-modified"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|QNetworkRequest
operator|::
name|LastModifiedHeader
return|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|qstricmp
argument_list|(
name|headerName
operator|.
name|constData
argument_list|()
argument_list|,
literal|"set-cookie"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|QNetworkRequest
operator|::
name|SetCookieHeader
return|;
elseif|else
if|if
condition|(
name|qstricmp
argument_list|(
name|headerName
operator|.
name|constData
argument_list|()
argument_list|,
literal|"server"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|QNetworkRequest
operator|::
name|ServerHeader
return|;
break|break;
case|case
literal|'u'
case|:
if|if
condition|(
name|qstricmp
argument_list|(
name|headerName
operator|.
name|constData
argument_list|()
argument_list|,
literal|"user-agent"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|QNetworkRequest
operator|::
name|UserAgentHeader
return|;
break|break;
block|}
return|return
name|QNetworkRequest
operator|::
name|KnownHeaders
argument_list|(
operator|-
literal|1
argument_list|)
return|;
comment|// nothing found
block|}
end_function
begin_function
DECL|function|parseHttpDate
specifier|static
name|QVariant
name|parseHttpDate
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|raw
parameter_list|)
block|{
name|QDateTime
name|dt
init|=
name|QNetworkHeadersPrivate
operator|::
name|fromHttpDate
argument_list|(
name|raw
argument_list|)
decl_stmt|;
if|if
condition|(
name|dt
operator|.
name|isValid
argument_list|()
condition|)
return|return
name|dt
return|;
return|return
name|QVariant
argument_list|()
return|;
comment|// transform an invalid QDateTime into a null QVariant
block|}
end_function
begin_function
DECL|function|parseCookieHeader
specifier|static
name|QVariant
name|parseCookieHeader
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|raw
parameter_list|)
block|{
name|QList
argument_list|<
name|QNetworkCookie
argument_list|>
name|result
decl_stmt|;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|cookieList
init|=
name|raw
operator|.
name|split
argument_list|(
literal|';'
argument_list|)
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|QByteArray
modifier|&
name|cookie
decl|,
name|cookieList
control|)
block|{
name|QList
argument_list|<
name|QNetworkCookie
argument_list|>
name|parsed
init|=
name|QNetworkCookie
operator|::
name|parseCookies
argument_list|(
name|cookie
operator|.
name|trimmed
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|parsed
operator|.
name|count
argument_list|()
operator|!=
literal|1
condition|)
return|return
name|QVariant
argument_list|()
return|;
comment|// invalid Cookie: header
name|result
operator|+=
name|parsed
expr_stmt|;
block|}
return|return
name|QVariant
operator|::
name|fromValue
argument_list|(
name|result
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|parseHeaderValue
specifier|static
name|QVariant
name|parseHeaderValue
parameter_list|(
name|QNetworkRequest
operator|::
name|KnownHeaders
name|header
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|value
parameter_list|)
block|{
comment|// header is always a valid value
switch|switch
condition|(
name|header
condition|)
block|{
case|case
name|QNetworkRequest
operator|::
name|UserAgentHeader
case|:
case|case
name|QNetworkRequest
operator|::
name|ServerHeader
case|:
case|case
name|QNetworkRequest
operator|::
name|ContentTypeHeader
case|:
comment|// copy exactly, convert to QString
return|return
name|QString
operator|::
name|fromLatin1
argument_list|(
name|value
argument_list|)
return|;
case|case
name|QNetworkRequest
operator|::
name|ContentLengthHeader
case|:
block|{
name|bool
name|ok
decl_stmt|;
name|qint64
name|result
init|=
name|value
operator|.
name|trimmed
argument_list|()
operator|.
name|toLongLong
argument_list|(
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
name|ok
condition|)
return|return
name|result
return|;
return|return
name|QVariant
argument_list|()
return|;
block|}
case|case
name|QNetworkRequest
operator|::
name|LocationHeader
case|:
block|{
name|QUrl
name|result
init|=
name|QUrl
operator|::
name|fromEncoded
argument_list|(
name|value
argument_list|,
name|QUrl
operator|::
name|StrictMode
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|.
name|isValid
argument_list|()
operator|&&
operator|!
name|result
operator|.
name|scheme
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|result
return|;
return|return
name|QVariant
argument_list|()
return|;
block|}
case|case
name|QNetworkRequest
operator|::
name|LastModifiedHeader
case|:
return|return
name|parseHttpDate
argument_list|(
name|value
argument_list|)
return|;
case|case
name|QNetworkRequest
operator|::
name|CookieHeader
case|:
return|return
name|parseCookieHeader
argument_list|(
name|value
argument_list|)
return|;
case|case
name|QNetworkRequest
operator|::
name|SetCookieHeader
case|:
return|return
name|QVariant
operator|::
name|fromValue
argument_list|(
name|QNetworkCookie
operator|::
name|parseCookies
argument_list|(
name|value
argument_list|)
argument_list|)
return|;
default|default:
name|Q_ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|QVariant
argument_list|()
return|;
block|}
end_function
begin_function
name|QNetworkHeadersPrivate
operator|::
name|RawHeadersList
operator|::
name|ConstIterator
DECL|function|findRawHeader
name|QNetworkHeadersPrivate
operator|::
name|findRawHeader
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|key
parameter_list|)
specifier|const
block|{
name|RawHeadersList
operator|::
name|ConstIterator
name|it
init|=
name|rawHeaders
operator|.
name|constBegin
argument_list|()
decl_stmt|;
name|RawHeadersList
operator|::
name|ConstIterator
name|end
init|=
name|rawHeaders
operator|.
name|constEnd
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|end
condition|;
operator|++
name|it
control|)
if|if
condition|(
name|qstricmp
argument_list|(
name|it
operator|->
name|first
operator|.
name|constData
argument_list|()
argument_list|,
name|key
operator|.
name|constData
argument_list|()
argument_list|)
operator|==
literal|0
condition|)
return|return
name|it
return|;
return|return
name|end
return|;
comment|// not found
block|}
end_function
begin_function
DECL|function|allRawHeaders
name|QNetworkHeadersPrivate
operator|::
name|RawHeadersList
name|QNetworkHeadersPrivate
operator|::
name|allRawHeaders
parameter_list|()
specifier|const
block|{
return|return
name|rawHeaders
return|;
block|}
end_function
begin_function
DECL|function|rawHeadersKeys
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|QNetworkHeadersPrivate
operator|::
name|rawHeadersKeys
parameter_list|()
specifier|const
block|{
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|result
decl_stmt|;
name|RawHeadersList
operator|::
name|ConstIterator
name|it
init|=
name|rawHeaders
operator|.
name|constBegin
argument_list|()
decl_stmt|,
name|end
init|=
name|rawHeaders
operator|.
name|constEnd
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|end
condition|;
operator|++
name|it
control|)
name|result
operator|<<
name|it
operator|->
name|first
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|setRawHeader
name|void
name|QNetworkHeadersPrivate
operator|::
name|setRawHeader
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|key
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|value
parameter_list|)
block|{
if|if
condition|(
name|key
operator|.
name|isEmpty
argument_list|()
condition|)
comment|// refuse to accept an empty raw header
return|return;
name|setRawHeaderInternal
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|parseAndSetHeader
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal     Sets the internal raw headers list to match \a list. The cooked headers     will also be updated.      If \a list contains duplicates, they will be stored, but only the first one     is usually accessed. */
end_comment
begin_function
DECL|function|setAllRawHeaders
name|void
name|QNetworkHeadersPrivate
operator|::
name|setAllRawHeaders
parameter_list|(
specifier|const
name|RawHeadersList
modifier|&
name|list
parameter_list|)
block|{
name|cookedHeaders
operator|.
name|clear
argument_list|()
expr_stmt|;
name|rawHeaders
operator|=
name|list
expr_stmt|;
name|RawHeadersList
operator|::
name|ConstIterator
name|it
init|=
name|rawHeaders
operator|.
name|constBegin
argument_list|()
decl_stmt|;
name|RawHeadersList
operator|::
name|ConstIterator
name|end
init|=
name|rawHeaders
operator|.
name|constEnd
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|end
condition|;
operator|++
name|it
control|)
name|parseAndSetHeader
argument_list|(
name|it
operator|->
name|first
argument_list|,
name|it
operator|->
name|second
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setCookedHeader
name|void
name|QNetworkHeadersPrivate
operator|::
name|setCookedHeader
parameter_list|(
name|QNetworkRequest
operator|::
name|KnownHeaders
name|header
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|value
parameter_list|)
block|{
name|QByteArray
name|name
init|=
name|headerName
argument_list|(
name|header
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// headerName verifies that \a header is a known value
name|qWarning
argument_list|(
literal|"QNetworkRequest::setHeader: invalid header value KnownHeader(%d) received"
argument_list|,
name|header
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|value
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|setRawHeaderInternal
argument_list|(
name|name
argument_list|,
name|QByteArray
argument_list|()
argument_list|)
expr_stmt|;
name|cookedHeaders
operator|.
name|remove
argument_list|(
name|header
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QByteArray
name|rawValue
init|=
name|headerValue
argument_list|(
name|header
argument_list|,
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|rawValue
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QNetworkRequest::setHeader: QVariant of type %s cannot be used with header %s"
argument_list|,
name|value
operator|.
name|typeName
argument_list|()
argument_list|,
name|name
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
name|setRawHeaderInternal
argument_list|(
name|name
argument_list|,
name|rawValue
argument_list|)
expr_stmt|;
name|cookedHeaders
operator|.
name|insert
argument_list|(
name|header
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|setRawHeaderInternal
name|void
name|QNetworkHeadersPrivate
operator|::
name|setRawHeaderInternal
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|key
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|value
parameter_list|)
block|{
name|RawHeadersList
operator|::
name|Iterator
name|it
init|=
name|rawHeaders
operator|.
name|begin
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|rawHeaders
operator|.
name|end
argument_list|()
condition|)
block|{
if|if
condition|(
name|qstricmp
argument_list|(
name|it
operator|->
name|first
operator|.
name|constData
argument_list|()
argument_list|,
name|key
operator|.
name|constData
argument_list|()
argument_list|)
operator|==
literal|0
condition|)
name|it
operator|=
name|rawHeaders
operator|.
name|erase
argument_list|(
name|it
argument_list|)
expr_stmt|;
else|else
operator|++
name|it
expr_stmt|;
block|}
if|if
condition|(
name|value
operator|.
name|isNull
argument_list|()
condition|)
return|return;
comment|// only wanted to erase key
name|RawHeaderPair
name|pair
decl_stmt|;
name|pair
operator|.
name|first
operator|=
name|key
expr_stmt|;
name|pair
operator|.
name|second
operator|=
name|value
expr_stmt|;
name|rawHeaders
operator|.
name|append
argument_list|(
name|pair
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|parseAndSetHeader
name|void
name|QNetworkHeadersPrivate
operator|::
name|parseAndSetHeader
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|key
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|value
parameter_list|)
block|{
comment|// is it a known header?
name|QNetworkRequest
operator|::
name|KnownHeaders
name|parsedKey
init|=
name|parseHeaderName
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|parsedKey
operator|!=
name|QNetworkRequest
operator|::
name|KnownHeaders
argument_list|(
operator|-
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|value
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|cookedHeaders
operator|.
name|remove
argument_list|(
name|parsedKey
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parsedKey
operator|==
name|QNetworkRequest
operator|::
name|ContentLengthHeader
operator|&&
name|cookedHeaders
operator|.
name|contains
argument_list|(
name|QNetworkRequest
operator|::
name|ContentLengthHeader
argument_list|)
condition|)
block|{
comment|// Only set the cooked header "Content-Length" once.
comment|// See bug QTBUG-15311
block|}
else|else
block|{
name|cookedHeaders
operator|.
name|insert
argument_list|(
name|parsedKey
argument_list|,
name|parseHeaderValue
argument_list|(
name|parsedKey
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|// Fast month string to int conversion. This code
end_comment
begin_comment
comment|// assumes that the Month name is correct and that
end_comment
begin_comment
comment|// the string is at least three chars long.
end_comment
begin_function
DECL|function|name_to_month
specifier|static
name|int
name|name_to_month
parameter_list|(
specifier|const
name|char
modifier|*
name|month_str
parameter_list|)
block|{
switch|switch
condition|(
name|month_str
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'J'
case|:
switch|switch
condition|(
name|month_str
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'a'
case|:
return|return
literal|1
return|;
case|case
literal|'u'
case|:
switch|switch
condition|(
name|month_str
index|[
literal|2
index|]
condition|)
block|{
case|case
literal|'n'
case|:
return|return
literal|6
return|;
case|case
literal|'l'
case|:
return|return
literal|7
return|;
block|}
block|}
break|break;
case|case
literal|'F'
case|:
return|return
literal|2
return|;
case|case
literal|'M'
case|:
switch|switch
condition|(
name|month_str
index|[
literal|2
index|]
condition|)
block|{
case|case
literal|'r'
case|:
return|return
literal|3
return|;
case|case
literal|'y'
case|:
return|return
literal|5
return|;
block|}
break|break;
case|case
literal|'A'
case|:
switch|switch
condition|(
name|month_str
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'p'
case|:
return|return
literal|4
return|;
case|case
literal|'u'
case|:
return|return
literal|8
return|;
block|}
break|break;
case|case
literal|'O'
case|:
return|return
literal|10
return|;
case|case
literal|'S'
case|:
return|return
literal|9
return|;
case|case
literal|'N'
case|:
return|return
literal|11
return|;
case|case
literal|'D'
case|:
return|return
literal|12
return|;
block|}
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|fromHttpDate
name|QDateTime
name|QNetworkHeadersPrivate
operator|::
name|fromHttpDate
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|value
parameter_list|)
block|{
comment|// HTTP dates have three possible formats:
comment|//  RFC 1123/822      -   ddd, dd MMM yyyy hh:mm:ss "GMT"
comment|//  RFC 850           -   dddd, dd-MMM-yy hh:mm:ss "GMT"
comment|//  ANSI C's asctime  -   ddd MMM d hh:mm:ss yyyy
comment|// We only handle them exactly. If they deviate, we bail out.
name|int
name|pos
init|=
name|value
operator|.
name|indexOf
argument_list|(
literal|','
argument_list|)
decl_stmt|;
name|QDateTime
name|dt
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_DATESTRING
if|if
condition|(
name|pos
operator|==
operator|-
literal|1
condition|)
block|{
comment|// no comma -> asctime(3) format
name|dt
operator|=
name|QDateTime
operator|::
name|fromString
argument_list|(
name|QString
operator|::
name|fromLatin1
argument_list|(
name|value
argument_list|)
argument_list|,
name|Qt
operator|::
name|TextDate
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Use sscanf over QLocal/QDateTimeParser for speed reasons. See the
comment|// Qt WebKit performance benchmarks to get an idea.
if|if
condition|(
name|pos
operator|==
literal|3
condition|)
block|{
name|char
name|month_name
index|[
literal|4
index|]
decl_stmt|;
name|int
name|day
decl_stmt|,
name|year
decl_stmt|,
name|hour
decl_stmt|,
name|minute
decl_stmt|,
name|second
decl_stmt|;
ifdef|#
directive|ifdef
name|Q_CC_MSVC
comment|// Use secure version to avoid compiler warning
if|if
condition|(
name|sscanf_s
argument_list|(
name|value
operator|.
name|constData
argument_list|()
argument_list|,
literal|"%*3s, %d %3s %d %d:%d:%d 'GMT'"
argument_list|,
operator|&
name|day
argument_list|,
name|month_name
argument_list|,
literal|4
argument_list|,
operator|&
name|year
argument_list|,
operator|&
name|hour
argument_list|,
operator|&
name|minute
argument_list|,
operator|&
name|second
argument_list|)
operator|==
literal|6
condition|)
else|#
directive|else
comment|// The POSIX secure mode is %ms (which allocates memory), too bleeding edge for now
comment|// In any case this is already safe as field width is specified.
if|if
condition|(
name|sscanf
argument_list|(
name|value
operator|.
name|constData
argument_list|()
argument_list|,
literal|"%*3s, %d %3s %d %d:%d:%d 'GMT'"
argument_list|,
operator|&
name|day
argument_list|,
name|month_name
argument_list|,
operator|&
name|year
argument_list|,
operator|&
name|hour
argument_list|,
operator|&
name|minute
argument_list|,
operator|&
name|second
argument_list|)
operator|==
literal|6
condition|)
endif|#
directive|endif
name|dt
operator|=
name|QDateTime
argument_list|(
name|QDate
argument_list|(
name|year
argument_list|,
name|name_to_month
argument_list|(
name|month_name
argument_list|)
argument_list|,
name|day
argument_list|)
argument_list|,
name|QTime
argument_list|(
name|hour
argument_list|,
name|minute
argument_list|,
name|second
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QLocale
name|c
init|=
name|QLocale
operator|::
name|c
argument_list|()
decl_stmt|;
comment|// eat the weekday, the comma and the space following it
name|QString
name|sansWeekday
init|=
name|QString
operator|::
name|fromLatin1
argument_list|(
name|value
operator|.
name|constData
argument_list|()
operator|+
name|pos
operator|+
literal|2
argument_list|)
decl_stmt|;
comment|// must be RFC 850 date
name|dt
operator|=
name|c
operator|.
name|toDateTime
argument_list|(
name|sansWeekday
argument_list|,
name|QLatin1String
argument_list|(
literal|"dd-MMM-yy hh:mm:ss 'GMT'"
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|// QT_NO_DATESTRING
if|if
condition|(
name|dt
operator|.
name|isValid
argument_list|()
condition|)
name|dt
operator|.
name|setTimeSpec
argument_list|(
name|Qt
operator|::
name|UTC
argument_list|)
expr_stmt|;
return|return
name|dt
return|;
block|}
end_function
begin_function
DECL|function|toHttpDate
name|QByteArray
name|QNetworkHeadersPrivate
operator|::
name|toHttpDate
parameter_list|(
specifier|const
name|QDateTime
modifier|&
name|dt
parameter_list|)
block|{
return|return
name|QLocale
operator|::
name|c
argument_list|()
operator|.
name|toString
argument_list|(
name|dt
argument_list|,
name|QLatin1String
argument_list|(
literal|"ddd, dd MMM yyyy hh:mm:ss 'GMT'"
argument_list|)
argument_list|)
operator|.
name|toLatin1
argument_list|()
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
