begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtNetwork module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_comment
comment|//#define QNETWORKACCESSHTTPBACKEND_DEBUG
end_comment
begin_include
include|#
directive|include
file|"qnetworkreplyhttpimpl_p.h"
end_include
begin_include
include|#
directive|include
file|"qnetworkaccessmanager_p.h"
end_include
begin_include
include|#
directive|include
file|"qnetworkaccesscache_p.h"
end_include
begin_include
include|#
directive|include
file|"qabstractnetworkcache.h"
end_include
begin_include
include|#
directive|include
file|"qnetworkrequest.h"
end_include
begin_include
include|#
directive|include
file|"qnetworkreply.h"
end_include
begin_include
include|#
directive|include
file|"qnetworkrequest_p.h"
end_include
begin_include
include|#
directive|include
file|"qnetworkcookie.h"
end_include
begin_include
include|#
directive|include
file|"qnetworkcookie_p.h"
end_include
begin_include
include|#
directive|include
file|"QtCore/qdatetime.h"
end_include
begin_include
include|#
directive|include
file|"QtCore/qelapsedtimer.h"
end_include
begin_include
include|#
directive|include
file|"QtNetwork/qsslconfiguration.h"
end_include
begin_include
include|#
directive|include
file|"qhttpthreaddelegate_p.h"
end_include
begin_include
include|#
directive|include
file|"qthread.h"
end_include
begin_include
include|#
directive|include
file|"QtCore/qcoreapplication.h"
end_include
begin_include
include|#
directive|include
file|"qnetworkcookiejar.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_HTTP
end_ifndef
begin_include
include|#
directive|include
file|<string.h>
end_include
begin_comment
comment|// for strchr
end_comment
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_class_decl
class_decl|class
name|QNetworkProxy
class_decl|;
end_class_decl
begin_function
DECL|function|isSeparator
specifier|static
specifier|inline
name|bool
name|isSeparator
parameter_list|(
specifier|register
name|char
name|c
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|separators
index|[]
init|=
literal|"()<>@,;:\\\"/[]?={}"
decl_stmt|;
return|return
name|isLWS
argument_list|(
name|c
argument_list|)
operator|||
name|strchr
argument_list|(
name|separators
argument_list|,
name|c
argument_list|)
operator|!=
literal|0
return|;
block|}
end_function
begin_comment
comment|// ### merge with nextField in cookiejar.cpp
end_comment
begin_function
DECL|function|parseHttpOptionHeader
specifier|static
name|QHash
argument_list|<
name|QByteArray
argument_list|,
name|QByteArray
argument_list|>
name|parseHttpOptionHeader
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|header
parameter_list|)
block|{
comment|// The HTTP header is of the form:
comment|// header          = #1(directives)
comment|// directives      = token | value-directive
comment|// value-directive = token "=" (token | quoted-string)
name|QHash
argument_list|<
name|QByteArray
argument_list|,
name|QByteArray
argument_list|>
name|result
decl_stmt|;
name|int
name|pos
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|true
condition|)
block|{
comment|// skip spaces
name|pos
operator|=
name|nextNonWhitespace
argument_list|(
name|header
argument_list|,
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|==
name|header
operator|.
name|length
argument_list|()
condition|)
return|return
name|result
return|;
comment|// end of parsing
comment|// pos points to a non-whitespace
name|int
name|comma
init|=
name|header
operator|.
name|indexOf
argument_list|(
literal|','
argument_list|,
name|pos
argument_list|)
decl_stmt|;
name|int
name|equal
init|=
name|header
operator|.
name|indexOf
argument_list|(
literal|'='
argument_list|,
name|pos
argument_list|)
decl_stmt|;
if|if
condition|(
name|comma
operator|==
name|pos
operator|||
name|equal
operator|==
name|pos
condition|)
comment|// huh? Broken header.
return|return
name|result
return|;
comment|// The key name is delimited by either a comma, an equal sign or the end
comment|// of the header, whichever comes first
name|int
name|end
init|=
name|comma
decl_stmt|;
if|if
condition|(
name|end
operator|==
operator|-
literal|1
condition|)
name|end
operator|=
name|header
operator|.
name|length
argument_list|()
expr_stmt|;
if|if
condition|(
name|equal
operator|!=
operator|-
literal|1
operator|&&
name|end
operator|>
name|equal
condition|)
name|end
operator|=
name|equal
expr_stmt|;
comment|// equal sign comes before comma/end
name|QByteArray
name|key
init|=
name|QByteArray
argument_list|(
name|header
operator|.
name|constData
argument_list|()
operator|+
name|pos
argument_list|,
name|end
operator|-
name|pos
argument_list|)
operator|.
name|trimmed
argument_list|()
operator|.
name|toLower
argument_list|()
decl_stmt|;
name|pos
operator|=
name|end
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|uint
argument_list|(
name|equal
argument_list|)
operator|<
name|uint
argument_list|(
name|comma
argument_list|)
condition|)
block|{
comment|// case: token "=" (token | quoted-string)
comment|// skip spaces
name|pos
operator|=
name|nextNonWhitespace
argument_list|(
name|header
argument_list|,
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|==
name|header
operator|.
name|length
argument_list|()
condition|)
comment|// huh? Broken header
return|return
name|result
return|;
name|QByteArray
name|value
decl_stmt|;
name|value
operator|.
name|reserve
argument_list|(
name|header
operator|.
name|length
argument_list|()
operator|-
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|header
operator|.
name|at
argument_list|(
name|pos
argument_list|)
operator|==
literal|'"'
condition|)
block|{
comment|// case: quoted-string
comment|// quoted-string  = (<"> *(qdtext | quoted-pair )<"> )
comment|// qdtext         =<any TEXT except<">>
comment|// quoted-pair    = "\" CHAR
operator|++
name|pos
expr_stmt|;
while|while
condition|(
name|pos
operator|<
name|header
operator|.
name|length
argument_list|()
condition|)
block|{
specifier|register
name|char
name|c
init|=
name|header
operator|.
name|at
argument_list|(
name|pos
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
block|{
comment|// end of quoted text
break|break;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
operator|++
name|pos
expr_stmt|;
if|if
condition|(
name|pos
operator|>=
name|header
operator|.
name|length
argument_list|()
condition|)
comment|// broken header
return|return
name|result
return|;
name|c
operator|=
name|header
operator|.
name|at
argument_list|(
name|pos
argument_list|)
expr_stmt|;
block|}
name|value
operator|+=
name|c
expr_stmt|;
operator|++
name|pos
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// case: token
while|while
condition|(
name|pos
operator|<
name|header
operator|.
name|length
argument_list|()
condition|)
block|{
specifier|register
name|char
name|c
init|=
name|header
operator|.
name|at
argument_list|(
name|pos
argument_list|)
decl_stmt|;
if|if
condition|(
name|isSeparator
argument_list|(
name|c
argument_list|)
condition|)
break|break;
name|value
operator|+=
name|c
expr_stmt|;
operator|++
name|pos
expr_stmt|;
block|}
block|}
name|result
operator|.
name|insert
argument_list|(
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|// find the comma now:
name|comma
operator|=
name|header
operator|.
name|indexOf
argument_list|(
literal|','
argument_list|,
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|comma
operator|==
operator|-
literal|1
condition|)
return|return
name|result
return|;
comment|// end of parsing
name|pos
operator|=
name|comma
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|// case: token
comment|// key is already set
name|result
operator|.
name|insert
argument_list|(
name|key
argument_list|,
name|QByteArray
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_constructor
DECL|function|QNetworkReplyHttpImpl
name|QNetworkReplyHttpImpl
operator|::
name|QNetworkReplyHttpImpl
parameter_list|(
name|QNetworkAccessManager
modifier|*
specifier|const
name|manager
parameter_list|,
specifier|const
name|QNetworkRequest
modifier|&
name|request
parameter_list|,
name|QNetworkAccessManager
operator|::
name|Operation
modifier|&
name|operation
parameter_list|,
name|QIODevice
modifier|*
name|outgoingData
parameter_list|)
member_init_list|:
name|QNetworkReply
argument_list|(
operator|*
operator|new
name|QNetworkReplyHttpImplPrivate
argument_list|,
name|manager
argument_list|)
block|{
name|Q_D
argument_list|(
name|QNetworkReplyHttpImpl
argument_list|)
expr_stmt|;
name|d
operator|->
name|manager
operator|=
name|manager
expr_stmt|;
name|d
operator|->
name|managerPrivate
operator|=
name|manager
operator|->
name|d_func
argument_list|()
expr_stmt|;
name|d
operator|->
name|request
operator|=
name|request
expr_stmt|;
name|d
operator|->
name|operation
operator|=
name|operation
expr_stmt|;
name|d
operator|->
name|outgoingData
operator|=
name|outgoingData
expr_stmt|;
name|d
operator|->
name|url
operator|=
name|request
operator|.
name|url
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_SSL
name|d
operator|->
name|sslConfiguration
operator|=
name|request
operator|.
name|sslConfiguration
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|// FIXME Later maybe set to Unbuffered, especially if it is zerocopy or from cache?
name|QIODevice
operator|::
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
expr_stmt|;
comment|// Internal code that does a HTTP reply for the synchronous Ajax
comment|// in Qt WebKit.
name|QVariant
name|synchronousHttpAttribute
init|=
name|request
operator|.
name|attribute
argument_list|(
cast|static_cast
argument_list|<
name|QNetworkRequest
operator|::
name|Attribute
argument_list|>
argument_list|(
name|QNetworkRequest
operator|::
name|SynchronousRequestAttribute
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|synchronousHttpAttribute
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|d
operator|->
name|synchronous
operator|=
name|synchronousHttpAttribute
operator|.
name|toBool
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|synchronous
operator|&&
name|outgoingData
condition|)
block|{
comment|// The synchronous HTTP is a corner case, we will put all upload data in one big QByteArray in the outgoingDataBuffer.
comment|// Yes, this is not the most efficient thing to do, but on the other hand synchronous XHR needs to die anyway.
name|d
operator|->
name|outgoingDataBuffer
operator|=
name|QSharedPointer
argument_list|<
name|QRingBuffer
argument_list|>
argument_list|(
operator|new
name|QRingBuffer
argument_list|()
argument_list|)
expr_stmt|;
name|qint64
name|previousDataSize
init|=
literal|0
decl_stmt|;
do|do
block|{
name|previousDataSize
operator|=
name|d
operator|->
name|outgoingDataBuffer
operator|->
name|size
argument_list|()
expr_stmt|;
name|d
operator|->
name|outgoingDataBuffer
operator|->
name|append
argument_list|(
name|d
operator|->
name|outgoingData
operator|->
name|readAll
argument_list|()
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|d
operator|->
name|outgoingDataBuffer
operator|->
name|size
argument_list|()
operator|!=
name|previousDataSize
condition|)
do|;
name|d
operator|->
name|_q_startOperation
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|outgoingData
condition|)
block|{
comment|// there is data to be uploaded, e.g. HTTP POST.
if|if
condition|(
operator|!
name|d
operator|->
name|outgoingData
operator|->
name|isSequential
argument_list|()
condition|)
block|{
comment|// fixed size non-sequential (random-access)
comment|// just start the operation
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|this
argument_list|,
literal|"_q_startOperation"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
comment|// FIXME make direct call?
block|}
else|else
block|{
name|bool
name|bufferingDisallowed
init|=
name|request
operator|.
name|attribute
argument_list|(
name|QNetworkRequest
operator|::
name|DoNotBufferUploadDataAttribute
argument_list|,
literal|false
argument_list|)
operator|.
name|toBool
argument_list|()
decl_stmt|;
if|if
condition|(
name|bufferingDisallowed
condition|)
block|{
comment|// if a valid content-length header for the request was supplied, we can disable buffering
comment|// if not, we will buffer anyway
if|if
condition|(
name|request
operator|.
name|header
argument_list|(
name|QNetworkRequest
operator|::
name|ContentLengthHeader
argument_list|)
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|this
argument_list|,
literal|"_q_startOperation"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
comment|// FIXME make direct call?
block|}
else|else
block|{
name|d
operator|->
name|state
operator|=
name|d
operator|->
name|Buffering
expr_stmt|;
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|this
argument_list|,
literal|"_q_bufferOutgoingData"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// _q_startOperation will be called when the buffering has finished.
name|d
operator|->
name|state
operator|=
name|d
operator|->
name|Buffering
expr_stmt|;
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|this
argument_list|,
literal|"_q_bufferOutgoingData"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|// No outgoing data (POST, ..)
name|d
operator|->
name|_q_startOperation
argument_list|()
expr_stmt|;
block|}
block|}
end_constructor
begin_destructor
DECL|function|~QNetworkReplyHttpImpl
name|QNetworkReplyHttpImpl
operator|::
name|~
name|QNetworkReplyHttpImpl
parameter_list|()
block|{
comment|// Most work is done in private destructor
block|}
end_destructor
begin_function
DECL|function|close
name|void
name|QNetworkReplyHttpImpl
operator|::
name|close
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QNetworkReplyHttpImpl
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|state
operator|==
name|QNetworkReplyHttpImplPrivate
operator|::
name|Aborted
operator|||
name|d
operator|->
name|state
operator|==
name|QNetworkReplyHttpImplPrivate
operator|::
name|Finished
condition|)
return|return;
comment|// According to the documentation close only stops the download
comment|// by closing we can ignore the download part and continue uploading.
name|QNetworkReply
operator|::
name|close
argument_list|()
expr_stmt|;
comment|// call finished which will emit signals
comment|// FIXME shouldn't this be emitted Queued?
name|d
operator|->
name|error
argument_list|(
name|OperationCanceledError
argument_list|,
name|tr
argument_list|(
literal|"Operation canceled"
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|finished
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|abort
name|void
name|QNetworkReplyHttpImpl
operator|::
name|abort
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QNetworkReplyHttpImpl
argument_list|)
expr_stmt|;
comment|// FIXME
if|if
condition|(
name|d
operator|->
name|state
operator|==
name|QNetworkReplyHttpImplPrivate
operator|::
name|Finished
operator|||
name|d
operator|->
name|state
operator|==
name|QNetworkReplyHttpImplPrivate
operator|::
name|Aborted
condition|)
return|return;
name|QNetworkReply
operator|::
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|state
operator|!=
name|QNetworkReplyHttpImplPrivate
operator|::
name|Finished
condition|)
block|{
comment|// call finished which will emit signals
comment|// FIXME shouldn't this be emitted Queued?
name|d
operator|->
name|error
argument_list|(
name|OperationCanceledError
argument_list|,
name|tr
argument_list|(
literal|"Operation canceled"
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|finished
argument_list|()
expr_stmt|;
block|}
name|d
operator|->
name|state
operator|=
name|QNetworkReplyHttpImplPrivate
operator|::
name|Aborted
expr_stmt|;
emit|emit
name|abortHttpRequest
argument_list|()
emit|;
block|}
end_function
begin_function
DECL|function|bytesAvailable
name|qint64
name|QNetworkReplyHttpImpl
operator|::
name|bytesAvailable
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QNetworkReplyHttpImpl
argument_list|)
expr_stmt|;
comment|// if we load from cache device
if|if
condition|(
name|d
operator|->
name|cacheLoadDevice
condition|)
block|{
return|return
name|QNetworkReply
operator|::
name|bytesAvailable
argument_list|()
operator|+
name|d
operator|->
name|cacheLoadDevice
operator|->
name|bytesAvailable
argument_list|()
operator|+
name|d
operator|->
name|downloadMultiBuffer
operator|.
name|byteAmount
argument_list|()
return|;
block|}
comment|// zerocopy buffer
if|if
condition|(
name|d
operator|->
name|downloadZerocopyBuffer
condition|)
block|{
return|return
name|QNetworkReply
operator|::
name|bytesAvailable
argument_list|()
operator|+
name|d
operator|->
name|downloadBufferCurrentSize
operator|-
name|d
operator|->
name|downloadBufferReadPosition
return|;
block|}
comment|// normal buffer
return|return
name|QNetworkReply
operator|::
name|bytesAvailable
argument_list|()
operator|+
name|d
operator|->
name|downloadMultiBuffer
operator|.
name|byteAmount
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|isSequential
name|bool
name|QNetworkReplyHttpImpl
operator|::
name|isSequential
parameter_list|()
specifier|const
block|{
comment|// FIXME In the cache of a cached load or the zero-copy buffer we could actually be non-sequential.
comment|// FIXME however this requires us to implement stuff like seek() too.
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|size
name|qint64
name|QNetworkReplyHttpImpl
operator|::
name|size
parameter_list|()
specifier|const
block|{
comment|// FIXME At some point, this could return a proper value, e.g. if we're non-sequential.
return|return
name|QNetworkReply
operator|::
name|size
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|readData
name|qint64
name|QNetworkReplyHttpImpl
operator|::
name|readData
parameter_list|(
name|char
modifier|*
name|data
parameter_list|,
name|qint64
name|maxlen
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QNetworkReplyHttpImpl
argument_list|)
expr_stmt|;
comment|// cacheload device
if|if
condition|(
name|d
operator|->
name|cacheLoadDevice
condition|)
block|{
comment|// FIXME bytesdownloaded, position etc?
comment|// There is something already in the buffer we buffered before because the user did not read()
comment|// anything, so we read there first:
if|if
condition|(
operator|!
name|d
operator|->
name|downloadMultiBuffer
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
return|return
name|d
operator|->
name|downloadMultiBuffer
operator|.
name|read
argument_list|(
name|data
argument_list|,
name|maxlen
argument_list|)
return|;
block|}
name|qint64
name|ret
init|=
name|d
operator|->
name|cacheLoadDevice
operator|->
name|read
argument_list|(
name|data
argument_list|,
name|maxlen
argument_list|)
decl_stmt|;
return|return
name|ret
return|;
block|}
comment|// zerocopy buffer
if|if
condition|(
name|d
operator|->
name|downloadZerocopyBuffer
condition|)
block|{
comment|// FIXME bytesdownloaded, position etc?
name|qint64
name|howMuch
init|=
name|qMin
argument_list|(
name|maxlen
argument_list|,
operator|(
name|d
operator|->
name|downloadBufferCurrentSize
operator|-
name|d
operator|->
name|downloadBufferReadPosition
operator|)
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|data
argument_list|,
name|d
operator|->
name|downloadZerocopyBuffer
operator|+
name|d
operator|->
name|downloadBufferReadPosition
argument_list|,
name|howMuch
argument_list|)
expr_stmt|;
name|d
operator|->
name|downloadBufferReadPosition
operator|+=
name|howMuch
expr_stmt|;
return|return
name|howMuch
return|;
block|}
comment|// normal buffer
if|if
condition|(
name|d
operator|->
name|downloadMultiBuffer
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|state
operator|==
name|d
operator|->
name|Finished
operator|||
name|d
operator|->
name|state
operator|==
name|d
operator|->
name|Aborted
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|maxlen
operator|==
literal|1
condition|)
block|{
comment|// optimization for getChar()
operator|*
name|data
operator|=
name|d
operator|->
name|downloadMultiBuffer
operator|.
name|getChar
argument_list|()
expr_stmt|;
if|if
condition|(
name|readBufferSize
argument_list|()
condition|)
emit|emit
name|readBufferFreed
argument_list|(
literal|1
argument_list|)
emit|;
return|return
literal|1
return|;
block|}
name|maxlen
operator|=
name|qMin
argument_list|<
name|qint64
argument_list|>
argument_list|(
name|maxlen
argument_list|,
name|d
operator|->
name|downloadMultiBuffer
operator|.
name|byteAmount
argument_list|()
argument_list|)
expr_stmt|;
name|qint64
name|bytesRead
init|=
name|d
operator|->
name|downloadMultiBuffer
operator|.
name|read
argument_list|(
name|data
argument_list|,
name|maxlen
argument_list|)
decl_stmt|;
if|if
condition|(
name|readBufferSize
argument_list|()
condition|)
emit|emit
name|readBufferFreed
argument_list|(
name|bytesRead
argument_list|)
emit|;
return|return
name|bytesRead
return|;
block|}
end_function
begin_function
DECL|function|setReadBufferSize
name|void
name|QNetworkReplyHttpImpl
operator|::
name|setReadBufferSize
parameter_list|(
name|qint64
name|size
parameter_list|)
block|{
name|QNetworkReply
operator|::
name|setReadBufferSize
argument_list|(
name|size
argument_list|)
expr_stmt|;
emit|emit
name|readBufferSizeChanged
argument_list|(
name|size
argument_list|)
emit|;
return|return;
block|}
end_function
begin_function
DECL|function|canReadLine
name|bool
name|QNetworkReplyHttpImpl
operator|::
name|canReadLine
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QNetworkReplyHttpImpl
argument_list|)
expr_stmt|;
if|if
condition|(
name|QNetworkReply
operator|::
name|canReadLine
argument_list|()
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|d
operator|->
name|cacheLoadDevice
condition|)
return|return
name|d
operator|->
name|cacheLoadDevice
operator|->
name|canReadLine
argument_list|()
operator|||
name|d
operator|->
name|downloadMultiBuffer
operator|.
name|canReadLine
argument_list|()
return|;
if|if
condition|(
name|d
operator|->
name|downloadZerocopyBuffer
condition|)
return|return
name|memchr
argument_list|(
name|d
operator|->
name|downloadZerocopyBuffer
operator|+
name|d
operator|->
name|downloadBufferReadPosition
argument_list|,
literal|'\n'
argument_list|,
name|d
operator|->
name|downloadBufferCurrentSize
operator|-
name|d
operator|->
name|downloadBufferReadPosition
argument_list|)
return|;
return|return
name|d
operator|->
name|downloadMultiBuffer
operator|.
name|canReadLine
argument_list|()
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_SSL
end_ifndef
begin_function
DECL|function|ignoreSslErrors
name|void
name|QNetworkReplyHttpImpl
operator|::
name|ignoreSslErrors
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QNetworkReplyHttpImpl
argument_list|)
expr_stmt|;
name|d
operator|->
name|pendingIgnoreAllSslErrors
operator|=
literal|true
expr_stmt|;
block|}
end_function
begin_function
DECL|function|ignoreSslErrorsImplementation
name|void
name|QNetworkReplyHttpImpl
operator|::
name|ignoreSslErrorsImplementation
parameter_list|(
specifier|const
name|QList
argument_list|<
name|QSslError
argument_list|>
modifier|&
name|errors
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QNetworkReplyHttpImpl
argument_list|)
expr_stmt|;
comment|// the pending list is set if QNetworkReply::ignoreSslErrors(const QList<QSslError>&errors)
comment|// is called before QNetworkAccessManager::get() (or post(), etc.)
name|d
operator|->
name|pendingIgnoreSslErrorsList
operator|=
name|errors
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setSslConfigurationImplementation
name|void
name|QNetworkReplyHttpImpl
operator|::
name|setSslConfigurationImplementation
parameter_list|(
specifier|const
name|QSslConfiguration
modifier|&
name|newconfig
parameter_list|)
block|{
comment|// Setting a SSL configuration on a reply is not supported. The user needs to set
comment|// her/his QSslConfiguration on the QNetworkRequest.
name|Q_UNUSED
argument_list|(
name|newconfig
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|sslConfigurationImplementation
name|void
name|QNetworkReplyHttpImpl
operator|::
name|sslConfigurationImplementation
parameter_list|(
name|QSslConfiguration
modifier|&
name|configuration
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QNetworkReplyHttpImpl
argument_list|)
expr_stmt|;
name|configuration
operator|=
name|d
operator|->
name|sslConfiguration
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_constructor
DECL|function|QNetworkReplyHttpImplPrivate
name|QNetworkReplyHttpImplPrivate
operator|::
name|QNetworkReplyHttpImplPrivate
parameter_list|()
member_init_list|:
name|QNetworkReplyPrivate
argument_list|()
member_init_list|,
name|manager
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|managerPrivate
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|synchronous
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|state
argument_list|(
name|Idle
argument_list|)
member_init_list|,
name|statusCode
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|outgoingData
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|bytesUploaded
argument_list|(
operator|-
literal|1
argument_list|)
member_init_list|,
name|cacheLoadDevice
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|loadingFromCache
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|cacheSaveDevice
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|cacheEnabled
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|resumeOffset
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|preMigrationDownloaded
argument_list|(
operator|-
literal|1
argument_list|)
member_init_list|,
name|bytesDownloaded
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|downloadBufferReadPosition
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|downloadBufferCurrentSize
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|downloadZerocopyBuffer
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|pendingDownloadDataEmissions
argument_list|(
operator|new
name|QAtomicInt
argument_list|()
argument_list|)
member_init_list|,
name|pendingDownloadProgressEmissions
argument_list|(
operator|new
name|QAtomicInt
argument_list|()
argument_list|)
ifndef|#
directive|ifndef
name|QT_NO_SSL
member_init_list|,
name|pendingIgnoreAllSslErrors
argument_list|(
literal|false
argument_list|)
endif|#
directive|endif
block|{ }
end_constructor
begin_destructor
DECL|function|~QNetworkReplyHttpImplPrivate
name|QNetworkReplyHttpImplPrivate
operator|::
name|~
name|QNetworkReplyHttpImplPrivate
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QNetworkReplyHttpImpl
argument_list|)
expr_stmt|;
comment|// This will do nothing if the request was already finished or aborted
emit|emit
name|q
operator|->
name|abortHttpRequest
argument_list|()
emit|;
block|}
end_destructor
begin_comment
comment|/*     For a given httpRequest     1) If AlwaysNetwork, return     2) If we have a cache entry for this url populate headers so the server can return 304     3) Calculate if response_is_fresh and if so send the cache and set loadedFromCache to true  */
end_comment
begin_function
DECL|function|loadFromCacheIfAllowed
name|bool
name|QNetworkReplyHttpImplPrivate
operator|::
name|loadFromCacheIfAllowed
parameter_list|(
name|QHttpNetworkRequest
modifier|&
name|httpRequest
parameter_list|)
block|{
name|QNetworkRequest
operator|::
name|CacheLoadControl
name|CacheLoadControlAttribute
init|=
operator|(
name|QNetworkRequest
operator|::
name|CacheLoadControl
operator|)
name|request
operator|.
name|attribute
argument_list|(
name|QNetworkRequest
operator|::
name|CacheLoadControlAttribute
argument_list|,
name|QNetworkRequest
operator|::
name|PreferNetwork
argument_list|)
operator|.
name|toInt
argument_list|()
decl_stmt|;
if|if
condition|(
name|CacheLoadControlAttribute
operator|==
name|QNetworkRequest
operator|::
name|AlwaysNetwork
condition|)
block|{
comment|// If the request does not already specify preferred cache-control
comment|// force reload from the network and tell any caching proxy servers to reload too
if|if
condition|(
operator|!
name|request
operator|.
name|rawHeaderList
argument_list|()
operator|.
name|contains
argument_list|(
literal|"Cache-Control"
argument_list|)
condition|)
block|{
name|httpRequest
operator|.
name|setHeaderField
argument_list|(
literal|"Cache-Control"
argument_list|,
literal|"no-cache"
argument_list|)
expr_stmt|;
name|httpRequest
operator|.
name|setHeaderField
argument_list|(
literal|"Pragma"
argument_list|,
literal|"no-cache"
argument_list|)
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
comment|// The disk cache API does not currently support partial content retrieval.
comment|// That is why we don't use the disk cache for any such requests.
if|if
condition|(
name|request
operator|.
name|hasRawHeader
argument_list|(
literal|"Range"
argument_list|)
condition|)
return|return
literal|false
return|;
name|QAbstractNetworkCache
modifier|*
name|nc
init|=
name|managerPrivate
operator|->
name|networkCache
decl_stmt|;
if|if
condition|(
operator|!
name|nc
condition|)
return|return
literal|false
return|;
comment|// no local cache
name|QNetworkCacheMetaData
name|metaData
init|=
name|nc
operator|->
name|metaData
argument_list|(
name|request
operator|.
name|url
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|metaData
operator|.
name|isValid
argument_list|()
condition|)
return|return
literal|false
return|;
comment|// not in cache
if|if
condition|(
operator|!
name|metaData
operator|.
name|saveToDisk
argument_list|()
condition|)
return|return
literal|false
return|;
name|QNetworkHeadersPrivate
name|cacheHeaders
decl_stmt|;
name|QNetworkHeadersPrivate
operator|::
name|RawHeadersList
operator|::
name|ConstIterator
name|it
decl_stmt|;
name|cacheHeaders
operator|.
name|setAllRawHeaders
argument_list|(
name|metaData
operator|.
name|rawHeaders
argument_list|()
argument_list|)
expr_stmt|;
name|it
operator|=
name|cacheHeaders
operator|.
name|findRawHeader
argument_list|(
literal|"etag"
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|!=
name|cacheHeaders
operator|.
name|rawHeaders
operator|.
name|constEnd
argument_list|()
condition|)
name|httpRequest
operator|.
name|setHeaderField
argument_list|(
literal|"If-None-Match"
argument_list|,
name|it
operator|->
name|second
argument_list|)
expr_stmt|;
name|QDateTime
name|lastModified
init|=
name|metaData
operator|.
name|lastModified
argument_list|()
decl_stmt|;
if|if
condition|(
name|lastModified
operator|.
name|isValid
argument_list|()
condition|)
name|httpRequest
operator|.
name|setHeaderField
argument_list|(
literal|"If-Modified-Since"
argument_list|,
name|QNetworkHeadersPrivate
operator|::
name|toHttpDate
argument_list|(
name|lastModified
argument_list|)
argument_list|)
expr_stmt|;
name|it
operator|=
name|cacheHeaders
operator|.
name|findRawHeader
argument_list|(
literal|"Cache-Control"
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|!=
name|cacheHeaders
operator|.
name|rawHeaders
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|QHash
argument_list|<
name|QByteArray
argument_list|,
name|QByteArray
argument_list|>
name|cacheControl
init|=
name|parseHttpOptionHeader
argument_list|(
name|it
operator|->
name|second
argument_list|)
decl_stmt|;
if|if
condition|(
name|cacheControl
operator|.
name|contains
argument_list|(
literal|"must-revalidate"
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
name|QDateTime
name|currentDateTime
init|=
name|QDateTime
operator|::
name|currentDateTime
argument_list|()
decl_stmt|;
name|QDateTime
name|expirationDate
init|=
name|metaData
operator|.
name|expirationDate
argument_list|()
decl_stmt|;
name|bool
name|response_is_fresh
decl_stmt|;
if|if
condition|(
operator|!
name|expirationDate
operator|.
name|isValid
argument_list|()
condition|)
block|{
comment|/*          * age_value          *      is the value of Age: header received by the cache with          *              this response.          * date_value          *      is the value of the origin server's Date: header          * request_time          *      is the (local) time when the cache made the request          *              that resulted in this cached response          * response_time          *      is the (local) time when the cache received the          *              response          * now          *      is the current (local) time          */
name|int
name|age_value
init|=
literal|0
decl_stmt|;
name|it
operator|=
name|cacheHeaders
operator|.
name|findRawHeader
argument_list|(
literal|"age"
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|!=
name|cacheHeaders
operator|.
name|rawHeaders
operator|.
name|constEnd
argument_list|()
condition|)
name|age_value
operator|=
name|it
operator|->
name|second
operator|.
name|toInt
argument_list|()
expr_stmt|;
name|QDateTime
name|dateHeader
decl_stmt|;
name|int
name|date_value
init|=
literal|0
decl_stmt|;
name|it
operator|=
name|cacheHeaders
operator|.
name|findRawHeader
argument_list|(
literal|"date"
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|!=
name|cacheHeaders
operator|.
name|rawHeaders
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|dateHeader
operator|=
name|QNetworkHeadersPrivate
operator|::
name|fromHttpDate
argument_list|(
name|it
operator|->
name|second
argument_list|)
expr_stmt|;
name|date_value
operator|=
name|dateHeader
operator|.
name|toTime_t
argument_list|()
expr_stmt|;
block|}
name|int
name|now
init|=
name|currentDateTime
operator|.
name|toUTC
argument_list|()
operator|.
name|toTime_t
argument_list|()
decl_stmt|;
name|int
name|request_time
init|=
name|now
decl_stmt|;
name|int
name|response_time
init|=
name|now
decl_stmt|;
comment|// Algorithm from RFC 2616 section 13.2.3
name|int
name|apparent_age
init|=
name|qMax
argument_list|(
literal|0
argument_list|,
name|response_time
operator|-
name|date_value
argument_list|)
decl_stmt|;
name|int
name|corrected_received_age
init|=
name|qMax
argument_list|(
name|apparent_age
argument_list|,
name|age_value
argument_list|)
decl_stmt|;
name|int
name|response_delay
init|=
name|response_time
operator|-
name|request_time
decl_stmt|;
name|int
name|corrected_initial_age
init|=
name|corrected_received_age
operator|+
name|response_delay
decl_stmt|;
name|int
name|resident_time
init|=
name|now
operator|-
name|response_time
decl_stmt|;
name|int
name|current_age
init|=
name|corrected_initial_age
operator|+
name|resident_time
decl_stmt|;
comment|// RFC 2616 13.2.4 Expiration Calculations
if|if
condition|(
operator|!
name|expirationDate
operator|.
name|isValid
argument_list|()
condition|)
block|{
if|if
condition|(
name|lastModified
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|int
name|diff
init|=
name|currentDateTime
operator|.
name|secsTo
argument_list|(
name|lastModified
argument_list|)
decl_stmt|;
name|expirationDate
operator|=
name|lastModified
expr_stmt|;
name|expirationDate
operator|.
name|addSecs
argument_list|(
name|diff
operator|/
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|httpRequest
operator|.
name|headerField
argument_list|(
literal|"Warning"
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QDateTime
name|dt
decl_stmt|;
name|dt
operator|.
name|setTime_t
argument_list|(
name|current_age
argument_list|)
expr_stmt|;
if|if
condition|(
name|dt
operator|.
name|daysTo
argument_list|(
name|currentDateTime
argument_list|)
operator|>
literal|1
condition|)
name|httpRequest
operator|.
name|setHeaderField
argument_list|(
literal|"Warning"
argument_list|,
literal|"113"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// the cache-saving code below sets the expirationDate with date+max_age
comment|// if "max-age" is present, or to Expires otherwise
name|int
name|freshness_lifetime
init|=
name|dateHeader
operator|.
name|secsTo
argument_list|(
name|expirationDate
argument_list|)
decl_stmt|;
name|response_is_fresh
operator|=
operator|(
name|freshness_lifetime
operator|>
name|current_age
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|// expiration date was calculated earlier (e.g. when storing object to the cache)
name|response_is_fresh
operator|=
name|currentDateTime
operator|.
name|secsTo
argument_list|(
name|expirationDate
argument_list|)
operator|>=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|response_is_fresh
condition|)
return|return
literal|false
return|;
if|#
directive|if
name|defined
argument_list|(
name|QNETWORKACCESSHTTPBACKEND_DEBUG
argument_list|)
name|qDebug
argument_list|()
operator|<<
literal|"response_is_fresh"
operator|<<
name|CacheLoadControlAttribute
expr_stmt|;
endif|#
directive|endif
return|return
name|sendCacheContents
argument_list|(
name|metaData
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|convert
name|QHttpNetworkRequest
operator|::
name|Priority
name|QNetworkReplyHttpImplPrivate
operator|::
name|convert
parameter_list|(
specifier|const
name|QNetworkRequest
operator|::
name|Priority
modifier|&
name|prio
parameter_list|)
block|{
switch|switch
condition|(
name|prio
condition|)
block|{
case|case
name|QNetworkRequest
operator|::
name|LowPriority
case|:
return|return
name|QHttpNetworkRequest
operator|::
name|LowPriority
return|;
case|case
name|QNetworkRequest
operator|::
name|HighPriority
case|:
return|return
name|QHttpNetworkRequest
operator|::
name|HighPriority
return|;
case|case
name|QNetworkRequest
operator|::
name|NormalPriority
case|:
default|default:
return|return
name|QHttpNetworkRequest
operator|::
name|NormalPriority
return|;
block|}
block|}
end_function
begin_function
DECL|function|postRequest
name|void
name|QNetworkReplyHttpImplPrivate
operator|::
name|postRequest
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QNetworkReplyHttpImpl
argument_list|)
expr_stmt|;
name|QThread
modifier|*
name|thread
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|synchronous
condition|)
block|{
comment|// A synchronous HTTP request uses its own thread
name|thread
operator|=
operator|new
name|QThread
argument_list|()
expr_stmt|;
name|thread
operator|->
name|setObjectName
argument_list|(
name|QStringLiteral
argument_list|(
literal|"Qt HTTP synchronous thread"
argument_list|)
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|thread
argument_list|,
name|SIGNAL
argument_list|(
name|finished
argument_list|()
argument_list|)
argument_list|,
name|thread
argument_list|,
name|SLOT
argument_list|(
name|deleteLater
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|thread
operator|->
name|start
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|managerPrivate
operator|->
name|httpThread
condition|)
block|{
comment|// We use the manager-global thread.
comment|// At some point we could switch to having multiple threads if it makes sense.
name|managerPrivate
operator|->
name|httpThread
operator|=
operator|new
name|QThread
argument_list|()
expr_stmt|;
name|managerPrivate
operator|->
name|httpThread
operator|->
name|setObjectName
argument_list|(
name|QStringLiteral
argument_list|(
literal|"Qt HTTP thread"
argument_list|)
argument_list|)
expr_stmt|;
name|managerPrivate
operator|->
name|httpThread
operator|->
name|start
argument_list|()
expr_stmt|;
name|thread
operator|=
name|managerPrivate
operator|->
name|httpThread
expr_stmt|;
block|}
else|else
block|{
comment|// Asynchronous request, thread already exists
name|thread
operator|=
name|managerPrivate
operator|->
name|httpThread
expr_stmt|;
block|}
name|QUrl
name|url
init|=
name|request
operator|.
name|url
argument_list|()
decl_stmt|;
name|httpRequest
operator|.
name|setUrl
argument_list|(
name|url
argument_list|)
expr_stmt|;
name|QString
name|scheme
init|=
name|url
operator|.
name|scheme
argument_list|()
operator|.
name|toLower
argument_list|()
decl_stmt|;
name|bool
name|ssl
init|=
operator|(
name|scheme
operator|==
name|QLatin1String
argument_list|(
literal|"https"
argument_list|)
operator|||
name|scheme
operator|==
name|QLatin1String
argument_list|(
literal|"preconnect-https"
argument_list|)
operator|)
decl_stmt|;
name|q
operator|->
name|setAttribute
argument_list|(
name|QNetworkRequest
operator|::
name|ConnectionEncryptedAttribute
argument_list|,
name|ssl
argument_list|)
expr_stmt|;
name|httpRequest
operator|.
name|setSsl
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
name|QNetworkProxy
name|transparentProxy
decl_stmt|,
name|cacheProxy
decl_stmt|;
comment|// FIXME the proxy stuff should be done in the HTTP thread
foreach|foreach
control|(
specifier|const
name|QNetworkProxy
modifier|&
name|p
decl|,
name|managerPrivate
operator|->
name|queryProxy
argument_list|(
name|QNetworkProxyQuery
argument_list|(
name|request
operator|.
name|url
argument_list|()
argument_list|)
argument_list|)
control|)
block|{
comment|// use the first proxy that works
comment|// for non-encrypted connections, any transparent or HTTP proxy
comment|// for encrypted, only transparent proxies
if|if
condition|(
operator|!
name|ssl
operator|&&
operator|(
name|p
operator|.
name|capabilities
argument_list|()
operator|&
name|QNetworkProxy
operator|::
name|CachingCapability
operator|)
operator|&&
operator|(
name|p
operator|.
name|type
argument_list|()
operator|==
name|QNetworkProxy
operator|::
name|HttpProxy
operator|||
name|p
operator|.
name|type
argument_list|()
operator|==
name|QNetworkProxy
operator|::
name|HttpCachingProxy
operator|)
condition|)
block|{
name|cacheProxy
operator|=
name|p
expr_stmt|;
name|transparentProxy
operator|=
name|QNetworkProxy
operator|::
name|NoProxy
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|p
operator|.
name|isTransparentProxy
argument_list|()
condition|)
block|{
name|transparentProxy
operator|=
name|p
expr_stmt|;
name|cacheProxy
operator|=
name|QNetworkProxy
operator|::
name|NoProxy
expr_stmt|;
break|break;
block|}
block|}
comment|// check if at least one of the proxies
if|if
condition|(
name|transparentProxy
operator|.
name|type
argument_list|()
operator|==
name|QNetworkProxy
operator|::
name|DefaultProxy
operator|&&
name|cacheProxy
operator|.
name|type
argument_list|()
operator|==
name|QNetworkProxy
operator|::
name|DefaultProxy
condition|)
block|{
comment|// unsuitable proxies
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|q
argument_list|,
literal|"_q_error"
argument_list|,
name|synchronous
condition|?
name|Qt
operator|::
name|DirectConnection
else|:
name|Qt
operator|::
name|QueuedConnection
argument_list|,
name|Q_ARG
argument_list|(
name|QNetworkReply
operator|::
name|NetworkError
argument_list|,
name|QNetworkReply
operator|::
name|ProxyNotFoundError
argument_list|)
argument_list|,
name|Q_ARG
argument_list|(
name|QString
argument_list|,
name|QNetworkReplyHttpImpl
operator|::
name|tr
argument_list|(
literal|"No suitable proxy found"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|q
argument_list|,
literal|"_q_finished"
argument_list|,
name|synchronous
condition|?
name|Qt
operator|::
name|DirectConnection
else|:
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|bool
name|loadedFromCache
init|=
literal|false
decl_stmt|;
name|httpRequest
operator|.
name|setPriority
argument_list|(
name|convert
argument_list|(
name|request
operator|.
name|priority
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|operation
condition|)
block|{
case|case
name|QNetworkAccessManager
operator|::
name|GetOperation
case|:
name|httpRequest
operator|.
name|setOperation
argument_list|(
name|QHttpNetworkRequest
operator|::
name|Get
argument_list|)
expr_stmt|;
name|loadedFromCache
operator|=
name|loadFromCacheIfAllowed
argument_list|(
name|httpRequest
argument_list|)
expr_stmt|;
break|break;
case|case
name|QNetworkAccessManager
operator|::
name|HeadOperation
case|:
name|httpRequest
operator|.
name|setOperation
argument_list|(
name|QHttpNetworkRequest
operator|::
name|Head
argument_list|)
expr_stmt|;
name|loadedFromCache
operator|=
name|loadFromCacheIfAllowed
argument_list|(
name|httpRequest
argument_list|)
expr_stmt|;
break|break;
case|case
name|QNetworkAccessManager
operator|::
name|PostOperation
case|:
name|invalidateCache
argument_list|()
expr_stmt|;
name|httpRequest
operator|.
name|setOperation
argument_list|(
name|QHttpNetworkRequest
operator|::
name|Post
argument_list|)
expr_stmt|;
name|createUploadByteDevice
argument_list|()
expr_stmt|;
break|break;
case|case
name|QNetworkAccessManager
operator|::
name|PutOperation
case|:
name|invalidateCache
argument_list|()
expr_stmt|;
name|httpRequest
operator|.
name|setOperation
argument_list|(
name|QHttpNetworkRequest
operator|::
name|Put
argument_list|)
expr_stmt|;
name|createUploadByteDevice
argument_list|()
expr_stmt|;
break|break;
case|case
name|QNetworkAccessManager
operator|::
name|DeleteOperation
case|:
name|invalidateCache
argument_list|()
expr_stmt|;
name|httpRequest
operator|.
name|setOperation
argument_list|(
name|QHttpNetworkRequest
operator|::
name|Delete
argument_list|)
expr_stmt|;
break|break;
case|case
name|QNetworkAccessManager
operator|::
name|CustomOperation
case|:
name|invalidateCache
argument_list|()
expr_stmt|;
comment|// for safety reasons, we don't know what the operation does
name|httpRequest
operator|.
name|setOperation
argument_list|(
name|QHttpNetworkRequest
operator|::
name|Custom
argument_list|)
expr_stmt|;
name|createUploadByteDevice
argument_list|()
expr_stmt|;
name|httpRequest
operator|.
name|setCustomVerb
argument_list|(
name|request
operator|.
name|attribute
argument_list|(
name|QNetworkRequest
operator|::
name|CustomVerbAttribute
argument_list|)
operator|.
name|toByteArray
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
comment|// can't happen
block|}
if|if
condition|(
name|loadedFromCache
condition|)
block|{
return|return;
comment|// no need to send the request! :)
block|}
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|headers
init|=
name|request
operator|.
name|rawHeaderList
argument_list|()
decl_stmt|;
if|if
condition|(
name|resumeOffset
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|headers
operator|.
name|contains
argument_list|(
literal|"Range"
argument_list|)
condition|)
block|{
comment|// Need to adjust resume offset for user specified range
name|headers
operator|.
name|removeOne
argument_list|(
literal|"Range"
argument_list|)
expr_stmt|;
comment|// We've already verified that requestRange starts with "bytes=", see canResume.
name|QByteArray
name|requestRange
init|=
name|request
operator|.
name|rawHeader
argument_list|(
literal|"Range"
argument_list|)
operator|.
name|mid
argument_list|(
literal|6
argument_list|)
decl_stmt|;
name|int
name|index
init|=
name|requestRange
operator|.
name|indexOf
argument_list|(
literal|'-'
argument_list|)
decl_stmt|;
name|quint64
name|requestStartOffset
init|=
name|requestRange
operator|.
name|left
argument_list|(
name|index
argument_list|)
operator|.
name|toULongLong
argument_list|()
decl_stmt|;
name|quint64
name|requestEndOffset
init|=
name|requestRange
operator|.
name|mid
argument_list|(
name|index
operator|+
literal|1
argument_list|)
operator|.
name|toULongLong
argument_list|()
decl_stmt|;
name|requestRange
operator|=
literal|"bytes="
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|resumeOffset
operator|+
name|requestStartOffset
argument_list|)
operator|+
literal|'-'
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|requestEndOffset
argument_list|)
expr_stmt|;
name|httpRequest
operator|.
name|setHeaderField
argument_list|(
literal|"Range"
argument_list|,
name|requestRange
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|httpRequest
operator|.
name|setHeaderField
argument_list|(
literal|"Range"
argument_list|,
literal|"bytes="
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|resumeOffset
argument_list|)
operator|+
literal|'-'
argument_list|)
expr_stmt|;
block|}
block|}
foreach|foreach
control|(
specifier|const
name|QByteArray
modifier|&
name|header
decl|,
name|headers
control|)
name|httpRequest
operator|.
name|setHeaderField
argument_list|(
name|header
argument_list|,
name|request
operator|.
name|rawHeader
argument_list|(
name|header
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|request
operator|.
name|attribute
argument_list|(
name|QNetworkRequest
operator|::
name|HttpPipeliningAllowedAttribute
argument_list|)
operator|.
name|toBool
argument_list|()
operator|==
literal|true
condition|)
name|httpRequest
operator|.
name|setPipeliningAllowed
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
cast|static_cast
argument_list|<
name|QNetworkRequest
operator|::
name|LoadControl
argument_list|>
argument_list|(
name|request
operator|.
name|attribute
argument_list|(
name|QNetworkRequest
operator|::
name|AuthenticationReuseAttribute
argument_list|,
name|QNetworkRequest
operator|::
name|Automatic
argument_list|)
operator|.
name|toInt
argument_list|()
argument_list|)
operator|==
name|QNetworkRequest
operator|::
name|Manual
condition|)
name|httpRequest
operator|.
name|setWithCredentials
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// Create the HTTP thread delegate
name|QHttpThreadDelegate
modifier|*
name|delegate
init|=
operator|new
name|QHttpThreadDelegate
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_BEARERMANAGEMENT
name|delegate
operator|->
name|networkSession
operator|=
name|managerPrivate
operator|->
name|getNetworkSession
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|// For the synchronous HTTP, this is the normal way the delegate gets deleted
comment|// For the asynchronous HTTP this is a safety measure, the delegate deletes itself when HTTP is finished
name|QObject
operator|::
name|connect
argument_list|(
name|thread
argument_list|,
name|SIGNAL
argument_list|(
name|finished
argument_list|()
argument_list|)
argument_list|,
name|delegate
argument_list|,
name|SLOT
argument_list|(
name|deleteLater
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// Set the properties it needs
name|delegate
operator|->
name|httpRequest
operator|=
name|httpRequest
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
name|delegate
operator|->
name|cacheProxy
operator|=
name|cacheProxy
expr_stmt|;
name|delegate
operator|->
name|transparentProxy
operator|=
name|transparentProxy
expr_stmt|;
endif|#
directive|endif
name|delegate
operator|->
name|ssl
operator|=
name|ssl
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_SSL
if|if
condition|(
name|ssl
condition|)
name|delegate
operator|->
name|incomingSslConfiguration
operator|=
name|request
operator|.
name|sslConfiguration
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|// Do we use synchronous HTTP?
name|delegate
operator|->
name|synchronous
operator|=
name|synchronous
expr_stmt|;
comment|// The authentication manager is used to avoid the BlockingQueuedConnection communication
comment|// from HTTP thread to user thread in some cases.
name|delegate
operator|->
name|authenticationManager
operator|=
name|managerPrivate
operator|->
name|authenticationManager
expr_stmt|;
if|if
condition|(
operator|!
name|synchronous
condition|)
block|{
comment|// Tell our zerocopy policy to the delegate
name|QVariant
name|downloadBufferMaximumSizeAttribute
init|=
name|request
operator|.
name|attribute
argument_list|(
name|QNetworkRequest
operator|::
name|MaximumDownloadBufferSizeAttribute
argument_list|)
decl_stmt|;
if|if
condition|(
name|downloadBufferMaximumSizeAttribute
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|delegate
operator|->
name|downloadBufferMaximumSize
operator|=
name|downloadBufferMaximumSizeAttribute
operator|.
name|toLongLong
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// If there is no MaximumDownloadBufferSizeAttribute set (which is for the majority
comment|// of QNetworkRequest) then we can assume we'll do it anyway for small HTTP replies.
comment|// This helps with performance and memory fragmentation.
name|delegate
operator|->
name|downloadBufferMaximumSize
operator|=
literal|128
operator|*
literal|1024
expr_stmt|;
block|}
comment|// These atomic integers are used for signal compression
name|delegate
operator|->
name|pendingDownloadData
operator|=
name|pendingDownloadDataEmissions
expr_stmt|;
name|delegate
operator|->
name|pendingDownloadProgress
operator|=
name|pendingDownloadProgressEmissions
expr_stmt|;
comment|// Connect the signals of the delegate to us
name|QObject
operator|::
name|connect
argument_list|(
name|delegate
argument_list|,
name|SIGNAL
argument_list|(
name|downloadData
argument_list|(
name|QByteArray
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|replyDownloadData
argument_list|(
name|QByteArray
argument_list|)
argument_list|)
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|delegate
argument_list|,
name|SIGNAL
argument_list|(
name|downloadFinished
argument_list|()
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|replyFinished
argument_list|()
argument_list|)
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|delegate
argument_list|,
name|SIGNAL
argument_list|(
name|downloadMetaData
argument_list|(
name|QList
argument_list|<
name|QPair
argument_list|<
name|QByteArray
argument_list|,
name|QByteArray
argument_list|>
argument_list|>
argument_list|,
name|int
argument_list|,
name|QString
argument_list|,
name|bool
argument_list|,
name|QSharedPointer
argument_list|<
name|char
argument_list|>
argument_list|,
name|qint64
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|replyDownloadMetaData
argument_list|(
name|QList
argument_list|<
name|QPair
argument_list|<
name|QByteArray
argument_list|,
name|QByteArray
argument_list|>
argument_list|>
argument_list|,
name|int
argument_list|,
name|QString
argument_list|,
name|bool
argument_list|,
name|QSharedPointer
argument_list|<
name|char
argument_list|>
argument_list|,
name|qint64
argument_list|)
argument_list|)
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|delegate
argument_list|,
name|SIGNAL
argument_list|(
name|downloadProgress
argument_list|(
name|qint64
argument_list|,
name|qint64
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|replyDownloadProgressSlot
argument_list|(
name|qint64
argument_list|,
name|qint64
argument_list|)
argument_list|)
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|delegate
argument_list|,
name|SIGNAL
argument_list|(
name|error
argument_list|(
name|QNetworkReply
operator|::
name|NetworkError
argument_list|,
name|QString
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|httpError
argument_list|(
name|QNetworkReply
operator|::
name|NetworkError
argument_list|,
name|QString
argument_list|)
argument_list|)
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_SSL
name|QObject
operator|::
name|connect
argument_list|(
name|delegate
argument_list|,
name|SIGNAL
argument_list|(
name|sslConfigurationChanged
argument_list|(
name|QSslConfiguration
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|replySslConfigurationChanged
argument_list|(
name|QSslConfiguration
argument_list|)
argument_list|)
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// Those need to report back, therefire BlockingQueuedConnection
name|QObject
operator|::
name|connect
argument_list|(
name|delegate
argument_list|,
name|SIGNAL
argument_list|(
name|authenticationRequired
argument_list|(
name|QHttpNetworkRequest
argument_list|,
name|QAuthenticator
operator|*
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|httpAuthenticationRequired
argument_list|(
name|QHttpNetworkRequest
argument_list|,
name|QAuthenticator
operator|*
argument_list|)
argument_list|)
argument_list|,
name|Qt
operator|::
name|BlockingQueuedConnection
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
name|QObject
operator|::
name|connect
argument_list|(
name|delegate
argument_list|,
name|SIGNAL
argument_list|(
name|proxyAuthenticationRequired
argument_list|(
name|QNetworkProxy
argument_list|,
name|QAuthenticator
operator|*
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|proxyAuthenticationRequired
argument_list|(
name|QNetworkProxy
argument_list|,
name|QAuthenticator
operator|*
argument_list|)
argument_list|)
argument_list|,
name|Qt
operator|::
name|BlockingQueuedConnection
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_SSL
name|QObject
operator|::
name|connect
argument_list|(
name|delegate
argument_list|,
name|SIGNAL
argument_list|(
name|encrypted
argument_list|()
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|replyEncrypted
argument_list|()
argument_list|)
argument_list|,
name|Qt
operator|::
name|BlockingQueuedConnection
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|delegate
argument_list|,
name|SIGNAL
argument_list|(
name|sslErrors
argument_list|(
name|QList
argument_list|<
name|QSslError
argument_list|>
argument_list|,
name|bool
operator|*
argument_list|,
name|QList
argument_list|<
name|QSslError
argument_list|>
operator|*
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|replySslErrors
argument_list|(
name|QList
argument_list|<
name|QSslError
argument_list|>
argument_list|,
name|bool
operator|*
argument_list|,
name|QList
argument_list|<
name|QSslError
argument_list|>
operator|*
argument_list|)
argument_list|)
argument_list|,
name|Qt
operator|::
name|BlockingQueuedConnection
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// This signal we will use to start the request.
name|QObject
operator|::
name|connect
argument_list|(
name|q
argument_list|,
name|SIGNAL
argument_list|(
name|startHttpRequest
argument_list|()
argument_list|)
argument_list|,
name|delegate
argument_list|,
name|SLOT
argument_list|(
name|startRequest
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|q
argument_list|,
name|SIGNAL
argument_list|(
name|abortHttpRequest
argument_list|()
argument_list|)
argument_list|,
name|delegate
argument_list|,
name|SLOT
argument_list|(
name|abortRequest
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// To throttle the connection.
name|QObject
operator|::
name|connect
argument_list|(
name|q
argument_list|,
name|SIGNAL
argument_list|(
name|readBufferSizeChanged
argument_list|(
name|qint64
argument_list|)
argument_list|)
argument_list|,
name|delegate
argument_list|,
name|SLOT
argument_list|(
name|readBufferSizeChanged
argument_list|(
name|qint64
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|q
argument_list|,
name|SIGNAL
argument_list|(
name|readBufferFreed
argument_list|(
name|qint64
argument_list|)
argument_list|)
argument_list|,
name|delegate
argument_list|,
name|SLOT
argument_list|(
name|readBufferFreed
argument_list|(
name|qint64
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|uploadByteDevice
condition|)
block|{
name|QNonContiguousByteDeviceThreadForwardImpl
modifier|*
name|forwardUploadDevice
init|=
operator|new
name|QNonContiguousByteDeviceThreadForwardImpl
argument_list|(
name|uploadByteDevice
operator|->
name|atEnd
argument_list|()
argument_list|,
name|uploadByteDevice
operator|->
name|size
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|uploadByteDevice
operator|->
name|isResetDisabled
argument_list|()
condition|)
name|forwardUploadDevice
operator|->
name|disableReset
argument_list|()
expr_stmt|;
name|forwardUploadDevice
operator|->
name|setParent
argument_list|(
name|delegate
argument_list|)
expr_stmt|;
comment|// needed to make sure it is moved on moveToThread()
name|delegate
operator|->
name|httpRequest
operator|.
name|setUploadByteDevice
argument_list|(
name|forwardUploadDevice
argument_list|)
expr_stmt|;
comment|// From main thread to user thread:
name|QObject
operator|::
name|connect
argument_list|(
name|q
argument_list|,
name|SIGNAL
argument_list|(
name|haveUploadData
argument_list|(
name|QByteArray
argument_list|,
name|bool
argument_list|,
name|qint64
argument_list|)
argument_list|)
argument_list|,
name|forwardUploadDevice
argument_list|,
name|SLOT
argument_list|(
name|haveDataSlot
argument_list|(
name|QByteArray
argument_list|,
name|bool
argument_list|,
name|qint64
argument_list|)
argument_list|)
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|uploadByteDevice
operator|.
name|data
argument_list|()
argument_list|,
name|SIGNAL
argument_list|(
name|readyRead
argument_list|()
argument_list|)
argument_list|,
name|forwardUploadDevice
argument_list|,
name|SIGNAL
argument_list|(
name|readyRead
argument_list|()
argument_list|)
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
comment|// From http thread to user thread:
name|QObject
operator|::
name|connect
argument_list|(
name|forwardUploadDevice
argument_list|,
name|SIGNAL
argument_list|(
name|wantData
argument_list|(
name|qint64
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|wantUploadDataSlot
argument_list|(
name|qint64
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|forwardUploadDevice
argument_list|,
name|SIGNAL
argument_list|(
name|processedData
argument_list|(
name|qint64
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|sentUploadDataSlot
argument_list|(
name|qint64
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|forwardUploadDevice
argument_list|,
name|SIGNAL
argument_list|(
name|resetData
argument_list|(
name|bool
operator|*
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|resetUploadDataSlot
argument_list|(
name|bool
operator|*
argument_list|)
argument_list|)
argument_list|,
name|Qt
operator|::
name|BlockingQueuedConnection
argument_list|)
expr_stmt|;
comment|// this is the only one with BlockingQueued!
block|}
block|}
elseif|else
if|if
condition|(
name|synchronous
condition|)
block|{
name|QObject
operator|::
name|connect
argument_list|(
name|q
argument_list|,
name|SIGNAL
argument_list|(
name|startHttpRequestSynchronously
argument_list|()
argument_list|)
argument_list|,
name|delegate
argument_list|,
name|SLOT
argument_list|(
name|startRequestSynchronously
argument_list|()
argument_list|)
argument_list|,
name|Qt
operator|::
name|BlockingQueuedConnection
argument_list|)
expr_stmt|;
if|if
condition|(
name|uploadByteDevice
condition|)
block|{
comment|// For the synchronous HTTP use case the use thread (this one here) is blocked
comment|// so we cannot use the asynchronous upload architecture.
comment|// We therefore won't use the QNonContiguousByteDeviceThreadForwardImpl but directly
comment|// use the uploadByteDevice provided to us by the QNetworkReplyImpl.
comment|// The code that is in start() makes sure it is safe to use from a thread
comment|// since it only wraps a QRingBuffer
name|delegate
operator|->
name|httpRequest
operator|.
name|setUploadByteDevice
argument_list|(
name|uploadByteDevice
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Move the delegate to the http thread
name|delegate
operator|->
name|moveToThread
argument_list|(
name|thread
argument_list|)
expr_stmt|;
comment|// This call automatically moves the uploadDevice too for the asynchronous case.
comment|// Prepare timers for progress notifications
name|downloadProgressSignalChoke
operator|.
name|start
argument_list|()
expr_stmt|;
name|uploadProgressSignalChoke
operator|.
name|invalidate
argument_list|()
expr_stmt|;
comment|// Send an signal to the delegate so it starts working in the other thread
if|if
condition|(
name|synchronous
condition|)
block|{
emit|emit
name|q
operator|->
name|startHttpRequestSynchronously
argument_list|()
emit|;
comment|// This one is BlockingQueuedConnection, so it will return when all work is done
if|if
condition|(
name|delegate
operator|->
name|incomingErrorCode
operator|!=
name|QNetworkReply
operator|::
name|NoError
condition|)
block|{
name|replyDownloadMetaData
argument_list|(
name|delegate
operator|->
name|incomingHeaders
argument_list|,
name|delegate
operator|->
name|incomingStatusCode
argument_list|,
name|delegate
operator|->
name|incomingReasonPhrase
argument_list|,
name|delegate
operator|->
name|isPipeliningUsed
argument_list|,
name|QSharedPointer
argument_list|<
name|char
argument_list|>
argument_list|()
argument_list|,
name|delegate
operator|->
name|incomingContentLength
argument_list|)
expr_stmt|;
name|replyDownloadData
argument_list|(
name|delegate
operator|->
name|synchronousDownloadData
argument_list|)
expr_stmt|;
name|httpError
argument_list|(
name|delegate
operator|->
name|incomingErrorCode
argument_list|,
name|delegate
operator|->
name|incomingErrorDetail
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|replyDownloadMetaData
argument_list|(
name|delegate
operator|->
name|incomingHeaders
argument_list|,
name|delegate
operator|->
name|incomingStatusCode
argument_list|,
name|delegate
operator|->
name|incomingReasonPhrase
argument_list|,
name|delegate
operator|->
name|isPipeliningUsed
argument_list|,
name|QSharedPointer
argument_list|<
name|char
argument_list|>
argument_list|()
argument_list|,
name|delegate
operator|->
name|incomingContentLength
argument_list|)
expr_stmt|;
name|replyDownloadData
argument_list|(
name|delegate
operator|->
name|synchronousDownloadData
argument_list|)
expr_stmt|;
block|}
name|thread
operator|->
name|quit
argument_list|()
expr_stmt|;
name|thread
operator|->
name|wait
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
if|if
condition|(
name|thread
operator|->
name|isFinished
argument_list|()
condition|)
operator|delete
name|thread
expr_stmt|;
else|else
name|QObject
operator|::
name|connect
argument_list|(
name|thread
argument_list|,
name|SIGNAL
argument_list|(
name|finished
argument_list|()
argument_list|)
argument_list|,
name|thread
argument_list|,
name|SLOT
argument_list|(
name|deleteLater
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|finished
argument_list|()
expr_stmt|;
block|}
else|else
block|{
emit|emit
name|q
operator|->
name|startHttpRequest
argument_list|()
emit|;
comment|// Signal to the HTTP thread and go back to user.
block|}
block|}
end_function
begin_function
DECL|function|invalidateCache
name|void
name|QNetworkReplyHttpImplPrivate
operator|::
name|invalidateCache
parameter_list|()
block|{
name|QAbstractNetworkCache
modifier|*
name|nc
init|=
name|managerPrivate
operator|->
name|networkCache
decl_stmt|;
if|if
condition|(
name|nc
condition|)
name|nc
operator|->
name|remove
argument_list|(
name|request
operator|.
name|url
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|initCacheSaveDevice
name|void
name|QNetworkReplyHttpImplPrivate
operator|::
name|initCacheSaveDevice
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QNetworkReplyHttpImpl
argument_list|)
expr_stmt|;
comment|// The disk cache does not support partial content, so don't even try to
comment|// save any such content into the cache.
if|if
condition|(
name|q
operator|->
name|attribute
argument_list|(
name|QNetworkRequest
operator|::
name|HttpStatusCodeAttribute
argument_list|)
operator|.
name|toInt
argument_list|()
operator|==
literal|206
condition|)
block|{
name|cacheEnabled
operator|=
literal|false
expr_stmt|;
return|return;
block|}
comment|// save the meta data
name|QNetworkCacheMetaData
name|metaData
decl_stmt|;
name|metaData
operator|.
name|setUrl
argument_list|(
name|url
argument_list|)
expr_stmt|;
name|metaData
operator|=
name|fetchCacheMetaData
argument_list|(
name|metaData
argument_list|)
expr_stmt|;
comment|// save the redirect request also in the cache
name|QVariant
name|redirectionTarget
init|=
name|q
operator|->
name|attribute
argument_list|(
name|QNetworkRequest
operator|::
name|RedirectionTargetAttribute
argument_list|)
decl_stmt|;
if|if
condition|(
name|redirectionTarget
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|QNetworkCacheMetaData
operator|::
name|AttributesMap
name|attributes
init|=
name|metaData
operator|.
name|attributes
argument_list|()
decl_stmt|;
name|attributes
operator|.
name|insert
argument_list|(
name|QNetworkRequest
operator|::
name|RedirectionTargetAttribute
argument_list|,
name|redirectionTarget
argument_list|)
expr_stmt|;
name|metaData
operator|.
name|setAttributes
argument_list|(
name|attributes
argument_list|)
expr_stmt|;
block|}
name|cacheSaveDevice
operator|=
name|managerPrivate
operator|->
name|networkCache
operator|->
name|prepare
argument_list|(
name|metaData
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cacheSaveDevice
operator|||
operator|(
name|cacheSaveDevice
operator|&&
operator|!
name|cacheSaveDevice
operator|->
name|isOpen
argument_list|()
operator|)
condition|)
block|{
if|if
condition|(
name|cacheSaveDevice
operator|&&
operator|!
name|cacheSaveDevice
operator|->
name|isOpen
argument_list|()
condition|)
name|qCritical
argument_list|(
literal|"QNetworkReplyImpl: network cache returned a device that is not open -- "
literal|"class %s probably needs to be fixed"
argument_list|,
name|managerPrivate
operator|->
name|networkCache
operator|->
name|metaObject
argument_list|()
operator|->
name|className
argument_list|()
argument_list|)
expr_stmt|;
name|managerPrivate
operator|->
name|networkCache
operator|->
name|remove
argument_list|(
name|url
argument_list|)
expr_stmt|;
name|cacheSaveDevice
operator|=
literal|0
expr_stmt|;
name|cacheEnabled
operator|=
literal|false
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|replyDownloadData
name|void
name|QNetworkReplyHttpImplPrivate
operator|::
name|replyDownloadData
parameter_list|(
name|QByteArray
name|d
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QNetworkReplyHttpImpl
argument_list|)
expr_stmt|;
comment|// If we're closed just ignore this data
if|if
condition|(
operator|!
name|q
operator|->
name|isOpen
argument_list|()
condition|)
return|return;
name|int
name|pendingSignals
init|=
operator|(
name|int
operator|)
name|pendingDownloadDataEmissions
operator|->
name|fetchAndAddAcquire
argument_list|(
operator|-
literal|1
argument_list|)
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|pendingSignals
operator|>
literal|0
condition|)
block|{
comment|// Some more signal emissions to this slot are pending.
comment|// Instead of writing the downstream data, we wait
comment|// and do it in the next call we get
comment|// (signal comppression)
name|pendingDownloadData
operator|.
name|append
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return;
block|}
name|pendingDownloadData
operator|.
name|append
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|d
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// We need to usa a copy for calling writeDownstreamData as we could
comment|// possibly recurse into this this function when we call
comment|// appendDownstreamDataSignalEmissions because the user might call
comment|// processEvents() or spin an event loop when this occur.
name|QByteDataBuffer
name|pendingDownloadDataCopy
init|=
name|pendingDownloadData
decl_stmt|;
name|pendingDownloadData
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|cacheEnabled
operator|&&
name|isCachingAllowed
argument_list|()
operator|&&
operator|!
name|cacheSaveDevice
condition|)
block|{
name|initCacheSaveDevice
argument_list|()
expr_stmt|;
block|}
name|qint64
name|bytesWritten
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|pendingDownloadDataCopy
operator|.
name|bufferCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|QByteArray
specifier|const
modifier|&
name|item
init|=
name|pendingDownloadDataCopy
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|cacheSaveDevice
condition|)
name|cacheSaveDevice
operator|->
name|write
argument_list|(
name|item
operator|.
name|constData
argument_list|()
argument_list|,
name|item
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|downloadMultiBuffer
operator|.
name|append
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|bytesWritten
operator|+=
name|item
operator|.
name|size
argument_list|()
expr_stmt|;
block|}
name|pendingDownloadDataCopy
operator|.
name|clear
argument_list|()
expr_stmt|;
name|bytesDownloaded
operator|+=
name|bytesWritten
expr_stmt|;
name|QVariant
name|totalSize
init|=
name|cookedHeaders
operator|.
name|value
argument_list|(
name|QNetworkRequest
operator|::
name|ContentLengthHeader
argument_list|)
decl_stmt|;
if|if
condition|(
name|preMigrationDownloaded
operator|!=
name|Q_INT64_C
argument_list|(
operator|-
literal|1
argument_list|)
condition|)
name|totalSize
operator|=
name|totalSize
operator|.
name|toLongLong
argument_list|()
operator|+
name|preMigrationDownloaded
expr_stmt|;
emit|emit
name|q
operator|->
name|readyRead
argument_list|()
emit|;
comment|// emit readyRead before downloadProgress incase this will cause events to be
comment|// processed and we get into a recursive call (as in QProgressDialog).
if|if
condition|(
name|downloadProgressSignalChoke
operator|.
name|elapsed
argument_list|()
operator|>=
name|progressSignalInterval
condition|)
block|{
name|downloadProgressSignalChoke
operator|.
name|restart
argument_list|()
expr_stmt|;
emit|emit
name|q
operator|->
name|downloadProgress
argument_list|(
name|bytesDownloaded
argument_list|,
name|totalSize
operator|.
name|isNull
argument_list|()
condition|?
name|Q_INT64_C
argument_list|(
operator|-
literal|1
argument_list|)
else|:
name|totalSize
operator|.
name|toLongLong
argument_list|()
argument_list|)
emit|;
block|}
block|}
end_function
begin_function
DECL|function|replyFinished
name|void
name|QNetworkReplyHttpImplPrivate
operator|::
name|replyFinished
parameter_list|()
block|{
comment|// We are already loading from cache, we still however
comment|// got this signal because it was posted already
if|if
condition|(
name|loadingFromCache
condition|)
return|return;
name|finished
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|checkForRedirect
name|void
name|QNetworkReplyHttpImplPrivate
operator|::
name|checkForRedirect
parameter_list|(
specifier|const
name|int
name|statusCode
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QNetworkReplyHttpImpl
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|statusCode
condition|)
block|{
case|case
literal|301
case|:
comment|// Moved Permanently
case|case
literal|302
case|:
comment|// Found
case|case
literal|303
case|:
comment|// See Other
case|case
literal|307
case|:
comment|// Temporary Redirect
comment|// What do we do about the caching of the HTML note?
comment|// The response to a 303 MUST NOT be cached, while the response to
comment|// all of the others is cacheable if the headers indicate it to be
name|QByteArray
name|header
init|=
name|q
operator|->
name|rawHeader
argument_list|(
literal|"location"
argument_list|)
decl_stmt|;
name|QUrl
name|url
init|=
name|QUrl
argument_list|(
name|QString
operator|::
name|fromUtf8
argument_list|(
name|header
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|url
operator|.
name|isValid
argument_list|()
condition|)
name|url
operator|=
name|QUrl
argument_list|(
name|QLatin1String
argument_list|(
name|header
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|->
name|setAttribute
argument_list|(
name|QNetworkRequest
operator|::
name|RedirectionTargetAttribute
argument_list|,
name|url
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|replyDownloadMetaData
name|void
name|QNetworkReplyHttpImplPrivate
operator|::
name|replyDownloadMetaData
parameter_list|(
name|QList
argument_list|<
name|QPair
argument_list|<
name|QByteArray
argument_list|,
name|QByteArray
argument_list|>
argument_list|>
name|hm
parameter_list|,
name|int
name|sc
parameter_list|,
name|QString
name|rp
parameter_list|,
name|bool
name|pu
parameter_list|,
name|QSharedPointer
argument_list|<
name|char
argument_list|>
name|db
parameter_list|,
name|qint64
name|contentLength
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QNetworkReplyHttpImpl
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|contentLength
argument_list|)
expr_stmt|;
name|statusCode
operator|=
name|sc
expr_stmt|;
name|reasonPhrase
operator|=
name|rp
expr_stmt|;
comment|// Download buffer
if|if
condition|(
operator|!
name|db
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|downloadBufferPointer
operator|=
name|db
expr_stmt|;
name|downloadZerocopyBuffer
operator|=
name|downloadBufferPointer
operator|.
name|data
argument_list|()
expr_stmt|;
name|downloadBufferCurrentSize
operator|=
literal|0
expr_stmt|;
name|q
operator|->
name|setAttribute
argument_list|(
name|QNetworkRequest
operator|::
name|DownloadBufferAttribute
argument_list|,
name|QVariant
operator|::
name|fromValue
argument_list|<
name|QSharedPointer
argument_list|<
name|char
argument_list|>
argument_list|>
argument_list|(
name|downloadBufferPointer
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|q
operator|->
name|setAttribute
argument_list|(
name|QNetworkRequest
operator|::
name|HttpPipeliningWasUsedAttribute
argument_list|,
name|pu
argument_list|)
expr_stmt|;
comment|// reconstruct the HTTP header
name|QList
argument_list|<
name|QPair
argument_list|<
name|QByteArray
argument_list|,
name|QByteArray
argument_list|>
argument_list|>
name|headerMap
init|=
name|hm
decl_stmt|;
name|QList
argument_list|<
name|QPair
argument_list|<
name|QByteArray
argument_list|,
name|QByteArray
argument_list|>
argument_list|>
operator|::
name|ConstIterator
name|it
init|=
name|headerMap
operator|.
name|constBegin
argument_list|()
decl_stmt|,
name|end
init|=
name|headerMap
operator|.
name|constEnd
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|end
condition|;
operator|++
name|it
control|)
block|{
name|QByteArray
name|value
init|=
name|q
operator|->
name|rawHeader
argument_list|(
name|it
operator|->
name|first
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|value
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|if
condition|(
name|qstricmp
argument_list|(
name|it
operator|->
name|first
operator|.
name|constData
argument_list|()
argument_list|,
literal|"set-cookie"
argument_list|)
operator|==
literal|0
condition|)
name|value
operator|+=
literal|'\n'
expr_stmt|;
else|else
name|value
operator|+=
literal|", "
expr_stmt|;
block|}
name|value
operator|+=
name|it
operator|->
name|second
expr_stmt|;
name|q
operator|->
name|setRawHeader
argument_list|(
name|it
operator|->
name|first
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
name|q
operator|->
name|setAttribute
argument_list|(
name|QNetworkRequest
operator|::
name|HttpStatusCodeAttribute
argument_list|,
name|statusCode
argument_list|)
expr_stmt|;
name|q
operator|->
name|setAttribute
argument_list|(
name|QNetworkRequest
operator|::
name|HttpReasonPhraseAttribute
argument_list|,
name|reasonPhrase
argument_list|)
expr_stmt|;
comment|// is it a redirection?
name|checkForRedirect
argument_list|(
name|statusCode
argument_list|)
expr_stmt|;
if|if
condition|(
name|statusCode
operator|>=
literal|500
operator|&&
name|statusCode
operator|<
literal|600
condition|)
block|{
name|QAbstractNetworkCache
modifier|*
name|nc
init|=
name|managerPrivate
operator|->
name|networkCache
decl_stmt|;
if|if
condition|(
name|nc
condition|)
block|{
name|QNetworkCacheMetaData
name|metaData
init|=
name|nc
operator|->
name|metaData
argument_list|(
name|request
operator|.
name|url
argument_list|()
argument_list|)
decl_stmt|;
name|QNetworkHeadersPrivate
name|cacheHeaders
decl_stmt|;
name|cacheHeaders
operator|.
name|setAllRawHeaders
argument_list|(
name|metaData
operator|.
name|rawHeaders
argument_list|()
argument_list|)
expr_stmt|;
name|QNetworkHeadersPrivate
operator|::
name|RawHeadersList
operator|::
name|ConstIterator
name|it
decl_stmt|;
name|it
operator|=
name|cacheHeaders
operator|.
name|findRawHeader
argument_list|(
literal|"Cache-Control"
argument_list|)
expr_stmt|;
name|bool
name|mustReValidate
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|it
operator|!=
name|cacheHeaders
operator|.
name|rawHeaders
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|QHash
argument_list|<
name|QByteArray
argument_list|,
name|QByteArray
argument_list|>
name|cacheControl
init|=
name|parseHttpOptionHeader
argument_list|(
name|it
operator|->
name|second
argument_list|)
decl_stmt|;
if|if
condition|(
name|cacheControl
operator|.
name|contains
argument_list|(
literal|"must-revalidate"
argument_list|)
condition|)
name|mustReValidate
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|mustReValidate
operator|&&
name|sendCacheContents
argument_list|(
name|metaData
argument_list|)
condition|)
return|return;
block|}
block|}
if|if
condition|(
name|statusCode
operator|==
literal|304
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|QNETWORKACCESSHTTPBACKEND_DEBUG
argument_list|)
name|qDebug
argument_list|()
operator|<<
literal|"Received a 304 from"
operator|<<
name|url
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|QAbstractNetworkCache
modifier|*
name|nc
init|=
name|managerPrivate
operator|->
name|networkCache
decl_stmt|;
if|if
condition|(
name|nc
condition|)
block|{
name|QNetworkCacheMetaData
name|oldMetaData
init|=
name|nc
operator|->
name|metaData
argument_list|(
name|request
operator|.
name|url
argument_list|()
argument_list|)
decl_stmt|;
name|QNetworkCacheMetaData
name|metaData
init|=
name|fetchCacheMetaData
argument_list|(
name|oldMetaData
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldMetaData
operator|!=
name|metaData
condition|)
name|nc
operator|->
name|updateMetaData
argument_list|(
name|metaData
argument_list|)
expr_stmt|;
if|if
condition|(
name|sendCacheContents
argument_list|(
name|metaData
argument_list|)
condition|)
return|return;
block|}
block|}
if|if
condition|(
name|statusCode
operator|!=
literal|304
operator|&&
name|statusCode
operator|!=
literal|303
condition|)
block|{
if|if
condition|(
operator|!
name|isCachingEnabled
argument_list|()
condition|)
name|setCachingEnabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
name|metaDataChanged
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|replyDownloadProgressSlot
name|void
name|QNetworkReplyHttpImplPrivate
operator|::
name|replyDownloadProgressSlot
parameter_list|(
name|qint64
name|bytesReceived
parameter_list|,
name|qint64
name|bytesTotal
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QNetworkReplyHttpImpl
argument_list|)
expr_stmt|;
comment|// If we're closed just ignore this data
if|if
condition|(
operator|!
name|q
operator|->
name|isOpen
argument_list|()
condition|)
return|return;
comment|// we can be sure here that there is a download buffer
name|int
name|pendingSignals
init|=
operator|(
name|int
operator|)
name|pendingDownloadProgressEmissions
operator|->
name|fetchAndAddAcquire
argument_list|(
operator|-
literal|1
argument_list|)
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|pendingSignals
operator|>
literal|0
condition|)
block|{
comment|// Let's ignore this signal and look at the next one coming in
comment|// (signal comppression)
return|return;
block|}
if|if
condition|(
operator|!
name|q
operator|->
name|isOpen
argument_list|()
condition|)
return|return;
if|if
condition|(
name|cacheEnabled
operator|&&
name|isCachingAllowed
argument_list|()
operator|&&
name|bytesReceived
operator|==
name|bytesTotal
condition|)
block|{
comment|// Write everything in one go if we use a download buffer. might be more performant.
name|initCacheSaveDevice
argument_list|()
expr_stmt|;
comment|// need to check again if cache enabled and device exists
if|if
condition|(
name|cacheSaveDevice
operator|&&
name|cacheEnabled
condition|)
name|cacheSaveDevice
operator|->
name|write
argument_list|(
name|downloadZerocopyBuffer
argument_list|,
name|bytesTotal
argument_list|)
expr_stmt|;
comment|// FIXME where is it closed?
block|}
name|bytesDownloaded
operator|=
name|bytesReceived
expr_stmt|;
name|downloadBufferCurrentSize
operator|=
name|bytesReceived
expr_stmt|;
comment|// Only emit readyRead when actual data is there
comment|// emit readyRead before downloadProgress incase this will cause events to be
comment|// processed and we get into a recursive call (as in QProgressDialog).
if|if
condition|(
name|bytesDownloaded
operator|>
literal|0
condition|)
emit|emit
name|q
operator|->
name|readyRead
argument_list|()
emit|;
if|if
condition|(
name|downloadProgressSignalChoke
operator|.
name|elapsed
argument_list|()
operator|>=
name|progressSignalInterval
condition|)
block|{
name|downloadProgressSignalChoke
operator|.
name|restart
argument_list|()
expr_stmt|;
emit|emit
name|q
operator|->
name|downloadProgress
argument_list|(
name|bytesDownloaded
argument_list|,
name|bytesTotal
argument_list|)
emit|;
block|}
block|}
end_function
begin_function
DECL|function|httpAuthenticationRequired
name|void
name|QNetworkReplyHttpImplPrivate
operator|::
name|httpAuthenticationRequired
parameter_list|(
specifier|const
name|QHttpNetworkRequest
modifier|&
name|request
parameter_list|,
name|QAuthenticator
modifier|*
name|auth
parameter_list|)
block|{
name|managerPrivate
operator|->
name|authenticationRequired
argument_list|(
name|auth
argument_list|,
name|q_func
argument_list|()
argument_list|,
name|synchronous
argument_list|,
name|url
argument_list|,
operator|&
name|urlForLastAuthentication
argument_list|,
name|request
operator|.
name|withCredentials
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
end_ifndef
begin_function
DECL|function|proxyAuthenticationRequired
name|void
name|QNetworkReplyHttpImplPrivate
operator|::
name|proxyAuthenticationRequired
parameter_list|(
specifier|const
name|QNetworkProxy
modifier|&
name|proxy
parameter_list|,
name|QAuthenticator
modifier|*
name|authenticator
parameter_list|)
block|{
name|managerPrivate
operator|->
name|proxyAuthenticationRequired
argument_list|(
name|proxy
argument_list|,
name|synchronous
argument_list|,
name|authenticator
argument_list|,
operator|&
name|lastProxyAuthentication
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|httpError
name|void
name|QNetworkReplyHttpImplPrivate
operator|::
name|httpError
parameter_list|(
name|QNetworkReply
operator|::
name|NetworkError
name|errorCode
parameter_list|,
specifier|const
name|QString
modifier|&
name|errorString
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|QNETWORKACCESSHTTPBACKEND_DEBUG
argument_list|)
name|qDebug
argument_list|()
operator|<<
literal|"http error!"
operator|<<
name|errorCode
operator|<<
name|errorString
expr_stmt|;
endif|#
directive|endif
comment|// FIXME?
name|error
argument_list|(
name|errorCode
argument_list|,
name|errorString
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_SSL
end_ifndef
begin_function
DECL|function|replyEncrypted
name|void
name|QNetworkReplyHttpImplPrivate
operator|::
name|replyEncrypted
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QNetworkReplyHttpImpl
argument_list|)
expr_stmt|;
emit|emit
name|q
operator|->
name|encrypted
argument_list|()
emit|;
block|}
end_function
begin_function
DECL|function|replySslErrors
name|void
name|QNetworkReplyHttpImplPrivate
operator|::
name|replySslErrors
parameter_list|(
specifier|const
name|QList
argument_list|<
name|QSslError
argument_list|>
modifier|&
name|list
parameter_list|,
name|bool
modifier|*
name|ignoreAll
parameter_list|,
name|QList
argument_list|<
name|QSslError
argument_list|>
modifier|*
name|toBeIgnored
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QNetworkReplyHttpImpl
argument_list|)
expr_stmt|;
emit|emit
name|q
operator|->
name|sslErrors
argument_list|(
name|list
argument_list|)
emit|;
comment|// Check if the callback set any ignore and return this here to http thread
if|if
condition|(
name|pendingIgnoreAllSslErrors
condition|)
operator|*
name|ignoreAll
operator|=
literal|true
expr_stmt|;
if|if
condition|(
operator|!
name|pendingIgnoreSslErrorsList
operator|.
name|isEmpty
argument_list|()
condition|)
operator|*
name|toBeIgnored
operator|=
name|pendingIgnoreSslErrorsList
expr_stmt|;
block|}
end_function
begin_function
DECL|function|replySslConfigurationChanged
name|void
name|QNetworkReplyHttpImplPrivate
operator|::
name|replySslConfigurationChanged
parameter_list|(
specifier|const
name|QSslConfiguration
modifier|&
name|sslConfiguration
parameter_list|)
block|{
comment|// Receiving the used SSL configuration from the HTTP thread
name|this
operator|->
name|sslConfiguration
operator|=
name|sslConfiguration
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// Coming from QNonContiguousByteDeviceThreadForwardImpl in HTTP thread
end_comment
begin_function
DECL|function|resetUploadDataSlot
name|void
name|QNetworkReplyHttpImplPrivate
operator|::
name|resetUploadDataSlot
parameter_list|(
name|bool
modifier|*
name|r
parameter_list|)
block|{
operator|*
name|r
operator|=
name|uploadByteDevice
operator|->
name|reset
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|// Coming from QNonContiguousByteDeviceThreadForwardImpl in HTTP thread
end_comment
begin_function
DECL|function|sentUploadDataSlot
name|void
name|QNetworkReplyHttpImplPrivate
operator|::
name|sentUploadDataSlot
parameter_list|(
name|qint64
name|amount
parameter_list|)
block|{
name|uploadByteDevice
operator|->
name|advanceReadPointer
argument_list|(
name|amount
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|// Coming from QNonContiguousByteDeviceThreadForwardImpl in HTTP thread
end_comment
begin_function
DECL|function|wantUploadDataSlot
name|void
name|QNetworkReplyHttpImplPrivate
operator|::
name|wantUploadDataSlot
parameter_list|(
name|qint64
name|maxSize
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QNetworkReplyHttpImpl
argument_list|)
expr_stmt|;
comment|// call readPointer
name|qint64
name|currentUploadDataLength
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|data
init|=
cast|const_cast
argument_list|<
name|char
operator|*
argument_list|>
argument_list|(
name|uploadByteDevice
operator|->
name|readPointer
argument_list|(
name|maxSize
argument_list|,
name|currentUploadDataLength
argument_list|)
argument_list|)
decl_stmt|;
comment|// Let's make a copy of this data
name|QByteArray
name|dataArray
argument_list|(
name|data
argument_list|,
name|currentUploadDataLength
argument_list|)
decl_stmt|;
comment|// Communicate back to HTTP thread
emit|emit
name|q
operator|->
name|haveUploadData
argument_list|(
name|dataArray
argument_list|,
name|uploadByteDevice
operator|->
name|atEnd
argument_list|()
argument_list|,
name|uploadByteDevice
operator|->
name|size
argument_list|()
argument_list|)
emit|;
block|}
end_function
begin_comment
comment|/*     A simple web page that can be used to test us: http://www.procata.com/cachetest/  */
end_comment
begin_function
DECL|function|sendCacheContents
name|bool
name|QNetworkReplyHttpImplPrivate
operator|::
name|sendCacheContents
parameter_list|(
specifier|const
name|QNetworkCacheMetaData
modifier|&
name|metaData
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QNetworkReplyHttpImpl
argument_list|)
expr_stmt|;
name|setCachingEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|metaData
operator|.
name|isValid
argument_list|()
condition|)
return|return
literal|false
return|;
name|QAbstractNetworkCache
modifier|*
name|nc
init|=
name|managerPrivate
operator|->
name|networkCache
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|nc
argument_list|)
expr_stmt|;
name|QIODevice
modifier|*
name|contents
init|=
name|nc
operator|->
name|data
argument_list|(
name|url
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|contents
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|QNETWORKACCESSHTTPBACKEND_DEBUG
argument_list|)
name|qDebug
argument_list|()
operator|<<
literal|"Can not send cache, the contents are 0"
operator|<<
name|url
expr_stmt|;
endif|#
directive|endif
return|return
literal|false
return|;
block|}
name|contents
operator|->
name|setParent
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|QNetworkCacheMetaData
operator|::
name|AttributesMap
name|attributes
init|=
name|metaData
operator|.
name|attributes
argument_list|()
decl_stmt|;
name|int
name|status
init|=
name|attributes
operator|.
name|value
argument_list|(
name|QNetworkRequest
operator|::
name|HttpStatusCodeAttribute
argument_list|)
operator|.
name|toInt
argument_list|()
decl_stmt|;
if|if
condition|(
name|status
operator|<
literal|100
condition|)
name|status
operator|=
literal|200
expr_stmt|;
comment|// fake it
name|q
operator|->
name|setAttribute
argument_list|(
name|QNetworkRequest
operator|::
name|HttpStatusCodeAttribute
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|q
operator|->
name|setAttribute
argument_list|(
name|QNetworkRequest
operator|::
name|HttpReasonPhraseAttribute
argument_list|,
name|attributes
operator|.
name|value
argument_list|(
name|QNetworkRequest
operator|::
name|HttpReasonPhraseAttribute
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|->
name|setAttribute
argument_list|(
name|QNetworkRequest
operator|::
name|SourceIsFromCacheAttribute
argument_list|,
literal|true
argument_list|)
expr_stmt|;
name|QNetworkCacheMetaData
operator|::
name|RawHeaderList
name|rawHeaders
init|=
name|metaData
operator|.
name|rawHeaders
argument_list|()
decl_stmt|;
name|QNetworkCacheMetaData
operator|::
name|RawHeaderList
operator|::
name|ConstIterator
name|it
init|=
name|rawHeaders
operator|.
name|constBegin
argument_list|()
decl_stmt|,
name|end
init|=
name|rawHeaders
operator|.
name|constEnd
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|end
condition|;
operator|++
name|it
control|)
name|setRawHeader
argument_list|(
name|it
operator|->
name|first
argument_list|,
name|it
operator|->
name|second
argument_list|)
expr_stmt|;
name|checkForRedirect
argument_list|(
name|status
argument_list|)
expr_stmt|;
name|cacheLoadDevice
operator|=
name|contents
expr_stmt|;
name|q
operator|->
name|connect
argument_list|(
name|cacheLoadDevice
argument_list|,
name|SIGNAL
argument_list|(
name|readyRead
argument_list|()
argument_list|)
argument_list|,
name|SLOT
argument_list|(
name|_q_cacheLoadReadyRead
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|->
name|connect
argument_list|(
name|cacheLoadDevice
argument_list|,
name|SIGNAL
argument_list|(
name|readChannelFinished
argument_list|()
argument_list|)
argument_list|,
name|SLOT
argument_list|(
name|_q_cacheLoadReadyRead
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// This needs to be emitted in the event loop because it can be reached at
comment|// the direct code path of qnam.get(...) before the user has a chance
comment|// to connect any signals.
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|q
argument_list|,
literal|"metaDataChanged"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|q
argument_list|,
literal|"_q_cacheLoadReadyRead"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QNETWORKACCESSHTTPBACKEND_DEBUG
argument_list|)
name|qDebug
argument_list|()
operator|<<
literal|"Successfully sent cache:"
operator|<<
name|url
operator|<<
name|contents
operator|->
name|size
argument_list|()
operator|<<
literal|"bytes"
expr_stmt|;
endif|#
directive|endif
comment|// Set the following flag so we can ignore some signals from HTTP thread
comment|// that would still come
name|loadingFromCache
operator|=
literal|true
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|fetchCacheMetaData
name|QNetworkCacheMetaData
name|QNetworkReplyHttpImplPrivate
operator|::
name|fetchCacheMetaData
parameter_list|(
specifier|const
name|QNetworkCacheMetaData
modifier|&
name|oldMetaData
parameter_list|)
specifier|const
block|{
name|Q_Q
argument_list|(
specifier|const
name|QNetworkReplyHttpImpl
argument_list|)
expr_stmt|;
name|QNetworkCacheMetaData
name|metaData
init|=
name|oldMetaData
decl_stmt|;
name|QNetworkHeadersPrivate
name|cacheHeaders
decl_stmt|;
name|cacheHeaders
operator|.
name|setAllRawHeaders
argument_list|(
name|metaData
operator|.
name|rawHeaders
argument_list|()
argument_list|)
expr_stmt|;
name|QNetworkHeadersPrivate
operator|::
name|RawHeadersList
operator|::
name|ConstIterator
name|it
decl_stmt|;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|newHeaders
init|=
name|q
operator|->
name|rawHeaderList
argument_list|()
decl_stmt|;
foreach|foreach
control|(
name|QByteArray
name|header
decl|,
name|newHeaders
control|)
block|{
name|QByteArray
name|originalHeader
init|=
name|header
decl_stmt|;
name|header
operator|=
name|header
operator|.
name|toLower
argument_list|()
expr_stmt|;
name|bool
name|hop_by_hop
init|=
operator|(
name|header
operator|==
literal|"connection"
operator|||
name|header
operator|==
literal|"keep-alive"
operator|||
name|header
operator|==
literal|"proxy-authenticate"
operator|||
name|header
operator|==
literal|"proxy-authorization"
operator|||
name|header
operator|==
literal|"te"
operator|||
name|header
operator|==
literal|"trailers"
operator|||
name|header
operator|==
literal|"transfer-encoding"
operator|||
name|header
operator|==
literal|"upgrade"
operator|)
decl_stmt|;
if|if
condition|(
name|hop_by_hop
condition|)
continue|continue;
comment|// for 4.6.0, we were planning to not store the date header in the
comment|// cached resource; through that we planned to reduce the number
comment|// of writes to disk when using a QNetworkDiskCache (i.e. don't
comment|// write to disk when only the date changes).
comment|// However, without the date we cannot calculate the age of the page
comment|// anymore.
comment|//if (header == "date")
comment|//continue;
comment|// Don't store Warning 1xx headers
if|if
condition|(
name|header
operator|==
literal|"warning"
condition|)
block|{
name|QByteArray
name|v
init|=
name|q
operator|->
name|rawHeader
argument_list|(
name|header
argument_list|)
decl_stmt|;
if|if
condition|(
name|v
operator|.
name|length
argument_list|()
operator|==
literal|3
operator|&&
name|v
index|[
literal|0
index|]
operator|==
literal|'1'
operator|&&
name|v
index|[
literal|1
index|]
operator|>=
literal|'0'
operator|&&
name|v
index|[
literal|1
index|]
operator|<=
literal|'9'
operator|&&
name|v
index|[
literal|2
index|]
operator|>=
literal|'0'
operator|&&
name|v
index|[
literal|2
index|]
operator|<=
literal|'9'
condition|)
continue|continue;
block|}
name|it
operator|=
name|cacheHeaders
operator|.
name|findRawHeader
argument_list|(
name|header
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|!=
name|cacheHeaders
operator|.
name|rawHeaders
operator|.
name|constEnd
argument_list|()
condition|)
block|{
comment|// Match the behavior of Firefox and assume Cache-Control: "no-transform"
if|if
condition|(
name|header
operator|==
literal|"content-encoding"
operator|||
name|header
operator|==
literal|"content-range"
operator|||
name|header
operator|==
literal|"content-type"
condition|)
continue|continue;
comment|// For MS servers that send "Content-Length: 0" on 304 responses
comment|// ignore this too
if|if
condition|(
name|header
operator|==
literal|"content-length"
condition|)
continue|continue;
block|}
if|#
directive|if
name|defined
argument_list|(
name|QNETWORKACCESSHTTPBACKEND_DEBUG
argument_list|)
name|QByteArray
name|n
init|=
name|rawHeader
argument_list|(
name|header
argument_list|)
decl_stmt|;
name|QByteArray
name|o
decl_stmt|;
if|if
condition|(
name|it
operator|!=
name|cacheHeaders
operator|.
name|rawHeaders
operator|.
name|constEnd
argument_list|()
condition|)
name|o
operator|=
operator|(
operator|*
name|it
operator|)
operator|.
name|second
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|o
operator|&&
name|header
operator|!=
literal|"date"
condition|)
block|{
name|qDebug
argument_list|()
operator|<<
literal|"replacing"
operator|<<
name|header
expr_stmt|;
name|qDebug
argument_list|()
operator|<<
literal|"new"
operator|<<
name|n
expr_stmt|;
name|qDebug
argument_list|()
operator|<<
literal|"old"
operator|<<
name|o
expr_stmt|;
block|}
endif|#
directive|endif
name|cacheHeaders
operator|.
name|setRawHeader
argument_list|(
name|originalHeader
argument_list|,
name|q
operator|->
name|rawHeader
argument_list|(
name|header
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|metaData
operator|.
name|setRawHeaders
argument_list|(
name|cacheHeaders
operator|.
name|rawHeaders
argument_list|)
expr_stmt|;
name|bool
name|checkExpired
init|=
literal|true
decl_stmt|;
name|QHash
argument_list|<
name|QByteArray
argument_list|,
name|QByteArray
argument_list|>
name|cacheControl
decl_stmt|;
name|it
operator|=
name|cacheHeaders
operator|.
name|findRawHeader
argument_list|(
literal|"Cache-Control"
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|!=
name|cacheHeaders
operator|.
name|rawHeaders
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|cacheControl
operator|=
name|parseHttpOptionHeader
argument_list|(
name|it
operator|->
name|second
argument_list|)
expr_stmt|;
name|QByteArray
name|maxAge
init|=
name|cacheControl
operator|.
name|value
argument_list|(
literal|"max-age"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|maxAge
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|checkExpired
operator|=
literal|false
expr_stmt|;
name|QDateTime
name|dt
init|=
name|QDateTime
operator|::
name|currentDateTime
argument_list|()
decl_stmt|;
name|dt
operator|=
name|dt
operator|.
name|addSecs
argument_list|(
name|maxAge
operator|.
name|toInt
argument_list|()
argument_list|)
expr_stmt|;
name|metaData
operator|.
name|setExpirationDate
argument_list|(
name|dt
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|checkExpired
condition|)
block|{
name|it
operator|=
name|cacheHeaders
operator|.
name|findRawHeader
argument_list|(
literal|"expires"
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|!=
name|cacheHeaders
operator|.
name|rawHeaders
operator|.
name|constEnd
argument_list|()
condition|)
block|{
name|QDateTime
name|expiredDateTime
init|=
name|QNetworkHeadersPrivate
operator|::
name|fromHttpDate
argument_list|(
name|it
operator|->
name|second
argument_list|)
decl_stmt|;
name|metaData
operator|.
name|setExpirationDate
argument_list|(
name|expiredDateTime
argument_list|)
expr_stmt|;
block|}
block|}
name|it
operator|=
name|cacheHeaders
operator|.
name|findRawHeader
argument_list|(
literal|"last-modified"
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|!=
name|cacheHeaders
operator|.
name|rawHeaders
operator|.
name|constEnd
argument_list|()
condition|)
name|metaData
operator|.
name|setLastModified
argument_list|(
name|QNetworkHeadersPrivate
operator|::
name|fromHttpDate
argument_list|(
name|it
operator|->
name|second
argument_list|)
argument_list|)
expr_stmt|;
name|bool
name|canDiskCache
decl_stmt|;
comment|// only cache GET replies by default, all other replies (POST, PUT, DELETE)
comment|//  are not cacheable by default (according to RFC 2616 section 9)
if|if
condition|(
name|httpRequest
operator|.
name|operation
argument_list|()
operator|==
name|QHttpNetworkRequest
operator|::
name|Get
condition|)
block|{
name|canDiskCache
operator|=
literal|true
expr_stmt|;
comment|// 14.32
comment|// HTTP/1.1 caches SHOULD treat "Pragma: no-cache" as if the client
comment|// had sent "Cache-Control: no-cache".
name|it
operator|=
name|cacheHeaders
operator|.
name|findRawHeader
argument_list|(
literal|"pragma"
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|!=
name|cacheHeaders
operator|.
name|rawHeaders
operator|.
name|constEnd
argument_list|()
operator|&&
name|it
operator|->
name|second
operator|==
literal|"no-cache"
condition|)
name|canDiskCache
operator|=
literal|false
expr_stmt|;
comment|// HTTP/1.1. Check the Cache-Control header
if|if
condition|(
name|cacheControl
operator|.
name|contains
argument_list|(
literal|"no-cache"
argument_list|)
condition|)
name|canDiskCache
operator|=
literal|false
expr_stmt|;
elseif|else
if|if
condition|(
name|cacheControl
operator|.
name|contains
argument_list|(
literal|"no-store"
argument_list|)
condition|)
name|canDiskCache
operator|=
literal|false
expr_stmt|;
comment|// responses to POST might be cacheable
block|}
elseif|else
if|if
condition|(
name|httpRequest
operator|.
name|operation
argument_list|()
operator|==
name|QHttpNetworkRequest
operator|::
name|Post
condition|)
block|{
name|canDiskCache
operator|=
literal|false
expr_stmt|;
comment|// some pages contain "expires:" and "cache-control: no-cache" field,
comment|// so we only might cache POST requests if we get "cache-control: max-age ..."
if|if
condition|(
name|cacheControl
operator|.
name|contains
argument_list|(
literal|"max-age"
argument_list|)
condition|)
name|canDiskCache
operator|=
literal|true
expr_stmt|;
comment|// responses to PUT and DELETE are not cacheable
block|}
else|else
block|{
name|canDiskCache
operator|=
literal|false
expr_stmt|;
block|}
name|metaData
operator|.
name|setSaveToDisk
argument_list|(
name|canDiskCache
argument_list|)
expr_stmt|;
name|QNetworkCacheMetaData
operator|::
name|AttributesMap
name|attributes
decl_stmt|;
if|if
condition|(
name|statusCode
operator|!=
literal|304
condition|)
block|{
comment|// update the status code
name|attributes
operator|.
name|insert
argument_list|(
name|QNetworkRequest
operator|::
name|HttpStatusCodeAttribute
argument_list|,
name|statusCode
argument_list|)
expr_stmt|;
name|attributes
operator|.
name|insert
argument_list|(
name|QNetworkRequest
operator|::
name|HttpReasonPhraseAttribute
argument_list|,
name|reasonPhrase
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// this is a redirection, keep the attributes intact
name|attributes
operator|=
name|oldMetaData
operator|.
name|attributes
argument_list|()
expr_stmt|;
block|}
name|metaData
operator|.
name|setAttributes
argument_list|(
name|attributes
argument_list|)
expr_stmt|;
return|return
name|metaData
return|;
block|}
end_function
begin_function
DECL|function|canResume
name|bool
name|QNetworkReplyHttpImplPrivate
operator|::
name|canResume
parameter_list|()
specifier|const
block|{
name|Q_Q
argument_list|(
specifier|const
name|QNetworkReplyHttpImpl
argument_list|)
expr_stmt|;
comment|// Only GET operation supports resuming.
if|if
condition|(
name|operation
operator|!=
name|QNetworkAccessManager
operator|::
name|GetOperation
condition|)
return|return
literal|false
return|;
comment|// Can only resume if server/resource supports Range header.
name|QByteArray
name|acceptRangesheaderName
argument_list|(
literal|"Accept-Ranges"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|q
operator|->
name|hasRawHeader
argument_list|(
name|acceptRangesheaderName
argument_list|)
operator|||
name|q
operator|->
name|rawHeader
argument_list|(
name|acceptRangesheaderName
argument_list|)
operator|==
literal|"none"
condition|)
return|return
literal|false
return|;
comment|// We only support resuming for byte ranges.
if|if
condition|(
name|request
operator|.
name|hasRawHeader
argument_list|(
literal|"Range"
argument_list|)
condition|)
block|{
name|QByteArray
name|range
init|=
name|request
operator|.
name|rawHeader
argument_list|(
literal|"Range"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|range
operator|.
name|startsWith
argument_list|(
literal|"bytes="
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
comment|// If we're using a download buffer then we don't support resuming/migration
comment|// right now. Too much trouble.
if|if
condition|(
name|downloadZerocopyBuffer
condition|)
return|return
literal|false
return|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|setResumeOffset
name|void
name|QNetworkReplyHttpImplPrivate
operator|::
name|setResumeOffset
parameter_list|(
name|quint64
name|offset
parameter_list|)
block|{
name|resumeOffset
operator|=
name|offset
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Starts the backend.  Returns true if the backend is started.  Returns false if the backend     could not be started due to an unopened or roaming session.  The caller should recall this     function once the session has been opened or the roaming process has finished. */
end_comment
begin_function
DECL|function|start
name|bool
name|QNetworkReplyHttpImplPrivate
operator|::
name|start
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|QT_NO_BEARERMANAGEMENT
name|QSharedPointer
argument_list|<
name|QNetworkSession
argument_list|>
name|networkSession
argument_list|(
name|managerPrivate
operator|->
name|getNetworkSession
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|networkSession
condition|)
block|{
endif|#
directive|endif
name|postRequest
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
ifndef|#
directive|ifndef
name|QT_NO_BEARERMANAGEMENT
block|}
comment|// This is not ideal.
specifier|const
name|QString
name|host
init|=
name|url
operator|.
name|host
argument_list|()
decl_stmt|;
if|if
condition|(
name|host
operator|==
name|QLatin1String
argument_list|(
literal|"localhost"
argument_list|)
operator|||
name|QHostAddress
argument_list|(
name|host
argument_list|)
operator|.
name|isLoopback
argument_list|()
condition|)
block|{
comment|// Don't need an open session for localhost access.
name|postRequest
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|networkSession
operator|->
name|isOpen
argument_list|()
operator|&&
name|networkSession
operator|->
name|state
argument_list|()
operator|==
name|QNetworkSession
operator|::
name|Connected
condition|)
block|{
name|Q_Q
argument_list|(
name|QNetworkReplyHttpImpl
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|networkSession
operator|.
name|data
argument_list|()
argument_list|,
name|SIGNAL
argument_list|(
name|usagePoliciesChanged
argument_list|(
name|QNetworkSession
operator|::
name|UsagePolicies
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_networkSessionUsagePoliciesChanged
argument_list|(
name|QNetworkSession
operator|::
name|UsagePolicies
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|postRequest
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|_q_startOperation
name|void
name|QNetworkReplyHttpImplPrivate
operator|::
name|_q_startOperation
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QNetworkReplyHttpImpl
argument_list|)
expr_stmt|;
comment|// ensure this function is only being called once
if|if
condition|(
name|state
operator|==
name|Working
condition|)
block|{
name|qDebug
argument_list|(
literal|"QNetworkReplyImpl::_q_startOperation was called more than once"
argument_list|)
expr_stmt|;
return|return;
block|}
name|state
operator|=
name|Working
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_BEARERMANAGEMENT
comment|// Do not start background requests if they are not allowed by session policy
name|QSharedPointer
argument_list|<
name|QNetworkSession
argument_list|>
name|session
argument_list|(
name|manager
operator|->
name|d_func
argument_list|()
operator|->
name|getNetworkSession
argument_list|()
argument_list|)
decl_stmt|;
name|QVariant
name|isBackground
init|=
name|request
operator|.
name|attribute
argument_list|(
name|QNetworkRequest
operator|::
name|BackgroundRequestAttribute
argument_list|,
name|QVariant
operator|::
name|fromValue
argument_list|(
literal|false
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|isBackground
operator|.
name|toBool
argument_list|()
operator|&&
name|session
operator|&&
name|session
operator|->
name|usagePolicies
argument_list|()
operator|.
name|testFlag
argument_list|(
name|QNetworkSession
operator|::
name|NoBackgroundTrafficPolicy
argument_list|)
condition|)
block|{
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|q
argument_list|,
literal|"_q_error"
argument_list|,
name|synchronous
condition|?
name|Qt
operator|::
name|DirectConnection
else|:
name|Qt
operator|::
name|QueuedConnection
argument_list|,
name|Q_ARG
argument_list|(
name|QNetworkReply
operator|::
name|NetworkError
argument_list|,
name|QNetworkReply
operator|::
name|BackgroundRequestNotAllowedError
argument_list|)
argument_list|,
name|Q_ARG
argument_list|(
name|QString
argument_list|,
name|QCoreApplication
operator|::
name|translate
argument_list|(
literal|"QNetworkReply"
argument_list|,
literal|"Background request not allowed."
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|q
argument_list|,
literal|"_q_finished"
argument_list|,
name|synchronous
condition|?
name|Qt
operator|::
name|DirectConnection
else|:
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|start
argument_list|()
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_BEARERMANAGEMENT
comment|// backend failed to start because the session state is not Connected.
comment|// QNetworkAccessManager will call reply->backend->start() again for us when the session
comment|// state changes.
name|state
operator|=
name|WaitingForSession
expr_stmt|;
if|if
condition|(
name|session
condition|)
block|{
name|QObject
operator|::
name|connect
argument_list|(
name|session
operator|.
name|data
argument_list|()
argument_list|,
name|SIGNAL
argument_list|(
name|error
argument_list|(
name|QNetworkSession
operator|::
name|SessionError
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_networkSessionFailed
argument_list|()
argument_list|)
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|session
operator|->
name|isOpen
argument_list|()
condition|)
block|{
name|session
operator|->
name|setSessionProperty
argument_list|(
name|QStringLiteral
argument_list|(
literal|"ConnectInBackground"
argument_list|)
argument_list|,
name|isBackground
argument_list|)
expr_stmt|;
name|session
operator|->
name|open
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|qWarning
argument_list|(
literal|"Backend is waiting for QNetworkSession to connect, but there is none!"
argument_list|)
expr_stmt|;
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|q
argument_list|,
literal|"_q_error"
argument_list|,
name|synchronous
condition|?
name|Qt
operator|::
name|DirectConnection
else|:
name|Qt
operator|::
name|QueuedConnection
argument_list|,
name|Q_ARG
argument_list|(
name|QNetworkReply
operator|::
name|NetworkError
argument_list|,
name|QNetworkReply
operator|::
name|NetworkSessionFailedError
argument_list|)
argument_list|,
name|Q_ARG
argument_list|(
name|QString
argument_list|,
name|QCoreApplication
operator|::
name|translate
argument_list|(
literal|"QNetworkReply"
argument_list|,
literal|"Network session error."
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|q
argument_list|,
literal|"_q_finished"
argument_list|,
name|synchronous
condition|?
name|Qt
operator|::
name|DirectConnection
else|:
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
return|return;
block|}
else|#
directive|else
name|qWarning
argument_list|(
literal|"Backend start failed"
argument_list|)
expr_stmt|;
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|q
argument_list|,
literal|"_q_error"
argument_list|,
name|synchronous
condition|?
name|Qt
operator|::
name|DirectConnection
else|:
name|Qt
operator|::
name|QueuedConnection
argument_list|,
name|Q_ARG
argument_list|(
name|QNetworkReply
operator|::
name|NetworkError
argument_list|,
name|QNetworkReply
operator|::
name|UnknownNetworkError
argument_list|)
argument_list|,
name|Q_ARG
argument_list|(
name|QString
argument_list|,
name|QCoreApplication
operator|::
name|translate
argument_list|(
literal|"QNetworkReply"
argument_list|,
literal|"backend start error."
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|q
argument_list|,
literal|"_q_finished"
argument_list|,
name|synchronous
condition|?
name|Qt
operator|::
name|DirectConnection
else|:
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
return|return;
endif|#
directive|endif
block|}
if|if
condition|(
name|synchronous
condition|)
block|{
name|state
operator|=
name|Finished
expr_stmt|;
name|q_func
argument_list|()
operator|->
name|setFinished
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|state
operator|!=
name|Finished
condition|)
block|{          }
block|}
block|}
end_function
begin_function
DECL|function|_q_cacheLoadReadyRead
name|void
name|QNetworkReplyHttpImplPrivate
operator|::
name|_q_cacheLoadReadyRead
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QNetworkReplyHttpImpl
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|!=
name|Working
condition|)
return|return;
if|if
condition|(
operator|!
name|cacheLoadDevice
operator|||
operator|!
name|q
operator|->
name|isOpen
argument_list|()
operator|||
operator|!
name|cacheLoadDevice
operator|->
name|bytesAvailable
argument_list|()
condition|)
return|return;
comment|// FIXME Optimize to use zerocopy download buffer if it is a QBuffer.
comment|// Needs to be done where sendCacheContents() (?) of HTTP is emitting
comment|// metaDataChanged ?
name|QVariant
name|totalSize
init|=
name|cookedHeaders
operator|.
name|value
argument_list|(
name|QNetworkRequest
operator|::
name|ContentLengthHeader
argument_list|)
decl_stmt|;
comment|// emit readyRead before downloadProgress incase this will cause events to be
comment|// processed and we get into a recursive call (as in QProgressDialog).
comment|// This readyRead() goes to the user. The user then may or may not read() anything.
emit|emit
name|q
operator|->
name|readyRead
argument_list|()
emit|;
if|if
condition|(
name|downloadProgressSignalChoke
operator|.
name|elapsed
argument_list|()
operator|>=
name|progressSignalInterval
condition|)
block|{
name|downloadProgressSignalChoke
operator|.
name|restart
argument_list|()
expr_stmt|;
emit|emit
name|q
operator|->
name|downloadProgress
argument_list|(
name|bytesDownloaded
argument_list|,
name|totalSize
operator|.
name|isNull
argument_list|()
condition|?
name|Q_INT64_C
argument_list|(
operator|-
literal|1
argument_list|)
else|:
name|totalSize
operator|.
name|toLongLong
argument_list|()
argument_list|)
emit|;
block|}
comment|// If there are still bytes available in the cacheLoadDevice then the user did not read
comment|// in response to the readyRead() signal. This means we have to load from the cacheLoadDevice
comment|// and buffer that stuff. This is needed to be able to properly emit finished() later.
while|while
condition|(
name|cacheLoadDevice
operator|->
name|bytesAvailable
argument_list|()
condition|)
block|{
name|downloadMultiBuffer
operator|.
name|append
argument_list|(
name|cacheLoadDevice
operator|->
name|readAll
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cacheLoadDevice
operator|->
name|isSequential
argument_list|()
condition|)
block|{
comment|// check if end and we can read the EOF -1
name|char
name|c
decl_stmt|;
name|qint64
name|actualCount
init|=
name|cacheLoadDevice
operator|->
name|read
argument_list|(
operator|&
name|c
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|actualCount
operator|<
literal|0
condition|)
block|{
name|cacheLoadDevice
operator|->
name|deleteLater
argument_list|()
expr_stmt|;
name|cacheLoadDevice
operator|=
literal|0
expr_stmt|;
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|q
argument_list|,
literal|"_q_finished"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|actualCount
operator|==
literal|1
condition|)
block|{
comment|// This is most probably not happening since most QIODevice returned something proper for bytesAvailable()
comment|// and had already been "emptied".
name|cacheLoadDevice
operator|->
name|ungetChar
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
operator|!
name|cacheLoadDevice
operator|->
name|isSequential
argument_list|()
operator|&&
name|cacheLoadDevice
operator|->
name|atEnd
argument_list|()
operator|)
condition|)
block|{
comment|// This codepath is in case the cache device is a QBuffer, e.g. from QNetworkDiskCache.
name|cacheLoadDevice
operator|->
name|deleteLater
argument_list|()
expr_stmt|;
name|cacheLoadDevice
operator|=
literal|0
expr_stmt|;
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|q
argument_list|,
literal|"_q_finished"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|_q_bufferOutgoingDataFinished
name|void
name|QNetworkReplyHttpImplPrivate
operator|::
name|_q_bufferOutgoingDataFinished
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QNetworkReplyHttpImpl
argument_list|)
expr_stmt|;
comment|// make sure this is only called once, ever.
comment|//_q_bufferOutgoingData may call it or the readChannelFinished emission
if|if
condition|(
name|state
operator|!=
name|Buffering
condition|)
return|return;
comment|// disconnect signals
name|QObject
operator|::
name|disconnect
argument_list|(
name|outgoingData
argument_list|,
name|SIGNAL
argument_list|(
name|readyRead
argument_list|()
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_bufferOutgoingData
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|disconnect
argument_list|(
name|outgoingData
argument_list|,
name|SIGNAL
argument_list|(
name|readChannelFinished
argument_list|()
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_bufferOutgoingDataFinished
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|// finally, start the request
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|q
argument_list|,
literal|"_q_startOperation"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|_q_bufferOutgoingData
name|void
name|QNetworkReplyHttpImplPrivate
operator|::
name|_q_bufferOutgoingData
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QNetworkReplyHttpImpl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|outgoingDataBuffer
condition|)
block|{
comment|// first call, create our buffer
name|outgoingDataBuffer
operator|=
name|QSharedPointer
argument_list|<
name|QRingBuffer
argument_list|>
argument_list|(
operator|new
name|QRingBuffer
argument_list|()
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|outgoingData
argument_list|,
name|SIGNAL
argument_list|(
name|readyRead
argument_list|()
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_bufferOutgoingData
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|outgoingData
argument_list|,
name|SIGNAL
argument_list|(
name|readChannelFinished
argument_list|()
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_bufferOutgoingDataFinished
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|qint64
name|bytesBuffered
init|=
literal|0
decl_stmt|;
name|qint64
name|bytesToBuffer
init|=
literal|0
decl_stmt|;
comment|// read data into our buffer
forever|forever
block|{
name|bytesToBuffer
operator|=
name|outgoingData
operator|->
name|bytesAvailable
argument_list|()
expr_stmt|;
comment|// unknown? just try 2 kB, this also ensures we always try to read the EOF
if|if
condition|(
name|bytesToBuffer
operator|<=
literal|0
condition|)
name|bytesToBuffer
operator|=
literal|2
operator|*
literal|1024
expr_stmt|;
name|char
modifier|*
name|dst
init|=
name|outgoingDataBuffer
operator|->
name|reserve
argument_list|(
name|bytesToBuffer
argument_list|)
decl_stmt|;
name|bytesBuffered
operator|=
name|outgoingData
operator|->
name|read
argument_list|(
name|dst
argument_list|,
name|bytesToBuffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytesBuffered
operator|==
operator|-
literal|1
condition|)
block|{
comment|// EOF has been reached.
name|outgoingDataBuffer
operator|->
name|chop
argument_list|(
name|bytesToBuffer
argument_list|)
expr_stmt|;
name|_q_bufferOutgoingDataFinished
argument_list|()
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|bytesBuffered
operator|==
literal|0
condition|)
block|{
comment|// nothing read right now, just wait until we get called again
name|outgoingDataBuffer
operator|->
name|chop
argument_list|(
name|bytesToBuffer
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|// don't break, try to read() again
name|outgoingDataBuffer
operator|->
name|chop
argument_list|(
name|bytesToBuffer
operator|-
name|bytesBuffered
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_BEARERMANAGEMENT
end_ifndef
begin_function
DECL|function|_q_networkSessionConnected
name|void
name|QNetworkReplyHttpImplPrivate
operator|::
name|_q_networkSessionConnected
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QNetworkReplyHttpImpl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|manager
condition|)
return|return;
name|QSharedPointer
argument_list|<
name|QNetworkSession
argument_list|>
name|session
init|=
name|managerPrivate
operator|->
name|getNetworkSession
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|session
condition|)
return|return;
if|if
condition|(
name|session
operator|->
name|state
argument_list|()
operator|!=
name|QNetworkSession
operator|::
name|Connected
condition|)
return|return;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|QNetworkReplyImplPrivate
operator|::
name|Buffering
case|:
case|case
name|QNetworkReplyImplPrivate
operator|::
name|Working
case|:
case|case
name|QNetworkReplyImplPrivate
operator|::
name|Reconnecting
case|:
comment|// Migrate existing downloads to new network connection.
name|migrateBackend
argument_list|()
expr_stmt|;
break|break;
case|case
name|QNetworkReplyImplPrivate
operator|::
name|WaitingForSession
case|:
comment|// Start waiting requests.
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|q
argument_list|,
literal|"_q_startOperation"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
break|break;
default|default:
empty_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|_q_networkSessionFailed
name|void
name|QNetworkReplyHttpImplPrivate
operator|::
name|_q_networkSessionFailed
parameter_list|()
block|{
comment|// Abort waiting and working replies.
if|if
condition|(
name|state
operator|==
name|WaitingForSession
operator|||
name|state
operator|==
name|Working
condition|)
block|{
name|state
operator|=
name|Working
expr_stmt|;
name|QSharedPointer
argument_list|<
name|QNetworkSession
argument_list|>
name|session
argument_list|(
name|manager
operator|->
name|d_func
argument_list|()
operator|->
name|getNetworkSession
argument_list|()
argument_list|)
decl_stmt|;
name|QString
name|errorStr
decl_stmt|;
if|if
condition|(
name|session
condition|)
name|errorStr
operator|=
name|session
operator|->
name|errorString
argument_list|()
expr_stmt|;
else|else
name|errorStr
operator|=
name|QCoreApplication
operator|::
name|translate
argument_list|(
literal|"QNetworkReply"
argument_list|,
literal|"Network session error."
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|QNetworkReplyImpl
operator|::
name|NetworkSessionFailedError
argument_list|,
name|errorStr
argument_list|)
expr_stmt|;
name|finished
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|_q_networkSessionUsagePoliciesChanged
name|void
name|QNetworkReplyHttpImplPrivate
operator|::
name|_q_networkSessionUsagePoliciesChanged
parameter_list|(
name|QNetworkSession
operator|::
name|UsagePolicies
name|newPolicies
parameter_list|)
block|{
if|if
condition|(
name|request
operator|.
name|attribute
argument_list|(
name|QNetworkRequest
operator|::
name|BackgroundRequestAttribute
argument_list|)
operator|.
name|toBool
argument_list|()
condition|)
block|{
if|if
condition|(
name|newPolicies
operator|&
name|QNetworkSession
operator|::
name|NoBackgroundTrafficPolicy
condition|)
block|{
comment|// Abort waiting and working replies.
if|if
condition|(
name|state
operator|==
name|WaitingForSession
operator|||
name|state
operator|==
name|Working
condition|)
block|{
name|state
operator|=
name|Working
expr_stmt|;
name|error
argument_list|(
name|QNetworkReply
operator|::
name|BackgroundRequestNotAllowedError
argument_list|,
name|QCoreApplication
operator|::
name|translate
argument_list|(
literal|"QNetworkReply"
argument_list|,
literal|"Background request not allowed."
argument_list|)
argument_list|)
expr_stmt|;
name|finished
argument_list|()
expr_stmt|;
block|}
comment|// ### if canResume(), then we could resume automatically
block|}
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// need to have this function since the reply is a private member variable
end_comment
begin_comment
comment|// and the special backends need to access this.
end_comment
begin_function
DECL|function|emitReplyUploadProgress
name|void
name|QNetworkReplyHttpImplPrivate
operator|::
name|emitReplyUploadProgress
parameter_list|(
name|qint64
name|bytesSent
parameter_list|,
name|qint64
name|bytesTotal
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QNetworkReplyHttpImpl
argument_list|)
expr_stmt|;
if|if
condition|(
name|isFinished
condition|)
return|return;
comment|//choke signal emissions, except the first and last signals which are unconditional
if|if
condition|(
name|uploadProgressSignalChoke
operator|.
name|isValid
argument_list|()
condition|)
block|{
if|if
condition|(
name|bytesSent
operator|!=
name|bytesTotal
operator|&&
name|uploadProgressSignalChoke
operator|.
name|elapsed
argument_list|()
operator|<
name|progressSignalInterval
condition|)
block|{
return|return;
block|}
name|uploadProgressSignalChoke
operator|.
name|restart
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|uploadProgressSignalChoke
operator|.
name|start
argument_list|()
expr_stmt|;
block|}
emit|emit
name|q
operator|->
name|uploadProgress
argument_list|(
name|bytesSent
argument_list|,
name|bytesTotal
argument_list|)
emit|;
block|}
end_function
begin_function
DECL|function|createUploadByteDevice
name|QNonContiguousByteDevice
modifier|*
name|QNetworkReplyHttpImplPrivate
operator|::
name|createUploadByteDevice
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QNetworkReplyHttpImpl
argument_list|)
expr_stmt|;
if|if
condition|(
name|outgoingDataBuffer
condition|)
name|uploadByteDevice
operator|=
name|QSharedPointer
argument_list|<
name|QNonContiguousByteDevice
argument_list|>
argument_list|(
name|QNonContiguousByteDeviceFactory
operator|::
name|create
argument_list|(
name|outgoingDataBuffer
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|outgoingData
condition|)
block|{
name|uploadByteDevice
operator|=
name|QSharedPointer
argument_list|<
name|QNonContiguousByteDevice
argument_list|>
argument_list|(
name|QNonContiguousByteDeviceFactory
operator|::
name|create
argument_list|(
name|outgoingData
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
name|bool
name|bufferDisallowed
init|=
name|request
operator|.
name|attribute
argument_list|(
name|QNetworkRequest
operator|::
name|DoNotBufferUploadDataAttribute
argument_list|,
name|QVariant
argument_list|(
literal|false
argument_list|)
argument_list|)
operator|==
name|QVariant
argument_list|(
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|bufferDisallowed
condition|)
name|uploadByteDevice
operator|->
name|disableReset
argument_list|()
expr_stmt|;
comment|// We want signal emissions only for normal asynchronous uploads
if|if
condition|(
operator|!
name|synchronous
condition|)
name|QObject
operator|::
name|connect
argument_list|(
name|uploadByteDevice
operator|.
name|data
argument_list|()
argument_list|,
name|SIGNAL
argument_list|(
name|readProgress
argument_list|(
name|qint64
argument_list|,
name|qint64
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|emitReplyUploadProgress
argument_list|(
name|qint64
argument_list|,
name|qint64
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|uploadByteDevice
operator|.
name|data
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|_q_finished
name|void
name|QNetworkReplyHttpImplPrivate
operator|::
name|_q_finished
parameter_list|()
block|{
comment|// This gets called queued, just forward to real call then
name|finished
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|finished
name|void
name|QNetworkReplyHttpImplPrivate
operator|::
name|finished
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QNetworkReplyHttpImpl
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|Finished
operator|||
name|state
operator|==
name|Aborted
operator|||
name|state
operator|==
name|WaitingForSession
condition|)
return|return;
name|QVariant
name|totalSize
init|=
name|cookedHeaders
operator|.
name|value
argument_list|(
name|QNetworkRequest
operator|::
name|ContentLengthHeader
argument_list|)
decl_stmt|;
if|if
condition|(
name|preMigrationDownloaded
operator|!=
name|Q_INT64_C
argument_list|(
operator|-
literal|1
argument_list|)
condition|)
name|totalSize
operator|=
name|totalSize
operator|.
name|toLongLong
argument_list|()
operator|+
name|preMigrationDownloaded
expr_stmt|;
if|if
condition|(
name|manager
condition|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_BEARERMANAGEMENT
name|QSharedPointer
argument_list|<
name|QNetworkSession
argument_list|>
name|session
init|=
name|managerPrivate
operator|->
name|getNetworkSession
argument_list|()
decl_stmt|;
if|if
condition|(
name|session
operator|&&
name|session
operator|->
name|state
argument_list|()
operator|==
name|QNetworkSession
operator|::
name|Roaming
operator|&&
name|state
operator|==
name|Working
operator|&&
name|errorCode
operator|!=
name|QNetworkReply
operator|::
name|OperationCanceledError
condition|)
block|{
comment|// only content with a known size will fail with a temporary network failure error
if|if
condition|(
operator|!
name|totalSize
operator|.
name|isNull
argument_list|()
condition|)
block|{
if|if
condition|(
name|bytesDownloaded
operator|!=
name|totalSize
condition|)
block|{
if|if
condition|(
name|migrateBackend
argument_list|()
condition|)
block|{
comment|// either we are migrating or the request is finished/aborted
if|if
condition|(
name|state
operator|==
name|Reconnecting
operator|||
name|state
operator|==
name|WaitingForSession
condition|)
block|{
return|return;
comment|// exit early if we are migrating.
block|}
block|}
else|else
block|{
name|error
argument_list|(
name|QNetworkReply
operator|::
name|TemporaryNetworkFailureError
argument_list|,
name|QNetworkReply
operator|::
name|tr
argument_list|(
literal|"Temporary network failure."
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
endif|#
directive|endif
block|}
name|state
operator|=
name|Finished
expr_stmt|;
name|q
operator|->
name|setFinished
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|totalSize
operator|.
name|isNull
argument_list|()
operator|||
name|totalSize
operator|==
operator|-
literal|1
condition|)
block|{
emit|emit
name|q
operator|->
name|downloadProgress
argument_list|(
name|bytesDownloaded
argument_list|,
name|bytesDownloaded
argument_list|)
emit|;
block|}
else|else
block|{
emit|emit
name|q
operator|->
name|downloadProgress
argument_list|(
name|bytesDownloaded
argument_list|,
name|totalSize
operator|.
name|toLongLong
argument_list|()
argument_list|)
emit|;
block|}
if|if
condition|(
name|bytesUploaded
operator|==
operator|-
literal|1
operator|&&
operator|(
name|outgoingData
operator|||
name|outgoingDataBuffer
operator|)
condition|)
emit|emit
name|q
operator|->
name|uploadProgress
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
emit|;
comment|// if we don't know the total size of or we received everything save the cache
if|if
condition|(
name|totalSize
operator|.
name|isNull
argument_list|()
operator|||
name|totalSize
operator|==
operator|-
literal|1
operator|||
name|bytesDownloaded
operator|==
name|totalSize
condition|)
name|completeCacheSave
argument_list|()
expr_stmt|;
emit|emit
name|q
operator|->
name|readChannelFinished
argument_list|()
emit|;
emit|emit
name|q
operator|->
name|finished
argument_list|()
emit|;
block|}
end_function
begin_function
DECL|function|_q_error
name|void
name|QNetworkReplyHttpImplPrivate
operator|::
name|_q_error
parameter_list|(
name|QNetworkReplyImpl
operator|::
name|NetworkError
name|code
parameter_list|,
specifier|const
name|QString
modifier|&
name|errorMessage
parameter_list|)
block|{
name|this
operator|->
name|error
argument_list|(
name|code
argument_list|,
name|errorMessage
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|error
name|void
name|QNetworkReplyHttpImplPrivate
operator|::
name|error
parameter_list|(
name|QNetworkReplyImpl
operator|::
name|NetworkError
name|code
parameter_list|,
specifier|const
name|QString
modifier|&
name|errorMessage
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QNetworkReplyHttpImpl
argument_list|)
expr_stmt|;
comment|// Can't set and emit multiple errors.
if|if
condition|(
name|errorCode
operator|!=
name|QNetworkReply
operator|::
name|NoError
condition|)
block|{
name|qWarning
argument_list|(
literal|"QNetworkReplyImplPrivate::error: Internal problem, this method must only be called once."
argument_list|)
expr_stmt|;
return|return;
block|}
name|errorCode
operator|=
name|code
expr_stmt|;
name|q
operator|->
name|setErrorString
argument_list|(
name|errorMessage
argument_list|)
expr_stmt|;
comment|// note: might not be a good idea, since users could decide to delete us
comment|// which would delete the backend too...
comment|// maybe we should protect the backend
emit|emit
name|q
operator|->
name|error
argument_list|(
name|code
argument_list|)
emit|;
block|}
end_function
begin_function
DECL|function|metaDataChanged
name|void
name|QNetworkReplyHttpImplPrivate
operator|::
name|metaDataChanged
parameter_list|()
block|{
comment|// FIXME merge this with replyDownloadMetaData(); ?
name|Q_Q
argument_list|(
name|QNetworkReplyHttpImpl
argument_list|)
expr_stmt|;
comment|// 1. do we have cookies?
comment|// 2. are we allowed to set them?
if|if
condition|(
name|cookedHeaders
operator|.
name|contains
argument_list|(
name|QNetworkRequest
operator|::
name|SetCookieHeader
argument_list|)
operator|&&
name|manager
operator|&&
operator|(
cast|static_cast
argument_list|<
name|QNetworkRequest
operator|::
name|LoadControl
argument_list|>
argument_list|(
name|request
operator|.
name|attribute
argument_list|(
name|QNetworkRequest
operator|::
name|CookieSaveControlAttribute
argument_list|,
name|QNetworkRequest
operator|::
name|Automatic
argument_list|)
operator|.
name|toInt
argument_list|()
argument_list|)
operator|==
name|QNetworkRequest
operator|::
name|Automatic
operator|)
condition|)
block|{
name|QList
argument_list|<
name|QNetworkCookie
argument_list|>
name|cookies
init|=
name|qvariant_cast
argument_list|<
name|QList
argument_list|<
name|QNetworkCookie
argument_list|>
argument_list|>
argument_list|(
name|cookedHeaders
operator|.
name|value
argument_list|(
name|QNetworkRequest
operator|::
name|SetCookieHeader
argument_list|)
argument_list|)
decl_stmt|;
name|QNetworkCookieJar
modifier|*
name|jar
init|=
name|manager
operator|->
name|cookieJar
argument_list|()
decl_stmt|;
if|if
condition|(
name|jar
condition|)
name|jar
operator|->
name|setCookiesFromUrl
argument_list|(
name|cookies
argument_list|,
name|url
argument_list|)
expr_stmt|;
block|}
emit|emit
name|q
operator|->
name|metaDataChanged
argument_list|()
emit|;
block|}
end_function
begin_comment
comment|/*     Migrates the backend of the QNetworkReply to a new network connection if required.  Returns     true if the reply is migrated or it is not required; otherwise returns false. */
end_comment
begin_function
DECL|function|migrateBackend
name|bool
name|QNetworkReplyHttpImplPrivate
operator|::
name|migrateBackend
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QNetworkReplyHttpImpl
argument_list|)
expr_stmt|;
comment|// Network reply is already finished or aborted, don't need to migrate.
if|if
condition|(
name|state
operator|==
name|Finished
operator|||
name|state
operator|==
name|Aborted
condition|)
return|return
literal|true
return|;
comment|// Backend does not support resuming download.
if|if
condition|(
operator|!
name|canResume
argument_list|()
condition|)
return|return
literal|false
return|;
comment|// Request has outgoing data, not migrating.
if|if
condition|(
name|outgoingData
condition|)
return|return
literal|false
return|;
comment|// Request is serviced from the cache, don't need to migrate.
if|if
condition|(
name|cacheLoadDevice
condition|)
return|return
literal|true
return|;
name|state
operator|=
name|Reconnecting
expr_stmt|;
name|cookedHeaders
operator|.
name|clear
argument_list|()
expr_stmt|;
name|rawHeaders
operator|.
name|clear
argument_list|()
expr_stmt|;
name|preMigrationDownloaded
operator|=
name|bytesDownloaded
expr_stmt|;
name|setResumeOffset
argument_list|(
name|bytesDownloaded
argument_list|)
expr_stmt|;
emit|emit
name|q
operator|->
name|abortHttpRequest
argument_list|()
emit|;
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|q
argument_list|,
literal|"_q_startOperation"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|createCache
name|void
name|QNetworkReplyHttpImplPrivate
operator|::
name|createCache
parameter_list|()
block|{
comment|// check if we can save and if we're allowed to
if|if
condition|(
operator|!
name|managerPrivate
operator|->
name|networkCache
operator|||
operator|!
name|request
operator|.
name|attribute
argument_list|(
name|QNetworkRequest
operator|::
name|CacheSaveControlAttribute
argument_list|,
literal|true
argument_list|)
operator|.
name|toBool
argument_list|()
condition|)
return|return;
name|cacheEnabled
operator|=
literal|true
expr_stmt|;
block|}
end_function
begin_function
DECL|function|isCachingEnabled
name|bool
name|QNetworkReplyHttpImplPrivate
operator|::
name|isCachingEnabled
parameter_list|()
specifier|const
block|{
return|return
operator|(
name|cacheEnabled
operator|&&
name|managerPrivate
operator|->
name|networkCache
operator|!=
literal|0
operator|)
return|;
block|}
end_function
begin_function
DECL|function|setCachingEnabled
name|void
name|QNetworkReplyHttpImplPrivate
operator|::
name|setCachingEnabled
parameter_list|(
name|bool
name|enable
parameter_list|)
block|{
if|if
condition|(
operator|!
name|enable
operator|&&
operator|!
name|cacheEnabled
condition|)
return|return;
comment|// nothing to do
if|if
condition|(
name|enable
operator|&&
name|cacheEnabled
condition|)
return|return;
comment|// nothing to do either!
if|if
condition|(
name|enable
condition|)
block|{
if|if
condition|(
name|bytesDownloaded
condition|)
block|{
name|qDebug
argument_list|()
operator|<<
literal|"setCachingEnabled: "
operator|<<
name|bytesDownloaded
operator|<<
literal|" bytesDownloaded"
expr_stmt|;
comment|// refuse to enable in this case
name|qCritical
argument_list|(
literal|"QNetworkReplyImpl: backend error: caching was enabled after some bytes had been written"
argument_list|)
expr_stmt|;
return|return;
block|}
name|createCache
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// someone told us to turn on, then back off?
comment|// ok... but you should make up your mind
name|qDebug
argument_list|(
literal|"QNetworkReplyImpl: setCachingEnabled(true) called after setCachingEnabled(false)"
argument_list|)
expr_stmt|;
name|managerPrivate
operator|->
name|networkCache
operator|->
name|remove
argument_list|(
name|url
argument_list|)
expr_stmt|;
name|cacheSaveDevice
operator|=
literal|0
expr_stmt|;
name|cacheEnabled
operator|=
literal|false
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|isCachingAllowed
name|bool
name|QNetworkReplyHttpImplPrivate
operator|::
name|isCachingAllowed
parameter_list|()
specifier|const
block|{
return|return
name|operation
operator|==
name|QNetworkAccessManager
operator|::
name|GetOperation
operator|||
name|operation
operator|==
name|QNetworkAccessManager
operator|::
name|HeadOperation
return|;
block|}
end_function
begin_function
DECL|function|completeCacheSave
name|void
name|QNetworkReplyHttpImplPrivate
operator|::
name|completeCacheSave
parameter_list|()
block|{
if|if
condition|(
name|cacheEnabled
operator|&&
name|errorCode
operator|!=
name|QNetworkReplyImpl
operator|::
name|NoError
condition|)
block|{
name|managerPrivate
operator|->
name|networkCache
operator|->
name|remove
argument_list|(
name|url
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cacheEnabled
operator|&&
name|cacheSaveDevice
condition|)
block|{
name|managerPrivate
operator|->
name|networkCache
operator|->
name|insert
argument_list|(
name|cacheSaveDevice
argument_list|)
expr_stmt|;
block|}
name|cacheSaveDevice
operator|=
literal|0
expr_stmt|;
name|cacheEnabled
operator|=
literal|false
expr_stmt|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_HTTP
end_comment
end_unit
