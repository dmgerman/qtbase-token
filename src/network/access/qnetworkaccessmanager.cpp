begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the QtNetwork module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qnetworkaccessmanager.h"
end_include
begin_include
include|#
directive|include
file|"qnetworkaccessmanager_p.h"
end_include
begin_include
include|#
directive|include
file|"qnetworkrequest.h"
end_include
begin_include
include|#
directive|include
file|"qnetworkreply.h"
end_include
begin_include
include|#
directive|include
file|"qnetworkreply_p.h"
end_include
begin_include
include|#
directive|include
file|"qnetworkcookie.h"
end_include
begin_include
include|#
directive|include
file|"qabstractnetworkcache.h"
end_include
begin_include
include|#
directive|include
file|"QtNetwork/qnetworksession.h"
end_include
begin_include
include|#
directive|include
file|"QtNetwork/private/qsharednetworksession_p.h"
end_include
begin_include
include|#
directive|include
file|"qnetworkaccessftpbackend_p.h"
end_include
begin_include
include|#
directive|include
file|"qnetworkaccessfilebackend_p.h"
end_include
begin_include
include|#
directive|include
file|"qnetworkaccessdebugpipebackend_p.h"
end_include
begin_include
include|#
directive|include
file|"qnetworkaccesscachebackend_p.h"
end_include
begin_include
include|#
directive|include
file|"qnetworkreplydataimpl_p.h"
end_include
begin_include
include|#
directive|include
file|"qnetworkreplyfileimpl_p.h"
end_include
begin_include
include|#
directive|include
file|"QtCore/qbuffer.h"
end_include
begin_include
include|#
directive|include
file|"QtCore/qurl.h"
end_include
begin_include
include|#
directive|include
file|"QtCore/qvector.h"
end_include
begin_include
include|#
directive|include
file|"QtNetwork/private/qauthenticator_p.h"
end_include
begin_include
include|#
directive|include
file|"QtNetwork/qsslconfiguration.h"
end_include
begin_include
include|#
directive|include
file|"QtNetwork/qnetworkconfigmanager.h"
end_include
begin_include
include|#
directive|include
file|"QtNetwork/qhttpmultipart.h"
end_include
begin_include
include|#
directive|include
file|"qhttpmultipart_p.h"
end_include
begin_include
include|#
directive|include
file|"qnetworkreplyhttpimpl_p.h"
end_include
begin_include
include|#
directive|include
file|"qthread.h"
end_include
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
name|Q_GLOBAL_STATIC
argument_list|(
name|QNetworkAccessFileBackendFactory
argument_list|,
name|fileBackend
argument_list|)
ifndef|#
directive|ifndef
name|QT_NO_FTP
name|Q_GLOBAL_STATIC
argument_list|(
name|QNetworkAccessFtpBackendFactory
argument_list|,
name|ftpBackend
argument_list|)
endif|#
directive|endif
comment|// QT_NO_FTP
ifdef|#
directive|ifdef
name|QT_BUILD_INTERNAL
name|Q_GLOBAL_STATIC
argument_list|(
name|QNetworkAccessDebugPipeBackendFactory
argument_list|,
name|debugpipeBackend
argument_list|)
endif|#
directive|endif
decl|static
DECL|function|ensureInitialized
name|void
name|ensureInitialized
argument_list|()
argument_list|{
ifndef|#
directive|ifndef
name|QT_NO_FTP
operator|(
name|void
operator|)
name|ftpBackend
argument_list|()
argument_list|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|QT_BUILD_INTERNAL
operator|(
name|void
operator|)
name|debugpipeBackend
argument_list|()
argument_list|;
endif|#
directive|endif
comment|// leave this one last since it will query the special QAbstractFileEngines
operator|(
name|void
operator|)
name|fileBackend
argument_list|()
argument_list|; }
comment|/*!     \class QNetworkAccessManager     \brief The QNetworkAccessManager class allows the application to     send network requests and receive replies     \since 4.4      \ingroup network     \inmodule QtNetwork     \reentrant      The Network Access API is constructed around one QNetworkAccessManager     object, which holds the common configuration and settings for the requests     it sends. It contains the proxy and cache configuration, as well as the     signals related to such issues, and reply signals that can be used to     monitor the progress of a network operation. One QNetworkAccessManager     should be enough for the whole Qt application.      Once a QNetworkAccessManager object has been created, the application can     use it to send requests over the network. A group of standard functions     are supplied that take a request and optional data, and each return a     QNetworkReply object. The returned object is used to obtain any data     returned in response to the corresponding request.      A simple download off the network could be accomplished with:     \snippet doc/src/snippets/code/src_network_access_qnetworkaccessmanager.cpp 0      QNetworkAccessManager has an asynchronous API.     When the \tt replyFinished slot above is called, the parameter it     takes is the QNetworkReply object containing the downloaded data     as well as meta-data (headers, etc.).      \note After the request has finished, it is the responsibility of the user     to delete the QNetworkReply object at an appropriate time. Do not directly     delete it inside the slot connected to finished(). You can use the     deleteLater() function.      \note QNetworkAccessManager queues the requests it receives. The number     of requests executed in parallel is dependent on the protocol.     Currently, for the HTTP protocol on desktop platforms, 6 requests are     executed in parallel for one host/port combination.      A more involved example, assuming the manager is already existent,     can be:     \snippet doc/src/snippets/code/src_network_access_qnetworkaccessmanager.cpp 1      \section1 Network and Roaming support      With the addition of the \l {Bearer Management} API to Qt 4.7     QNetworkAccessManager gained the ability to manage network connections.     QNetworkAccessManager can start the network interface if the device is     offline and terminates the interface if the current process is the last     one to use the uplink. Note that some platform utilize grace periods from     when the last application stops using a uplink until the system actually     terminates the connectivity link. Roaming is equally transparent. Any     queued/pending network requests are automatically transferred to new     access point.      Clients wanting to utilize this feature should not require any changes. In fact     it is likely that existing platform specific connection code can simply be     removed from the application.      \note The network and roaming support in QNetworkAccessManager is conditional     upon the platform supporting connection management. The     \l QNetworkConfigurationManager::NetworkSessionRequired can be used to     detect whether QNetworkAccessManager utilizes this feature. Currently only     Meego/Harmattan platforms provide connection management support.      \note This feature cannot be used in combination with the Bearer Management     API as provided by QtMobility. Applications have to migrate to the Qt version     of Bearer Management.      \sa QNetworkRequest, QNetworkReply, QNetworkProxy */
comment|/*!     \enum QNetworkAccessManager::Operation      Indicates the operation this reply is processing.      \value HeadOperation        retrieve headers operation (created     with head())      \value GetOperation         retrieve headers and download contents     (created with get())      \value PutOperation         upload contents operation (created     with put())      \value PostOperation        send the contents of an HTML form for     processing via HTTP POST (created with post())      \value DeleteOperation      delete contents operation (created with     deleteResource())      \value CustomOperation      custom operation (created with     sendCustomRequest())    \since 4.7      \omitvalue UnknownOperation      \sa QNetworkReply::operation() */
comment|/*!     \enum QNetworkAccessManager::NetworkAccessibility      Indicates whether the network is accessible via this network access manager.      \value UnknownAccessibility     The network accessibility cannot be determined.     \value NotAccessible            The network is not currently accessible, either because there                                     is currently no network coverage or network access has been                                     explicitly disabled by a call to setNetworkAccessible().     \value Accessible               The network is accessible.      \sa networkAccessible */
comment|/*!     \property QNetworkAccessManager::networkAccessible     \brief whether the network is currently accessible via this network access manager.      \since 4.7      If the network is \l {NotAccessible}{not accessible} the network access manager will not     process any new network requests, all such requests will fail with an error.  Requests with     URLs with the file:// scheme will still be processed.      By default the value of this property reflects the physical state of the device.  Applications     may override it to disable all network requests via this network access manager by calling      \snippet doc/src/snippets/code/src_network_access_qnetworkaccessmanager.cpp 4      Network requests can be reenabled again by calling      \snippet doc/src/snippets/code/src_network_access_qnetworkaccessmanager.cpp 5      \note Calling setNetworkAccessible() does not change the network state. */
comment|/*!     \fn void QNetworkAccessManager::networkAccessibleChanged(QNetworkAccessManager::NetworkAccessibility accessible)      This signal is emitted when the value of the \l networkAccessible property changes.     \a accessible is the new network accessibility. */
comment|/*!     \fn void QNetworkAccessManager::networkSessionConnected()      \since 4.7      \internal      This signal is emitted when the status of the network session changes into a usable (Connected)     state. It is used to signal to QNetworkReplys to start or migrate their network operation once     the network session has been opened or finished roaming. */
comment|/*!     \fn void QNetworkAccessManager::proxyAuthenticationRequired(const QNetworkProxy&proxy, QAuthenticator *authenticator)      This signal is emitted whenever a proxy requests authentication     and QNetworkAccessManager cannot find a valid, cached     credential. The slot connected to this signal should fill in the     credentials for the proxy \a proxy in the \a authenticator object.      QNetworkAccessManager will cache the credentials internally. The     next time the proxy requests authentication, QNetworkAccessManager     will automatically send the same credential without emitting the     proxyAuthenticationRequired signal again.      If the proxy rejects the credentials, QNetworkAccessManager will     emit the signal again.      \sa proxy(), setProxy(), authenticationRequired() */
comment|/*!     \fn void QNetworkAccessManager::authenticationRequired(QNetworkReply *reply, QAuthenticator *authenticator)      This signal is emitted whenever a final server requests     authentication before it delivers the requested contents. The slot     connected to this signal should fill the credentials for the     contents (which can be determined by inspecting the \a reply     object) in the \a authenticator object.      QNetworkAccessManager will cache the credentials internally and     will send the same values if the server requires authentication     again, without emitting the authenticationRequired() signal. If it     rejects the credentials, this signal will be emitted again.      \note To have the request not send credentials you must not call     setUser() or setPassword() on the \a authenticator object. This     will result in the the \l finished() signal being emitted with a     \l QNetworkReply with error \l AuthenticationRequiredError.      \note It is not possible to use a QueuedConnection to connect to     this signal, as the connection will fail if the authenticator has     not been filled in with new information when the signal returns.      \sa proxyAuthenticationRequired(), QAuthenticator::setUser(), QAuthenticator::setPassword() */
comment|/*!     \fn void QNetworkAccessManager::finished(QNetworkReply *reply)      This signal is emitted whenever a pending network reply is     finished. The \a reply parameter will contain a pointer to the     reply that has just finished. This signal is emitted in tandem     with the QNetworkReply::finished() signal.      See QNetworkReply::finished() for information on the status that     the object will be in.      \note Do not delete the \a reply object in the slot connected to this     signal. Use deleteLater().      \sa QNetworkReply::finished(), QNetworkReply::error() */
comment|/*!     \fn void QNetworkAccessManager::sslErrors(QNetworkReply *reply, const QList<QSslError>&errors)      This signal is emitted if the SSL/TLS session encountered errors     during the set up, including certificate verification errors. The     \a errors parameter contains the list of errors and \a reply is     the QNetworkReply that is encountering these errors.      To indicate that the errors are not fatal and that the connection     should proceed, the QNetworkReply::ignoreSslErrors() function should be called     from the slot connected to this signal. If it is not called, the     SSL session will be torn down before any data is exchanged     (including the URL).      This signal can be used to display an error message to the user     indicating that security may be compromised and display the     SSL settings (see sslConfiguration() to obtain it). If the user     decides to proceed after analyzing the remote certificate, the     slot should call ignoreSslErrors().      \sa QSslSocket::sslErrors(), QNetworkReply::sslErrors(),     QNetworkReply::sslConfiguration(), QNetworkReply::ignoreSslErrors() */
comment|/*!     Constructs a QNetworkAccessManager object that is the center of     the Network Access API and sets \a parent as the parent object. */
DECL|function|QNetworkAccessManager
name|QNetworkAccessManager
operator|::
name|QNetworkAccessManager
argument_list|(
name|QObject
operator|*
name|parent
argument_list|)
range|:
name|QObject
argument_list|(
argument|*new QNetworkAccessManagerPrivate
argument_list|,
argument|parent
argument_list|)
block|{
name|ensureInitialized
argument_list|()
block|;
name|qRegisterMetaType
argument_list|<
name|QNetworkReply
operator|::
name|NetworkError
argument_list|>
argument_list|(
literal|"QNetworkReply::NetworkError"
argument_list|)
block|;
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
name|qRegisterMetaType
argument_list|<
name|QNetworkProxy
argument_list|>
argument_list|(
literal|"QNetworkProxy"
argument_list|)
block|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_OPENSSL
name|qRegisterMetaType
argument_list|<
name|QList
argument_list|<
name|QSslError
argument_list|>
argument_list|>
argument_list|(
literal|"QList<QSslError>"
argument_list|)
block|;
name|qRegisterMetaType
argument_list|<
name|QSslConfiguration
argument_list|>
argument_list|(
literal|"QSslConfiguration"
argument_list|)
block|;
endif|#
directive|endif
name|qRegisterMetaType
argument_list|<
name|QList
argument_list|<
name|QPair
argument_list|<
name|QByteArray
argument_list|,
name|QByteArray
argument_list|>
argument_list|>
argument_list|>
argument_list|(
literal|"QList<QPair<QByteArray,QByteArray>>"
argument_list|)
block|;
name|qRegisterMetaType
argument_list|<
name|QHttpNetworkRequest
argument_list|>
argument_list|(
literal|"QHttpNetworkRequest"
argument_list|)
block|;
name|qRegisterMetaType
argument_list|<
name|QNetworkReply
operator|::
name|NetworkError
argument_list|>
argument_list|(
literal|"QNetworkReply::NetworkError"
argument_list|)
block|;
name|qRegisterMetaType
argument_list|<
name|QSharedPointer
argument_list|<
name|char
argument_list|>
argument_list|>
argument_list|(
literal|"QSharedPointer<char>"
argument_list|)
block|; }
comment|/*!     Destroys the QNetworkAccessManager object and frees up any     resources. Note that QNetworkReply objects that are returned from     this class have this object set as their parents, which means that     they will be deleted along with it if you don't call     QObject::setParent() on them. */
DECL|function|~QNetworkAccessManager
name|QNetworkAccessManager
operator|::
name|~
name|QNetworkAccessManager
operator|(
operator|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
operator|delete
name|d_func
argument_list|()
operator|->
name|proxyFactory
block|;
endif|#
directive|endif
comment|// Delete the QNetworkReply children first.
comment|// Else a QAbstractNetworkCache might get deleted in ~QObject
comment|// before a QNetworkReply that accesses the QAbstractNetworkCache
comment|// object in its destructor.
name|qDeleteAll
argument_list|(
name|findChildren
argument_list|<
name|QNetworkReply
operator|*
argument_list|>
argument_list|()
argument_list|)
block|;
comment|// The other children will be deleted in this ~QObject
comment|// FIXME instead of this "hack" make the QNetworkReplyImpl
comment|// properly watch the cache deletion, e.g. via a QWeakPointer.
block|}
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
comment|/*!     Returns the QNetworkProxy that the requests sent using this     QNetworkAccessManager object will use. The default value for the     proxy is QNetworkProxy::DefaultProxy.      \sa setProxy(), setProxyFactory(), proxyAuthenticationRequired() */
DECL|function|proxy
name|QNetworkProxy
name|QNetworkAccessManager
operator|::
name|proxy
operator|(
operator|)
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|proxy
return|;
block|}
end_decl_stmt
begin_comment
comment|/*!     Sets the proxy to be used in future requests to be \a proxy. This     does not affect requests that have already been sent. The     proxyAuthenticationRequired() signal will be emitted if the proxy     requests authentication.      A proxy set with this function will be used for all requests     issued by QNetworkAccessManager. In some cases, it might be     necessary to select different proxies depending on the type of     request being sent or the destination host. If that's the case,     you should consider using setProxyFactory().      \sa proxy(), proxyAuthenticationRequired() */
end_comment
begin_function
DECL|function|setProxy
name|void
name|QNetworkAccessManager
operator|::
name|setProxy
parameter_list|(
specifier|const
name|QNetworkProxy
modifier|&
name|proxy
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QNetworkAccessManager
argument_list|)
expr_stmt|;
operator|delete
name|d
operator|->
name|proxyFactory
expr_stmt|;
name|d
operator|->
name|proxy
operator|=
name|proxy
expr_stmt|;
name|d
operator|->
name|proxyFactory
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn QNetworkProxyFactory *QNetworkAccessManager::proxyFactory() const     \since 4.5      Returns the proxy factory that this QNetworkAccessManager object     is using to determine the proxies to be used for requests.      Note that the pointer returned by this function is managed by     QNetworkAccessManager and could be deleted at any time.      \sa setProxyFactory(), proxy() */
end_comment
begin_function
DECL|function|proxyFactory
name|QNetworkProxyFactory
modifier|*
name|QNetworkAccessManager
operator|::
name|proxyFactory
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|proxyFactory
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5      Sets the proxy factory for this class to be \a factory. A proxy     factory is used to determine a more specific list of proxies to be     used for a given request, instead of trying to use the same proxy     value for all requests.      All queries sent by QNetworkAccessManager will have type     QNetworkProxyQuery::UrlRequest.      For example, a proxy factory could apply the following rules:     \list       \o if the target address is in the local network (for example,          if the hostname contains no dots or if it's an IP address in          the organization's range), return QNetworkProxy::NoProxy       \o if the request is FTP, return an FTP proxy       \o if the request is HTTP or HTTPS, then return an HTTP proxy       \o otherwise, return a SOCKSv5 proxy server     \endlist      The lifetime of the object \a factory will be managed by     QNetworkAccessManager. It will delete the object when necessary.      \note If a specific proxy is set with setProxy(), the factory will not     be used.      \sa proxyFactory(), setProxy(), QNetworkProxyQuery */
end_comment
begin_function
DECL|function|setProxyFactory
name|void
name|QNetworkAccessManager
operator|::
name|setProxyFactory
parameter_list|(
name|QNetworkProxyFactory
modifier|*
name|factory
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QNetworkAccessManager
argument_list|)
expr_stmt|;
operator|delete
name|d
operator|->
name|proxyFactory
expr_stmt|;
name|d
operator|->
name|proxyFactory
operator|=
name|factory
expr_stmt|;
name|d
operator|->
name|proxy
operator|=
name|QNetworkProxy
argument_list|()
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \since 4.5      Returns the cache that is used to store data obtained from the network.      \sa setCache() */
end_comment
begin_function
DECL|function|cache
name|QAbstractNetworkCache
modifier|*
name|QNetworkAccessManager
operator|::
name|cache
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QNetworkAccessManager
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|networkCache
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5      Sets the manager's network cache to be the \a cache specified. The cache     is used for all requests dispatched by the manager.      Use this function to set the network cache object to a class that implements     additional features, like saving the cookies to permanent storage.      \note QNetworkAccessManager takes ownership of the \a cache object.      QNetworkAccessManager by default does not have a set cache.     Qt provides a simple disk cache, QNetworkDiskCache, which can be used.      \sa cache(), QNetworkRequest::CacheLoadControl */
end_comment
begin_function
DECL|function|setCache
name|void
name|QNetworkAccessManager
operator|::
name|setCache
parameter_list|(
name|QAbstractNetworkCache
modifier|*
name|cache
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QNetworkAccessManager
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|networkCache
operator|!=
name|cache
condition|)
block|{
operator|delete
name|d
operator|->
name|networkCache
expr_stmt|;
name|d
operator|->
name|networkCache
operator|=
name|cache
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|networkCache
condition|)
name|d
operator|->
name|networkCache
operator|->
name|setParent
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Returns the QNetworkCookieJar that is used to store cookies     obtained from the network as well as cookies that are about to be     sent.      \sa setCookieJar() */
end_comment
begin_function
DECL|function|cookieJar
name|QNetworkCookieJar
modifier|*
name|QNetworkAccessManager
operator|::
name|cookieJar
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QNetworkAccessManager
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|cookieJar
condition|)
name|d
operator|->
name|createCookieJar
argument_list|()
expr_stmt|;
return|return
name|d
operator|->
name|cookieJar
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the manager's cookie jar to be the \a cookieJar specified.     The cookie jar is used by all requests dispatched by the manager.      Use this function to set the cookie jar object to a class that     implements additional features, like saving the cookies to permanent     storage.      \note QNetworkAccessManager takes ownership of the \a cookieJar object.      If \a cookieJar is in the same thread as this QNetworkAccessManager,     it will set the parent of the \a cookieJar     so that the cookie jar is deleted when this     object is deleted as well. If you want to share cookie jars     between different QNetworkAccessManager objects, you may want to     set the cookie jar's parent to 0 after calling this function.      QNetworkAccessManager by default does not implement any cookie     policy of its own: it accepts all cookies sent by the server, as     long as they are well formed and meet the minimum security     requirements (cookie domain matches the request's and cookie path     matches the request's). In order to implement your own security     policy, override the QNetworkCookieJar::cookiesForUrl() and     QNetworkCookieJar::setCookiesFromUrl() virtual functions. Those     functions are called by QNetworkAccessManager when it detects a     new cookie.      \sa cookieJar(), QNetworkCookieJar::cookiesForUrl(), QNetworkCookieJar::setCookiesFromUrl() */
end_comment
begin_function
DECL|function|setCookieJar
name|void
name|QNetworkAccessManager
operator|::
name|setCookieJar
parameter_list|(
name|QNetworkCookieJar
modifier|*
name|cookieJar
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QNetworkAccessManager
argument_list|)
expr_stmt|;
name|d
operator|->
name|cookieJarCreated
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|cookieJar
operator|!=
name|cookieJar
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|cookieJar
operator|&&
name|d
operator|->
name|cookieJar
operator|->
name|parent
argument_list|()
operator|==
name|this
condition|)
operator|delete
name|d
operator|->
name|cookieJar
expr_stmt|;
name|d
operator|->
name|cookieJar
operator|=
name|cookieJar
expr_stmt|;
if|if
condition|(
name|thread
argument_list|()
operator|==
name|cookieJar
operator|->
name|thread
argument_list|()
condition|)
name|d
operator|->
name|cookieJar
operator|->
name|setParent
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Posts a request to obtain the network headers for \a request     and returns a new QNetworkReply object which will contain such headers.      The function is named after the HTTP request associated (HEAD). */
end_comment
begin_function
DECL|function|head
name|QNetworkReply
modifier|*
name|QNetworkAccessManager
operator|::
name|head
parameter_list|(
specifier|const
name|QNetworkRequest
modifier|&
name|request
parameter_list|)
block|{
return|return
name|d_func
argument_list|()
operator|->
name|postProcess
argument_list|(
name|createRequest
argument_list|(
name|QNetworkAccessManager
operator|::
name|HeadOperation
argument_list|,
name|request
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Posts a request to obtain the contents of the target \a request     and returns a new QNetworkReply object opened for reading which emits the      \l{QIODevice::readyRead()}{readyRead()} signal whenever new data      arrives.      The contents as well as associated headers will be downloaded.      \sa post(), put(), deleteResource(), sendCustomRequest() */
end_comment
begin_function
DECL|function|get
name|QNetworkReply
modifier|*
name|QNetworkAccessManager
operator|::
name|get
parameter_list|(
specifier|const
name|QNetworkRequest
modifier|&
name|request
parameter_list|)
block|{
return|return
name|d_func
argument_list|()
operator|->
name|postProcess
argument_list|(
name|createRequest
argument_list|(
name|QNetworkAccessManager
operator|::
name|GetOperation
argument_list|,
name|request
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Sends an HTTP POST request to the destination specified by \a request     and returns a new QNetworkReply object opened for reading that will      contain the reply sent by the server. The contents of  the \a data      device will be uploaded to the server.      \a data must be open for reading and must remain valid until the      finished() signal is emitted for this reply.      \note Sending a POST request on protocols other than HTTP and     HTTPS is undefined and will probably fail.      \sa get(), put(), deleteResource(), sendCustomRequest() */
end_comment
begin_function
DECL|function|post
name|QNetworkReply
modifier|*
name|QNetworkAccessManager
operator|::
name|post
parameter_list|(
specifier|const
name|QNetworkRequest
modifier|&
name|request
parameter_list|,
name|QIODevice
modifier|*
name|data
parameter_list|)
block|{
return|return
name|d_func
argument_list|()
operator|->
name|postProcess
argument_list|(
name|createRequest
argument_list|(
name|QNetworkAccessManager
operator|::
name|PostOperation
argument_list|,
name|request
argument_list|,
name|data
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Sends the contents of the \a data byte array to the destination      specified by \a request. */
end_comment
begin_function
DECL|function|post
name|QNetworkReply
modifier|*
name|QNetworkAccessManager
operator|::
name|post
parameter_list|(
specifier|const
name|QNetworkRequest
modifier|&
name|request
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|data
parameter_list|)
block|{
name|QBuffer
modifier|*
name|buffer
init|=
operator|new
name|QBuffer
decl_stmt|;
name|buffer
operator|->
name|setData
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|buffer
operator|->
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
expr_stmt|;
name|QNetworkReply
modifier|*
name|reply
init|=
name|post
argument_list|(
name|request
argument_list|,
name|buffer
argument_list|)
decl_stmt|;
name|buffer
operator|->
name|setParent
argument_list|(
name|reply
argument_list|)
expr_stmt|;
return|return
name|reply
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.8      \overload      Sends the contents of the \a multiPart message to the destination     specified by \a request.      This can be used for sending MIME multipart messages over HTTP.      \sa QHttpMultiPart, QHttpPart, put() */
end_comment
begin_function
DECL|function|post
name|QNetworkReply
modifier|*
name|QNetworkAccessManager
operator|::
name|post
parameter_list|(
specifier|const
name|QNetworkRequest
modifier|&
name|request
parameter_list|,
name|QHttpMultiPart
modifier|*
name|multiPart
parameter_list|)
block|{
name|QNetworkRequest
name|newRequest
init|=
name|d_func
argument_list|()
operator|->
name|prepareMultipart
argument_list|(
name|request
argument_list|,
name|multiPart
argument_list|)
decl_stmt|;
name|QIODevice
modifier|*
name|device
init|=
name|multiPart
operator|->
name|d_func
argument_list|()
operator|->
name|device
decl_stmt|;
name|QNetworkReply
modifier|*
name|reply
init|=
name|post
argument_list|(
name|newRequest
argument_list|,
name|device
argument_list|)
decl_stmt|;
return|return
name|reply
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.8      \overload      Sends the contents of the \a multiPart message to the destination     specified by \a request.      This can be used for sending MIME multipart messages over HTTP.      \sa QHttpMultiPart, QHttpPart, post() */
end_comment
begin_function
DECL|function|put
name|QNetworkReply
modifier|*
name|QNetworkAccessManager
operator|::
name|put
parameter_list|(
specifier|const
name|QNetworkRequest
modifier|&
name|request
parameter_list|,
name|QHttpMultiPart
modifier|*
name|multiPart
parameter_list|)
block|{
name|QNetworkRequest
name|newRequest
init|=
name|d_func
argument_list|()
operator|->
name|prepareMultipart
argument_list|(
name|request
argument_list|,
name|multiPart
argument_list|)
decl_stmt|;
name|QIODevice
modifier|*
name|device
init|=
name|multiPart
operator|->
name|d_func
argument_list|()
operator|->
name|device
decl_stmt|;
name|QNetworkReply
modifier|*
name|reply
init|=
name|put
argument_list|(
name|newRequest
argument_list|,
name|device
argument_list|)
decl_stmt|;
return|return
name|reply
return|;
block|}
end_function
begin_comment
comment|/*!     Uploads the contents of \a data to the destination \a request and     returnes a new QNetworkReply object that will be open for reply.      \a data must be opened for reading when this function is called     and must remain valid until the finished() signal is emitted for     this reply.      Whether anything will be available for reading from the returned     object is protocol dependent. For HTTP, the server may send a      small HTML page indicating the upload was successful (or not).      Other protocols will probably have content in their replies.      \note For HTTP, this request will send a PUT request, which most servers     do not allow. Form upload mechanisms, including that of uploading     files through HTML forms, use the POST mechanism.      \sa get(), post(), deleteResource(), sendCustomRequest() */
end_comment
begin_function
DECL|function|put
name|QNetworkReply
modifier|*
name|QNetworkAccessManager
operator|::
name|put
parameter_list|(
specifier|const
name|QNetworkRequest
modifier|&
name|request
parameter_list|,
name|QIODevice
modifier|*
name|data
parameter_list|)
block|{
return|return
name|d_func
argument_list|()
operator|->
name|postProcess
argument_list|(
name|createRequest
argument_list|(
name|QNetworkAccessManager
operator|::
name|PutOperation
argument_list|,
name|request
argument_list|,
name|data
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Sends the contents of the \a data byte array to the destination     specified by \a request. */
end_comment
begin_function
DECL|function|put
name|QNetworkReply
modifier|*
name|QNetworkAccessManager
operator|::
name|put
parameter_list|(
specifier|const
name|QNetworkRequest
modifier|&
name|request
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|data
parameter_list|)
block|{
name|QBuffer
modifier|*
name|buffer
init|=
operator|new
name|QBuffer
decl_stmt|;
name|buffer
operator|->
name|setData
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|buffer
operator|->
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
expr_stmt|;
name|QNetworkReply
modifier|*
name|reply
init|=
name|put
argument_list|(
name|request
argument_list|,
name|buffer
argument_list|)
decl_stmt|;
name|buffer
operator|->
name|setParent
argument_list|(
name|reply
argument_list|)
expr_stmt|;
return|return
name|reply
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.6      Sends a request to delete the resource identified by the URL of \a request.      \note This feature is currently available for HTTP only, performing an      HTTP DELETE request.      \sa get(), post(), put(), sendCustomRequest() */
end_comment
begin_function
DECL|function|deleteResource
name|QNetworkReply
modifier|*
name|QNetworkAccessManager
operator|::
name|deleteResource
parameter_list|(
specifier|const
name|QNetworkRequest
modifier|&
name|request
parameter_list|)
block|{
return|return
name|d_func
argument_list|()
operator|->
name|postProcess
argument_list|(
name|createRequest
argument_list|(
name|QNetworkAccessManager
operator|::
name|DeleteOperation
argument_list|,
name|request
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_BEARERMANAGEMENT
end_ifndef
begin_comment
comment|/*!     \since 4.7      Sets the network configuration that will be used when creating the     \l {QNetworkSession}{network session} to \a config.      The network configuration is used to create and open a network session before any request that     requires network access is process.  If no network configuration is explicitly set via this     function the network configuration returned by     QNetworkConfigurationManager::defaultConfiguration() will be used.      To restore the default network configuration set the network configuration to the value     returned from QNetworkConfigurationManager::defaultConfiguration().      \snippet doc/src/snippets/code/src_network_access_qnetworkaccessmanager.cpp 2      If an invalid network configuration is set, a network session will not be created.  In this     case network requests will be processed regardless, but may fail.  For example:      \snippet doc/src/snippets/code/src_network_access_qnetworkaccessmanager.cpp 3      \sa configuration(), QNetworkSession */
end_comment
begin_function
DECL|function|setConfiguration
name|void
name|QNetworkAccessManager
operator|::
name|setConfiguration
parameter_list|(
specifier|const
name|QNetworkConfiguration
modifier|&
name|config
parameter_list|)
block|{
name|d_func
argument_list|()
operator|->
name|createSession
argument_list|(
name|config
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.7      Returns the network configuration that will be used to create the     \l {QNetworkSession}{network session} which will be used when processing network requests.      \sa setConfiguration(), activeConfiguration() */
end_comment
begin_function
DECL|function|configuration
name|QNetworkConfiguration
name|QNetworkAccessManager
operator|::
name|configuration
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QNetworkAccessManager
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|networkSession
condition|)
return|return
name|d
operator|->
name|networkSession
operator|->
name|configuration
argument_list|()
return|;
else|else
return|return
name|QNetworkConfiguration
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.7      Returns the current active network configuration.      If the network configuration returned by configuration() is of type     QNetworkConfiguration::ServiceNetwork this function will return the current active child     network configuration of that configuration.  Otherwise returns the same network configuration     as configuration().      Use this function to return the actual network configuration currently in use by the network     session.      \sa configuration() */
end_comment
begin_function
DECL|function|activeConfiguration
name|QNetworkConfiguration
name|QNetworkAccessManager
operator|::
name|activeConfiguration
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QNetworkAccessManager
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|networkSession
condition|)
block|{
name|QNetworkConfigurationManager
name|manager
decl_stmt|;
return|return
name|manager
operator|.
name|configurationFromIdentifier
argument_list|(
name|d
operator|->
name|networkSession
operator|->
name|sessionProperty
argument_list|(
name|QLatin1String
argument_list|(
literal|"ActiveConfiguration"
argument_list|)
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|QNetworkConfiguration
argument_list|()
return|;
block|}
block|}
end_function
begin_comment
comment|/*!     \since 4.7      Overrides the reported network accessibility.  If \a accessible is NotAccessible the reported     network accessiblity will always be NotAccessible.  Otherwise the reported network     accessibility will reflect the actual device state. */
end_comment
begin_function
DECL|function|setNetworkAccessible
name|void
name|QNetworkAccessManager
operator|::
name|setNetworkAccessible
parameter_list|(
name|QNetworkAccessManager
operator|::
name|NetworkAccessibility
name|accessible
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QNetworkAccessManager
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|networkAccessible
operator|!=
name|accessible
condition|)
block|{
name|NetworkAccessibility
name|previous
init|=
name|networkAccessible
argument_list|()
decl_stmt|;
name|d
operator|->
name|networkAccessible
operator|=
name|accessible
expr_stmt|;
name|NetworkAccessibility
name|current
init|=
name|networkAccessible
argument_list|()
decl_stmt|;
if|if
condition|(
name|previous
operator|!=
name|current
condition|)
emit|emit
name|networkAccessibleChanged
argument_list|(
name|current
argument_list|)
emit|;
block|}
block|}
end_function
begin_comment
comment|/*!     \since 4.7      Returns the current network accessibility. */
end_comment
begin_function
DECL|function|networkAccessible
name|QNetworkAccessManager
operator|::
name|NetworkAccessibility
name|QNetworkAccessManager
operator|::
name|networkAccessible
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QNetworkAccessManager
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|networkSession
condition|)
block|{
comment|// d->online holds online/offline state of this network session.
if|if
condition|(
name|d
operator|->
name|online
condition|)
return|return
name|d
operator|->
name|networkAccessible
return|;
else|else
return|return
name|NotAccessible
return|;
block|}
else|else
block|{
comment|// Network accessibility is either disabled or unknown.
return|return
operator|(
name|d
operator|->
name|networkAccessible
operator|==
name|NotAccessible
operator|)
condition|?
name|NotAccessible
else|:
name|UnknownAccessibility
return|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_BEARERMANAGEMENT
end_comment
begin_comment
comment|/*!     \since 4.7      Sends a custom request to the server identified by the URL of \a request.      It is the user's responsibility to send a \a verb to the server that is valid     according to the HTTP specification.      This method provides means to send verbs other than the common ones provided     via get() or post() etc., for instance sending an HTTP OPTIONS command.      If \a data is not empty, the contents of the \a data     device will be uploaded to the server; in that case, data must be open for     reading and must remain valid until the finished() signal is emitted for this reply.      \note This feature is currently available for HTTP(S) only.      \sa get(), post(), put(), deleteResource() */
end_comment
begin_function
DECL|function|sendCustomRequest
name|QNetworkReply
modifier|*
name|QNetworkAccessManager
operator|::
name|sendCustomRequest
parameter_list|(
specifier|const
name|QNetworkRequest
modifier|&
name|request
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|verb
parameter_list|,
name|QIODevice
modifier|*
name|data
parameter_list|)
block|{
name|QNetworkRequest
name|newRequest
argument_list|(
name|request
argument_list|)
decl_stmt|;
name|newRequest
operator|.
name|setAttribute
argument_list|(
name|QNetworkRequest
operator|::
name|CustomVerbAttribute
argument_list|,
name|verb
argument_list|)
expr_stmt|;
return|return
name|d_func
argument_list|()
operator|->
name|postProcess
argument_list|(
name|createRequest
argument_list|(
name|QNetworkAccessManager
operator|::
name|CustomOperation
argument_list|,
name|newRequest
argument_list|,
name|data
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a new QNetworkReply object to handle the operation \a op     and request \a req. The device \a outgoingData is always 0 for Get and     Head requests, but is the value passed to post() and put() in     those operations (the QByteArray variants will pass a QBuffer     object).      The default implementation calls QNetworkCookieJar::cookiesForUrl()     on the cookie jar set with setCookieJar() to obtain the cookies to     be sent to the remote server.      The returned object must be in an open state. */
end_comment
begin_function
DECL|function|createRequest
name|QNetworkReply
modifier|*
name|QNetworkAccessManager
operator|::
name|createRequest
parameter_list|(
name|QNetworkAccessManager
operator|::
name|Operation
name|op
parameter_list|,
specifier|const
name|QNetworkRequest
modifier|&
name|req
parameter_list|,
name|QIODevice
modifier|*
name|outgoingData
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QNetworkAccessManager
argument_list|)
expr_stmt|;
name|bool
name|isLocalFile
init|=
name|req
operator|.
name|url
argument_list|()
operator|.
name|isLocalFile
argument_list|()
decl_stmt|;
name|QString
name|scheme
init|=
name|req
operator|.
name|url
argument_list|()
operator|.
name|scheme
argument_list|()
operator|.
name|toLower
argument_list|()
decl_stmt|;
comment|// fast path for GET on file:// URLs
comment|// The QNetworkAccessFileBackend will right now only be used for PUT
if|if
condition|(
operator|(
name|op
operator|==
name|QNetworkAccessManager
operator|::
name|GetOperation
operator|||
name|op
operator|==
name|QNetworkAccessManager
operator|::
name|HeadOperation
operator|)
operator|&&
operator|(
name|isLocalFile
operator|||
name|scheme
operator|==
name|QLatin1String
argument_list|(
literal|"qrc"
argument_list|)
operator|)
condition|)
block|{
return|return
operator|new
name|QNetworkReplyFileImpl
argument_list|(
name|this
argument_list|,
name|req
argument_list|,
name|op
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|op
operator|==
name|QNetworkAccessManager
operator|::
name|GetOperation
operator|||
name|op
operator|==
name|QNetworkAccessManager
operator|::
name|HeadOperation
operator|)
operator|&&
name|scheme
operator|==
name|QLatin1String
argument_list|(
literal|"data"
argument_list|)
condition|)
block|{
return|return
operator|new
name|QNetworkReplyDataImpl
argument_list|(
name|this
argument_list|,
name|req
argument_list|,
name|op
argument_list|)
return|;
block|}
comment|// A request with QNetworkRequest::AlwaysCache does not need any bearer management
name|QNetworkRequest
operator|::
name|CacheLoadControl
name|mode
init|=
cast|static_cast
argument_list|<
name|QNetworkRequest
operator|::
name|CacheLoadControl
argument_list|>
argument_list|(
name|req
operator|.
name|attribute
argument_list|(
name|QNetworkRequest
operator|::
name|CacheLoadControlAttribute
argument_list|,
name|QNetworkRequest
operator|::
name|PreferNetwork
argument_list|)
operator|.
name|toInt
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|QNetworkRequest
operator|::
name|AlwaysCache
operator|&&
operator|(
name|op
operator|==
name|QNetworkAccessManager
operator|::
name|GetOperation
operator|||
name|op
operator|==
name|QNetworkAccessManager
operator|::
name|HeadOperation
operator|)
condition|)
block|{
comment|// FIXME Implement a QNetworkReplyCacheImpl instead, see QTBUG-15106
name|QNetworkReplyImpl
modifier|*
name|reply
init|=
operator|new
name|QNetworkReplyImpl
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|QNetworkReplyImplPrivate
modifier|*
name|priv
init|=
name|reply
operator|->
name|d_func
argument_list|()
decl_stmt|;
name|priv
operator|->
name|manager
operator|=
name|this
expr_stmt|;
name|priv
operator|->
name|backend
operator|=
operator|new
name|QNetworkAccessCacheBackend
argument_list|()
expr_stmt|;
name|priv
operator|->
name|backend
operator|->
name|manager
operator|=
name|this
operator|->
name|d_func
argument_list|()
expr_stmt|;
name|priv
operator|->
name|backend
operator|->
name|setParent
argument_list|(
name|reply
argument_list|)
expr_stmt|;
name|priv
operator|->
name|backend
operator|->
name|reply
operator|=
name|priv
expr_stmt|;
name|priv
operator|->
name|setup
argument_list|(
name|op
argument_list|,
name|req
argument_list|,
name|outgoingData
argument_list|)
expr_stmt|;
return|return
name|reply
return|;
block|}
ifndef|#
directive|ifndef
name|QT_NO_BEARERMANAGEMENT
comment|// Return a disabled network reply if network access is disabled.
comment|// Except if the scheme is empty or file://.
if|if
condition|(
operator|!
name|d
operator|->
name|networkAccessible
operator|&&
operator|!
name|isLocalFile
condition|)
block|{
return|return
operator|new
name|QDisabledNetworkReply
argument_list|(
name|this
argument_list|,
name|req
argument_list|,
name|op
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|d
operator|->
name|networkSession
operator|&&
operator|(
name|d
operator|->
name|initializeSession
operator|||
operator|!
name|d
operator|->
name|networkConfiguration
operator|.
name|isEmpty
argument_list|()
operator|)
condition|)
block|{
name|QNetworkConfigurationManager
name|manager
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|networkConfiguration
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|d
operator|->
name|createSession
argument_list|(
name|manager
operator|.
name|configurationFromIdentifier
argument_list|(
name|d
operator|->
name|networkConfiguration
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|manager
operator|.
name|capabilities
argument_list|()
operator|&
name|QNetworkConfigurationManager
operator|::
name|NetworkSessionRequired
condition|)
name|d
operator|->
name|createSession
argument_list|(
name|manager
operator|.
name|defaultConfiguration
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|d
operator|->
name|initializeSession
operator|=
literal|false
expr_stmt|;
block|}
block|}
if|if
condition|(
name|d
operator|->
name|networkSession
condition|)
name|d
operator|->
name|networkSession
operator|->
name|setSessionProperty
argument_list|(
name|QLatin1String
argument_list|(
literal|"AutoCloseSessionTimeout"
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|QNetworkRequest
name|request
init|=
name|req
decl_stmt|;
if|if
condition|(
operator|!
name|request
operator|.
name|header
argument_list|(
name|QNetworkRequest
operator|::
name|ContentLengthHeader
argument_list|)
operator|.
name|isValid
argument_list|()
operator|&&
name|outgoingData
operator|&&
operator|!
name|outgoingData
operator|->
name|isSequential
argument_list|()
condition|)
block|{
comment|// request has no Content-Length
comment|// but the data that is outgoing is random-access
name|request
operator|.
name|setHeader
argument_list|(
name|QNetworkRequest
operator|::
name|ContentLengthHeader
argument_list|,
name|outgoingData
operator|->
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
cast|static_cast
argument_list|<
name|QNetworkRequest
operator|::
name|LoadControl
argument_list|>
argument_list|(
name|request
operator|.
name|attribute
argument_list|(
name|QNetworkRequest
operator|::
name|CookieLoadControlAttribute
argument_list|,
name|QNetworkRequest
operator|::
name|Automatic
argument_list|)
operator|.
name|toInt
argument_list|()
argument_list|)
operator|==
name|QNetworkRequest
operator|::
name|Automatic
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|cookieJar
condition|)
block|{
name|QList
argument_list|<
name|QNetworkCookie
argument_list|>
name|cookies
init|=
name|d
operator|->
name|cookieJar
operator|->
name|cookiesForUrl
argument_list|(
name|request
operator|.
name|url
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|cookies
operator|.
name|isEmpty
argument_list|()
condition|)
name|request
operator|.
name|setHeader
argument_list|(
name|QNetworkRequest
operator|::
name|CookieHeader
argument_list|,
name|QVariant
operator|::
name|fromValue
argument_list|(
name|cookies
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
ifndef|#
directive|ifndef
name|QT_NO_HTTP
comment|// Since Qt 5 we use the new QNetworkReplyHttpImpl
if|if
condition|(
name|scheme
operator|==
name|QLatin1String
argument_list|(
literal|"http"
argument_list|)
operator|||
name|scheme
operator|==
name|QLatin1String
argument_list|(
literal|"https"
argument_list|)
condition|)
block|{
name|QNetworkReplyHttpImpl
modifier|*
name|reply
init|=
operator|new
name|QNetworkReplyHttpImpl
argument_list|(
name|this
argument_list|,
name|request
argument_list|,
name|op
argument_list|,
name|outgoingData
argument_list|)
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_BEARERMANAGEMENT
name|connect
argument_list|(
name|this
argument_list|,
name|SIGNAL
argument_list|(
name|networkSessionConnected
argument_list|()
argument_list|)
argument_list|,
name|reply
argument_list|,
name|SLOT
argument_list|(
name|_q_networkSessionConnected
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|reply
return|;
block|}
endif|#
directive|endif
comment|// QT_NO_HTTP
comment|// first step: create the reply
name|QUrl
name|url
init|=
name|request
operator|.
name|url
argument_list|()
decl_stmt|;
name|QNetworkReplyImpl
modifier|*
name|reply
init|=
operator|new
name|QNetworkReplyImpl
argument_list|(
name|this
argument_list|)
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_BEARERMANAGEMENT
if|if
condition|(
operator|!
name|isLocalFile
condition|)
block|{
name|connect
argument_list|(
name|this
argument_list|,
name|SIGNAL
argument_list|(
name|networkSessionConnected
argument_list|()
argument_list|)
argument_list|,
name|reply
argument_list|,
name|SLOT
argument_list|(
name|_q_networkSessionConnected
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|QNetworkReplyImplPrivate
modifier|*
name|priv
init|=
name|reply
operator|->
name|d_func
argument_list|()
decl_stmt|;
name|priv
operator|->
name|manager
operator|=
name|this
expr_stmt|;
comment|// second step: fetch cached credentials
comment|// This is not done for the time being, we should use signal emissions to request
comment|// the credentials from cache.
comment|// third step: find a backend
name|priv
operator|->
name|backend
operator|=
name|d
operator|->
name|findBackend
argument_list|(
name|op
argument_list|,
name|request
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|->
name|backend
condition|)
block|{
name|priv
operator|->
name|backend
operator|->
name|setParent
argument_list|(
name|reply
argument_list|)
expr_stmt|;
name|priv
operator|->
name|backend
operator|->
name|reply
operator|=
name|priv
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|QT_NO_OPENSSL
name|reply
operator|->
name|setSslConfiguration
argument_list|(
name|request
operator|.
name|sslConfiguration
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// fourth step: setup the reply
name|priv
operator|->
name|setup
argument_list|(
name|op
argument_list|,
name|request
argument_list|,
name|outgoingData
argument_list|)
expr_stmt|;
return|return
name|reply
return|;
block|}
end_function
begin_comment
comment|/*!     \since 5.0      Flushes the internal cache of authentication data and network connections.      This function is useful for doing auto tests.  */
end_comment
begin_function
DECL|function|clearAccessCache
name|void
name|QNetworkAccessManager
operator|::
name|clearAccessCache
parameter_list|()
block|{
name|QNetworkAccessManagerPrivate
operator|::
name|clearCache
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|_q_replyFinished
name|void
name|QNetworkAccessManagerPrivate
operator|::
name|_q_replyFinished
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QNetworkAccessManager
argument_list|)
expr_stmt|;
name|QNetworkReply
modifier|*
name|reply
init|=
name|qobject_cast
argument_list|<
name|QNetworkReply
operator|*
argument_list|>
argument_list|(
name|q
operator|->
name|sender
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|reply
condition|)
emit|emit
name|q
operator|->
name|finished
argument_list|(
name|reply
argument_list|)
emit|;
ifndef|#
directive|ifndef
name|QT_NO_BEARERMANAGEMENT
if|if
condition|(
name|networkSession
operator|&&
name|q
operator|->
name|findChildren
argument_list|<
name|QNetworkReply
operator|*
argument_list|>
argument_list|()
operator|.
name|count
argument_list|()
operator|==
literal|1
condition|)
name|networkSession
operator|->
name|setSessionProperty
argument_list|(
name|QLatin1String
argument_list|(
literal|"AutoCloseSessionTimeout"
argument_list|)
argument_list|,
literal|120000
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|_q_replySslErrors
name|void
name|QNetworkAccessManagerPrivate
operator|::
name|_q_replySslErrors
parameter_list|(
specifier|const
name|QList
argument_list|<
name|QSslError
argument_list|>
modifier|&
name|errors
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_OPENSSL
name|Q_Q
argument_list|(
name|QNetworkAccessManager
argument_list|)
expr_stmt|;
name|QNetworkReply
modifier|*
name|reply
init|=
name|qobject_cast
argument_list|<
name|QNetworkReply
operator|*
argument_list|>
argument_list|(
name|q
operator|->
name|sender
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|reply
condition|)
emit|emit
name|q
operator|->
name|sslErrors
argument_list|(
name|reply
argument_list|,
name|errors
argument_list|)
emit|;
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|errors
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|postProcess
name|QNetworkReply
modifier|*
name|QNetworkAccessManagerPrivate
operator|::
name|postProcess
parameter_list|(
name|QNetworkReply
modifier|*
name|reply
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QNetworkAccessManager
argument_list|)
expr_stmt|;
name|QNetworkReplyPrivate
operator|::
name|setManager
argument_list|(
name|reply
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|q
operator|->
name|connect
argument_list|(
name|reply
argument_list|,
name|SIGNAL
argument_list|(
name|finished
argument_list|()
argument_list|)
argument_list|,
name|SLOT
argument_list|(
name|_q_replyFinished
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_OPENSSL
comment|/* In case we're compiled without SSL support, we don't have this signal and we need to      * avoid getting a connection error. */
name|q
operator|->
name|connect
argument_list|(
name|reply
argument_list|,
name|SIGNAL
argument_list|(
name|sslErrors
argument_list|(
name|QList
argument_list|<
name|QSslError
argument_list|>
argument_list|)
argument_list|)
argument_list|,
name|SLOT
argument_list|(
name|_q_replySslErrors
argument_list|(
name|QList
argument_list|<
name|QSslError
argument_list|>
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|reply
return|;
block|}
end_function
begin_function
DECL|function|createCookieJar
name|void
name|QNetworkAccessManagerPrivate
operator|::
name|createCookieJar
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|cookieJarCreated
condition|)
block|{
comment|// keep the ugly hack in here
name|QNetworkAccessManagerPrivate
modifier|*
name|that
init|=
cast|const_cast
argument_list|<
name|QNetworkAccessManagerPrivate
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|that
operator|->
name|cookieJar
operator|=
operator|new
name|QNetworkCookieJar
argument_list|(
name|that
operator|->
name|q_func
argument_list|()
argument_list|)
expr_stmt|;
name|that
operator|->
name|cookieJarCreated
operator|=
literal|true
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|authenticationRequired
name|void
name|QNetworkAccessManagerPrivate
operator|::
name|authenticationRequired
parameter_list|(
name|QAuthenticator
modifier|*
name|authenticator
parameter_list|,
name|QNetworkReply
modifier|*
name|reply
parameter_list|,
name|bool
name|synchronous
parameter_list|,
name|QUrl
modifier|&
name|url
parameter_list|,
name|QUrl
modifier|*
name|urlForLastAuthentication
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QNetworkAccessManager
argument_list|)
expr_stmt|;
comment|// don't try the cache for the same URL twice in a row
comment|// being called twice for the same URL means the authentication failed
comment|// also called when last URL is empty, e.g. on first call
if|if
condition|(
name|urlForLastAuthentication
operator|->
name|isEmpty
argument_list|()
operator|||
name|url
operator|!=
operator|*
name|urlForLastAuthentication
condition|)
block|{
name|QNetworkAuthenticationCredential
name|cred
init|=
name|authenticationManager
operator|->
name|fetchCachedCredentials
argument_list|(
name|url
argument_list|,
name|authenticator
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|cred
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|authenticator
operator|->
name|setUser
argument_list|(
name|cred
operator|.
name|user
argument_list|)
expr_stmt|;
name|authenticator
operator|->
name|setPassword
argument_list|(
name|cred
operator|.
name|password
argument_list|)
expr_stmt|;
operator|*
name|urlForLastAuthentication
operator|=
name|url
expr_stmt|;
return|return;
block|}
block|}
comment|// if we emit a signal here in synchronous mode, the user might spin
comment|// an event loop, which might recurse and lead to problems
if|if
condition|(
name|synchronous
condition|)
return|return;
operator|*
name|urlForLastAuthentication
operator|=
name|url
expr_stmt|;
emit|emit
name|q
operator|->
name|authenticationRequired
argument_list|(
name|reply
argument_list|,
name|authenticator
argument_list|)
emit|;
name|authenticationManager
operator|->
name|cacheCredentials
argument_list|(
name|url
argument_list|,
name|authenticator
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
end_ifndef
begin_function
DECL|function|proxyAuthenticationRequired
name|void
name|QNetworkAccessManagerPrivate
operator|::
name|proxyAuthenticationRequired
parameter_list|(
specifier|const
name|QNetworkProxy
modifier|&
name|proxy
parameter_list|,
name|bool
name|synchronous
parameter_list|,
name|QAuthenticator
modifier|*
name|authenticator
parameter_list|,
name|QNetworkProxy
modifier|*
name|lastProxyAuthentication
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QNetworkAccessManager
argument_list|)
expr_stmt|;
name|QAuthenticatorPrivate
modifier|*
name|priv
init|=
name|QAuthenticatorPrivate
operator|::
name|getPrivate
argument_list|(
operator|*
name|authenticator
argument_list|)
decl_stmt|;
if|if
condition|(
name|proxy
operator|!=
operator|*
name|lastProxyAuthentication
operator|&&
operator|(
operator|!
name|priv
operator|||
operator|!
name|priv
operator|->
name|hasFailed
operator|)
condition|)
block|{
name|QNetworkAuthenticationCredential
name|cred
init|=
name|authenticationManager
operator|->
name|fetchCachedProxyCredentials
argument_list|(
name|proxy
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|cred
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|authenticator
operator|->
name|setUser
argument_list|(
name|cred
operator|.
name|user
argument_list|)
expr_stmt|;
name|authenticator
operator|->
name|setPassword
argument_list|(
name|cred
operator|.
name|password
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|// if we emit a signal here in synchronous mode, the user might spin
comment|// an event loop, which might recurse and lead to problems
if|if
condition|(
name|synchronous
condition|)
return|return;
operator|*
name|lastProxyAuthentication
operator|=
name|proxy
expr_stmt|;
emit|emit
name|q
operator|->
name|proxyAuthenticationRequired
argument_list|(
name|proxy
argument_list|,
name|authenticator
argument_list|)
emit|;
name|authenticationManager
operator|->
name|cacheProxyCredentials
argument_list|(
name|proxy
argument_list|,
name|authenticator
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|queryProxy
name|QList
argument_list|<
name|QNetworkProxy
argument_list|>
name|QNetworkAccessManagerPrivate
operator|::
name|queryProxy
parameter_list|(
specifier|const
name|QNetworkProxyQuery
modifier|&
name|query
parameter_list|)
block|{
name|QList
argument_list|<
name|QNetworkProxy
argument_list|>
name|proxies
decl_stmt|;
if|if
condition|(
name|proxyFactory
condition|)
block|{
name|proxies
operator|=
name|proxyFactory
operator|->
name|queryProxy
argument_list|(
name|query
argument_list|)
expr_stmt|;
if|if
condition|(
name|proxies
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QNetworkAccessManager: factory %p has returned an empty result set"
argument_list|,
name|proxyFactory
argument_list|)
expr_stmt|;
name|proxies
operator|<<
name|QNetworkProxy
operator|::
name|NoProxy
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|proxy
operator|.
name|type
argument_list|()
operator|==
name|QNetworkProxy
operator|::
name|DefaultProxy
condition|)
block|{
comment|// no proxy set, query the application
return|return
name|QNetworkProxyFactory
operator|::
name|proxyForQuery
argument_list|(
name|query
argument_list|)
return|;
block|}
else|else
block|{
name|proxies
operator|<<
name|proxy
expr_stmt|;
block|}
return|return
name|proxies
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|clearCache
name|void
name|QNetworkAccessManagerPrivate
operator|::
name|clearCache
parameter_list|(
name|QNetworkAccessManager
modifier|*
name|manager
parameter_list|)
block|{
name|manager
operator|->
name|d_func
argument_list|()
operator|->
name|objectCache
operator|.
name|clear
argument_list|()
expr_stmt|;
name|manager
operator|->
name|d_func
argument_list|()
operator|->
name|authenticationManager
operator|->
name|clearCache
argument_list|()
expr_stmt|;
if|if
condition|(
name|manager
operator|->
name|d_func
argument_list|()
operator|->
name|httpThread
condition|)
block|{
comment|// The thread will deleteLater() itself from its finished() signal
name|manager
operator|->
name|d_func
argument_list|()
operator|->
name|httpThread
operator|->
name|quit
argument_list|()
expr_stmt|;
name|manager
operator|->
name|d_func
argument_list|()
operator|->
name|httpThread
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function
begin_destructor
DECL|function|~QNetworkAccessManagerPrivate
name|QNetworkAccessManagerPrivate
operator|::
name|~
name|QNetworkAccessManagerPrivate
parameter_list|()
block|{
if|if
condition|(
name|httpThread
condition|)
block|{
comment|// The thread will deleteLater() itself from its finished() signal
name|httpThread
operator|->
name|quit
argument_list|()
expr_stmt|;
name|httpThread
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_destructor
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_BEARERMANAGEMENT
end_ifndef
begin_function
DECL|function|createSession
name|void
name|QNetworkAccessManagerPrivate
operator|::
name|createSession
parameter_list|(
specifier|const
name|QNetworkConfiguration
modifier|&
name|config
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QNetworkAccessManager
argument_list|)
expr_stmt|;
name|initializeSession
operator|=
literal|false
expr_stmt|;
name|QSharedPointer
argument_list|<
name|QNetworkSession
argument_list|>
name|newSession
decl_stmt|;
if|if
condition|(
name|config
operator|.
name|isValid
argument_list|()
condition|)
name|newSession
operator|=
name|QSharedNetworkSessionManager
operator|::
name|getSession
argument_list|(
name|config
argument_list|)
expr_stmt|;
if|if
condition|(
name|networkSession
condition|)
block|{
comment|//do nothing if new and old session are the same
if|if
condition|(
name|networkSession
operator|==
name|newSession
condition|)
return|return;
comment|//disconnect from old session
name|QObject
operator|::
name|disconnect
argument_list|(
name|networkSession
operator|.
name|data
argument_list|()
argument_list|,
name|SIGNAL
argument_list|(
name|opened
argument_list|()
argument_list|)
argument_list|,
name|q
argument_list|,
name|SIGNAL
argument_list|(
name|networkSessionConnected
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|disconnect
argument_list|(
name|networkSession
operator|.
name|data
argument_list|()
argument_list|,
name|SIGNAL
argument_list|(
name|closed
argument_list|()
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_networkSessionClosed
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|disconnect
argument_list|(
name|networkSession
operator|.
name|data
argument_list|()
argument_list|,
name|SIGNAL
argument_list|(
name|stateChanged
argument_list|(
name|QNetworkSession
operator|::
name|State
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_networkSessionStateChanged
argument_list|(
name|QNetworkSession
operator|::
name|State
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|//switch to new session (null if config was invalid)
name|networkSession
operator|=
name|newSession
expr_stmt|;
if|if
condition|(
operator|!
name|networkSession
condition|)
block|{
name|online
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|networkAccessible
operator|==
name|QNetworkAccessManager
operator|::
name|NotAccessible
condition|)
emit|emit
name|q
operator|->
name|networkAccessibleChanged
argument_list|(
name|QNetworkAccessManager
operator|::
name|NotAccessible
argument_list|)
emit|;
else|else
emit|emit
name|q
operator|->
name|networkAccessibleChanged
argument_list|(
name|QNetworkAccessManager
operator|::
name|UnknownAccessibility
argument_list|)
emit|;
return|return;
block|}
comment|//connect to new session
name|QObject
operator|::
name|connect
argument_list|(
name|networkSession
operator|.
name|data
argument_list|()
argument_list|,
name|SIGNAL
argument_list|(
name|opened
argument_list|()
argument_list|)
argument_list|,
name|q
argument_list|,
name|SIGNAL
argument_list|(
name|networkSessionConnected
argument_list|()
argument_list|)
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
comment|//QueuedConnection is used to avoid deleting the networkSession inside its closed signal
name|QObject
operator|::
name|connect
argument_list|(
name|networkSession
operator|.
name|data
argument_list|()
argument_list|,
name|SIGNAL
argument_list|(
name|closed
argument_list|()
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_networkSessionClosed
argument_list|()
argument_list|)
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|networkSession
operator|.
name|data
argument_list|()
argument_list|,
name|SIGNAL
argument_list|(
name|stateChanged
argument_list|(
name|QNetworkSession
operator|::
name|State
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_networkSessionStateChanged
argument_list|(
name|QNetworkSession
operator|::
name|State
argument_list|)
argument_list|)
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
name|_q_networkSessionStateChanged
argument_list|(
name|networkSession
operator|->
name|state
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|_q_networkSessionClosed
name|void
name|QNetworkAccessManagerPrivate
operator|::
name|_q_networkSessionClosed
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QNetworkAccessManager
argument_list|)
expr_stmt|;
if|if
condition|(
name|networkSession
condition|)
block|{
name|networkConfiguration
operator|=
name|networkSession
operator|->
name|configuration
argument_list|()
operator|.
name|identifier
argument_list|()
expr_stmt|;
comment|//disconnect from old session
name|QObject
operator|::
name|disconnect
argument_list|(
name|networkSession
operator|.
name|data
argument_list|()
argument_list|,
name|SIGNAL
argument_list|(
name|opened
argument_list|()
argument_list|)
argument_list|,
name|q
argument_list|,
name|SIGNAL
argument_list|(
name|networkSessionConnected
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|disconnect
argument_list|(
name|networkSession
operator|.
name|data
argument_list|()
argument_list|,
name|SIGNAL
argument_list|(
name|closed
argument_list|()
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_networkSessionClosed
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|disconnect
argument_list|(
name|networkSession
operator|.
name|data
argument_list|()
argument_list|,
name|SIGNAL
argument_list|(
name|stateChanged
argument_list|(
name|QNetworkSession
operator|::
name|State
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_networkSessionStateChanged
argument_list|(
name|QNetworkSession
operator|::
name|State
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|networkSession
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|_q_networkSessionStateChanged
name|void
name|QNetworkAccessManagerPrivate
operator|::
name|_q_networkSessionStateChanged
parameter_list|(
name|QNetworkSession
operator|::
name|State
name|state
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QNetworkAccessManager
argument_list|)
expr_stmt|;
comment|//Do not emit the networkSessionConnected signal here, except for roaming -> connected
comment|//transition, otherwise it is emitted twice in a row when opening a connection.
if|if
condition|(
name|state
operator|==
name|QNetworkSession
operator|::
name|Connected
operator|&&
name|lastSessionState
operator|==
name|QNetworkSession
operator|::
name|Roaming
condition|)
emit|emit
name|q
operator|->
name|networkSessionConnected
argument_list|()
emit|;
name|lastSessionState
operator|=
name|state
expr_stmt|;
if|if
condition|(
name|online
condition|)
block|{
if|if
condition|(
name|state
operator|!=
name|QNetworkSession
operator|::
name|Connected
operator|&&
name|state
operator|!=
name|QNetworkSession
operator|::
name|Roaming
condition|)
block|{
name|online
operator|=
literal|false
expr_stmt|;
emit|emit
name|q
operator|->
name|networkAccessibleChanged
argument_list|(
name|QNetworkAccessManager
operator|::
name|NotAccessible
argument_list|)
emit|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|state
operator|==
name|QNetworkSession
operator|::
name|Connected
operator|||
name|state
operator|==
name|QNetworkSession
operator|::
name|Roaming
condition|)
block|{
name|online
operator|=
literal|true
expr_stmt|;
emit|emit
name|q
operator|->
name|networkAccessibleChanged
argument_list|(
name|networkAccessible
argument_list|)
emit|;
block|}
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_BEARERMANAGEMENT
end_comment
begin_function
DECL|function|prepareMultipart
name|QNetworkRequest
name|QNetworkAccessManagerPrivate
operator|::
name|prepareMultipart
parameter_list|(
specifier|const
name|QNetworkRequest
modifier|&
name|request
parameter_list|,
name|QHttpMultiPart
modifier|*
name|multiPart
parameter_list|)
block|{
comment|// copy the request, we probably need to add some headers
name|QNetworkRequest
name|newRequest
argument_list|(
name|request
argument_list|)
decl_stmt|;
comment|// add Content-Type header if not there already
if|if
condition|(
operator|!
name|request
operator|.
name|header
argument_list|(
name|QNetworkRequest
operator|::
name|ContentTypeHeader
argument_list|)
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|QByteArray
name|contentType
decl_stmt|;
name|contentType
operator|.
name|reserve
argument_list|(
literal|34
operator|+
name|multiPart
operator|->
name|d_func
argument_list|()
operator|->
name|boundary
operator|.
name|count
argument_list|()
argument_list|)
expr_stmt|;
name|contentType
operator|+=
literal|"multipart/"
expr_stmt|;
switch|switch
condition|(
name|multiPart
operator|->
name|d_func
argument_list|()
operator|->
name|contentType
condition|)
block|{
case|case
name|QHttpMultiPart
operator|::
name|RelatedType
case|:
name|contentType
operator|+=
literal|"related"
expr_stmt|;
break|break;
case|case
name|QHttpMultiPart
operator|::
name|FormDataType
case|:
name|contentType
operator|+=
literal|"form-data"
expr_stmt|;
break|break;
case|case
name|QHttpMultiPart
operator|::
name|AlternativeType
case|:
name|contentType
operator|+=
literal|"alternative"
expr_stmt|;
break|break;
default|default:
name|contentType
operator|+=
literal|"mixed"
expr_stmt|;
break|break;
block|}
comment|// putting the boundary into quotes, recommended in RFC 2046 section 5.1.1
name|contentType
operator|+=
literal|"; boundary=\""
operator|+
name|multiPart
operator|->
name|d_func
argument_list|()
operator|->
name|boundary
operator|+
literal|"\""
expr_stmt|;
name|newRequest
operator|.
name|setHeader
argument_list|(
name|QNetworkRequest
operator|::
name|ContentTypeHeader
argument_list|,
name|QVariant
argument_list|(
name|contentType
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// add MIME-Version header if not there already (we must include the header
comment|// if the message conforms to RFC 2045, see section 4 of that RFC)
name|QByteArray
name|mimeHeader
argument_list|(
literal|"MIME-Version"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|request
operator|.
name|hasRawHeader
argument_list|(
name|mimeHeader
argument_list|)
condition|)
name|newRequest
operator|.
name|setRawHeader
argument_list|(
name|mimeHeader
argument_list|,
name|QByteArray
argument_list|(
literal|"1.0"
argument_list|)
argument_list|)
expr_stmt|;
name|QIODevice
modifier|*
name|device
init|=
name|multiPart
operator|->
name|d_func
argument_list|()
operator|->
name|device
decl_stmt|;
if|if
condition|(
operator|!
name|device
operator|->
name|isReadable
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|device
operator|->
name|isOpen
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|device
operator|->
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
condition|)
name|qWarning
argument_list|(
literal|"could not open device for reading"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|qWarning
argument_list|(
literal|"device is not readable"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|newRequest
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_include
include|#
directive|include
file|"moc_qnetworkaccessmanager.cpp"
end_include
end_unit
