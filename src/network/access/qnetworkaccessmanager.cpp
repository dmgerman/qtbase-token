begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtNetwork module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qnetworkaccessmanager.h"
end_include
begin_include
include|#
directive|include
file|"qnetworkaccessmanager_p.h"
end_include
begin_include
include|#
directive|include
file|"qnetworkrequest.h"
end_include
begin_include
include|#
directive|include
file|"qnetworkreply.h"
end_include
begin_include
include|#
directive|include
file|"qnetworkreply_p.h"
end_include
begin_include
include|#
directive|include
file|"qnetworkcookie.h"
end_include
begin_include
include|#
directive|include
file|"qnetworkcookiejar.h"
end_include
begin_include
include|#
directive|include
file|"qabstractnetworkcache.h"
end_include
begin_include
include|#
directive|include
file|"QtNetwork/qnetworksession.h"
end_include
begin_include
include|#
directive|include
file|"QtNetwork/private/qsharednetworksession_p.h"
end_include
begin_include
include|#
directive|include
file|"qnetworkaccessftpbackend_p.h"
end_include
begin_include
include|#
directive|include
file|"qnetworkaccessfilebackend_p.h"
end_include
begin_include
include|#
directive|include
file|"qnetworkaccessdebugpipebackend_p.h"
end_include
begin_include
include|#
directive|include
file|"qnetworkaccesscachebackend_p.h"
end_include
begin_include
include|#
directive|include
file|"qnetworkreplydataimpl_p.h"
end_include
begin_include
include|#
directive|include
file|"qnetworkreplyfileimpl_p.h"
end_include
begin_include
include|#
directive|include
file|"QtCore/qbuffer.h"
end_include
begin_include
include|#
directive|include
file|"QtCore/qurl.h"
end_include
begin_include
include|#
directive|include
file|"QtCore/qvector.h"
end_include
begin_include
include|#
directive|include
file|"QtNetwork/private/qauthenticator_p.h"
end_include
begin_include
include|#
directive|include
file|"QtNetwork/qsslconfiguration.h"
end_include
begin_include
include|#
directive|include
file|"QtNetwork/qnetworkconfigmanager.h"
end_include
begin_include
include|#
directive|include
file|"QtNetwork/qhttpmultipart.h"
end_include
begin_include
include|#
directive|include
file|"qhttpmultipart_p.h"
end_include
begin_include
include|#
directive|include
file|"qnetworkreplyhttpimpl_p.h"
end_include
begin_include
include|#
directive|include
file|"qthread.h"
end_include
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
name|Q_GLOBAL_STATIC
argument_list|(
name|QNetworkAccessFileBackendFactory
argument_list|,
name|fileBackend
argument_list|)
ifndef|#
directive|ifndef
name|QT_NO_FTP
name|Q_GLOBAL_STATIC
argument_list|(
name|QNetworkAccessFtpBackendFactory
argument_list|,
name|ftpBackend
argument_list|)
endif|#
directive|endif
comment|// QT_NO_FTP
ifdef|#
directive|ifdef
name|QT_BUILD_INTERNAL
name|Q_GLOBAL_STATIC
argument_list|(
name|QNetworkAccessDebugPipeBackendFactory
argument_list|,
name|debugpipeBackend
argument_list|)
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_MAC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_IOS
argument_list|)
include|#
directive|include
file|<CoreServices/CoreServices.h>
include|#
directive|include
file|<SystemConfiguration/SystemConfiguration.h>
include|#
directive|include
file|<Security/SecKeychain.h>
DECL|function|getProxyAuth
name|bool
name|getProxyAuth
argument_list|(
specifier|const
name|QString
operator|&
name|proxyHostname
argument_list|,
specifier|const
name|QString
operator|&
name|scheme
argument_list|,
name|QString
operator|&
name|username
argument_list|,
name|QString
operator|&
name|password
argument_list|)
argument_list|{
name|OSStatus
name|err
argument_list|;
name|SecKeychainItemRef
name|itemRef
argument_list|;
name|bool
name|retValue
operator|=
literal|false
argument_list|;
name|SecProtocolType
name|protocolType
operator|=
name|kSecProtocolTypeAny
argument_list|;     if
operator|(
name|scheme
operator|.
name|compare
argument_list|(
name|QLatin1String
argument_list|(
literal|"ftp"
argument_list|)
argument_list|,
name|Qt
operator|::
name|CaseInsensitive
argument_list|)
operator|==
literal|0
operator|)
block|{
name|protocolType
operator|=
name|kSecProtocolTypeFTP
block|;     }
elseif|else
if|if
condition|(
name|scheme
operator|.
name|compare
argument_list|(
name|QLatin1String
argument_list|(
literal|"http"
argument_list|)
argument_list|,
name|Qt
operator|::
name|CaseInsensitive
argument_list|)
operator|==
literal|0
condition|)
block|{
name|protocolType
operator|=
name|kSecProtocolTypeHTTP
block|;     }
elseif|else
if|if
condition|(
name|scheme
operator|.
name|compare
argument_list|(
name|QLatin1String
argument_list|(
literal|"https"
argument_list|)
argument_list|,
name|Qt
operator|::
name|CaseInsensitive
argument_list|)
operator|==
literal|0
condition|)
block|{
name|protocolType
operator|=
name|kSecProtocolTypeHTTPS
block|;     }
name|QByteArray
name|proxyHostnameUtf8
argument_list|(
name|proxyHostname
operator|.
name|toUtf8
argument_list|()
argument_list|)
expr_stmt|;
end_decl_stmt
begin_expr_stmt
name|err
operator|=
name|SecKeychainFindInternetPassword
argument_list|(
name|NULL
argument_list|,
name|proxyHostnameUtf8
operator|.
name|length
argument_list|()
argument_list|,
name|proxyHostnameUtf8
operator|.
name|constData
argument_list|()
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|protocolType
argument_list|,
name|kSecAuthenticationTypeAny
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|itemRef
argument_list|)
expr_stmt|;
end_expr_stmt
begin_if
if|if
condition|(
name|err
operator|==
name|noErr
condition|)
block|{
name|SecKeychainAttribute
name|attr
decl_stmt|;
name|SecKeychainAttributeList
name|attrList
decl_stmt|;
name|UInt32
name|length
decl_stmt|;
name|void
modifier|*
name|outData
decl_stmt|;
name|attr
operator|.
name|tag
operator|=
name|kSecAccountItemAttr
expr_stmt|;
name|attr
operator|.
name|length
operator|=
literal|0
expr_stmt|;
name|attr
operator|.
name|data
operator|=
name|NULL
expr_stmt|;
name|attrList
operator|.
name|count
operator|=
literal|1
expr_stmt|;
name|attrList
operator|.
name|attr
operator|=
operator|&
name|attr
expr_stmt|;
if|if
condition|(
name|SecKeychainItemCopyContent
argument_list|(
name|itemRef
argument_list|,
name|NULL
argument_list|,
operator|&
name|attrList
argument_list|,
operator|&
name|length
argument_list|,
operator|&
name|outData
argument_list|)
operator|==
name|noErr
condition|)
block|{
name|username
operator|=
name|QString
operator|::
name|fromUtf8
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|attr
operator|.
name|data
argument_list|,
name|attr
operator|.
name|length
argument_list|)
expr_stmt|;
name|password
operator|=
name|QString
operator|::
name|fromUtf8
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|outData
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|SecKeychainItemFreeContent
argument_list|(
operator|&
name|attrList
argument_list|,
name|outData
argument_list|)
expr_stmt|;
name|retValue
operator|=
literal|true
expr_stmt|;
block|}
name|CFRelease
argument_list|(
name|itemRef
argument_list|)
expr_stmt|;
block|}
end_if
begin_return
return|return
name|retValue
return|;
end_return
begin_endif
unit|}
endif|#
directive|endif
end_endif
begin_function
unit|static
DECL|function|ensureInitialized
name|void
name|ensureInitialized
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|QT_NO_FTP
operator|(
name|void
operator|)
name|ftpBackend
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|QT_BUILD_INTERNAL
operator|(
name|void
operator|)
name|debugpipeBackend
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|// leave this one last since it will query the special QAbstractFileEngines
operator|(
name|void
operator|)
name|fileBackend
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \class QNetworkAccessManager     \brief The QNetworkAccessManager class allows the application to     send network requests and receive replies     \since 4.4      \ingroup network     \inmodule QtNetwork     \reentrant      The Network Access API is constructed around one QNetworkAccessManager     object, which holds the common configuration and settings for the requests     it sends. It contains the proxy and cache configuration, as well as the     signals related to such issues, and reply signals that can be used to     monitor the progress of a network operation. One QNetworkAccessManager     should be enough for the whole Qt application.      Once a QNetworkAccessManager object has been created, the application can     use it to send requests over the network. A group of standard functions     are supplied that take a request and optional data, and each return a     QNetworkReply object. The returned object is used to obtain any data     returned in response to the corresponding request.      A simple download off the network could be accomplished with:     \snippet code/src_network_access_qnetworkaccessmanager.cpp 0      QNetworkAccessManager has an asynchronous API.     When the \tt replyFinished slot above is called, the parameter it     takes is the QNetworkReply object containing the downloaded data     as well as meta-data (headers, etc.).      \note After the request has finished, it is the responsibility of the user     to delete the QNetworkReply object at an appropriate time. Do not directly     delete it inside the slot connected to finished(). You can use the     deleteLater() function.      \note QNetworkAccessManager queues the requests it receives. The number     of requests executed in parallel is dependent on the protocol.     Currently, for the HTTP protocol on desktop platforms, 6 requests are     executed in parallel for one host/port combination.      A more involved example, assuming the manager is already existent,     can be:     \snippet code/src_network_access_qnetworkaccessmanager.cpp 1      \section1 Network and Roaming support      With the addition of the \l {Bearer Management} API to Qt 4.7     QNetworkAccessManager gained the ability to manage network connections.     QNetworkAccessManager can start the network interface if the device is     offline and terminates the interface if the current process is the last     one to use the uplink. Note that some platforms utilize grace periods from     when the last application stops using a uplink until the system actually     terminates the connectivity link. Roaming is equally transparent. Any     queued/pending network requests are automatically transferred to the new     access point.      Clients wanting to utilize this feature should not require any changes. In fact     it is likely that existing platform specific connection code can simply be     removed from the application.      \note The network and roaming support in QNetworkAccessManager is conditional     upon the platform supporting connection management. The     \l QNetworkConfigurationManager::NetworkSessionRequired can be used to     detect whether QNetworkAccessManager utilizes this feature. Currently only     Meego/Harmattan platforms provide connection management support.      \note This feature cannot be used in combination with the Bearer Management     API as provided by QtMobility. Applications have to migrate to the Qt version     of Bearer Management.      \sa QNetworkRequest, QNetworkReply, QNetworkProxy */
end_comment
begin_comment
comment|/*!     \enum QNetworkAccessManager::Operation      Indicates the operation this reply is processing.      \value HeadOperation        retrieve headers operation (created     with head())      \value GetOperation         retrieve headers and download contents     (created with get())      \value PutOperation         upload contents operation (created     with put())      \value PostOperation        send the contents of an HTML form for     processing via HTTP POST (created with post())      \value DeleteOperation      delete contents operation (created with     deleteResource())      \value CustomOperation      custom operation (created with     sendCustomRequest())    \since 4.7      \omitvalue UnknownOperation      \sa QNetworkReply::operation() */
end_comment
begin_comment
comment|/*!     \enum QNetworkAccessManager::NetworkAccessibility      Indicates whether the network is accessible via this network access manager.      \value UnknownAccessibility     The network accessibility cannot be determined.     \value NotAccessible            The network is not currently accessible, either because there                                     is currently no network coverage or network access has been                                     explicitly disabled by a call to setNetworkAccessible().     \value Accessible               The network is accessible.      \sa networkAccessible */
end_comment
begin_comment
comment|/*!     \property QNetworkAccessManager::networkAccessible     \brief whether the network is currently accessible via this network access manager.      \since 4.7      If the network is \l {NotAccessible}{not accessible} the network access manager will not     process any new network requests, all such requests will fail with an error.  Requests with     URLs with the file:// scheme will still be processed.      By default the value of this property reflects the physical state of the device.  Applications     may override it to disable all network requests via this network access manager by calling      \snippet code/src_network_access_qnetworkaccessmanager.cpp 4      Network requests can be reenabled again by calling      \snippet code/src_network_access_qnetworkaccessmanager.cpp 5      \note Calling setNetworkAccessible() does not change the network state. */
end_comment
begin_comment
comment|/*!     \fn void QNetworkAccessManager::networkAccessibleChanged(QNetworkAccessManager::NetworkAccessibility accessible)      This signal is emitted when the value of the \l networkAccessible property changes.     \a accessible is the new network accessibility. */
end_comment
begin_comment
comment|/*!     \fn void QNetworkAccessManager::networkSessionConnected()      \since 4.7      \internal      This signal is emitted when the status of the network session changes into a usable (Connected)     state. It is used to signal to QNetworkReplys to start or migrate their network operation once     the network session has been opened or finished roaming. */
end_comment
begin_comment
comment|/*!     \fn void QNetworkAccessManager::proxyAuthenticationRequired(const QNetworkProxy&proxy, QAuthenticator *authenticator)      This signal is emitted whenever a proxy requests authentication     and QNetworkAccessManager cannot find a valid, cached     credential. The slot connected to this signal should fill in the     credentials for the proxy \a proxy in the \a authenticator object.      QNetworkAccessManager will cache the credentials internally. The     next time the proxy requests authentication, QNetworkAccessManager     will automatically send the same credential without emitting the     proxyAuthenticationRequired signal again.      If the proxy rejects the credentials, QNetworkAccessManager will     emit the signal again.      \sa proxy(), setProxy(), authenticationRequired() */
end_comment
begin_comment
comment|/*!     \fn void QNetworkAccessManager::authenticationRequired(QNetworkReply *reply, QAuthenticator *authenticator)      This signal is emitted whenever a final server requests     authentication before it delivers the requested contents. The slot     connected to this signal should fill the credentials for the     contents (which can be determined by inspecting the \a reply     object) in the \a authenticator object.      QNetworkAccessManager will cache the credentials internally and     will send the same values if the server requires authentication     again, without emitting the authenticationRequired() signal. If it     rejects the credentials, this signal will be emitted again.      \note To have the request not send credentials you must not call     setUser() or setPassword() on the \a authenticator object. This     will result in the \l finished() signal being emitted with a     \l QNetworkReply with error \l {QNetworkReply::} {AuthenticationRequiredError}.      \note It is not possible to use a QueuedConnection to connect to     this signal, as the connection will fail if the authenticator has     not been filled in with new information when the signal returns.      \sa proxyAuthenticationRequired(), QAuthenticator::setUser(), QAuthenticator::setPassword() */
end_comment
begin_comment
comment|/*!     \fn void QNetworkAccessManager::finished(QNetworkReply *reply)      This signal is emitted whenever a pending network reply is     finished. The \a reply parameter will contain a pointer to the     reply that has just finished. This signal is emitted in tandem     with the QNetworkReply::finished() signal.      See QNetworkReply::finished() for information on the status that     the object will be in.      \note Do not delete the \a reply object in the slot connected to this     signal. Use deleteLater().      \sa QNetworkReply::finished(), QNetworkReply::error() */
end_comment
begin_comment
comment|/*!     \fn void QNetworkAccessManager::encrypted(QNetworkReply *reply)     \since 5.1      This signal is emitted when an SSL/TLS session has successfully     completed the initial handshake. At this point, no user data     has been transmitted. The signal can be used to perform     additional checks on the certificate chain, for example to     notify users when the certificate for a website has changed. The     \a reply parameter specifies which network reply is responsible.     If the reply does not match the expected criteria then it should     be aborted by calling QNetworkReply::abort() by a slot connected     to this signal. The SSL configuration in use can be inspected     using the QNetworkReply::sslConfiguration() method.      Internally, QNetworkAccessManager may open multiple connections     to a server, in order to allow it process requests in parallel.     These connections may be reused, which means that the encrypted()     signal would not be emitted. This means that you are only     guaranteed to receive this signal for the first connection to a     site in the lifespan of the QNetworkAccessManager.      \sa QSslSocket::encrypted()     \sa QNetworkReply::encrypted() */
end_comment
begin_comment
comment|/*!     \fn void QNetworkAccessManager::sslErrors(QNetworkReply *reply, const QList<QSslError>&errors)      This signal is emitted if the SSL/TLS session encountered errors     during the set up, including certificate verification errors. The     \a errors parameter contains the list of errors and \a reply is     the QNetworkReply that is encountering these errors.      To indicate that the errors are not fatal and that the connection     should proceed, the QNetworkReply::ignoreSslErrors() function should be called     from the slot connected to this signal. If it is not called, the     SSL session will be torn down before any data is exchanged     (including the URL).      This signal can be used to display an error message to the user     indicating that security may be compromised and display the     SSL settings (see sslConfiguration() to obtain it). If the user     decides to proceed after analyzing the remote certificate, the     slot should call ignoreSslErrors().      \sa QSslSocket::sslErrors(), QNetworkReply::sslErrors(),     QNetworkReply::sslConfiguration(), QNetworkReply::ignoreSslErrors() */
end_comment
begin_comment
comment|/*!     Constructs a QNetworkAccessManager object that is the center of     the Network Access API and sets \a parent as the parent object. */
end_comment
begin_constructor
DECL|function|QNetworkAccessManager
name|QNetworkAccessManager
operator|::
name|QNetworkAccessManager
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|new
name|QNetworkAccessManagerPrivate
argument_list|,
name|parent
argument_list|)
block|{
name|Q_D
argument_list|(
name|QNetworkAccessManager
argument_list|)
expr_stmt|;
name|ensureInitialized
argument_list|()
expr_stmt|;
name|qRegisterMetaType
argument_list|<
name|QNetworkReply
operator|::
name|NetworkError
argument_list|>
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
name|qRegisterMetaType
argument_list|<
name|QNetworkProxy
argument_list|>
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_SSL
name|qRegisterMetaType
argument_list|<
name|QList
argument_list|<
name|QSslError
argument_list|>
argument_list|>
argument_list|()
expr_stmt|;
name|qRegisterMetaType
argument_list|<
name|QSslConfiguration
argument_list|>
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|qRegisterMetaType
argument_list|<
name|QList
argument_list|<
name|QPair
argument_list|<
name|QByteArray
argument_list|,
name|QByteArray
argument_list|>
argument_list|>
argument_list|>
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_HTTP
name|qRegisterMetaType
argument_list|<
name|QHttpNetworkRequest
argument_list|>
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|qRegisterMetaType
argument_list|<
name|QNetworkReply
operator|::
name|NetworkError
argument_list|>
argument_list|()
expr_stmt|;
name|qRegisterMetaType
argument_list|<
name|QSharedPointer
argument_list|<
name|char
argument_list|>
argument_list|>
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_BEARERMANAGEMENT
if|if
condition|(
operator|!
name|d
operator|->
name|networkSessionRequired
condition|)
block|{
comment|// if a session is required, we track online state through
comment|// the QNetworkSession's signals
name|connect
argument_list|(
operator|&
name|d
operator|->
name|networkConfigurationManager
argument_list|,
name|SIGNAL
argument_list|(
name|onlineStateChanged
argument_list|(
name|bool
argument_list|)
argument_list|)
argument_list|,
name|SLOT
argument_list|(
name|_q_onlineStateChanged
argument_list|(
name|bool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// we would need all active configurations to check for
comment|// d->networkConfigurationManager.isOnline(), which is asynchronous
comment|// and potentially expensive. We can just check the configuration here
name|d
operator|->
name|online
operator|=
operator|(
name|d
operator|->
name|networkConfiguration
operator|.
name|state
argument_list|()
operator|&
name|QNetworkConfiguration
operator|::
name|Active
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_constructor
begin_comment
comment|/*!     Destroys the QNetworkAccessManager object and frees up any     resources. Note that QNetworkReply objects that are returned from     this class have this object set as their parents, which means that     they will be deleted along with it if you don't call     QObject::setParent() on them. */
end_comment
begin_destructor
DECL|function|~QNetworkAccessManager
name|QNetworkAccessManager
operator|::
name|~
name|QNetworkAccessManager
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
operator|delete
name|d_func
argument_list|()
operator|->
name|proxyFactory
expr_stmt|;
endif|#
directive|endif
comment|// Delete the QNetworkReply children first.
comment|// Else a QAbstractNetworkCache might get deleted in ~QObject
comment|// before a QNetworkReply that accesses the QAbstractNetworkCache
comment|// object in its destructor.
name|qDeleteAll
argument_list|(
name|findChildren
argument_list|<
name|QNetworkReply
operator|*
argument_list|>
argument_list|()
argument_list|)
expr_stmt|;
comment|// The other children will be deleted in this ~QObject
comment|// FIXME instead of this "hack" make the QNetworkReplyImpl
comment|// properly watch the cache deletion, e.g. via a QWeakPointer.
block|}
end_destructor
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
end_ifndef
begin_comment
comment|/*!     Returns the QNetworkProxy that the requests sent using this     QNetworkAccessManager object will use. The default value for the     proxy is QNetworkProxy::DefaultProxy.      \sa setProxy(), setProxyFactory(), proxyAuthenticationRequired() */
end_comment
begin_function
DECL|function|proxy
name|QNetworkProxy
name|QNetworkAccessManager
operator|::
name|proxy
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|proxy
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the proxy to be used in future requests to be \a proxy. This     does not affect requests that have already been sent. The     proxyAuthenticationRequired() signal will be emitted if the proxy     requests authentication.      A proxy set with this function will be used for all requests     issued by QNetworkAccessManager. In some cases, it might be     necessary to select different proxies depending on the type of     request being sent or the destination host. If that's the case,     you should consider using setProxyFactory().      \sa proxy(), proxyAuthenticationRequired() */
end_comment
begin_function
DECL|function|setProxy
name|void
name|QNetworkAccessManager
operator|::
name|setProxy
parameter_list|(
specifier|const
name|QNetworkProxy
modifier|&
name|proxy
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QNetworkAccessManager
argument_list|)
expr_stmt|;
operator|delete
name|d
operator|->
name|proxyFactory
expr_stmt|;
name|d
operator|->
name|proxy
operator|=
name|proxy
expr_stmt|;
name|d
operator|->
name|proxyFactory
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn QNetworkProxyFactory *QNetworkAccessManager::proxyFactory() const     \since 4.5      Returns the proxy factory that this QNetworkAccessManager object     is using to determine the proxies to be used for requests.      Note that the pointer returned by this function is managed by     QNetworkAccessManager and could be deleted at any time.      \sa setProxyFactory(), proxy() */
end_comment
begin_function
DECL|function|proxyFactory
name|QNetworkProxyFactory
modifier|*
name|QNetworkAccessManager
operator|::
name|proxyFactory
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|proxyFactory
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5      Sets the proxy factory for this class to be \a factory. A proxy     factory is used to determine a more specific list of proxies to be     used for a given request, instead of trying to use the same proxy     value for all requests.      All queries sent by QNetworkAccessManager will have type     QNetworkProxyQuery::UrlRequest.      For example, a proxy factory could apply the following rules:     \list       \li if the target address is in the local network (for example,          if the hostname contains no dots or if it's an IP address in          the organization's range), return QNetworkProxy::NoProxy       \li if the request is FTP, return an FTP proxy       \li if the request is HTTP or HTTPS, then return an HTTP proxy       \li otherwise, return a SOCKSv5 proxy server     \endlist      The lifetime of the object \a factory will be managed by     QNetworkAccessManager. It will delete the object when necessary.      \note If a specific proxy is set with setProxy(), the factory will not     be used.      \sa proxyFactory(), setProxy(), QNetworkProxyQuery */
end_comment
begin_function
DECL|function|setProxyFactory
name|void
name|QNetworkAccessManager
operator|::
name|setProxyFactory
parameter_list|(
name|QNetworkProxyFactory
modifier|*
name|factory
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QNetworkAccessManager
argument_list|)
expr_stmt|;
operator|delete
name|d
operator|->
name|proxyFactory
expr_stmt|;
name|d
operator|->
name|proxyFactory
operator|=
name|factory
expr_stmt|;
name|d
operator|->
name|proxy
operator|=
name|QNetworkProxy
argument_list|()
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \since 4.5      Returns the cache that is used to store data obtained from the network.      \sa setCache() */
end_comment
begin_function
DECL|function|cache
name|QAbstractNetworkCache
modifier|*
name|QNetworkAccessManager
operator|::
name|cache
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QNetworkAccessManager
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|networkCache
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5      Sets the manager's network cache to be the \a cache specified. The cache     is used for all requests dispatched by the manager.      Use this function to set the network cache object to a class that implements     additional features, like saving the cookies to permanent storage.      \note QNetworkAccessManager takes ownership of the \a cache object.      QNetworkAccessManager by default does not have a set cache.     Qt provides a simple disk cache, QNetworkDiskCache, which can be used.      \sa cache(), QNetworkRequest::CacheLoadControl */
end_comment
begin_function
DECL|function|setCache
name|void
name|QNetworkAccessManager
operator|::
name|setCache
parameter_list|(
name|QAbstractNetworkCache
modifier|*
name|cache
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QNetworkAccessManager
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|networkCache
operator|!=
name|cache
condition|)
block|{
operator|delete
name|d
operator|->
name|networkCache
expr_stmt|;
name|d
operator|->
name|networkCache
operator|=
name|cache
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|networkCache
condition|)
name|d
operator|->
name|networkCache
operator|->
name|setParent
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Returns the QNetworkCookieJar that is used to store cookies     obtained from the network as well as cookies that are about to be     sent.      \sa setCookieJar() */
end_comment
begin_function
DECL|function|cookieJar
name|QNetworkCookieJar
modifier|*
name|QNetworkAccessManager
operator|::
name|cookieJar
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QNetworkAccessManager
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|cookieJar
condition|)
name|d
operator|->
name|createCookieJar
argument_list|()
expr_stmt|;
return|return
name|d
operator|->
name|cookieJar
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the manager's cookie jar to be the \a cookieJar specified.     The cookie jar is used by all requests dispatched by the manager.      Use this function to set the cookie jar object to a class that     implements additional features, like saving the cookies to permanent     storage.      \note QNetworkAccessManager takes ownership of the \a cookieJar object.      If \a cookieJar is in the same thread as this QNetworkAccessManager,     it will set the parent of the \a cookieJar     so that the cookie jar is deleted when this     object is deleted as well. If you want to share cookie jars     between different QNetworkAccessManager objects, you may want to     set the cookie jar's parent to 0 after calling this function.      QNetworkAccessManager by default does not implement any cookie     policy of its own: it accepts all cookies sent by the server, as     long as they are well formed and meet the minimum security     requirements (cookie domain matches the request's and cookie path     matches the request's). In order to implement your own security     policy, override the QNetworkCookieJar::cookiesForUrl() and     QNetworkCookieJar::setCookiesFromUrl() virtual functions. Those     functions are called by QNetworkAccessManager when it detects a     new cookie.      \sa cookieJar(), QNetworkCookieJar::cookiesForUrl(), QNetworkCookieJar::setCookiesFromUrl() */
end_comment
begin_function
DECL|function|setCookieJar
name|void
name|QNetworkAccessManager
operator|::
name|setCookieJar
parameter_list|(
name|QNetworkCookieJar
modifier|*
name|cookieJar
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QNetworkAccessManager
argument_list|)
expr_stmt|;
name|d
operator|->
name|cookieJarCreated
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|cookieJar
operator|!=
name|cookieJar
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|cookieJar
operator|&&
name|d
operator|->
name|cookieJar
operator|->
name|parent
argument_list|()
operator|==
name|this
condition|)
operator|delete
name|d
operator|->
name|cookieJar
expr_stmt|;
name|d
operator|->
name|cookieJar
operator|=
name|cookieJar
expr_stmt|;
if|if
condition|(
name|thread
argument_list|()
operator|==
name|cookieJar
operator|->
name|thread
argument_list|()
condition|)
name|d
operator|->
name|cookieJar
operator|->
name|setParent
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Posts a request to obtain the network headers for \a request     and returns a new QNetworkReply object which will contain such headers.      The function is named after the HTTP request associated (HEAD). */
end_comment
begin_function
DECL|function|head
name|QNetworkReply
modifier|*
name|QNetworkAccessManager
operator|::
name|head
parameter_list|(
specifier|const
name|QNetworkRequest
modifier|&
name|request
parameter_list|)
block|{
return|return
name|d_func
argument_list|()
operator|->
name|postProcess
argument_list|(
name|createRequest
argument_list|(
name|QNetworkAccessManager
operator|::
name|HeadOperation
argument_list|,
name|request
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Posts a request to obtain the contents of the target \a request     and returns a new QNetworkReply object opened for reading which emits the     \l{QIODevice::readyRead()}{readyRead()} signal whenever new data     arrives.      The contents as well as associated headers will be downloaded.      \sa post(), put(), deleteResource(), sendCustomRequest() */
end_comment
begin_function
DECL|function|get
name|QNetworkReply
modifier|*
name|QNetworkAccessManager
operator|::
name|get
parameter_list|(
specifier|const
name|QNetworkRequest
modifier|&
name|request
parameter_list|)
block|{
return|return
name|d_func
argument_list|()
operator|->
name|postProcess
argument_list|(
name|createRequest
argument_list|(
name|QNetworkAccessManager
operator|::
name|GetOperation
argument_list|,
name|request
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Sends an HTTP POST request to the destination specified by \a request     and returns a new QNetworkReply object opened for reading that will     contain the reply sent by the server. The contents of  the \a data     device will be uploaded to the server.      \a data must be open for reading and must remain valid until the     finished() signal is emitted for this reply.      \note Sending a POST request on protocols other than HTTP and     HTTPS is undefined and will probably fail.      \sa get(), put(), deleteResource(), sendCustomRequest() */
end_comment
begin_function
DECL|function|post
name|QNetworkReply
modifier|*
name|QNetworkAccessManager
operator|::
name|post
parameter_list|(
specifier|const
name|QNetworkRequest
modifier|&
name|request
parameter_list|,
name|QIODevice
modifier|*
name|data
parameter_list|)
block|{
return|return
name|d_func
argument_list|()
operator|->
name|postProcess
argument_list|(
name|createRequest
argument_list|(
name|QNetworkAccessManager
operator|::
name|PostOperation
argument_list|,
name|request
argument_list|,
name|data
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Sends the contents of the \a data byte array to the destination     specified by \a request. */
end_comment
begin_function
DECL|function|post
name|QNetworkReply
modifier|*
name|QNetworkAccessManager
operator|::
name|post
parameter_list|(
specifier|const
name|QNetworkRequest
modifier|&
name|request
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|data
parameter_list|)
block|{
name|QBuffer
modifier|*
name|buffer
init|=
operator|new
name|QBuffer
decl_stmt|;
name|buffer
operator|->
name|setData
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|buffer
operator|->
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
expr_stmt|;
name|QNetworkReply
modifier|*
name|reply
init|=
name|post
argument_list|(
name|request
argument_list|,
name|buffer
argument_list|)
decl_stmt|;
name|buffer
operator|->
name|setParent
argument_list|(
name|reply
argument_list|)
expr_stmt|;
return|return
name|reply
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.8      \overload      Sends the contents of the \a multiPart message to the destination     specified by \a request.      This can be used for sending MIME multipart messages over HTTP.      \sa QHttpMultiPart, QHttpPart, put() */
end_comment
begin_function
DECL|function|post
name|QNetworkReply
modifier|*
name|QNetworkAccessManager
operator|::
name|post
parameter_list|(
specifier|const
name|QNetworkRequest
modifier|&
name|request
parameter_list|,
name|QHttpMultiPart
modifier|*
name|multiPart
parameter_list|)
block|{
name|QNetworkRequest
name|newRequest
init|=
name|d_func
argument_list|()
operator|->
name|prepareMultipart
argument_list|(
name|request
argument_list|,
name|multiPart
argument_list|)
decl_stmt|;
name|QIODevice
modifier|*
name|device
init|=
name|multiPart
operator|->
name|d_func
argument_list|()
operator|->
name|device
decl_stmt|;
name|QNetworkReply
modifier|*
name|reply
init|=
name|post
argument_list|(
name|newRequest
argument_list|,
name|device
argument_list|)
decl_stmt|;
return|return
name|reply
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.8      \overload      Sends the contents of the \a multiPart message to the destination     specified by \a request.      This can be used for sending MIME multipart messages over HTTP.      \sa QHttpMultiPart, QHttpPart, post() */
end_comment
begin_function
DECL|function|put
name|QNetworkReply
modifier|*
name|QNetworkAccessManager
operator|::
name|put
parameter_list|(
specifier|const
name|QNetworkRequest
modifier|&
name|request
parameter_list|,
name|QHttpMultiPart
modifier|*
name|multiPart
parameter_list|)
block|{
name|QNetworkRequest
name|newRequest
init|=
name|d_func
argument_list|()
operator|->
name|prepareMultipart
argument_list|(
name|request
argument_list|,
name|multiPart
argument_list|)
decl_stmt|;
name|QIODevice
modifier|*
name|device
init|=
name|multiPart
operator|->
name|d_func
argument_list|()
operator|->
name|device
decl_stmt|;
name|QNetworkReply
modifier|*
name|reply
init|=
name|put
argument_list|(
name|newRequest
argument_list|,
name|device
argument_list|)
decl_stmt|;
return|return
name|reply
return|;
block|}
end_function
begin_comment
comment|/*!     Uploads the contents of \a data to the destination \a request and     returnes a new QNetworkReply object that will be open for reply.      \a data must be opened for reading when this function is called     and must remain valid until the finished() signal is emitted for     this reply.      Whether anything will be available for reading from the returned     object is protocol dependent. For HTTP, the server may send a     small HTML page indicating the upload was successful (or not).     Other protocols will probably have content in their replies.      \note For HTTP, this request will send a PUT request, which most servers     do not allow. Form upload mechanisms, including that of uploading     files through HTML forms, use the POST mechanism.      \sa get(), post(), deleteResource(), sendCustomRequest() */
end_comment
begin_function
DECL|function|put
name|QNetworkReply
modifier|*
name|QNetworkAccessManager
operator|::
name|put
parameter_list|(
specifier|const
name|QNetworkRequest
modifier|&
name|request
parameter_list|,
name|QIODevice
modifier|*
name|data
parameter_list|)
block|{
return|return
name|d_func
argument_list|()
operator|->
name|postProcess
argument_list|(
name|createRequest
argument_list|(
name|QNetworkAccessManager
operator|::
name|PutOperation
argument_list|,
name|request
argument_list|,
name|data
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \overload      Sends the contents of the \a data byte array to the destination     specified by \a request. */
end_comment
begin_function
DECL|function|put
name|QNetworkReply
modifier|*
name|QNetworkAccessManager
operator|::
name|put
parameter_list|(
specifier|const
name|QNetworkRequest
modifier|&
name|request
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|data
parameter_list|)
block|{
name|QBuffer
modifier|*
name|buffer
init|=
operator|new
name|QBuffer
decl_stmt|;
name|buffer
operator|->
name|setData
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|buffer
operator|->
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
expr_stmt|;
name|QNetworkReply
modifier|*
name|reply
init|=
name|put
argument_list|(
name|request
argument_list|,
name|buffer
argument_list|)
decl_stmt|;
name|buffer
operator|->
name|setParent
argument_list|(
name|reply
argument_list|)
expr_stmt|;
return|return
name|reply
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.6      Sends a request to delete the resource identified by the URL of \a request.      \note This feature is currently available for HTTP only, performing an     HTTP DELETE request.      \sa get(), post(), put(), sendCustomRequest() */
end_comment
begin_function
DECL|function|deleteResource
name|QNetworkReply
modifier|*
name|QNetworkAccessManager
operator|::
name|deleteResource
parameter_list|(
specifier|const
name|QNetworkRequest
modifier|&
name|request
parameter_list|)
block|{
return|return
name|d_func
argument_list|()
operator|->
name|postProcess
argument_list|(
name|createRequest
argument_list|(
name|QNetworkAccessManager
operator|::
name|DeleteOperation
argument_list|,
name|request
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_BEARERMANAGEMENT
end_ifndef
begin_comment
comment|/*!     \since 4.7      Sets the network configuration that will be used when creating the     \l {QNetworkSession}{network session} to \a config.      The network configuration is used to create and open a network session before any request that     requires network access is process.  If no network configuration is explicitly set via this     function the network configuration returned by     QNetworkConfigurationManager::defaultConfiguration() will be used.      To restore the default network configuration set the network configuration to the value     returned from QNetworkConfigurationManager::defaultConfiguration().      Setting a network configuration means that the QNetworkAccessManager instance will only     be using the specified one. In particular, if the default network configuration changes     (upon e.g. Wifi being available), this new configuration needs to be enabled     manually if desired.      \snippet code/src_network_access_qnetworkaccessmanager.cpp 2      If an invalid network configuration is set, a network session will not be created.  In this     case network requests will be processed regardless, but may fail.  For example:      \snippet code/src_network_access_qnetworkaccessmanager.cpp 3      \sa configuration(), QNetworkSession */
end_comment
begin_function
DECL|function|setConfiguration
name|void
name|QNetworkAccessManager
operator|::
name|setConfiguration
parameter_list|(
specifier|const
name|QNetworkConfiguration
modifier|&
name|config
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QNetworkAccessManager
argument_list|)
expr_stmt|;
name|d
operator|->
name|networkConfiguration
operator|=
name|config
expr_stmt|;
name|d
operator|->
name|customNetworkConfiguration
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|createSession
argument_list|(
name|config
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.7      Returns the network configuration that will be used to create the     \l {QNetworkSession}{network session} which will be used when processing network requests.      \sa setConfiguration(), activeConfiguration() */
end_comment
begin_function
DECL|function|configuration
name|QNetworkConfiguration
name|QNetworkAccessManager
operator|::
name|configuration
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QNetworkAccessManager
argument_list|)
expr_stmt|;
name|QSharedPointer
argument_list|<
name|QNetworkSession
argument_list|>
name|session
argument_list|(
name|d
operator|->
name|getNetworkSession
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|session
condition|)
block|{
return|return
name|session
operator|->
name|configuration
argument_list|()
return|;
block|}
else|else
block|{
name|QNetworkConfigurationManager
name|manager
decl_stmt|;
return|return
name|manager
operator|.
name|defaultConfiguration
argument_list|()
return|;
block|}
block|}
end_function
begin_comment
comment|/*!     \since 4.7      Returns the current active network configuration.      If the network configuration returned by configuration() is of type     QNetworkConfiguration::ServiceNetwork this function will return the current active child     network configuration of that configuration.  Otherwise returns the same network configuration     as configuration().      Use this function to return the actual network configuration currently in use by the network     session.      \sa configuration() */
end_comment
begin_function
DECL|function|activeConfiguration
name|QNetworkConfiguration
name|QNetworkAccessManager
operator|::
name|activeConfiguration
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QNetworkAccessManager
argument_list|)
expr_stmt|;
name|QSharedPointer
argument_list|<
name|QNetworkSession
argument_list|>
name|networkSession
argument_list|(
name|d
operator|->
name|getNetworkSession
argument_list|()
argument_list|)
decl_stmt|;
name|QNetworkConfigurationManager
name|manager
decl_stmt|;
if|if
condition|(
name|networkSession
condition|)
block|{
return|return
name|manager
operator|.
name|configurationFromIdentifier
argument_list|(
name|networkSession
operator|->
name|sessionProperty
argument_list|(
name|QLatin1String
argument_list|(
literal|"ActiveConfiguration"
argument_list|)
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|manager
operator|.
name|defaultConfiguration
argument_list|()
return|;
block|}
block|}
end_function
begin_comment
comment|/*!     \since 4.7      Overrides the reported network accessibility.  If \a accessible is NotAccessible the reported     network accessiblity will always be NotAccessible.  Otherwise the reported network     accessibility will reflect the actual device state. */
end_comment
begin_function
DECL|function|setNetworkAccessible
name|void
name|QNetworkAccessManager
operator|::
name|setNetworkAccessible
parameter_list|(
name|QNetworkAccessManager
operator|::
name|NetworkAccessibility
name|accessible
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QNetworkAccessManager
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|networkAccessible
operator|!=
name|accessible
condition|)
block|{
name|NetworkAccessibility
name|previous
init|=
name|networkAccessible
argument_list|()
decl_stmt|;
name|d
operator|->
name|networkAccessible
operator|=
name|accessible
expr_stmt|;
name|NetworkAccessibility
name|current
init|=
name|networkAccessible
argument_list|()
decl_stmt|;
if|if
condition|(
name|previous
operator|!=
name|current
condition|)
emit|emit
name|networkAccessibleChanged
argument_list|(
name|current
argument_list|)
emit|;
block|}
block|}
end_function
begin_comment
comment|/*!     \since 4.7      Returns the current network accessibility. */
end_comment
begin_function
DECL|function|networkAccessible
name|QNetworkAccessManager
operator|::
name|NetworkAccessibility
name|QNetworkAccessManager
operator|::
name|networkAccessible
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QNetworkAccessManager
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|networkSessionRequired
condition|)
block|{
name|QSharedPointer
argument_list|<
name|QNetworkSession
argument_list|>
name|networkSession
argument_list|(
name|d
operator|->
name|getNetworkSession
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|networkSession
condition|)
block|{
comment|// d->online holds online/offline state of this network session.
if|if
condition|(
name|d
operator|->
name|online
condition|)
return|return
name|d
operator|->
name|networkAccessible
return|;
else|else
return|return
name|NotAccessible
return|;
block|}
else|else
block|{
comment|// Network accessibility is either disabled or unknown.
return|return
operator|(
name|d
operator|->
name|networkAccessible
operator|==
name|NotAccessible
operator|)
condition|?
name|NotAccessible
else|:
name|UnknownAccessibility
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|d
operator|->
name|online
condition|)
return|return
name|d
operator|->
name|networkAccessible
return|;
else|else
return|return
name|NotAccessible
return|;
block|}
block|}
end_function
begin_comment
comment|/*!     \internal      Returns the network session currently in use.     This can be changed at any time, ownership remains with the QNetworkAccessManager */
end_comment
begin_function
DECL|function|getNetworkSession
specifier|const
name|QWeakPointer
argument_list|<
specifier|const
name|QNetworkSession
argument_list|>
name|QNetworkAccessManagerPrivate
operator|::
name|getNetworkSession
parameter_list|(
specifier|const
name|QNetworkAccessManager
modifier|*
name|q
parameter_list|)
block|{
return|return
name|q
operator|->
name|d_func
argument_list|()
operator|->
name|networkSessionWeakRef
return|;
block|}
end_function
begin_function
DECL|function|getNetworkSession
name|QSharedPointer
argument_list|<
name|QNetworkSession
argument_list|>
name|QNetworkAccessManagerPrivate
operator|::
name|getNetworkSession
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|networkSessionStrongRef
condition|)
return|return
name|networkSessionStrongRef
return|;
return|return
name|networkSessionWeakRef
operator|.
name|toStrongRef
argument_list|()
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_BEARERMANAGEMENT
end_comment
begin_comment
comment|/*!     \since 4.7      Sends a custom request to the server identified by the URL of \a request.      It is the user's responsibility to send a \a verb to the server that is valid     according to the HTTP specification.      This method provides means to send verbs other than the common ones provided     via get() or post() etc., for instance sending an HTTP OPTIONS command.      If \a data is not empty, the contents of the \a data     device will be uploaded to the server; in that case, data must be open for     reading and must remain valid until the finished() signal is emitted for this reply.      \note This feature is currently available for HTTP(S) only.      \sa get(), post(), put(), deleteResource() */
end_comment
begin_function
DECL|function|sendCustomRequest
name|QNetworkReply
modifier|*
name|QNetworkAccessManager
operator|::
name|sendCustomRequest
parameter_list|(
specifier|const
name|QNetworkRequest
modifier|&
name|request
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|verb
parameter_list|,
name|QIODevice
modifier|*
name|data
parameter_list|)
block|{
name|QNetworkRequest
name|newRequest
argument_list|(
name|request
argument_list|)
decl_stmt|;
name|newRequest
operator|.
name|setAttribute
argument_list|(
name|QNetworkRequest
operator|::
name|CustomVerbAttribute
argument_list|,
name|verb
argument_list|)
expr_stmt|;
return|return
name|d_func
argument_list|()
operator|->
name|postProcess
argument_list|(
name|createRequest
argument_list|(
name|QNetworkAccessManager
operator|::
name|CustomOperation
argument_list|,
name|newRequest
argument_list|,
name|data
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a new QNetworkReply object to handle the operation \a op     and request \a req. The device \a outgoingData is always 0 for Get and     Head requests, but is the value passed to post() and put() in     those operations (the QByteArray variants will pass a QBuffer     object).      The default implementation calls QNetworkCookieJar::cookiesForUrl()     on the cookie jar set with setCookieJar() to obtain the cookies to     be sent to the remote server.      The returned object must be in an open state. */
end_comment
begin_function
DECL|function|createRequest
name|QNetworkReply
modifier|*
name|QNetworkAccessManager
operator|::
name|createRequest
parameter_list|(
name|QNetworkAccessManager
operator|::
name|Operation
name|op
parameter_list|,
specifier|const
name|QNetworkRequest
modifier|&
name|req
parameter_list|,
name|QIODevice
modifier|*
name|outgoingData
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QNetworkAccessManager
argument_list|)
expr_stmt|;
name|bool
name|isLocalFile
init|=
name|req
operator|.
name|url
argument_list|()
operator|.
name|isLocalFile
argument_list|()
decl_stmt|;
name|QString
name|scheme
init|=
name|req
operator|.
name|url
argument_list|()
operator|.
name|scheme
argument_list|()
operator|.
name|toLower
argument_list|()
decl_stmt|;
comment|// fast path for GET on file:// URLs
comment|// The QNetworkAccessFileBackend will right now only be used for PUT
if|if
condition|(
operator|(
name|op
operator|==
name|QNetworkAccessManager
operator|::
name|GetOperation
operator|||
name|op
operator|==
name|QNetworkAccessManager
operator|::
name|HeadOperation
operator|)
operator|&&
operator|(
name|isLocalFile
operator|||
name|scheme
operator|==
name|QLatin1String
argument_list|(
literal|"qrc"
argument_list|)
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_ANDROID
argument_list|)
operator|||
name|scheme
operator|==
name|QLatin1String
argument_list|(
literal|"assets"
argument_list|)
endif|#
directive|endif
operator|)
condition|)
block|{
return|return
operator|new
name|QNetworkReplyFileImpl
argument_list|(
name|this
argument_list|,
name|req
argument_list|,
name|op
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|op
operator|==
name|QNetworkAccessManager
operator|::
name|GetOperation
operator|||
name|op
operator|==
name|QNetworkAccessManager
operator|::
name|HeadOperation
operator|)
operator|&&
name|scheme
operator|==
name|QLatin1String
argument_list|(
literal|"data"
argument_list|)
condition|)
block|{
return|return
operator|new
name|QNetworkReplyDataImpl
argument_list|(
name|this
argument_list|,
name|req
argument_list|,
name|op
argument_list|)
return|;
block|}
comment|// A request with QNetworkRequest::AlwaysCache does not need any bearer management
name|QNetworkRequest
operator|::
name|CacheLoadControl
name|mode
init|=
cast|static_cast
argument_list|<
name|QNetworkRequest
operator|::
name|CacheLoadControl
argument_list|>
argument_list|(
name|req
operator|.
name|attribute
argument_list|(
name|QNetworkRequest
operator|::
name|CacheLoadControlAttribute
argument_list|,
name|QNetworkRequest
operator|::
name|PreferNetwork
argument_list|)
operator|.
name|toInt
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|QNetworkRequest
operator|::
name|AlwaysCache
operator|&&
operator|(
name|op
operator|==
name|QNetworkAccessManager
operator|::
name|GetOperation
operator|||
name|op
operator|==
name|QNetworkAccessManager
operator|::
name|HeadOperation
operator|)
condition|)
block|{
comment|// FIXME Implement a QNetworkReplyCacheImpl instead, see QTBUG-15106
name|QNetworkReplyImpl
modifier|*
name|reply
init|=
operator|new
name|QNetworkReplyImpl
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|QNetworkReplyImplPrivate
modifier|*
name|priv
init|=
name|reply
operator|->
name|d_func
argument_list|()
decl_stmt|;
name|priv
operator|->
name|manager
operator|=
name|this
expr_stmt|;
name|priv
operator|->
name|backend
operator|=
operator|new
name|QNetworkAccessCacheBackend
argument_list|()
expr_stmt|;
name|priv
operator|->
name|backend
operator|->
name|manager
operator|=
name|this
operator|->
name|d_func
argument_list|()
expr_stmt|;
name|priv
operator|->
name|backend
operator|->
name|setParent
argument_list|(
name|reply
argument_list|)
expr_stmt|;
name|priv
operator|->
name|backend
operator|->
name|reply
operator|=
name|priv
expr_stmt|;
name|priv
operator|->
name|setup
argument_list|(
name|op
argument_list|,
name|req
argument_list|,
name|outgoingData
argument_list|)
expr_stmt|;
return|return
name|reply
return|;
block|}
ifndef|#
directive|ifndef
name|QT_NO_BEARERMANAGEMENT
comment|// Return a disabled network reply if network access is disabled.
comment|// Except if the scheme is empty or file://.
if|if
condition|(
operator|!
name|d
operator|->
name|networkAccessible
operator|&&
operator|!
name|isLocalFile
condition|)
block|{
return|return
operator|new
name|QDisabledNetworkReply
argument_list|(
name|this
argument_list|,
name|req
argument_list|,
name|op
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|d
operator|->
name|networkSessionStrongRef
operator|&&
operator|(
name|d
operator|->
name|initializeSession
operator|||
operator|!
name|d
operator|->
name|networkConfiguration
operator|.
name|identifier
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|)
condition|)
block|{
name|QNetworkConfigurationManager
name|manager
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|networkConfiguration
operator|.
name|identifier
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|d
operator|->
name|createSession
argument_list|(
name|d
operator|->
name|networkConfiguration
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|manager
operator|.
name|capabilities
argument_list|()
operator|&
name|QNetworkConfigurationManager
operator|::
name|NetworkSessionRequired
condition|)
name|d
operator|->
name|createSession
argument_list|(
name|manager
operator|.
name|defaultConfiguration
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|d
operator|->
name|initializeSession
operator|=
literal|false
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|QNetworkRequest
name|request
init|=
name|req
decl_stmt|;
if|if
condition|(
operator|!
name|request
operator|.
name|header
argument_list|(
name|QNetworkRequest
operator|::
name|ContentLengthHeader
argument_list|)
operator|.
name|isValid
argument_list|()
operator|&&
name|outgoingData
operator|&&
operator|!
name|outgoingData
operator|->
name|isSequential
argument_list|()
condition|)
block|{
comment|// request has no Content-Length
comment|// but the data that is outgoing is random-access
name|request
operator|.
name|setHeader
argument_list|(
name|QNetworkRequest
operator|::
name|ContentLengthHeader
argument_list|,
name|outgoingData
operator|->
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
cast|static_cast
argument_list|<
name|QNetworkRequest
operator|::
name|LoadControl
argument_list|>
argument_list|(
name|request
operator|.
name|attribute
argument_list|(
name|QNetworkRequest
operator|::
name|CookieLoadControlAttribute
argument_list|,
name|QNetworkRequest
operator|::
name|Automatic
argument_list|)
operator|.
name|toInt
argument_list|()
argument_list|)
operator|==
name|QNetworkRequest
operator|::
name|Automatic
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|cookieJar
condition|)
block|{
name|QList
argument_list|<
name|QNetworkCookie
argument_list|>
name|cookies
init|=
name|d
operator|->
name|cookieJar
operator|->
name|cookiesForUrl
argument_list|(
name|request
operator|.
name|url
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|cookies
operator|.
name|isEmpty
argument_list|()
condition|)
name|request
operator|.
name|setHeader
argument_list|(
name|QNetworkRequest
operator|::
name|CookieHeader
argument_list|,
name|QVariant
operator|::
name|fromValue
argument_list|(
name|cookies
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
ifndef|#
directive|ifndef
name|QT_NO_HTTP
comment|// Since Qt 5 we use the new QNetworkReplyHttpImpl
if|if
condition|(
name|scheme
operator|==
name|QLatin1String
argument_list|(
literal|"http"
argument_list|)
ifndef|#
directive|ifndef
name|QT_NO_SSL
operator|||
name|scheme
operator|==
name|QLatin1String
argument_list|(
literal|"https"
argument_list|)
endif|#
directive|endif
condition|)
block|{
name|QNetworkReplyHttpImpl
modifier|*
name|reply
init|=
operator|new
name|QNetworkReplyHttpImpl
argument_list|(
name|this
argument_list|,
name|request
argument_list|,
name|op
argument_list|,
name|outgoingData
argument_list|)
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_BEARERMANAGEMENT
name|connect
argument_list|(
name|this
argument_list|,
name|SIGNAL
argument_list|(
name|networkSessionConnected
argument_list|()
argument_list|)
argument_list|,
name|reply
argument_list|,
name|SLOT
argument_list|(
name|_q_networkSessionConnected
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|reply
return|;
block|}
endif|#
directive|endif
comment|// QT_NO_HTTP
comment|// first step: create the reply
name|QNetworkReplyImpl
modifier|*
name|reply
init|=
operator|new
name|QNetworkReplyImpl
argument_list|(
name|this
argument_list|)
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_BEARERMANAGEMENT
if|if
condition|(
operator|!
name|isLocalFile
condition|)
block|{
name|connect
argument_list|(
name|this
argument_list|,
name|SIGNAL
argument_list|(
name|networkSessionConnected
argument_list|()
argument_list|)
argument_list|,
name|reply
argument_list|,
name|SLOT
argument_list|(
name|_q_networkSessionConnected
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|QNetworkReplyImplPrivate
modifier|*
name|priv
init|=
name|reply
operator|->
name|d_func
argument_list|()
decl_stmt|;
name|priv
operator|->
name|manager
operator|=
name|this
expr_stmt|;
comment|// second step: fetch cached credentials
comment|// This is not done for the time being, we should use signal emissions to request
comment|// the credentials from cache.
comment|// third step: find a backend
name|priv
operator|->
name|backend
operator|=
name|d
operator|->
name|findBackend
argument_list|(
name|op
argument_list|,
name|request
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|->
name|backend
condition|)
block|{
name|priv
operator|->
name|backend
operator|->
name|setParent
argument_list|(
name|reply
argument_list|)
expr_stmt|;
name|priv
operator|->
name|backend
operator|->
name|reply
operator|=
name|priv
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|QT_NO_SSL
name|reply
operator|->
name|setSslConfiguration
argument_list|(
name|request
operator|.
name|sslConfiguration
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// fourth step: setup the reply
name|priv
operator|->
name|setup
argument_list|(
name|op
argument_list|,
name|request
argument_list|,
name|outgoingData
argument_list|)
expr_stmt|;
return|return
name|reply
return|;
block|}
end_function
begin_comment
comment|/*!     \since 5.2      Lists all the URL schemes supported by the access manager.      \sa supportedSchemesImplementation() */
end_comment
begin_function
DECL|function|supportedSchemes
name|QStringList
name|QNetworkAccessManager
operator|::
name|supportedSchemes
parameter_list|()
specifier|const
block|{
name|QStringList
name|schemes
decl_stmt|;
name|QNetworkAccessManager
modifier|*
name|self
init|=
cast|const_cast
argument_list|<
name|QNetworkAccessManager
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
comment|// We know we call a const slot
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|self
argument_list|,
literal|"supportedSchemesImplementation"
argument_list|,
name|Qt
operator|::
name|DirectConnection
argument_list|,
name|Q_RETURN_ARG
argument_list|(
name|QStringList
argument_list|,
name|schemes
argument_list|)
argument_list|)
expr_stmt|;
name|schemes
operator|.
name|removeDuplicates
argument_list|()
expr_stmt|;
return|return
name|schemes
return|;
block|}
end_function
begin_comment
comment|/*!     \since 5.2      Lists all the URL schemes supported by the access manager.      You should not call this function directly; use     QNetworkAccessManager::supportedSchemes() instead.      Reimplement this slot to provide your own supported schemes     in a QNetworkAccessManager subclass. It is for instance necessary     when your subclass provides support for new protocols.      Because of binary compatibility constraints, the supportedSchemes()     method (introduced in Qt 5.2) is not virtual. Instead, supportedSchemes()     will dynamically detect and call this slot.      \sa supportedSchemes() */
end_comment
begin_function
DECL|function|supportedSchemesImplementation
name|QStringList
name|QNetworkAccessManager
operator|::
name|supportedSchemesImplementation
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QNetworkAccessManager
argument_list|)
expr_stmt|;
name|QStringList
name|schemes
init|=
name|d
operator|->
name|backendSupportedSchemes
argument_list|()
decl_stmt|;
comment|// Those ones don't exist in backends
ifndef|#
directive|ifndef
name|QT_NO_HTTP
name|schemes
operator|<<
name|QStringLiteral
argument_list|(
literal|"http"
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_SSL
if|if
condition|(
name|QSslSocket
operator|::
name|supportsSsl
argument_list|()
condition|)
name|schemes
operator|<<
name|QStringLiteral
argument_list|(
literal|"https"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|schemes
operator|<<
name|QStringLiteral
argument_list|(
literal|"data"
argument_list|)
expr_stmt|;
return|return
name|schemes
return|;
block|}
end_function
begin_comment
comment|/*!     \since 5.0      Flushes the internal cache of authentication data and network connections.      This function is useful for doing auto tests.  */
end_comment
begin_function
DECL|function|clearAccessCache
name|void
name|QNetworkAccessManager
operator|::
name|clearAccessCache
parameter_list|()
block|{
name|QNetworkAccessManagerPrivate
operator|::
name|clearCache
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|_q_replyFinished
name|void
name|QNetworkAccessManagerPrivate
operator|::
name|_q_replyFinished
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QNetworkAccessManager
argument_list|)
expr_stmt|;
name|QNetworkReply
modifier|*
name|reply
init|=
name|qobject_cast
argument_list|<
name|QNetworkReply
operator|*
argument_list|>
argument_list|(
name|q
operator|->
name|sender
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|reply
condition|)
emit|emit
name|q
operator|->
name|finished
argument_list|(
name|reply
argument_list|)
emit|;
ifndef|#
directive|ifndef
name|QT_NO_BEARERMANAGEMENT
comment|// If there are no active requests, release our reference to the network session.
comment|// It will not be destroyed immediately, but rather when the connection cache is flushed
comment|// after 2 minutes.
name|activeReplyCount
operator|--
expr_stmt|;
if|if
condition|(
name|networkSessionStrongRef
operator|&&
name|activeReplyCount
operator|==
literal|0
condition|)
name|networkSessionStrongRef
operator|.
name|clear
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|_q_replyEncrypted
name|void
name|QNetworkAccessManagerPrivate
operator|::
name|_q_replyEncrypted
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|QT_NO_SSL
name|Q_Q
argument_list|(
name|QNetworkAccessManager
argument_list|)
expr_stmt|;
name|QNetworkReply
modifier|*
name|reply
init|=
name|qobject_cast
argument_list|<
name|QNetworkReply
operator|*
argument_list|>
argument_list|(
name|q
operator|->
name|sender
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|reply
condition|)
emit|emit
name|q
operator|->
name|encrypted
argument_list|(
name|reply
argument_list|)
emit|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|_q_replySslErrors
name|void
name|QNetworkAccessManagerPrivate
operator|::
name|_q_replySslErrors
parameter_list|(
specifier|const
name|QList
argument_list|<
name|QSslError
argument_list|>
modifier|&
name|errors
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_SSL
name|Q_Q
argument_list|(
name|QNetworkAccessManager
argument_list|)
expr_stmt|;
name|QNetworkReply
modifier|*
name|reply
init|=
name|qobject_cast
argument_list|<
name|QNetworkReply
operator|*
argument_list|>
argument_list|(
name|q
operator|->
name|sender
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|reply
condition|)
emit|emit
name|q
operator|->
name|sslErrors
argument_list|(
name|reply
argument_list|,
name|errors
argument_list|)
emit|;
else|#
directive|else
name|Q_UNUSED
argument_list|(
name|errors
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|postProcess
name|QNetworkReply
modifier|*
name|QNetworkAccessManagerPrivate
operator|::
name|postProcess
parameter_list|(
name|QNetworkReply
modifier|*
name|reply
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QNetworkAccessManager
argument_list|)
expr_stmt|;
name|QNetworkReplyPrivate
operator|::
name|setManager
argument_list|(
name|reply
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|q
operator|->
name|connect
argument_list|(
name|reply
argument_list|,
name|SIGNAL
argument_list|(
name|finished
argument_list|()
argument_list|)
argument_list|,
name|SLOT
argument_list|(
name|_q_replyFinished
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_SSL
comment|/* In case we're compiled without SSL support, we don't have this signal and we need to      * avoid getting a connection error. */
name|q
operator|->
name|connect
argument_list|(
name|reply
argument_list|,
name|SIGNAL
argument_list|(
name|encrypted
argument_list|()
argument_list|)
argument_list|,
name|SLOT
argument_list|(
name|_q_replyEncrypted
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|->
name|connect
argument_list|(
name|reply
argument_list|,
name|SIGNAL
argument_list|(
name|sslErrors
argument_list|(
name|QList
argument_list|<
name|QSslError
argument_list|>
argument_list|)
argument_list|)
argument_list|,
name|SLOT
argument_list|(
name|_q_replySslErrors
argument_list|(
name|QList
argument_list|<
name|QSslError
argument_list|>
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_BEARERMANAGEMENT
name|activeReplyCount
operator|++
expr_stmt|;
endif|#
directive|endif
return|return
name|reply
return|;
block|}
end_function
begin_function
DECL|function|createCookieJar
name|void
name|QNetworkAccessManagerPrivate
operator|::
name|createCookieJar
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|cookieJarCreated
condition|)
block|{
comment|// keep the ugly hack in here
name|QNetworkAccessManagerPrivate
modifier|*
name|that
init|=
cast|const_cast
argument_list|<
name|QNetworkAccessManagerPrivate
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|that
operator|->
name|cookieJar
operator|=
operator|new
name|QNetworkCookieJar
argument_list|(
name|that
operator|->
name|q_func
argument_list|()
argument_list|)
expr_stmt|;
name|that
operator|->
name|cookieJarCreated
operator|=
literal|true
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|authenticationRequired
name|void
name|QNetworkAccessManagerPrivate
operator|::
name|authenticationRequired
parameter_list|(
name|QAuthenticator
modifier|*
name|authenticator
parameter_list|,
name|QNetworkReply
modifier|*
name|reply
parameter_list|,
name|bool
name|synchronous
parameter_list|,
name|QUrl
modifier|&
name|url
parameter_list|,
name|QUrl
modifier|*
name|urlForLastAuthentication
parameter_list|,
name|bool
name|allowAuthenticationReuse
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QNetworkAccessManager
argument_list|)
expr_stmt|;
comment|// don't try the cache for the same URL twice in a row
comment|// being called twice for the same URL means the authentication failed
comment|// also called when last URL is empty, e.g. on first call
if|if
condition|(
name|allowAuthenticationReuse
operator|&&
operator|(
name|urlForLastAuthentication
operator|->
name|isEmpty
argument_list|()
operator|||
name|url
operator|!=
operator|*
name|urlForLastAuthentication
operator|)
condition|)
block|{
comment|// if credentials are included in the url, then use them
if|if
condition|(
operator|!
name|url
operator|.
name|userName
argument_list|()
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|url
operator|.
name|password
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|authenticator
operator|->
name|setUser
argument_list|(
name|url
operator|.
name|userName
argument_list|()
argument_list|)
expr_stmt|;
name|authenticator
operator|->
name|setPassword
argument_list|(
name|url
operator|.
name|password
argument_list|()
argument_list|)
expr_stmt|;
operator|*
name|urlForLastAuthentication
operator|=
name|url
expr_stmt|;
name|authenticationManager
operator|->
name|cacheCredentials
argument_list|(
name|url
argument_list|,
name|authenticator
argument_list|)
expr_stmt|;
return|return;
block|}
name|QNetworkAuthenticationCredential
name|cred
init|=
name|authenticationManager
operator|->
name|fetchCachedCredentials
argument_list|(
name|url
argument_list|,
name|authenticator
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|cred
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|authenticator
operator|->
name|setUser
argument_list|(
name|cred
operator|.
name|user
argument_list|)
expr_stmt|;
name|authenticator
operator|->
name|setPassword
argument_list|(
name|cred
operator|.
name|password
argument_list|)
expr_stmt|;
operator|*
name|urlForLastAuthentication
operator|=
name|url
expr_stmt|;
return|return;
block|}
block|}
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_MAC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_IOS
argument_list|)
comment|//now we try to get the username and password from keychain
comment|//if not successful signal will be emitted
name|QString
name|username
decl_stmt|;
name|QString
name|password
decl_stmt|;
if|if
condition|(
name|getProxyAuth
argument_list|(
name|proxy
operator|.
name|hostName
argument_list|()
argument_list|,
name|reply
operator|->
name|request
argument_list|()
operator|.
name|url
argument_list|()
operator|.
name|scheme
argument_list|()
argument_list|,
name|username
argument_list|,
name|password
argument_list|)
condition|)
block|{
name|authenticator
operator|->
name|setUser
argument_list|(
name|username
argument_list|)
expr_stmt|;
name|authenticator
operator|->
name|setPassword
argument_list|(
name|password
argument_list|)
expr_stmt|;
name|authenticationManager
operator|->
name|cacheProxyCredentials
argument_list|(
name|proxy
argument_list|,
name|authenticator
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
endif|#
directive|endif
comment|//QT_NO_NETWORKPROXY
comment|// if we emit a signal here in synchronous mode, the user might spin
comment|// an event loop, which might recurse and lead to problems
if|if
condition|(
name|synchronous
condition|)
return|return;
operator|*
name|urlForLastAuthentication
operator|=
name|url
expr_stmt|;
emit|emit
name|q
operator|->
name|authenticationRequired
argument_list|(
name|reply
argument_list|,
name|authenticator
argument_list|)
emit|;
if|if
condition|(
name|allowAuthenticationReuse
condition|)
name|authenticationManager
operator|->
name|cacheCredentials
argument_list|(
name|url
argument_list|,
name|authenticator
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
end_ifndef
begin_function
DECL|function|proxyAuthenticationRequired
name|void
name|QNetworkAccessManagerPrivate
operator|::
name|proxyAuthenticationRequired
parameter_list|(
specifier|const
name|QNetworkProxy
modifier|&
name|proxy
parameter_list|,
name|bool
name|synchronous
parameter_list|,
name|QAuthenticator
modifier|*
name|authenticator
parameter_list|,
name|QNetworkProxy
modifier|*
name|lastProxyAuthentication
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QNetworkAccessManager
argument_list|)
expr_stmt|;
name|QAuthenticatorPrivate
modifier|*
name|priv
init|=
name|QAuthenticatorPrivate
operator|::
name|getPrivate
argument_list|(
operator|*
name|authenticator
argument_list|)
decl_stmt|;
if|if
condition|(
name|proxy
operator|!=
operator|*
name|lastProxyAuthentication
operator|&&
operator|(
operator|!
name|priv
operator|||
operator|!
name|priv
operator|->
name|hasFailed
operator|)
condition|)
block|{
name|QNetworkAuthenticationCredential
name|cred
init|=
name|authenticationManager
operator|->
name|fetchCachedProxyCredentials
argument_list|(
name|proxy
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|cred
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|authenticator
operator|->
name|setUser
argument_list|(
name|cred
operator|.
name|user
argument_list|)
expr_stmt|;
name|authenticator
operator|->
name|setPassword
argument_list|(
name|cred
operator|.
name|password
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|// if we emit a signal here in synchronous mode, the user might spin
comment|// an event loop, which might recurse and lead to problems
if|if
condition|(
name|synchronous
condition|)
return|return;
operator|*
name|lastProxyAuthentication
operator|=
name|proxy
expr_stmt|;
emit|emit
name|q
operator|->
name|proxyAuthenticationRequired
argument_list|(
name|proxy
argument_list|,
name|authenticator
argument_list|)
emit|;
name|authenticationManager
operator|->
name|cacheProxyCredentials
argument_list|(
name|proxy
argument_list|,
name|authenticator
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|queryProxy
name|QList
argument_list|<
name|QNetworkProxy
argument_list|>
name|QNetworkAccessManagerPrivate
operator|::
name|queryProxy
parameter_list|(
specifier|const
name|QNetworkProxyQuery
modifier|&
name|query
parameter_list|)
block|{
name|QList
argument_list|<
name|QNetworkProxy
argument_list|>
name|proxies
decl_stmt|;
if|if
condition|(
name|proxyFactory
condition|)
block|{
name|proxies
operator|=
name|proxyFactory
operator|->
name|queryProxy
argument_list|(
name|query
argument_list|)
expr_stmt|;
if|if
condition|(
name|proxies
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QNetworkAccessManager: factory %p has returned an empty result set"
argument_list|,
name|proxyFactory
argument_list|)
expr_stmt|;
name|proxies
operator|<<
name|QNetworkProxy
operator|::
name|NoProxy
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|proxy
operator|.
name|type
argument_list|()
operator|==
name|QNetworkProxy
operator|::
name|DefaultProxy
condition|)
block|{
comment|// no proxy set, query the application
return|return
name|QNetworkProxyFactory
operator|::
name|proxyForQuery
argument_list|(
name|query
argument_list|)
return|;
block|}
else|else
block|{
name|proxies
operator|<<
name|proxy
expr_stmt|;
block|}
return|return
name|proxies
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|clearCache
name|void
name|QNetworkAccessManagerPrivate
operator|::
name|clearCache
parameter_list|(
name|QNetworkAccessManager
modifier|*
name|manager
parameter_list|)
block|{
name|manager
operator|->
name|d_func
argument_list|()
operator|->
name|objectCache
operator|.
name|clear
argument_list|()
expr_stmt|;
name|manager
operator|->
name|d_func
argument_list|()
operator|->
name|authenticationManager
operator|->
name|clearCache
argument_list|()
expr_stmt|;
if|if
condition|(
name|manager
operator|->
name|d_func
argument_list|()
operator|->
name|httpThread
condition|)
block|{
name|manager
operator|->
name|d_func
argument_list|()
operator|->
name|httpThread
operator|->
name|quit
argument_list|()
expr_stmt|;
name|manager
operator|->
name|d_func
argument_list|()
operator|->
name|httpThread
operator|->
name|wait
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
if|if
condition|(
name|manager
operator|->
name|d_func
argument_list|()
operator|->
name|httpThread
operator|->
name|isFinished
argument_list|()
condition|)
operator|delete
name|manager
operator|->
name|d_func
argument_list|()
operator|->
name|httpThread
expr_stmt|;
else|else
name|QObject
operator|::
name|connect
argument_list|(
name|manager
operator|->
name|d_func
argument_list|()
operator|->
name|httpThread
argument_list|,
name|SIGNAL
argument_list|(
name|finished
argument_list|()
argument_list|)
argument_list|,
name|manager
operator|->
name|d_func
argument_list|()
operator|->
name|httpThread
argument_list|,
name|SLOT
argument_list|(
name|deleteLater
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|manager
operator|->
name|d_func
argument_list|()
operator|->
name|httpThread
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function
begin_destructor
DECL|function|~QNetworkAccessManagerPrivate
name|QNetworkAccessManagerPrivate
operator|::
name|~
name|QNetworkAccessManagerPrivate
parameter_list|()
block|{
if|if
condition|(
name|httpThread
condition|)
block|{
name|httpThread
operator|->
name|quit
argument_list|()
expr_stmt|;
name|httpThread
operator|->
name|wait
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
if|if
condition|(
name|httpThread
operator|->
name|isFinished
argument_list|()
condition|)
operator|delete
name|httpThread
expr_stmt|;
else|else
name|QObject
operator|::
name|connect
argument_list|(
name|httpThread
argument_list|,
name|SIGNAL
argument_list|(
name|finished
argument_list|()
argument_list|)
argument_list|,
name|httpThread
argument_list|,
name|SLOT
argument_list|(
name|deleteLater
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|httpThread
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_destructor
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_BEARERMANAGEMENT
end_ifndef
begin_function
DECL|function|createSession
name|void
name|QNetworkAccessManagerPrivate
operator|::
name|createSession
parameter_list|(
specifier|const
name|QNetworkConfiguration
modifier|&
name|config
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QNetworkAccessManager
argument_list|)
expr_stmt|;
name|initializeSession
operator|=
literal|false
expr_stmt|;
comment|//resurrect weak ref if possible
name|networkSessionStrongRef
operator|=
name|networkSessionWeakRef
operator|.
name|toStrongRef
argument_list|()
expr_stmt|;
name|QSharedPointer
argument_list|<
name|QNetworkSession
argument_list|>
name|newSession
decl_stmt|;
if|if
condition|(
name|config
operator|.
name|isValid
argument_list|()
condition|)
name|newSession
operator|=
name|QSharedNetworkSessionManager
operator|::
name|getSession
argument_list|(
name|config
argument_list|)
expr_stmt|;
if|if
condition|(
name|networkSessionStrongRef
condition|)
block|{
comment|//do nothing if new and old session are the same
if|if
condition|(
name|networkSessionStrongRef
operator|==
name|newSession
condition|)
return|return;
comment|//disconnect from old session
name|QObject
operator|::
name|disconnect
argument_list|(
name|networkSessionStrongRef
operator|.
name|data
argument_list|()
argument_list|,
name|SIGNAL
argument_list|(
name|opened
argument_list|()
argument_list|)
argument_list|,
name|q
argument_list|,
name|SIGNAL
argument_list|(
name|networkSessionConnected
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|disconnect
argument_list|(
name|networkSessionStrongRef
operator|.
name|data
argument_list|()
argument_list|,
name|SIGNAL
argument_list|(
name|closed
argument_list|()
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_networkSessionClosed
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|disconnect
argument_list|(
name|networkSessionStrongRef
operator|.
name|data
argument_list|()
argument_list|,
name|SIGNAL
argument_list|(
name|stateChanged
argument_list|(
name|QNetworkSession
operator|::
name|State
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_networkSessionStateChanged
argument_list|(
name|QNetworkSession
operator|::
name|State
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|//switch to new session (null if config was invalid)
name|networkSessionStrongRef
operator|=
name|newSession
expr_stmt|;
name|networkSessionWeakRef
operator|=
name|networkSessionStrongRef
operator|.
name|toWeakRef
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|networkSessionStrongRef
condition|)
block|{
name|online
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|networkAccessible
operator|==
name|QNetworkAccessManager
operator|::
name|NotAccessible
condition|)
emit|emit
name|q
operator|->
name|networkAccessibleChanged
argument_list|(
name|QNetworkAccessManager
operator|::
name|NotAccessible
argument_list|)
emit|;
else|else
emit|emit
name|q
operator|->
name|networkAccessibleChanged
argument_list|(
name|QNetworkAccessManager
operator|::
name|UnknownAccessibility
argument_list|)
emit|;
return|return;
block|}
comment|//connect to new session
name|QObject
operator|::
name|connect
argument_list|(
name|networkSessionStrongRef
operator|.
name|data
argument_list|()
argument_list|,
name|SIGNAL
argument_list|(
name|opened
argument_list|()
argument_list|)
argument_list|,
name|q
argument_list|,
name|SIGNAL
argument_list|(
name|networkSessionConnected
argument_list|()
argument_list|)
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
comment|//QueuedConnection is used to avoid deleting the networkSession inside its closed signal
name|QObject
operator|::
name|connect
argument_list|(
name|networkSessionStrongRef
operator|.
name|data
argument_list|()
argument_list|,
name|SIGNAL
argument_list|(
name|closed
argument_list|()
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_networkSessionClosed
argument_list|()
argument_list|)
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|networkSessionStrongRef
operator|.
name|data
argument_list|()
argument_list|,
name|SIGNAL
argument_list|(
name|stateChanged
argument_list|(
name|QNetworkSession
operator|::
name|State
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_networkSessionStateChanged
argument_list|(
name|QNetworkSession
operator|::
name|State
argument_list|)
argument_list|)
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
name|_q_networkSessionStateChanged
argument_list|(
name|networkSessionStrongRef
operator|->
name|state
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|_q_networkSessionClosed
name|void
name|QNetworkAccessManagerPrivate
operator|::
name|_q_networkSessionClosed
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QNetworkAccessManager
argument_list|)
expr_stmt|;
name|QSharedPointer
argument_list|<
name|QNetworkSession
argument_list|>
name|networkSession
argument_list|(
name|getNetworkSession
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|networkSession
condition|)
block|{
name|networkConfiguration
operator|=
name|networkSession
operator|->
name|configuration
argument_list|()
expr_stmt|;
comment|//disconnect from old session
name|QObject
operator|::
name|disconnect
argument_list|(
name|networkSession
operator|.
name|data
argument_list|()
argument_list|,
name|SIGNAL
argument_list|(
name|opened
argument_list|()
argument_list|)
argument_list|,
name|q
argument_list|,
name|SIGNAL
argument_list|(
name|networkSessionConnected
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|disconnect
argument_list|(
name|networkSession
operator|.
name|data
argument_list|()
argument_list|,
name|SIGNAL
argument_list|(
name|closed
argument_list|()
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_networkSessionClosed
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|disconnect
argument_list|(
name|networkSession
operator|.
name|data
argument_list|()
argument_list|,
name|SIGNAL
argument_list|(
name|stateChanged
argument_list|(
name|QNetworkSession
operator|::
name|State
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_networkSessionStateChanged
argument_list|(
name|QNetworkSession
operator|::
name|State
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|networkSessionStrongRef
operator|.
name|clear
argument_list|()
expr_stmt|;
name|networkSessionWeakRef
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|_q_networkSessionStateChanged
name|void
name|QNetworkAccessManagerPrivate
operator|::
name|_q_networkSessionStateChanged
parameter_list|(
name|QNetworkSession
operator|::
name|State
name|state
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QNetworkAccessManager
argument_list|)
expr_stmt|;
comment|//Do not emit the networkSessionConnected signal here, except for roaming -> connected
comment|//transition, otherwise it is emitted twice in a row when opening a connection.
if|if
condition|(
name|state
operator|==
name|QNetworkSession
operator|::
name|Connected
operator|&&
name|lastSessionState
operator|==
name|QNetworkSession
operator|::
name|Roaming
condition|)
emit|emit
name|q
operator|->
name|networkSessionConnected
argument_list|()
emit|;
name|lastSessionState
operator|=
name|state
expr_stmt|;
if|if
condition|(
name|online
condition|)
block|{
if|if
condition|(
name|state
operator|!=
name|QNetworkSession
operator|::
name|Connected
operator|&&
name|state
operator|!=
name|QNetworkSession
operator|::
name|Roaming
condition|)
block|{
name|online
operator|=
literal|false
expr_stmt|;
emit|emit
name|q
operator|->
name|networkAccessibleChanged
argument_list|(
name|QNetworkAccessManager
operator|::
name|NotAccessible
argument_list|)
emit|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|state
operator|==
name|QNetworkSession
operator|::
name|Connected
operator|||
name|state
operator|==
name|QNetworkSession
operator|::
name|Roaming
condition|)
block|{
name|online
operator|=
literal|true
expr_stmt|;
emit|emit
name|q
operator|->
name|networkAccessibleChanged
argument_list|(
name|networkAccessible
argument_list|)
emit|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|_q_onlineStateChanged
name|void
name|QNetworkAccessManagerPrivate
operator|::
name|_q_onlineStateChanged
parameter_list|(
name|bool
name|isOnline
parameter_list|)
block|{
comment|// if the user set a config, we only care whether this one is active.
comment|// Otherwise, this QNAM is online if there is an online config.
if|if
condition|(
name|customNetworkConfiguration
condition|)
block|{
name|online
operator|=
operator|(
name|networkConfiguration
operator|.
name|state
argument_list|()
operator|&
name|QNetworkConfiguration
operator|::
name|Active
operator|)
expr_stmt|;
block|}
else|else
block|{
name|online
operator|=
name|isOnline
expr_stmt|;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_BEARERMANAGEMENT
end_comment
begin_function
DECL|function|prepareMultipart
name|QNetworkRequest
name|QNetworkAccessManagerPrivate
operator|::
name|prepareMultipart
parameter_list|(
specifier|const
name|QNetworkRequest
modifier|&
name|request
parameter_list|,
name|QHttpMultiPart
modifier|*
name|multiPart
parameter_list|)
block|{
comment|// copy the request, we probably need to add some headers
name|QNetworkRequest
name|newRequest
argument_list|(
name|request
argument_list|)
decl_stmt|;
comment|// add Content-Type header if not there already
if|if
condition|(
operator|!
name|request
operator|.
name|header
argument_list|(
name|QNetworkRequest
operator|::
name|ContentTypeHeader
argument_list|)
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|QByteArray
name|contentType
decl_stmt|;
name|contentType
operator|.
name|reserve
argument_list|(
literal|34
operator|+
name|multiPart
operator|->
name|d_func
argument_list|()
operator|->
name|boundary
operator|.
name|count
argument_list|()
argument_list|)
expr_stmt|;
name|contentType
operator|+=
literal|"multipart/"
expr_stmt|;
switch|switch
condition|(
name|multiPart
operator|->
name|d_func
argument_list|()
operator|->
name|contentType
condition|)
block|{
case|case
name|QHttpMultiPart
operator|::
name|RelatedType
case|:
name|contentType
operator|+=
literal|"related"
expr_stmt|;
break|break;
case|case
name|QHttpMultiPart
operator|::
name|FormDataType
case|:
name|contentType
operator|+=
literal|"form-data"
expr_stmt|;
break|break;
case|case
name|QHttpMultiPart
operator|::
name|AlternativeType
case|:
name|contentType
operator|+=
literal|"alternative"
expr_stmt|;
break|break;
default|default:
name|contentType
operator|+=
literal|"mixed"
expr_stmt|;
break|break;
block|}
comment|// putting the boundary into quotes, recommended in RFC 2046 section 5.1.1
name|contentType
operator|+=
literal|"; boundary=\""
operator|+
name|multiPart
operator|->
name|d_func
argument_list|()
operator|->
name|boundary
operator|+
literal|"\""
expr_stmt|;
name|newRequest
operator|.
name|setHeader
argument_list|(
name|QNetworkRequest
operator|::
name|ContentTypeHeader
argument_list|,
name|QVariant
argument_list|(
name|contentType
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// add MIME-Version header if not there already (we must include the header
comment|// if the message conforms to RFC 2045, see section 4 of that RFC)
name|QByteArray
name|mimeHeader
argument_list|(
literal|"MIME-Version"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|request
operator|.
name|hasRawHeader
argument_list|(
name|mimeHeader
argument_list|)
condition|)
name|newRequest
operator|.
name|setRawHeader
argument_list|(
name|mimeHeader
argument_list|,
name|QByteArray
argument_list|(
literal|"1.0"
argument_list|)
argument_list|)
expr_stmt|;
name|QIODevice
modifier|*
name|device
init|=
name|multiPart
operator|->
name|d_func
argument_list|()
operator|->
name|device
decl_stmt|;
if|if
condition|(
operator|!
name|device
operator|->
name|isReadable
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|device
operator|->
name|isOpen
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|device
operator|->
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
condition|)
name|qWarning
argument_list|(
literal|"could not open device for reading"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|qWarning
argument_list|(
literal|"device is not readable"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|newRequest
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_include
include|#
directive|include
file|"moc_qnetworkaccessmanager.cpp"
end_include
end_unit
