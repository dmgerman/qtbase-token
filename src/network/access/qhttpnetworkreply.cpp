begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtNetwork module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qhttpnetworkreply_p.h"
end_include
begin_include
include|#
directive|include
file|"qhttpnetworkconnection_p.h"
end_include
begin_include
include|#
directive|include
file|<qbytearraymatcher.h>
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_HTTP
end_ifndef
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_SSL
end_ifndef
begin_include
include|#
directive|include
file|<QtNetwork/qsslkey.h>
end_include
begin_include
include|#
directive|include
file|<QtNetwork/qsslcipher.h>
end_include
begin_include
include|#
directive|include
file|<QtNetwork/qsslconfiguration.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_COMPRESS
end_ifndef
begin_include
include|#
directive|include
file|<zlib.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_constructor
DECL|function|QHttpNetworkReply
name|QHttpNetworkReply
operator|::
name|QHttpNetworkReply
parameter_list|(
specifier|const
name|QUrl
modifier|&
name|url
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|new
name|QHttpNetworkReplyPrivate
argument_list|(
name|url
argument_list|)
argument_list|,
name|parent
argument_list|)
block|{ }
end_constructor
begin_destructor
DECL|function|~QHttpNetworkReply
name|QHttpNetworkReply
operator|::
name|~
name|QHttpNetworkReply
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QHttpNetworkReply
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|connection
condition|)
block|{
name|d
operator|->
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|removeReply
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|QT_NO_COMPRESS
if|if
condition|(
name|d
operator|->
name|autoDecompress
operator|&&
name|d
operator|->
name|isCompressed
argument_list|()
operator|&&
name|d
operator|->
name|inflateStrm
condition|)
name|inflateEnd
argument_list|(
name|d
operator|->
name|inflateStrm
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_destructor
begin_function
DECL|function|url
name|QUrl
name|QHttpNetworkReply
operator|::
name|url
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|url
return|;
block|}
end_function
begin_function
DECL|function|setUrl
name|void
name|QHttpNetworkReply
operator|::
name|setUrl
parameter_list|(
specifier|const
name|QUrl
modifier|&
name|url
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QHttpNetworkReply
argument_list|)
expr_stmt|;
name|d
operator|->
name|url
operator|=
name|url
expr_stmt|;
block|}
end_function
begin_function
DECL|function|contentLength
name|qint64
name|QHttpNetworkReply
operator|::
name|contentLength
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|contentLength
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|setContentLength
name|void
name|QHttpNetworkReply
operator|::
name|setContentLength
parameter_list|(
name|qint64
name|length
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QHttpNetworkReply
argument_list|)
expr_stmt|;
name|d
operator|->
name|setContentLength
argument_list|(
name|length
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|header
name|QList
argument_list|<
name|QPair
argument_list|<
name|QByteArray
argument_list|,
name|QByteArray
argument_list|>
argument_list|>
name|QHttpNetworkReply
operator|::
name|header
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|fields
return|;
block|}
end_function
begin_function
DECL|function|headerField
name|QByteArray
name|QHttpNetworkReply
operator|::
name|headerField
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|name
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|defaultValue
parameter_list|)
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|headerField
argument_list|(
name|name
argument_list|,
name|defaultValue
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|setHeaderField
name|void
name|QHttpNetworkReply
operator|::
name|setHeaderField
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|name
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|data
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QHttpNetworkReply
argument_list|)
expr_stmt|;
name|d
operator|->
name|setHeaderField
argument_list|(
name|name
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|parseHeader
name|void
name|QHttpNetworkReply
operator|::
name|parseHeader
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|header
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QHttpNetworkReply
argument_list|)
expr_stmt|;
name|d
operator|->
name|parseHeader
argument_list|(
name|header
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|request
name|QHttpNetworkRequest
name|QHttpNetworkReply
operator|::
name|request
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|request
return|;
block|}
end_function
begin_function
DECL|function|setRequest
name|void
name|QHttpNetworkReply
operator|::
name|setRequest
parameter_list|(
specifier|const
name|QHttpNetworkRequest
modifier|&
name|request
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QHttpNetworkReply
argument_list|)
expr_stmt|;
name|d
operator|->
name|request
operator|=
name|request
expr_stmt|;
name|d
operator|->
name|ssl
operator|=
name|request
operator|.
name|isSsl
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|statusCode
name|int
name|QHttpNetworkReply
operator|::
name|statusCode
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|statusCode
return|;
block|}
end_function
begin_function
DECL|function|setStatusCode
name|void
name|QHttpNetworkReply
operator|::
name|setStatusCode
parameter_list|(
name|int
name|code
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QHttpNetworkReply
argument_list|)
expr_stmt|;
name|d
operator|->
name|statusCode
operator|=
name|code
expr_stmt|;
block|}
end_function
begin_function
DECL|function|errorString
name|QString
name|QHttpNetworkReply
operator|::
name|errorString
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|errorString
return|;
block|}
end_function
begin_function
DECL|function|reasonPhrase
name|QString
name|QHttpNetworkReply
operator|::
name|reasonPhrase
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|reasonPhrase
return|;
block|}
end_function
begin_function
DECL|function|setErrorString
name|void
name|QHttpNetworkReply
operator|::
name|setErrorString
parameter_list|(
specifier|const
name|QString
modifier|&
name|error
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QHttpNetworkReply
argument_list|)
expr_stmt|;
name|d
operator|->
name|errorString
operator|=
name|error
expr_stmt|;
block|}
end_function
begin_function
DECL|function|majorVersion
name|int
name|QHttpNetworkReply
operator|::
name|majorVersion
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|majorVersion
return|;
block|}
end_function
begin_function
DECL|function|minorVersion
name|int
name|QHttpNetworkReply
operator|::
name|minorVersion
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|minorVersion
return|;
block|}
end_function
begin_function
DECL|function|bytesAvailable
name|qint64
name|QHttpNetworkReply
operator|::
name|bytesAvailable
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QHttpNetworkReply
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|connection
condition|)
return|return
name|d
operator|->
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|uncompressedBytesAvailable
argument_list|(
operator|*
name|this
argument_list|)
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_function
DECL|function|bytesAvailableNextBlock
name|qint64
name|QHttpNetworkReply
operator|::
name|bytesAvailableNextBlock
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QHttpNetworkReply
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|connection
condition|)
return|return
name|d
operator|->
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|uncompressedBytesAvailableNextBlock
argument_list|(
operator|*
name|this
argument_list|)
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_function
DECL|function|readAnyAvailable
name|bool
name|QHttpNetworkReply
operator|::
name|readAnyAvailable
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QHttpNetworkReply
argument_list|)
expr_stmt|;
return|return
operator|(
name|d
operator|->
name|responseData
operator|.
name|bufferCount
argument_list|()
operator|>
literal|0
operator|)
return|;
block|}
end_function
begin_function
DECL|function|readAny
name|QByteArray
name|QHttpNetworkReply
operator|::
name|readAny
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QHttpNetworkReply
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|responseData
operator|.
name|bufferCount
argument_list|()
operator|==
literal|0
condition|)
return|return
name|QByteArray
argument_list|()
return|;
comment|// we'll take the last buffer, so schedule another read from http
if|if
condition|(
name|d
operator|->
name|downstreamLimited
operator|&&
name|d
operator|->
name|responseData
operator|.
name|bufferCount
argument_list|()
operator|==
literal|1
condition|)
name|d
operator|->
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|readMoreLater
argument_list|(
name|this
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|responseData
operator|.
name|read
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|readAll
name|QByteArray
name|QHttpNetworkReply
operator|::
name|readAll
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QHttpNetworkReply
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|responseData
operator|.
name|readAll
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|read
name|QByteArray
name|QHttpNetworkReply
operator|::
name|read
parameter_list|(
name|qint64
name|amount
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QHttpNetworkReply
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|responseData
operator|.
name|read
argument_list|(
name|amount
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|sizeNextBlock
name|qint64
name|QHttpNetworkReply
operator|::
name|sizeNextBlock
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QHttpNetworkReply
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|responseData
operator|.
name|sizeNextBlock
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|setDownstreamLimited
name|void
name|QHttpNetworkReply
operator|::
name|setDownstreamLimited
parameter_list|(
name|bool
name|dsl
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QHttpNetworkReply
argument_list|)
expr_stmt|;
name|d
operator|->
name|downstreamLimited
operator|=
name|dsl
expr_stmt|;
name|d
operator|->
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|readMoreLater
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setReadBufferSize
name|void
name|QHttpNetworkReply
operator|::
name|setReadBufferSize
parameter_list|(
name|qint64
name|size
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QHttpNetworkReply
argument_list|)
expr_stmt|;
name|d
operator|->
name|readBufferMaxSize
operator|=
name|size
expr_stmt|;
block|}
end_function
begin_function
DECL|function|supportsUserProvidedDownloadBuffer
name|bool
name|QHttpNetworkReply
operator|::
name|supportsUserProvidedDownloadBuffer
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QHttpNetworkReply
argument_list|)
expr_stmt|;
return|return
operator|(
operator|!
name|d
operator|->
name|isChunked
argument_list|()
operator|&&
operator|!
name|d
operator|->
name|autoDecompress
operator|&&
name|d
operator|->
name|bodyLength
operator|>
literal|0
operator|&&
name|d
operator|->
name|statusCode
operator|==
literal|200
operator|)
return|;
block|}
end_function
begin_function
DECL|function|setUserProvidedDownloadBuffer
name|void
name|QHttpNetworkReply
operator|::
name|setUserProvidedDownloadBuffer
parameter_list|(
name|char
modifier|*
name|b
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QHttpNetworkReply
argument_list|)
expr_stmt|;
if|if
condition|(
name|supportsUserProvidedDownloadBuffer
argument_list|()
condition|)
name|d
operator|->
name|userProvidedDownloadBuffer
operator|=
name|b
expr_stmt|;
block|}
end_function
begin_function
DECL|function|userProvidedDownloadBuffer
name|char
modifier|*
name|QHttpNetworkReply
operator|::
name|userProvidedDownloadBuffer
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QHttpNetworkReply
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|userProvidedDownloadBuffer
return|;
block|}
end_function
begin_function
DECL|function|isFinished
name|bool
name|QHttpNetworkReply
operator|::
name|isFinished
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|state
operator|==
name|QHttpNetworkReplyPrivate
operator|::
name|AllDoneState
return|;
block|}
end_function
begin_function
DECL|function|isPipeliningUsed
name|bool
name|QHttpNetworkReply
operator|::
name|isPipeliningUsed
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|pipeliningUsed
return|;
block|}
end_function
begin_function
DECL|function|connection
name|QHttpNetworkConnection
modifier|*
name|QHttpNetworkReply
operator|::
name|connection
parameter_list|()
block|{
return|return
name|d_func
argument_list|()
operator|->
name|connection
return|;
block|}
end_function
begin_constructor
DECL|function|QHttpNetworkReplyPrivate
name|QHttpNetworkReplyPrivate
operator|::
name|QHttpNetworkReplyPrivate
parameter_list|(
specifier|const
name|QUrl
modifier|&
name|newUrl
parameter_list|)
member_init_list|:
name|QHttpNetworkHeaderPrivate
argument_list|(
name|newUrl
argument_list|)
member_init_list|,
name|state
argument_list|(
name|NothingDoneState
argument_list|)
member_init_list|,
name|ssl
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|statusCode
argument_list|(
literal|100
argument_list|)
member_init_list|,
name|majorVersion
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|minorVersion
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|bodyLength
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|contentRead
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|totalProgress
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|chunkedTransferEncoding
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|connectionCloseEnabled
argument_list|(
literal|true
argument_list|)
member_init_list|,
name|forceConnectionCloseEnabled
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|lastChunkRead
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|currentChunkSize
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|currentChunkRead
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|readBufferMaxSize
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|connection
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|autoDecompress
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|responseData
argument_list|()
member_init_list|,
name|requestIsPrepared
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|pipeliningUsed
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|downstreamLimited
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|userProvidedDownloadBuffer
argument_list|(
literal|0
argument_list|)
ifndef|#
directive|ifndef
name|QT_NO_COMPRESS
member_init_list|,
name|inflateStrm
argument_list|(
literal|0
argument_list|)
endif|#
directive|endif
block|{
name|QString
name|scheme
init|=
name|newUrl
operator|.
name|scheme
argument_list|()
decl_stmt|;
if|if
condition|(
name|scheme
operator|==
name|QLatin1String
argument_list|(
literal|"preconnect-http"
argument_list|)
operator|||
name|scheme
operator|==
name|QLatin1String
argument_list|(
literal|"preconnect-https"
argument_list|)
condition|)
comment|// make sure we do not close the socket after preconnecting
name|connectionCloseEnabled
operator|=
literal|false
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QHttpNetworkReplyPrivate
name|QHttpNetworkReplyPrivate
operator|::
name|~
name|QHttpNetworkReplyPrivate
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|QT_NO_COMPRESS
if|if
condition|(
name|inflateStrm
condition|)
operator|delete
name|inflateStrm
expr_stmt|;
endif|#
directive|endif
block|}
end_destructor
begin_function
DECL|function|clearHttpLayerInformation
name|void
name|QHttpNetworkReplyPrivate
operator|::
name|clearHttpLayerInformation
parameter_list|()
block|{
name|state
operator|=
name|NothingDoneState
expr_stmt|;
name|statusCode
operator|=
literal|100
expr_stmt|;
name|bodyLength
operator|=
literal|0
expr_stmt|;
name|contentRead
operator|=
literal|0
expr_stmt|;
name|totalProgress
operator|=
literal|0
expr_stmt|;
name|currentChunkSize
operator|=
literal|0
expr_stmt|;
name|currentChunkRead
operator|=
literal|0
expr_stmt|;
name|lastChunkRead
operator|=
literal|false
expr_stmt|;
name|connectionCloseEnabled
operator|=
literal|true
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_COMPRESS
if|if
condition|(
name|autoDecompress
operator|&&
name|inflateStrm
condition|)
name|inflateEnd
argument_list|(
name|inflateStrm
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fields
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|// TODO: Isn't everything HTTP layer related? We don't need to set connection and connectionChannel to 0 at all
end_comment
begin_function
DECL|function|clear
name|void
name|QHttpNetworkReplyPrivate
operator|::
name|clear
parameter_list|()
block|{
name|connection
operator|=
literal|0
expr_stmt|;
name|connectionChannel
operator|=
literal|0
expr_stmt|;
name|autoDecompress
operator|=
literal|false
expr_stmt|;
name|clearHttpLayerInformation
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|// QHttpNetworkReplyPrivate
end_comment
begin_function
DECL|function|bytesAvailable
name|qint64
name|QHttpNetworkReplyPrivate
operator|::
name|bytesAvailable
parameter_list|()
specifier|const
block|{
return|return
operator|(
name|state
operator|!=
name|ReadingDataState
condition|?
literal|0
else|:
name|fragment
operator|.
name|size
argument_list|()
operator|)
return|;
block|}
end_function
begin_function
DECL|function|isCompressed
name|bool
name|QHttpNetworkReplyPrivate
operator|::
name|isCompressed
parameter_list|()
block|{
name|QByteArray
name|encoding
init|=
name|headerField
argument_list|(
literal|"content-encoding"
argument_list|)
decl_stmt|;
return|return
name|qstricmp
argument_list|(
name|encoding
operator|.
name|constData
argument_list|()
argument_list|,
literal|"gzip"
argument_list|)
operator|==
literal|0
operator|||
name|qstricmp
argument_list|(
name|encoding
operator|.
name|constData
argument_list|()
argument_list|,
literal|"deflate"
argument_list|)
operator|==
literal|0
return|;
block|}
end_function
begin_function
DECL|function|removeAutoDecompressHeader
name|void
name|QHttpNetworkReplyPrivate
operator|::
name|removeAutoDecompressHeader
parameter_list|()
block|{
comment|// The header "Content-Encoding  = gzip" is retained.
comment|// Content-Length is removed since the actual one send by the server is for compressed data
name|QByteArray
name|name
argument_list|(
literal|"content-length"
argument_list|)
decl_stmt|;
name|QList
argument_list|<
name|QPair
argument_list|<
name|QByteArray
argument_list|,
name|QByteArray
argument_list|>
argument_list|>
operator|::
name|Iterator
name|it
init|=
name|fields
operator|.
name|begin
argument_list|()
decl_stmt|,
name|end
init|=
name|fields
operator|.
name|end
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|end
condition|)
block|{
if|if
condition|(
name|qstricmp
argument_list|(
name|name
operator|.
name|constData
argument_list|()
argument_list|,
name|it
operator|->
name|first
operator|.
name|constData
argument_list|()
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fields
operator|.
name|erase
argument_list|(
name|it
argument_list|)
expr_stmt|;
break|break;
block|}
operator|++
name|it
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|findChallenge
name|bool
name|QHttpNetworkReplyPrivate
operator|::
name|findChallenge
parameter_list|(
name|bool
name|forProxy
parameter_list|,
name|QByteArray
modifier|&
name|challenge
parameter_list|)
specifier|const
block|{
name|challenge
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// find out the type of authentication protocol requested.
name|QByteArray
name|header
init|=
name|forProxy
condition|?
literal|"proxy-authenticate"
else|:
literal|"www-authenticate"
decl_stmt|;
comment|// pick the best protocol (has to match parsing in QAuthenticatorPrivate)
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|challenges
init|=
name|headerFieldValues
argument_list|(
name|header
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|challenges
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|QByteArray
name|line
init|=
name|challenges
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|// todo use qstrincmp
if|if
condition|(
operator|!
name|line
operator|.
name|toLower
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"negotiate"
argument_list|)
condition|)
name|challenge
operator|=
name|line
expr_stmt|;
block|}
return|return
operator|!
name|challenge
operator|.
name|isEmpty
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|authenticationMethod
name|QAuthenticatorPrivate
operator|::
name|Method
name|QHttpNetworkReplyPrivate
operator|::
name|authenticationMethod
parameter_list|(
name|bool
name|isProxy
parameter_list|)
specifier|const
block|{
comment|// The logic is same as the one used in void QAuthenticatorPrivate::parseHttpResponse()
name|QAuthenticatorPrivate
operator|::
name|Method
name|method
init|=
name|QAuthenticatorPrivate
operator|::
name|None
decl_stmt|;
name|QByteArray
name|header
init|=
name|isProxy
condition|?
literal|"proxy-authenticate"
else|:
literal|"www-authenticate"
decl_stmt|;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|challenges
init|=
name|headerFieldValues
argument_list|(
name|header
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|challenges
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|QByteArray
name|line
init|=
name|challenges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|trimmed
argument_list|()
operator|.
name|toLower
argument_list|()
decl_stmt|;
if|if
condition|(
name|method
operator|<
name|QAuthenticatorPrivate
operator|::
name|Basic
operator|&&
name|line
operator|.
name|startsWith
argument_list|(
literal|"basic"
argument_list|)
condition|)
block|{
name|method
operator|=
name|QAuthenticatorPrivate
operator|::
name|Basic
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|method
operator|<
name|QAuthenticatorPrivate
operator|::
name|Ntlm
operator|&&
name|line
operator|.
name|startsWith
argument_list|(
literal|"ntlm"
argument_list|)
condition|)
block|{
name|method
operator|=
name|QAuthenticatorPrivate
operator|::
name|Ntlm
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|method
operator|<
name|QAuthenticatorPrivate
operator|::
name|DigestMd5
operator|&&
name|line
operator|.
name|startsWith
argument_list|(
literal|"digest"
argument_list|)
condition|)
block|{
name|method
operator|=
name|QAuthenticatorPrivate
operator|::
name|DigestMd5
expr_stmt|;
block|}
block|}
return|return
name|method
return|;
block|}
end_function
begin_function
DECL|function|readStatus
name|qint64
name|QHttpNetworkReplyPrivate
operator|::
name|readStatus
parameter_list|(
name|QAbstractSocket
modifier|*
name|socket
parameter_list|)
block|{
if|if
condition|(
name|fragment
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// reserve bytes for the status line. This is better than always append() which reallocs the byte array
name|fragment
operator|.
name|reserve
argument_list|(
literal|32
argument_list|)
expr_stmt|;
block|}
name|qint64
name|bytes
init|=
literal|0
decl_stmt|;
name|char
name|c
decl_stmt|;
name|qint64
name|haveRead
init|=
literal|0
decl_stmt|;
do|do
block|{
name|haveRead
operator|=
name|socket
operator|->
name|read
argument_list|(
operator|&
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|haveRead
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
comment|// unexpected EOF
elseif|else
if|if
condition|(
name|haveRead
operator|==
literal|0
condition|)
break|break;
comment|// read more later
elseif|else
if|if
condition|(
name|haveRead
operator|==
literal|1
operator|&&
name|fragment
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|&&
operator|(
name|c
operator|==
literal|11
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|'\r'
operator|||
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|31
operator|)
condition|)
continue|continue;
comment|// Ignore all whitespace that was trailing froma previous request on that socket
name|bytes
operator|++
expr_stmt|;
comment|// allow both CRLF& LF (only) line endings
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
comment|// remove the CR at the end
if|if
condition|(
name|fragment
operator|.
name|endsWith
argument_list|(
literal|'\r'
argument_list|)
condition|)
block|{
name|fragment
operator|.
name|truncate
argument_list|(
name|fragment
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|bool
name|ok
init|=
name|parseStatus
argument_list|(
name|fragment
argument_list|)
decl_stmt|;
name|state
operator|=
name|ReadingHeaderState
expr_stmt|;
name|fragment
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
break|break;
block|}
else|else
block|{
name|fragment
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
comment|// is this a valid reply?
if|if
condition|(
name|fragment
operator|.
name|length
argument_list|()
operator|>=
literal|5
operator|&&
operator|!
name|fragment
operator|.
name|startsWith
argument_list|(
literal|"HTTP/"
argument_list|)
condition|)
block|{
name|fragment
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
do|while
condition|(
name|haveRead
operator|==
literal|1
condition|)
do|;
return|return
name|bytes
return|;
block|}
end_function
begin_function
DECL|function|parseStatus
name|bool
name|QHttpNetworkReplyPrivate
operator|::
name|parseStatus
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|status
parameter_list|)
block|{
comment|// from RFC 2616:
comment|//        Status-Line = HTTP-Version SP Status-Code SP Reason-Phrase CRLF
comment|//        HTTP-Version   = "HTTP" "/" 1*DIGIT "." 1*DIGIT
comment|// that makes: 'HTTP/n.n xxx Message'
comment|// byte count:  0123456789012
specifier|static
specifier|const
name|int
name|minLength
init|=
literal|11
decl_stmt|;
specifier|static
specifier|const
name|int
name|dotPos
init|=
literal|6
decl_stmt|;
specifier|static
specifier|const
name|int
name|spacePos
init|=
literal|8
decl_stmt|;
specifier|static
specifier|const
name|char
name|httpMagic
index|[]
init|=
literal|"HTTP/"
decl_stmt|;
if|if
condition|(
name|status
operator|.
name|length
argument_list|()
operator|<
name|minLength
operator|||
operator|!
name|status
operator|.
name|startsWith
argument_list|(
name|httpMagic
argument_list|)
operator|||
name|status
operator|.
name|at
argument_list|(
name|dotPos
argument_list|)
operator|!=
literal|'.'
operator|||
name|status
operator|.
name|at
argument_list|(
name|spacePos
argument_list|)
operator|!=
literal|' '
condition|)
block|{
comment|// I don't know how to parse this status line
return|return
literal|false
return|;
block|}
comment|// optimize for the valid case: defer checking until the end
name|majorVersion
operator|=
name|status
operator|.
name|at
argument_list|(
name|dotPos
operator|-
literal|1
argument_list|)
operator|-
literal|'0'
expr_stmt|;
name|minorVersion
operator|=
name|status
operator|.
name|at
argument_list|(
name|dotPos
operator|+
literal|1
argument_list|)
operator|-
literal|'0'
expr_stmt|;
name|int
name|i
init|=
name|spacePos
decl_stmt|;
name|int
name|j
init|=
name|status
operator|.
name|indexOf
argument_list|(
literal|' '
argument_list|,
name|i
operator|+
literal|1
argument_list|)
decl_stmt|;
comment|// j == -1 || at(j) == ' ' so j+1 == 0&& j+1<= length()
specifier|const
name|QByteArray
name|code
init|=
name|status
operator|.
name|mid
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|j
operator|-
name|i
operator|-
literal|1
argument_list|)
decl_stmt|;
name|bool
name|ok
decl_stmt|;
name|statusCode
operator|=
name|code
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
expr_stmt|;
name|reasonPhrase
operator|=
name|QString
operator|::
name|fromLatin1
argument_list|(
name|status
operator|.
name|constData
argument_list|()
operator|+
name|j
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|ok
operator|&&
name|uint
argument_list|(
name|majorVersion
argument_list|)
operator|<=
literal|9
operator|&&
name|uint
argument_list|(
name|minorVersion
argument_list|)
operator|<=
literal|9
return|;
block|}
end_function
begin_function
DECL|function|readHeader
name|qint64
name|QHttpNetworkReplyPrivate
operator|::
name|readHeader
parameter_list|(
name|QAbstractSocket
modifier|*
name|socket
parameter_list|)
block|{
if|if
condition|(
name|fragment
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// according to http://dev.opera.com/articles/view/mama-http-headers/ the average size of the header
comment|// block is 381 bytes.
comment|// reserve bytes. This is better than always append() which reallocs the byte array.
name|fragment
operator|.
name|reserve
argument_list|(
literal|512
argument_list|)
expr_stmt|;
block|}
name|qint64
name|bytes
init|=
literal|0
decl_stmt|;
name|char
name|c
init|=
literal|0
decl_stmt|;
name|bool
name|allHeaders
init|=
literal|false
decl_stmt|;
name|qint64
name|haveRead
init|=
literal|0
decl_stmt|;
do|do
block|{
name|haveRead
operator|=
name|socket
operator|->
name|read
argument_list|(
operator|&
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|haveRead
operator|==
literal|0
condition|)
block|{
comment|// read more later
break|break;
block|}
elseif|else
if|if
condition|(
name|haveRead
operator|==
operator|-
literal|1
condition|)
block|{
comment|// connection broke down
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
name|fragment
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|bytes
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
comment|// check for possible header endings. As per HTTP rfc,
comment|// the header endings will be marked by CRLFCRLF. But
comment|// we will allow CRLFCRLF, CRLFLF, LFLF
if|if
condition|(
name|fragment
operator|.
name|endsWith
argument_list|(
literal|"\r\n\r\n"
argument_list|)
operator|||
name|fragment
operator|.
name|endsWith
argument_list|(
literal|"\r\n\n"
argument_list|)
operator|||
name|fragment
operator|.
name|endsWith
argument_list|(
literal|"\n\n"
argument_list|)
condition|)
name|allHeaders
operator|=
literal|true
expr_stmt|;
comment|// there is another case: We have no headers. Then the fragment equals just the line ending
if|if
condition|(
operator|(
name|fragment
operator|.
name|length
argument_list|()
operator|==
literal|2
operator|&&
name|fragment
operator|.
name|endsWith
argument_list|(
literal|"\r\n"
argument_list|)
operator|)
operator|||
operator|(
name|fragment
operator|.
name|length
argument_list|()
operator|==
literal|1
operator|&&
name|fragment
operator|.
name|endsWith
argument_list|(
literal|"\n"
argument_list|)
operator|)
condition|)
name|allHeaders
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
operator|!
name|allHeaders
operator|&&
name|haveRead
operator|>
literal|0
condition|)
do|;
comment|// we received all headers now parse them
if|if
condition|(
name|allHeaders
condition|)
block|{
name|parseHeader
argument_list|(
name|fragment
argument_list|)
expr_stmt|;
name|state
operator|=
name|ReadingDataState
expr_stmt|;
name|fragment
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// next fragment
name|bodyLength
operator|=
name|contentLength
argument_list|()
expr_stmt|;
comment|// cache the length
comment|// cache isChunked() since it is called often
name|chunkedTransferEncoding
operator|=
name|headerField
argument_list|(
literal|"transfer-encoding"
argument_list|)
operator|.
name|toLower
argument_list|()
operator|.
name|contains
argument_list|(
literal|"chunked"
argument_list|)
expr_stmt|;
comment|// cache isConnectionCloseEnabled since it is called often
name|QByteArray
name|connectionHeaderField
init|=
name|headerField
argument_list|(
literal|"connection"
argument_list|)
decl_stmt|;
comment|// check for explicit indication of close or the implicit connection close of HTTP/1.0
name|connectionCloseEnabled
operator|=
operator|(
name|connectionHeaderField
operator|.
name|toLower
argument_list|()
operator|.
name|contains
argument_list|(
literal|"close"
argument_list|)
operator|||
name|headerField
argument_list|(
literal|"proxy-connection"
argument_list|)
operator|.
name|toLower
argument_list|()
operator|.
name|contains
argument_list|(
literal|"close"
argument_list|)
operator|)
operator|||
operator|(
name|majorVersion
operator|==
literal|1
operator|&&
name|minorVersion
operator|==
literal|0
operator|&&
operator|(
name|connectionHeaderField
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|headerField
argument_list|(
literal|"proxy-connection"
argument_list|)
operator|.
name|toLower
argument_list|()
operator|.
name|contains
argument_list|(
literal|"keep-alive"
argument_list|)
operator|)
operator|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_COMPRESS
if|if
condition|(
name|autoDecompress
operator|&&
name|isCompressed
argument_list|()
condition|)
block|{
comment|// allocate inflate state
if|if
condition|(
operator|!
name|inflateStrm
condition|)
name|inflateStrm
operator|=
operator|new
name|z_stream
expr_stmt|;
name|inflateStrm
operator|->
name|zalloc
operator|=
name|Z_NULL
expr_stmt|;
name|inflateStrm
operator|->
name|zfree
operator|=
name|Z_NULL
expr_stmt|;
name|inflateStrm
operator|->
name|opaque
operator|=
name|Z_NULL
expr_stmt|;
name|inflateStrm
operator|->
name|avail_in
operator|=
literal|0
expr_stmt|;
name|inflateStrm
operator|->
name|next_in
operator|=
name|Z_NULL
expr_stmt|;
comment|// "windowBits can also be greater than 15 for optional gzip decoding.
comment|// Add 32 to windowBits to enable zlib and gzip decoding with automatic header detection"
comment|// http://www.zlib.net/manual.html
name|int
name|ret
init|=
name|inflateInit2
argument_list|(
name|inflateStrm
argument_list|,
name|MAX_WBITS
operator|+
literal|32
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|!=
name|Z_OK
condition|)
return|return
operator|-
literal|1
return|;
block|}
endif|#
directive|endif
block|}
return|return
name|bytes
return|;
block|}
end_function
begin_function
DECL|function|parseHeader
name|void
name|QHttpNetworkReplyPrivate
operator|::
name|parseHeader
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|header
parameter_list|)
block|{
comment|// see rfc2616, sec 4 for information about HTTP/1.1 headers.
comment|// allows relaxed parsing here, accepts both CRLF& LF line endings
specifier|const
name|QByteArrayMatcher
name|lf
argument_list|(
literal|"\n"
argument_list|)
decl_stmt|;
specifier|const
name|QByteArrayMatcher
name|colon
argument_list|(
literal|":"
argument_list|)
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|header
operator|.
name|count
argument_list|()
condition|)
block|{
name|int
name|j
init|=
name|colon
operator|.
name|indexIn
argument_list|(
name|header
argument_list|,
name|i
argument_list|)
decl_stmt|;
comment|// field-name
if|if
condition|(
name|j
operator|==
operator|-
literal|1
condition|)
break|break;
specifier|const
name|QByteArray
name|field
init|=
name|header
operator|.
name|mid
argument_list|(
name|i
argument_list|,
name|j
operator|-
name|i
argument_list|)
operator|.
name|trimmed
argument_list|()
decl_stmt|;
name|j
operator|++
expr_stmt|;
comment|// any number of LWS is allowed before and after the value
name|QByteArray
name|value
decl_stmt|;
do|do
block|{
name|i
operator|=
name|lf
operator|.
name|indexIn
argument_list|(
name|header
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
break|break;
if|if
condition|(
operator|!
name|value
operator|.
name|isEmpty
argument_list|()
condition|)
name|value
operator|+=
literal|' '
expr_stmt|;
comment|// check if we have CRLF or only LF
name|bool
name|hasCR
init|=
operator|(
name|i
operator|&&
name|header
index|[
name|i
operator|-
literal|1
index|]
operator|==
literal|'\r'
operator|)
decl_stmt|;
name|int
name|length
init|=
name|i
operator|-
operator|(
name|hasCR
condition|?
literal|1
else|:
literal|0
operator|)
operator|-
name|j
decl_stmt|;
name|value
operator|+=
name|header
operator|.
name|mid
argument_list|(
name|j
argument_list|,
name|length
argument_list|)
operator|.
name|trimmed
argument_list|()
expr_stmt|;
name|j
operator|=
operator|++
name|i
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|<
name|header
operator|.
name|count
argument_list|()
operator|&&
operator|(
name|header
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|==
literal|' '
operator|||
name|header
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|==
literal|'\t'
operator|)
condition|)
do|;
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
break|break;
comment|// something is wrong
name|fields
operator|.
name|append
argument_list|(
name|qMakePair
argument_list|(
name|field
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|isChunked
name|bool
name|QHttpNetworkReplyPrivate
operator|::
name|isChunked
parameter_list|()
block|{
return|return
name|chunkedTransferEncoding
return|;
block|}
end_function
begin_function
DECL|function|isConnectionCloseEnabled
name|bool
name|QHttpNetworkReplyPrivate
operator|::
name|isConnectionCloseEnabled
parameter_list|()
block|{
return|return
name|connectionCloseEnabled
operator|||
name|forceConnectionCloseEnabled
return|;
block|}
end_function
begin_comment
comment|// note this function can only be used for non-chunked, non-compressed with
end_comment
begin_comment
comment|// known content length
end_comment
begin_function
DECL|function|readBodyVeryFast
name|qint64
name|QHttpNetworkReplyPrivate
operator|::
name|readBodyVeryFast
parameter_list|(
name|QAbstractSocket
modifier|*
name|socket
parameter_list|,
name|char
modifier|*
name|b
parameter_list|)
block|{
comment|// This first read is to flush the buffer inside the socket
name|qint64
name|haveRead
init|=
literal|0
decl_stmt|;
name|haveRead
operator|=
name|socket
operator|->
name|read
argument_list|(
name|b
argument_list|,
name|bodyLength
operator|-
name|contentRead
argument_list|)
expr_stmt|;
if|if
condition|(
name|haveRead
operator|==
operator|-
literal|1
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|contentRead
operator|+=
name|haveRead
expr_stmt|;
if|if
condition|(
name|contentRead
operator|==
name|bodyLength
condition|)
block|{
name|state
operator|=
name|AllDoneState
expr_stmt|;
block|}
return|return
name|haveRead
return|;
block|}
end_function
begin_comment
comment|// note this function can only be used for non-chunked, non-compressed with
end_comment
begin_comment
comment|// known content length
end_comment
begin_function
DECL|function|readBodyFast
name|qint64
name|QHttpNetworkReplyPrivate
operator|::
name|readBodyFast
parameter_list|(
name|QAbstractSocket
modifier|*
name|socket
parameter_list|,
name|QByteDataBuffer
modifier|*
name|rb
parameter_list|)
block|{
name|qint64
name|toBeRead
init|=
name|qMin
argument_list|(
name|socket
operator|->
name|bytesAvailable
argument_list|()
argument_list|,
name|bodyLength
operator|-
name|contentRead
argument_list|)
decl_stmt|;
if|if
condition|(
name|readBufferMaxSize
condition|)
name|toBeRead
operator|=
name|qMin
argument_list|(
name|toBeRead
argument_list|,
name|readBufferMaxSize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|toBeRead
condition|)
return|return
literal|0
return|;
name|QByteArray
name|bd
decl_stmt|;
name|bd
operator|.
name|resize
argument_list|(
name|toBeRead
argument_list|)
expr_stmt|;
name|qint64
name|haveRead
init|=
name|socket
operator|->
name|read
argument_list|(
name|bd
operator|.
name|data
argument_list|()
argument_list|,
name|toBeRead
argument_list|)
decl_stmt|;
if|if
condition|(
name|haveRead
operator|==
operator|-
literal|1
condition|)
block|{
name|bd
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
comment|// ### error checking here;
block|}
name|bd
operator|.
name|resize
argument_list|(
name|haveRead
argument_list|)
expr_stmt|;
name|rb
operator|->
name|append
argument_list|(
name|bd
argument_list|)
expr_stmt|;
if|if
condition|(
name|contentRead
operator|+
name|haveRead
operator|==
name|bodyLength
condition|)
block|{
name|state
operator|=
name|AllDoneState
expr_stmt|;
block|}
name|contentRead
operator|+=
name|haveRead
expr_stmt|;
return|return
name|haveRead
return|;
block|}
end_function
begin_function
DECL|function|readBody
name|qint64
name|QHttpNetworkReplyPrivate
operator|::
name|readBody
parameter_list|(
name|QAbstractSocket
modifier|*
name|socket
parameter_list|,
name|QByteDataBuffer
modifier|*
name|out
parameter_list|)
block|{
name|qint64
name|bytes
init|=
literal|0
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_COMPRESS
comment|// for gzip we'll allocate a temporary one that we then decompress
name|QByteDataBuffer
modifier|*
name|tempOutDataBuffer
init|=
operator|(
name|autoDecompress
condition|?
operator|new
name|QByteDataBuffer
else|:
name|out
operator|)
decl_stmt|;
else|#
directive|else
name|QByteDataBuffer
modifier|*
name|tempOutDataBuffer
init|=
name|out
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|isChunked
argument_list|()
condition|)
block|{
comment|// chunked transfer encoding (rfc 2616, sec 3.6)
name|bytes
operator|+=
name|readReplyBodyChunked
argument_list|(
name|socket
argument_list|,
name|tempOutDataBuffer
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bodyLength
operator|>
literal|0
condition|)
block|{
comment|// we have a Content-Length
name|bytes
operator|+=
name|readReplyBodyRaw
argument_list|(
name|socket
argument_list|,
name|tempOutDataBuffer
argument_list|,
name|bodyLength
operator|-
name|contentRead
argument_list|)
expr_stmt|;
if|if
condition|(
name|contentRead
operator|+
name|bytes
operator|==
name|bodyLength
condition|)
name|state
operator|=
name|AllDoneState
expr_stmt|;
block|}
else|else
block|{
comment|// no content length. just read what's possible
name|bytes
operator|+=
name|readReplyBodyRaw
argument_list|(
name|socket
argument_list|,
name|tempOutDataBuffer
argument_list|,
name|socket
operator|->
name|bytesAvailable
argument_list|()
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|QT_NO_COMPRESS
comment|// This is true if there is compressed encoding and we're supposed to use it.
if|if
condition|(
name|autoDecompress
condition|)
block|{
name|qint64
name|uncompressRet
init|=
name|uncompressBodyData
argument_list|(
name|tempOutDataBuffer
argument_list|,
name|out
argument_list|)
decl_stmt|;
operator|delete
name|tempOutDataBuffer
expr_stmt|;
if|if
condition|(
name|uncompressRet
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
block|}
endif|#
directive|endif
name|contentRead
operator|+=
name|bytes
expr_stmt|;
return|return
name|bytes
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_COMPRESS
end_ifndef
begin_function
DECL|function|uncompressBodyData
name|qint64
name|QHttpNetworkReplyPrivate
operator|::
name|uncompressBodyData
parameter_list|(
name|QByteDataBuffer
modifier|*
name|in
parameter_list|,
name|QByteDataBuffer
modifier|*
name|out
parameter_list|)
block|{
if|if
condition|(
operator|!
name|inflateStrm
condition|)
return|return
operator|-
literal|1
return|;
name|bool
name|triedRawDeflate
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|in
operator|->
name|bufferCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|QByteArray
modifier|&
name|bIn
init|=
operator|(
operator|*
name|in
operator|)
index|[
name|i
index|]
decl_stmt|;
name|inflateStrm
operator|->
name|avail_in
operator|=
name|bIn
operator|.
name|size
argument_list|()
expr_stmt|;
name|inflateStrm
operator|->
name|next_in
operator|=
cast|reinterpret_cast
argument_list|<
name|Bytef
operator|*
argument_list|>
argument_list|(
name|bIn
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
do|do
block|{
name|QByteArray
name|bOut
decl_stmt|;
comment|// make a wild guess about the uncompressed size.
name|bOut
operator|.
name|reserve
argument_list|(
name|inflateStrm
operator|->
name|avail_in
operator|*
literal|3
operator|+
literal|512
argument_list|)
expr_stmt|;
name|inflateStrm
operator|->
name|avail_out
operator|=
name|bOut
operator|.
name|capacity
argument_list|()
expr_stmt|;
name|inflateStrm
operator|->
name|next_out
operator|=
cast|reinterpret_cast
argument_list|<
name|Bytef
operator|*
argument_list|>
argument_list|(
name|bOut
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
name|int
name|ret
init|=
name|inflate
argument_list|(
name|inflateStrm
argument_list|,
name|Z_NO_FLUSH
argument_list|)
decl_stmt|;
comment|//All negative return codes are errors, in the context of HTTP compression, Z_NEED_DICT is also an error.
comment|// in the case where we get Z_DATA_ERROR this could be because we received raw deflate compressed data.
if|if
condition|(
name|ret
operator|==
name|Z_DATA_ERROR
operator|&&
operator|!
name|triedRawDeflate
condition|)
block|{
name|inflateEnd
argument_list|(
name|inflateStrm
argument_list|)
expr_stmt|;
name|triedRawDeflate
operator|=
literal|true
expr_stmt|;
name|inflateStrm
operator|->
name|zalloc
operator|=
name|Z_NULL
expr_stmt|;
name|inflateStrm
operator|->
name|zfree
operator|=
name|Z_NULL
expr_stmt|;
name|inflateStrm
operator|->
name|opaque
operator|=
name|Z_NULL
expr_stmt|;
name|inflateStrm
operator|->
name|avail_in
operator|=
literal|0
expr_stmt|;
name|inflateStrm
operator|->
name|next_in
operator|=
name|Z_NULL
expr_stmt|;
name|int
name|ret
init|=
name|inflateInit2
argument_list|(
name|inflateStrm
argument_list|,
operator|-
name|MAX_WBITS
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|!=
name|Z_OK
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
name|inflateStrm
operator|->
name|avail_in
operator|=
name|bIn
operator|.
name|size
argument_list|()
expr_stmt|;
name|inflateStrm
operator|->
name|next_in
operator|=
cast|reinterpret_cast
argument_list|<
name|Bytef
operator|*
argument_list|>
argument_list|(
name|bIn
operator|.
name|data
argument_list|()
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
elseif|else
if|if
condition|(
name|ret
operator|<
literal|0
operator|||
name|ret
operator|==
name|Z_NEED_DICT
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|bOut
operator|.
name|resize
argument_list|(
name|bOut
operator|.
name|capacity
argument_list|()
operator|-
name|inflateStrm
operator|->
name|avail_out
argument_list|)
expr_stmt|;
name|out
operator|->
name|append
argument_list|(
name|bOut
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|Z_STREAM_END
condition|)
return|return
name|out
operator|->
name|byteAmount
argument_list|()
return|;
block|}
do|while
condition|(
name|inflateStrm
operator|->
name|avail_in
operator|>
literal|0
condition|)
do|;
block|}
return|return
name|out
operator|->
name|byteAmount
argument_list|()
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|readReplyBodyRaw
name|qint64
name|QHttpNetworkReplyPrivate
operator|::
name|readReplyBodyRaw
parameter_list|(
name|QAbstractSocket
modifier|*
name|socket
parameter_list|,
name|QByteDataBuffer
modifier|*
name|out
parameter_list|,
name|qint64
name|size
parameter_list|)
block|{
comment|// FIXME get rid of this function and just use readBodyFast and give it socket->bytesAvailable()
name|qint64
name|bytes
init|=
literal|0
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|socket
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|int
name|toBeRead
init|=
name|qMin
argument_list|<
name|qint64
argument_list|>
argument_list|(
literal|128
operator|*
literal|1024
argument_list|,
name|qMin
argument_list|<
name|qint64
argument_list|>
argument_list|(
name|size
argument_list|,
name|socket
operator|->
name|bytesAvailable
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|readBufferMaxSize
condition|)
name|toBeRead
operator|=
name|qMin
argument_list|<
name|qint64
argument_list|>
argument_list|(
name|toBeRead
argument_list|,
name|readBufferMaxSize
argument_list|)
expr_stmt|;
while|while
condition|(
name|toBeRead
operator|>
literal|0
condition|)
block|{
name|QByteArray
name|byteData
decl_stmt|;
name|byteData
operator|.
name|resize
argument_list|(
name|toBeRead
argument_list|)
expr_stmt|;
name|qint64
name|haveRead
init|=
name|socket
operator|->
name|read
argument_list|(
name|byteData
operator|.
name|data
argument_list|()
argument_list|,
name|byteData
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|haveRead
operator|<=
literal|0
condition|)
block|{
comment|// ### error checking here
name|byteData
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return
name|bytes
return|;
block|}
name|byteData
operator|.
name|resize
argument_list|(
name|haveRead
argument_list|)
expr_stmt|;
name|out
operator|->
name|append
argument_list|(
name|byteData
argument_list|)
expr_stmt|;
name|bytes
operator|+=
name|haveRead
expr_stmt|;
name|size
operator|-=
name|haveRead
expr_stmt|;
name|toBeRead
operator|=
name|qMin
argument_list|<
name|qint64
argument_list|>
argument_list|(
literal|128
operator|*
literal|1024
argument_list|,
name|qMin
argument_list|<
name|qint64
argument_list|>
argument_list|(
name|size
argument_list|,
name|socket
operator|->
name|bytesAvailable
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|bytes
return|;
block|}
end_function
begin_function
DECL|function|readReplyBodyChunked
name|qint64
name|QHttpNetworkReplyPrivate
operator|::
name|readReplyBodyChunked
parameter_list|(
name|QAbstractSocket
modifier|*
name|socket
parameter_list|,
name|QByteDataBuffer
modifier|*
name|out
parameter_list|)
block|{
name|qint64
name|bytes
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|socket
operator|->
name|bytesAvailable
argument_list|()
condition|)
block|{
if|if
condition|(
name|readBufferMaxSize
operator|&&
operator|(
name|bytes
operator|>
name|readBufferMaxSize
operator|)
condition|)
break|break;
if|if
condition|(
operator|!
name|lastChunkRead
operator|&&
name|currentChunkRead
operator|>=
name|currentChunkSize
condition|)
block|{
comment|// For the first chunk and when we're done with a chunk
name|currentChunkSize
operator|=
literal|0
expr_stmt|;
name|currentChunkRead
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bytes
condition|)
block|{
comment|// After a chunk
name|char
name|crlf
index|[
literal|2
index|]
decl_stmt|;
comment|// read the "\r\n" after the chunk
name|qint64
name|haveRead
init|=
name|socket
operator|->
name|read
argument_list|(
name|crlf
argument_list|,
literal|2
argument_list|)
decl_stmt|;
comment|// FIXME: This code is slightly broken and not optimal. What if the 2 bytes are not available yet?!
comment|// For nice reasons (the toLong in getChunkSize accepting \n at the beginning
comment|// it right now still works, but we should definitely fix this.
if|if
condition|(
name|haveRead
operator|!=
literal|2
condition|)
return|return
name|bytes
return|;
comment|// FIXME
name|bytes
operator|+=
name|haveRead
expr_stmt|;
block|}
comment|// Note that chunk size gets stored in currentChunkSize, what is returned is the bytes read
name|bytes
operator|+=
name|getChunkSize
argument_list|(
name|socket
argument_list|,
operator|&
name|currentChunkSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|currentChunkSize
operator|==
operator|-
literal|1
condition|)
break|break;
block|}
comment|// if the chunk size is 0, end of the stream
if|if
condition|(
name|currentChunkSize
operator|==
literal|0
operator|||
name|lastChunkRead
condition|)
block|{
name|lastChunkRead
operator|=
literal|true
expr_stmt|;
comment|// try to read the "\r\n" after the chunk
name|char
name|crlf
index|[
literal|2
index|]
decl_stmt|;
name|qint64
name|haveRead
init|=
name|socket
operator|->
name|read
argument_list|(
name|crlf
argument_list|,
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|haveRead
operator|>
literal|0
condition|)
name|bytes
operator|+=
name|haveRead
expr_stmt|;
if|if
condition|(
operator|(
name|haveRead
operator|==
literal|2
operator|&&
name|crlf
index|[
literal|0
index|]
operator|==
literal|'\r'
operator|&&
name|crlf
index|[
literal|1
index|]
operator|==
literal|'\n'
operator|)
operator|||
operator|(
name|haveRead
operator|==
literal|1
operator|&&
name|crlf
index|[
literal|0
index|]
operator|==
literal|'\n'
operator|)
condition|)
name|state
operator|=
name|AllDoneState
expr_stmt|;
elseif|else
if|if
condition|(
name|haveRead
operator|==
literal|1
operator|&&
name|crlf
index|[
literal|0
index|]
operator|==
literal|'\r'
condition|)
break|break;
comment|// Still waiting for the last \n
elseif|else
if|if
condition|(
name|haveRead
operator|>
literal|0
condition|)
block|{
comment|// If we read something else then CRLF, we need to close the channel.
name|forceConnectionCloseEnabled
operator|=
literal|true
expr_stmt|;
name|state
operator|=
name|AllDoneState
expr_stmt|;
block|}
break|break;
block|}
comment|// otherwise, try to begin reading this chunk / to read what is missing for this chunk
name|qint64
name|haveRead
init|=
name|readReplyBodyRaw
argument_list|(
name|socket
argument_list|,
name|out
argument_list|,
name|currentChunkSize
operator|-
name|currentChunkRead
argument_list|)
decl_stmt|;
name|currentChunkRead
operator|+=
name|haveRead
expr_stmt|;
name|bytes
operator|+=
name|haveRead
expr_stmt|;
comment|// ### error checking here
block|}
return|return
name|bytes
return|;
block|}
end_function
begin_function
DECL|function|getChunkSize
name|qint64
name|QHttpNetworkReplyPrivate
operator|::
name|getChunkSize
parameter_list|(
name|QAbstractSocket
modifier|*
name|socket
parameter_list|,
name|qint64
modifier|*
name|chunkSize
parameter_list|)
block|{
name|qint64
name|bytes
init|=
literal|0
decl_stmt|;
name|char
name|crlf
index|[
literal|2
index|]
decl_stmt|;
operator|*
name|chunkSize
operator|=
operator|-
literal|1
expr_stmt|;
name|int
name|bytesAvailable
init|=
name|socket
operator|->
name|bytesAvailable
argument_list|()
decl_stmt|;
comment|// FIXME rewrite to permanent loop without bytesAvailable
while|while
condition|(
name|bytesAvailable
operator|>
name|bytes
condition|)
block|{
name|qint64
name|sniffedBytes
init|=
name|socket
operator|->
name|peek
argument_list|(
name|crlf
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|int
name|fragmentSize
init|=
name|fragment
operator|.
name|size
argument_list|()
decl_stmt|;
comment|// check the next two bytes for a "\r\n", skip blank lines
if|if
condition|(
operator|(
name|fragmentSize
operator|&&
name|sniffedBytes
operator|==
literal|2
operator|&&
name|crlf
index|[
literal|0
index|]
operator|==
literal|'\r'
operator|&&
name|crlf
index|[
literal|1
index|]
operator|==
literal|'\n'
operator|)
operator|||
operator|(
name|fragmentSize
operator|>
literal|1
operator|&&
name|fragment
operator|.
name|endsWith
argument_list|(
literal|'\r'
argument_list|)
operator|&&
name|crlf
index|[
literal|0
index|]
operator|==
literal|'\n'
operator|)
condition|)
block|{
name|bytes
operator|+=
name|socket
operator|->
name|read
argument_list|(
name|crlf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|// read the \r or \n
if|if
condition|(
name|crlf
index|[
literal|0
index|]
operator|==
literal|'\r'
condition|)
name|bytes
operator|+=
name|socket
operator|->
name|read
argument_list|(
name|crlf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|// read the \n
name|bool
name|ok
init|=
literal|false
decl_stmt|;
comment|// ignore the chunk-extension
name|fragment
operator|=
name|fragment
operator|.
name|mid
argument_list|(
literal|0
argument_list|,
name|fragment
operator|.
name|indexOf
argument_list|(
literal|';'
argument_list|)
argument_list|)
operator|.
name|trimmed
argument_list|()
expr_stmt|;
operator|*
name|chunkSize
operator|=
name|fragment
operator|.
name|toLong
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|fragment
operator|.
name|clear
argument_list|()
expr_stmt|;
break|break;
comment|// size done
block|}
else|else
block|{
comment|// read the fragment to the buffer
name|char
name|c
init|=
literal|0
decl_stmt|;
name|qint64
name|haveRead
init|=
name|socket
operator|->
name|read
argument_list|(
operator|&
name|c
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|haveRead
operator|<
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
comment|// FIXME
block|}
name|bytes
operator|+=
name|haveRead
expr_stmt|;
name|fragment
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|bytes
return|;
block|}
end_function
begin_function
DECL|function|shouldEmitSignals
name|bool
name|QHttpNetworkReplyPrivate
operator|::
name|shouldEmitSignals
parameter_list|()
block|{
comment|// for 401& 407 don't emit the data signals. Content along with these
comment|// responses are send only if the authentication fails.
return|return
operator|(
name|statusCode
operator|!=
literal|401
operator|&&
name|statusCode
operator|!=
literal|407
operator|)
return|;
block|}
end_function
begin_function
DECL|function|expectContent
name|bool
name|QHttpNetworkReplyPrivate
operator|::
name|expectContent
parameter_list|()
block|{
comment|// check whether we can expect content after the headers (rfc 2616, sec4.4)
if|if
condition|(
operator|(
name|statusCode
operator|>=
literal|100
operator|&&
name|statusCode
operator|<
literal|200
operator|)
operator|||
name|statusCode
operator|==
literal|204
operator|||
name|statusCode
operator|==
literal|304
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|request
operator|.
name|operation
argument_list|()
operator|==
name|QHttpNetworkRequest
operator|::
name|Head
condition|)
return|return
literal|false
return|;
comment|// no body expected for HEAD request
name|qint64
name|expectedContentLength
init|=
name|contentLength
argument_list|()
decl_stmt|;
if|if
condition|(
name|expectedContentLength
operator|==
literal|0
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|expectedContentLength
operator|==
operator|-
literal|1
operator|&&
name|bodyLength
operator|==
literal|0
condition|)
block|{
comment|// The content-length header was stripped, but its value was 0.
comment|// This would be the case for an explicitly zero-length compressed response.
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|eraseData
name|void
name|QHttpNetworkReplyPrivate
operator|::
name|eraseData
parameter_list|()
block|{
name|compressedData
operator|.
name|clear
argument_list|()
expr_stmt|;
name|responseData
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|// SSL support below
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_SSL
end_ifndef
begin_function
DECL|function|sslConfiguration
name|QSslConfiguration
name|QHttpNetworkReply
operator|::
name|sslConfiguration
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QHttpNetworkReply
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|connectionChannel
condition|)
return|return
name|QSslConfiguration
argument_list|()
return|;
name|QSslSocket
modifier|*
name|sslSocket
init|=
name|qobject_cast
argument_list|<
name|QSslSocket
operator|*
argument_list|>
argument_list|(
name|d
operator|->
name|connectionChannel
operator|->
name|socket
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sslSocket
condition|)
return|return
name|QSslConfiguration
argument_list|()
return|;
return|return
name|sslSocket
operator|->
name|sslConfiguration
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|setSslConfiguration
name|void
name|QHttpNetworkReply
operator|::
name|setSslConfiguration
parameter_list|(
specifier|const
name|QSslConfiguration
modifier|&
name|config
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QHttpNetworkReply
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|connection
condition|)
name|d
operator|->
name|connection
operator|->
name|setSslConfiguration
argument_list|(
name|config
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|ignoreSslErrors
name|void
name|QHttpNetworkReply
operator|::
name|ignoreSslErrors
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QHttpNetworkReply
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|connection
condition|)
name|d
operator|->
name|connection
operator|->
name|ignoreSslErrors
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|ignoreSslErrors
name|void
name|QHttpNetworkReply
operator|::
name|ignoreSslErrors
parameter_list|(
specifier|const
name|QList
argument_list|<
name|QSslError
argument_list|>
modifier|&
name|errors
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QHttpNetworkReply
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|connection
condition|)
name|d
operator|->
name|connection
operator|->
name|ignoreSslErrors
argument_list|(
name|errors
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//QT_NO_SSL
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_HTTP
end_comment
end_unit
