begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the QtNetwork module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** No Commercial Usage ** This file contains pre-release code and may not be distributed. ** You may use this file in accordance with the terms and conditions ** contained in the Technology Preview License Agreement accompanying ** this package. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights.  These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** If you have questions regarding the use of this file, please contact ** Nokia at qt-info@nokia.com. ** ** ** ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qhttpnetworkreply_p.h"
end_include
begin_include
include|#
directive|include
file|"qhttpnetworkconnection_p.h"
end_include
begin_include
include|#
directive|include
file|<qbytearraymatcher.h>
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_HTTP
end_ifndef
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_OPENSSL
end_ifndef
begin_include
include|#
directive|include
file|<QtNetwork/qsslkey.h>
end_include
begin_include
include|#
directive|include
file|<QtNetwork/qsslcipher.h>
end_include
begin_include
include|#
directive|include
file|<QtNetwork/qsslconfiguration.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_constructor
DECL|function|QHttpNetworkReply
name|QHttpNetworkReply
operator|::
name|QHttpNetworkReply
parameter_list|(
specifier|const
name|QUrl
modifier|&
name|url
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|new
name|QHttpNetworkReplyPrivate
argument_list|(
name|url
argument_list|)
argument_list|,
name|parent
argument_list|)
block|{ }
end_constructor
begin_destructor
DECL|function|~QHttpNetworkReply
name|QHttpNetworkReply
operator|::
name|~
name|QHttpNetworkReply
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QHttpNetworkReply
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|connection
condition|)
block|{
name|d
operator|->
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|removeReply
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
end_destructor
begin_function
DECL|function|url
name|QUrl
name|QHttpNetworkReply
operator|::
name|url
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|url
return|;
block|}
end_function
begin_function
DECL|function|setUrl
name|void
name|QHttpNetworkReply
operator|::
name|setUrl
parameter_list|(
specifier|const
name|QUrl
modifier|&
name|url
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QHttpNetworkReply
argument_list|)
expr_stmt|;
name|d
operator|->
name|url
operator|=
name|url
expr_stmt|;
block|}
end_function
begin_function
DECL|function|contentLength
name|qint64
name|QHttpNetworkReply
operator|::
name|contentLength
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|contentLength
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|setContentLength
name|void
name|QHttpNetworkReply
operator|::
name|setContentLength
parameter_list|(
name|qint64
name|length
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QHttpNetworkReply
argument_list|)
expr_stmt|;
name|d
operator|->
name|setContentLength
argument_list|(
name|length
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|header
name|QList
argument_list|<
name|QPair
argument_list|<
name|QByteArray
argument_list|,
name|QByteArray
argument_list|>
argument_list|>
name|QHttpNetworkReply
operator|::
name|header
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|fields
return|;
block|}
end_function
begin_function
DECL|function|headerField
name|QByteArray
name|QHttpNetworkReply
operator|::
name|headerField
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|name
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|defaultValue
parameter_list|)
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|headerField
argument_list|(
name|name
argument_list|,
name|defaultValue
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|setHeaderField
name|void
name|QHttpNetworkReply
operator|::
name|setHeaderField
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|name
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|data
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QHttpNetworkReply
argument_list|)
expr_stmt|;
name|d
operator|->
name|setHeaderField
argument_list|(
name|name
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|parseHeader
name|void
name|QHttpNetworkReply
operator|::
name|parseHeader
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|header
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QHttpNetworkReply
argument_list|)
expr_stmt|;
name|d
operator|->
name|parseHeader
argument_list|(
name|header
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|request
name|QHttpNetworkRequest
name|QHttpNetworkReply
operator|::
name|request
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|request
return|;
block|}
end_function
begin_function
DECL|function|setRequest
name|void
name|QHttpNetworkReply
operator|::
name|setRequest
parameter_list|(
specifier|const
name|QHttpNetworkRequest
modifier|&
name|request
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QHttpNetworkReply
argument_list|)
expr_stmt|;
name|d
operator|->
name|request
operator|=
name|request
expr_stmt|;
name|d
operator|->
name|ssl
operator|=
name|request
operator|.
name|isSsl
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|statusCode
name|int
name|QHttpNetworkReply
operator|::
name|statusCode
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|statusCode
return|;
block|}
end_function
begin_function
DECL|function|setStatusCode
name|void
name|QHttpNetworkReply
operator|::
name|setStatusCode
parameter_list|(
name|int
name|code
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QHttpNetworkReply
argument_list|)
expr_stmt|;
name|d
operator|->
name|statusCode
operator|=
name|code
expr_stmt|;
block|}
end_function
begin_function
DECL|function|errorString
name|QString
name|QHttpNetworkReply
operator|::
name|errorString
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|errorString
return|;
block|}
end_function
begin_function
DECL|function|reasonPhrase
name|QString
name|QHttpNetworkReply
operator|::
name|reasonPhrase
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|reasonPhrase
return|;
block|}
end_function
begin_function
DECL|function|setErrorString
name|void
name|QHttpNetworkReply
operator|::
name|setErrorString
parameter_list|(
specifier|const
name|QString
modifier|&
name|error
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QHttpNetworkReply
argument_list|)
expr_stmt|;
name|d
operator|->
name|errorString
operator|=
name|error
expr_stmt|;
block|}
end_function
begin_function
DECL|function|majorVersion
name|int
name|QHttpNetworkReply
operator|::
name|majorVersion
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|majorVersion
return|;
block|}
end_function
begin_function
DECL|function|minorVersion
name|int
name|QHttpNetworkReply
operator|::
name|minorVersion
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|minorVersion
return|;
block|}
end_function
begin_function
DECL|function|bytesAvailable
name|qint64
name|QHttpNetworkReply
operator|::
name|bytesAvailable
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QHttpNetworkReply
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|connection
condition|)
return|return
name|d
operator|->
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|uncompressedBytesAvailable
argument_list|(
operator|*
name|this
argument_list|)
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_function
DECL|function|bytesAvailableNextBlock
name|qint64
name|QHttpNetworkReply
operator|::
name|bytesAvailableNextBlock
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QHttpNetworkReply
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|connection
condition|)
return|return
name|d
operator|->
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|uncompressedBytesAvailableNextBlock
argument_list|(
operator|*
name|this
argument_list|)
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_function
DECL|function|readAnyAvailable
name|bool
name|QHttpNetworkReply
operator|::
name|readAnyAvailable
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QHttpNetworkReply
argument_list|)
expr_stmt|;
return|return
operator|(
name|d
operator|->
name|responseData
operator|.
name|bufferCount
argument_list|()
operator|>
literal|0
operator|)
return|;
block|}
end_function
begin_function
DECL|function|readAny
name|QByteArray
name|QHttpNetworkReply
operator|::
name|readAny
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QHttpNetworkReply
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|responseData
operator|.
name|bufferCount
argument_list|()
operator|==
literal|0
condition|)
return|return
name|QByteArray
argument_list|()
return|;
comment|// we'll take the last buffer, so schedule another read from http
if|if
condition|(
name|d
operator|->
name|downstreamLimited
operator|&&
name|d
operator|->
name|responseData
operator|.
name|bufferCount
argument_list|()
operator|==
literal|1
condition|)
name|d
operator|->
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|readMoreLater
argument_list|(
name|this
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|responseData
operator|.
name|read
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|readAll
name|QByteArray
name|QHttpNetworkReply
operator|::
name|readAll
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QHttpNetworkReply
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|responseData
operator|.
name|readAll
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|setDownstreamLimited
name|void
name|QHttpNetworkReply
operator|::
name|setDownstreamLimited
parameter_list|(
name|bool
name|dsl
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QHttpNetworkReply
argument_list|)
expr_stmt|;
name|d
operator|->
name|downstreamLimited
operator|=
name|dsl
expr_stmt|;
name|d
operator|->
name|connection
operator|->
name|d_func
argument_list|()
operator|->
name|readMoreLater
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|supportsUserProvidedDownloadBuffer
name|bool
name|QHttpNetworkReply
operator|::
name|supportsUserProvidedDownloadBuffer
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QHttpNetworkReply
argument_list|)
expr_stmt|;
return|return
operator|(
operator|!
name|d
operator|->
name|isChunked
argument_list|()
operator|&&
operator|!
name|d
operator|->
name|autoDecompress
operator|&&
name|d
operator|->
name|bodyLength
operator|>
literal|0
operator|)
return|;
block|}
end_function
begin_function
DECL|function|setUserProvidedDownloadBuffer
name|void
name|QHttpNetworkReply
operator|::
name|setUserProvidedDownloadBuffer
parameter_list|(
name|char
modifier|*
name|b
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QHttpNetworkReply
argument_list|)
expr_stmt|;
if|if
condition|(
name|supportsUserProvidedDownloadBuffer
argument_list|()
condition|)
name|d
operator|->
name|userProvidedDownloadBuffer
operator|=
name|b
expr_stmt|;
block|}
end_function
begin_function
DECL|function|userProvidedDownloadBuffer
name|char
modifier|*
name|QHttpNetworkReply
operator|::
name|userProvidedDownloadBuffer
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QHttpNetworkReply
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|userProvidedDownloadBuffer
return|;
block|}
end_function
begin_function
DECL|function|isFinished
name|bool
name|QHttpNetworkReply
operator|::
name|isFinished
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|state
operator|==
name|QHttpNetworkReplyPrivate
operator|::
name|AllDoneState
return|;
block|}
end_function
begin_function
DECL|function|isPipeliningUsed
name|bool
name|QHttpNetworkReply
operator|::
name|isPipeliningUsed
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|pipeliningUsed
return|;
block|}
end_function
begin_function
DECL|function|connection
name|QHttpNetworkConnection
modifier|*
name|QHttpNetworkReply
operator|::
name|connection
parameter_list|()
block|{
return|return
name|d_func
argument_list|()
operator|->
name|connection
return|;
block|}
end_function
begin_constructor
DECL|function|QHttpNetworkReplyPrivate
name|QHttpNetworkReplyPrivate
operator|::
name|QHttpNetworkReplyPrivate
parameter_list|(
specifier|const
name|QUrl
modifier|&
name|newUrl
parameter_list|)
member_init_list|:
name|QHttpNetworkHeaderPrivate
argument_list|(
name|newUrl
argument_list|)
member_init_list|,
name|state
argument_list|(
name|NothingDoneState
argument_list|)
member_init_list|,
name|ssl
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|statusCode
argument_list|(
literal|100
argument_list|)
member_init_list|,
name|majorVersion
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|minorVersion
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|bodyLength
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|contentRead
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|totalProgress
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|chunkedTransferEncoding
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|connectionCloseEnabled
argument_list|(
literal|true
argument_list|)
member_init_list|,
name|forceConnectionCloseEnabled
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|currentChunkSize
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|currentChunkRead
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|connection
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|initInflate
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|autoDecompress
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|responseData
argument_list|()
member_init_list|,
name|requestIsPrepared
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|pipeliningUsed
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|downstreamLimited
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|userProvidedDownloadBuffer
argument_list|(
literal|0
argument_list|)
block|{ }
end_constructor
begin_destructor
DECL|function|~QHttpNetworkReplyPrivate
name|QHttpNetworkReplyPrivate
operator|::
name|~
name|QHttpNetworkReplyPrivate
parameter_list|()
block|{ }
end_destructor
begin_function
DECL|function|clearHttpLayerInformation
name|void
name|QHttpNetworkReplyPrivate
operator|::
name|clearHttpLayerInformation
parameter_list|()
block|{
name|state
operator|=
name|NothingDoneState
expr_stmt|;
name|statusCode
operator|=
literal|100
expr_stmt|;
name|bodyLength
operator|=
literal|0
expr_stmt|;
name|contentRead
operator|=
literal|0
expr_stmt|;
name|totalProgress
operator|=
literal|0
expr_stmt|;
name|currentChunkSize
operator|=
literal|0
expr_stmt|;
name|currentChunkRead
operator|=
literal|0
expr_stmt|;
name|connectionCloseEnabled
operator|=
literal|true
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_COMPRESS
if|if
condition|(
name|initInflate
condition|)
name|inflateEnd
argument_list|(
operator|&
name|inflateStrm
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|initInflate
operator|=
literal|false
expr_stmt|;
name|streamEnd
operator|=
literal|false
expr_stmt|;
name|fields
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|// TODO: Isn't everything HTTP layer related? We don't need to set connection and connectionChannel to 0 at all
end_comment
begin_function
DECL|function|clear
name|void
name|QHttpNetworkReplyPrivate
operator|::
name|clear
parameter_list|()
block|{
name|connection
operator|=
literal|0
expr_stmt|;
name|connectionChannel
operator|=
literal|0
expr_stmt|;
name|autoDecompress
operator|=
literal|false
expr_stmt|;
name|clearHttpLayerInformation
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|// QHttpNetworkReplyPrivate
end_comment
begin_function
DECL|function|bytesAvailable
name|qint64
name|QHttpNetworkReplyPrivate
operator|::
name|bytesAvailable
parameter_list|()
specifier|const
block|{
return|return
operator|(
name|state
operator|!=
name|ReadingDataState
condition|?
literal|0
else|:
name|fragment
operator|.
name|size
argument_list|()
operator|)
return|;
block|}
end_function
begin_function
DECL|function|isGzipped
name|bool
name|QHttpNetworkReplyPrivate
operator|::
name|isGzipped
parameter_list|()
block|{
name|QByteArray
name|encoding
init|=
name|headerField
argument_list|(
literal|"content-encoding"
argument_list|)
decl_stmt|;
return|return
name|qstricmp
argument_list|(
name|encoding
operator|.
name|constData
argument_list|()
argument_list|,
literal|"gzip"
argument_list|)
operator|==
literal|0
return|;
block|}
end_function
begin_function
DECL|function|removeAutoDecompressHeader
name|void
name|QHttpNetworkReplyPrivate
operator|::
name|removeAutoDecompressHeader
parameter_list|()
block|{
comment|// The header "Content-Encoding  = gzip" is retained.
comment|// Content-Length is removed since the actual one send by the server is for compressed data
name|QByteArray
name|name
argument_list|(
literal|"content-length"
argument_list|)
decl_stmt|;
name|QList
argument_list|<
name|QPair
argument_list|<
name|QByteArray
argument_list|,
name|QByteArray
argument_list|>
argument_list|>
operator|::
name|Iterator
name|it
init|=
name|fields
operator|.
name|begin
argument_list|()
decl_stmt|,
name|end
init|=
name|fields
operator|.
name|end
argument_list|()
decl_stmt|;
while|while
condition|(
name|it
operator|!=
name|end
condition|)
block|{
if|if
condition|(
name|qstricmp
argument_list|(
name|name
operator|.
name|constData
argument_list|()
argument_list|,
name|it
operator|->
name|first
operator|.
name|constData
argument_list|()
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fields
operator|.
name|erase
argument_list|(
name|it
argument_list|)
expr_stmt|;
break|break;
block|}
operator|++
name|it
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|findChallenge
name|bool
name|QHttpNetworkReplyPrivate
operator|::
name|findChallenge
parameter_list|(
name|bool
name|forProxy
parameter_list|,
name|QByteArray
modifier|&
name|challenge
parameter_list|)
specifier|const
block|{
name|challenge
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// find out the type of authentication protocol requested.
name|QByteArray
name|header
init|=
name|forProxy
condition|?
literal|"proxy-authenticate"
else|:
literal|"www-authenticate"
decl_stmt|;
comment|// pick the best protocol (has to match parsing in QAuthenticatorPrivate)
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|challenges
init|=
name|headerFieldValues
argument_list|(
name|header
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|challenges
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|QByteArray
name|line
init|=
name|challenges
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|// todo use qstrincmp
if|if
condition|(
operator|!
name|line
operator|.
name|toLower
argument_list|()
operator|.
name|startsWith
argument_list|(
literal|"negotiate"
argument_list|)
condition|)
name|challenge
operator|=
name|line
expr_stmt|;
block|}
return|return
operator|!
name|challenge
operator|.
name|isEmpty
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|authenticationMethod
name|QAuthenticatorPrivate
operator|::
name|Method
name|QHttpNetworkReplyPrivate
operator|::
name|authenticationMethod
parameter_list|(
name|bool
name|isProxy
parameter_list|)
specifier|const
block|{
comment|// The logic is same as the one used in void QAuthenticatorPrivate::parseHttpResponse()
name|QAuthenticatorPrivate
operator|::
name|Method
name|method
init|=
name|QAuthenticatorPrivate
operator|::
name|None
decl_stmt|;
name|QByteArray
name|header
init|=
name|isProxy
condition|?
literal|"proxy-authenticate"
else|:
literal|"www-authenticate"
decl_stmt|;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|challenges
init|=
name|headerFieldValues
argument_list|(
name|header
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|challenges
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|QByteArray
name|line
init|=
name|challenges
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|trimmed
argument_list|()
operator|.
name|toLower
argument_list|()
decl_stmt|;
if|if
condition|(
name|method
operator|<
name|QAuthenticatorPrivate
operator|::
name|Basic
operator|&&
name|line
operator|.
name|startsWith
argument_list|(
literal|"basic"
argument_list|)
condition|)
block|{
name|method
operator|=
name|QAuthenticatorPrivate
operator|::
name|Basic
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|method
operator|<
name|QAuthenticatorPrivate
operator|::
name|Ntlm
operator|&&
name|line
operator|.
name|startsWith
argument_list|(
literal|"ntlm"
argument_list|)
condition|)
block|{
name|method
operator|=
name|QAuthenticatorPrivate
operator|::
name|Ntlm
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|method
operator|<
name|QAuthenticatorPrivate
operator|::
name|DigestMd5
operator|&&
name|line
operator|.
name|startsWith
argument_list|(
literal|"digest"
argument_list|)
condition|)
block|{
name|method
operator|=
name|QAuthenticatorPrivate
operator|::
name|DigestMd5
expr_stmt|;
block|}
block|}
return|return
name|method
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_COMPRESS
end_ifndef
begin_function
DECL|function|gzipCheckHeader
name|bool
name|QHttpNetworkReplyPrivate
operator|::
name|gzipCheckHeader
parameter_list|(
name|QByteArray
modifier|&
name|content
parameter_list|,
name|int
modifier|&
name|pos
parameter_list|)
block|{
name|int
name|method
init|=
literal|0
decl_stmt|;
comment|// method byte
name|int
name|flags
init|=
literal|0
decl_stmt|;
comment|// flags byte
name|bool
name|ret
init|=
literal|false
decl_stmt|;
comment|// Assure two bytes in the buffer so we can peek ahead -- handle case
comment|// where first byte of header is at the end of the buffer after the last
comment|// gzip segment
name|pos
operator|=
operator|-
literal|1
expr_stmt|;
name|QByteArray
modifier|&
name|body
init|=
name|content
decl_stmt|;
name|int
name|maxPos
init|=
name|body
operator|.
name|size
argument_list|()
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|maxPos
operator|<
literal|1
condition|)
block|{
return|return
name|ret
return|;
block|}
comment|// Peek ahead to check the gzip magic header
if|if
condition|(
name|body
index|[
literal|0
index|]
operator|!=
name|char
argument_list|(
name|gz_magic
index|[
literal|0
index|]
argument_list|)
operator|||
name|body
index|[
literal|1
index|]
operator|!=
name|char
argument_list|(
name|gz_magic
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
return|return
name|ret
return|;
block|}
name|pos
operator|+=
literal|2
expr_stmt|;
comment|// Check the rest of the gzip header
if|if
condition|(
operator|++
name|pos
operator|<=
name|maxPos
condition|)
name|method
operator|=
name|body
index|[
name|pos
index|]
expr_stmt|;
if|if
condition|(
name|pos
operator|++
operator|<=
name|maxPos
condition|)
name|flags
operator|=
name|body
index|[
name|pos
index|]
expr_stmt|;
if|if
condition|(
name|method
operator|!=
name|Z_DEFLATED
operator|||
operator|(
name|flags
operator|&
name|RESERVED
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
name|ret
return|;
block|}
comment|// Discard time, xflags and OS code:
name|pos
operator|+=
literal|6
expr_stmt|;
if|if
condition|(
name|pos
operator|>
name|maxPos
condition|)
return|return
name|ret
return|;
if|if
condition|(
operator|(
name|flags
operator|&
name|EXTRA_FIELD
operator|)
operator|&&
operator|(
operator|(
name|pos
operator|+
literal|2
operator|)
operator|<=
name|maxPos
operator|)
condition|)
block|{
comment|// skip the extra field
name|unsigned
name|len
init|=
operator|(
name|unsigned
operator|)
name|body
index|[
operator|++
name|pos
index|]
decl_stmt|;
name|len
operator|+=
operator|(
operator|(
name|unsigned
operator|)
name|body
index|[
operator|++
name|pos
index|]
operator|)
operator|<<
literal|8
expr_stmt|;
name|pos
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|pos
operator|>
name|maxPos
condition|)
return|return
name|ret
return|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|ORIG_NAME
operator|)
operator|!=
literal|0
condition|)
block|{
comment|// skip the original file name
while|while
condition|(
operator|++
name|pos
operator|<=
name|maxPos
operator|&&
name|body
index|[
name|pos
index|]
condition|)
block|{}
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|COMMENT
operator|)
operator|!=
literal|0
condition|)
block|{
comment|// skip the .gz file comment
while|while
condition|(
operator|++
name|pos
operator|<=
name|maxPos
operator|&&
name|body
index|[
name|pos
index|]
condition|)
block|{}
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|HEAD_CRC
operator|)
operator|!=
literal|0
condition|)
block|{
comment|// skip the header crc
name|pos
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|pos
operator|>
name|maxPos
condition|)
return|return
name|ret
return|;
block|}
name|ret
operator|=
operator|(
name|pos
operator|<
name|maxPos
operator|)
expr_stmt|;
comment|// return failed, if no more bytes left
return|return
name|ret
return|;
block|}
end_function
begin_function
DECL|function|gunzipBodyPartially
name|int
name|QHttpNetworkReplyPrivate
operator|::
name|gunzipBodyPartially
parameter_list|(
name|QByteArray
modifier|&
name|compressed
parameter_list|,
name|QByteArray
modifier|&
name|inflated
parameter_list|)
block|{
name|int
name|ret
init|=
name|Z_DATA_ERROR
decl_stmt|;
name|unsigned
name|have
decl_stmt|;
name|unsigned
name|char
name|out
index|[
name|CHUNK
index|]
decl_stmt|;
name|int
name|pos
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|!
name|initInflate
condition|)
block|{
comment|// check the header
if|if
condition|(
operator|!
name|gzipCheckHeader
argument_list|(
name|compressed
argument_list|,
name|pos
argument_list|)
condition|)
return|return
name|ret
return|;
comment|// allocate inflate state
name|inflateStrm
operator|.
name|zalloc
operator|=
name|Z_NULL
expr_stmt|;
name|inflateStrm
operator|.
name|zfree
operator|=
name|Z_NULL
expr_stmt|;
name|inflateStrm
operator|.
name|opaque
operator|=
name|Z_NULL
expr_stmt|;
name|inflateStrm
operator|.
name|avail_in
operator|=
literal|0
expr_stmt|;
name|inflateStrm
operator|.
name|next_in
operator|=
name|Z_NULL
expr_stmt|;
name|ret
operator|=
name|inflateInit2
argument_list|(
operator|&
name|inflateStrm
argument_list|,
operator|-
name|MAX_WBITS
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|Z_OK
condition|)
return|return
name|ret
return|;
name|initInflate
operator|=
literal|true
expr_stmt|;
name|streamEnd
operator|=
literal|false
expr_stmt|;
block|}
comment|//remove the header.
name|compressed
operator|.
name|remove
argument_list|(
literal|0
argument_list|,
name|pos
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|// expand until deflate stream ends
name|inflateStrm
operator|.
name|next_in
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|compressed
operator|.
name|data
argument_list|()
expr_stmt|;
name|inflateStrm
operator|.
name|avail_in
operator|=
name|compressed
operator|.
name|size
argument_list|()
expr_stmt|;
do|do
block|{
name|inflateStrm
operator|.
name|avail_out
operator|=
sizeof|sizeof
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|inflateStrm
operator|.
name|next_out
operator|=
name|out
expr_stmt|;
name|ret
operator|=
name|inflate
argument_list|(
operator|&
name|inflateStrm
argument_list|,
name|Z_NO_FLUSH
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ret
condition|)
block|{
case|case
name|Z_NEED_DICT
case|:
name|ret
operator|=
name|Z_DATA_ERROR
expr_stmt|;
comment|// and fall through
case|case
name|Z_DATA_ERROR
case|:
case|case
name|Z_MEM_ERROR
case|:
name|inflateEnd
argument_list|(
operator|&
name|inflateStrm
argument_list|)
expr_stmt|;
name|initInflate
operator|=
literal|false
expr_stmt|;
return|return
name|ret
return|;
block|}
name|have
operator|=
sizeof|sizeof
argument_list|(
name|out
argument_list|)
operator|-
name|inflateStrm
operator|.
name|avail_out
expr_stmt|;
name|inflated
operator|.
name|append
argument_list|(
name|QByteArray
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|out
argument_list|,
name|have
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|inflateStrm
operator|.
name|avail_out
operator|==
literal|0
condition|)
do|;
comment|// clean up and return
if|if
condition|(
name|ret
operator|<=
name|Z_ERRNO
operator|||
name|ret
operator|==
name|Z_STREAM_END
condition|)
block|{
name|inflateEnd
argument_list|(
operator|&
name|inflateStrm
argument_list|)
expr_stmt|;
name|initInflate
operator|=
literal|false
expr_stmt|;
block|}
name|streamEnd
operator|=
operator|(
name|ret
operator|==
name|Z_STREAM_END
operator|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|readStatus
name|qint64
name|QHttpNetworkReplyPrivate
operator|::
name|readStatus
parameter_list|(
name|QAbstractSocket
modifier|*
name|socket
parameter_list|)
block|{
if|if
condition|(
name|fragment
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// reserve bytes for the status line. This is better than always append() which reallocs the byte array
name|fragment
operator|.
name|reserve
argument_list|(
literal|32
argument_list|)
expr_stmt|;
block|}
name|qint64
name|bytes
init|=
literal|0
decl_stmt|;
name|char
name|c
decl_stmt|;
name|qint64
name|haveRead
init|=
literal|0
decl_stmt|;
do|do
block|{
name|haveRead
operator|=
name|socket
operator|->
name|read
argument_list|(
operator|&
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|haveRead
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
comment|// unexpected EOF
elseif|else
if|if
condition|(
name|haveRead
operator|==
literal|0
condition|)
break|break;
comment|// read more later
elseif|else
if|if
condition|(
name|haveRead
operator|==
literal|1
operator|&&
name|bytes
operator|==
literal|0
operator|&&
operator|(
name|c
operator|==
literal|11
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|'\r'
operator|||
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|31
operator|)
condition|)
continue|continue;
comment|// Ignore all whitespace that was trailing froma previous request on that socket
name|bytes
operator|++
expr_stmt|;
comment|// allow both CRLF& LF (only) line endings
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
comment|// remove the CR at the end
if|if
condition|(
name|fragment
operator|.
name|endsWith
argument_list|(
literal|'\r'
argument_list|)
condition|)
block|{
name|fragment
operator|.
name|truncate
argument_list|(
name|fragment
operator|.
name|length
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|bool
name|ok
init|=
name|parseStatus
argument_list|(
name|fragment
argument_list|)
decl_stmt|;
name|state
operator|=
name|ReadingHeaderState
expr_stmt|;
name|fragment
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
break|break;
block|}
else|else
block|{
name|fragment
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
comment|// is this a valid reply?
if|if
condition|(
name|fragment
operator|.
name|length
argument_list|()
operator|>=
literal|5
operator|&&
operator|!
name|fragment
operator|.
name|startsWith
argument_list|(
literal|"HTTP/"
argument_list|)
condition|)
block|{
name|fragment
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
do|while
condition|(
name|haveRead
operator|==
literal|1
condition|)
do|;
return|return
name|bytes
return|;
block|}
end_function
begin_function
DECL|function|parseStatus
name|bool
name|QHttpNetworkReplyPrivate
operator|::
name|parseStatus
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|status
parameter_list|)
block|{
comment|// from RFC 2616:
comment|//        Status-Line = HTTP-Version SP Status-Code SP Reason-Phrase CRLF
comment|//        HTTP-Version   = "HTTP" "/" 1*DIGIT "." 1*DIGIT
comment|// that makes: 'HTTP/n.n xxx Message'
comment|// byte count:  0123456789012
specifier|static
specifier|const
name|int
name|minLength
init|=
literal|11
decl_stmt|;
specifier|static
specifier|const
name|int
name|dotPos
init|=
literal|6
decl_stmt|;
specifier|static
specifier|const
name|int
name|spacePos
init|=
literal|8
decl_stmt|;
specifier|static
specifier|const
name|char
name|httpMagic
index|[]
init|=
literal|"HTTP/"
decl_stmt|;
if|if
condition|(
name|status
operator|.
name|length
argument_list|()
operator|<
name|minLength
operator|||
operator|!
name|status
operator|.
name|startsWith
argument_list|(
name|httpMagic
argument_list|)
operator|||
name|status
operator|.
name|at
argument_list|(
name|dotPos
argument_list|)
operator|!=
literal|'.'
operator|||
name|status
operator|.
name|at
argument_list|(
name|spacePos
argument_list|)
operator|!=
literal|' '
condition|)
block|{
comment|// I don't know how to parse this status line
return|return
literal|false
return|;
block|}
comment|// optimize for the valid case: defer checking until the end
name|majorVersion
operator|=
name|status
operator|.
name|at
argument_list|(
name|dotPos
operator|-
literal|1
argument_list|)
operator|-
literal|'0'
expr_stmt|;
name|minorVersion
operator|=
name|status
operator|.
name|at
argument_list|(
name|dotPos
operator|+
literal|1
argument_list|)
operator|-
literal|'0'
expr_stmt|;
name|int
name|i
init|=
name|spacePos
decl_stmt|;
name|int
name|j
init|=
name|status
operator|.
name|indexOf
argument_list|(
literal|' '
argument_list|,
name|i
operator|+
literal|1
argument_list|)
decl_stmt|;
comment|// j == -1 || at(j) == ' ' so j+1 == 0&& j+1<= length()
specifier|const
name|QByteArray
name|code
init|=
name|status
operator|.
name|mid
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|j
operator|-
name|i
operator|-
literal|1
argument_list|)
decl_stmt|;
name|bool
name|ok
decl_stmt|;
name|statusCode
operator|=
name|code
operator|.
name|toInt
argument_list|(
operator|&
name|ok
argument_list|)
expr_stmt|;
name|reasonPhrase
operator|=
name|QString
operator|::
name|fromLatin1
argument_list|(
name|status
operator|.
name|constData
argument_list|()
operator|+
name|j
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|ok
operator|&&
name|uint
argument_list|(
name|majorVersion
argument_list|)
operator|<=
literal|9
operator|&&
name|uint
argument_list|(
name|minorVersion
argument_list|)
operator|<=
literal|9
return|;
block|}
end_function
begin_function
DECL|function|readHeader
name|qint64
name|QHttpNetworkReplyPrivate
operator|::
name|readHeader
parameter_list|(
name|QAbstractSocket
modifier|*
name|socket
parameter_list|)
block|{
if|if
condition|(
name|fragment
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// according to http://dev.opera.com/articles/view/mama-http-headers/ the average size of the header
comment|// block is 381 bytes.
comment|// reserve bytes. This is better than always append() which reallocs the byte array.
name|fragment
operator|.
name|reserve
argument_list|(
literal|512
argument_list|)
expr_stmt|;
block|}
name|qint64
name|bytes
init|=
literal|0
decl_stmt|;
name|char
name|c
init|=
literal|0
decl_stmt|;
name|bool
name|allHeaders
init|=
literal|false
decl_stmt|;
name|qint64
name|haveRead
init|=
literal|0
decl_stmt|;
do|do
block|{
name|haveRead
operator|=
name|socket
operator|->
name|read
argument_list|(
operator|&
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|haveRead
operator|==
literal|0
condition|)
block|{
comment|// read more later
break|break;
block|}
elseif|else
if|if
condition|(
name|haveRead
operator|==
operator|-
literal|1
condition|)
block|{
comment|// connection broke down
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
name|fragment
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|bytes
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
comment|// check for possible header endings. As per HTTP rfc,
comment|// the header endings will be marked by CRLFCRLF. But
comment|// we will allow CRLFCRLF, CRLFLF, LFLF
if|if
condition|(
name|fragment
operator|.
name|endsWith
argument_list|(
literal|"\r\n\r\n"
argument_list|)
operator|||
name|fragment
operator|.
name|endsWith
argument_list|(
literal|"\r\n\n"
argument_list|)
operator|||
name|fragment
operator|.
name|endsWith
argument_list|(
literal|"\n\n"
argument_list|)
condition|)
name|allHeaders
operator|=
literal|true
expr_stmt|;
comment|// there is another case: We have no headers. Then the fragment equals just the line ending
if|if
condition|(
operator|(
name|fragment
operator|.
name|length
argument_list|()
operator|==
literal|2
operator|&&
name|fragment
operator|.
name|endsWith
argument_list|(
literal|"\r\n"
argument_list|)
operator|)
operator|||
operator|(
name|fragment
operator|.
name|length
argument_list|()
operator|==
literal|1
operator|&&
name|fragment
operator|.
name|endsWith
argument_list|(
literal|"\n"
argument_list|)
operator|)
condition|)
name|allHeaders
operator|=
literal|true
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
operator|!
name|allHeaders
operator|&&
name|haveRead
operator|>
literal|0
condition|)
do|;
comment|// we received all headers now parse them
if|if
condition|(
name|allHeaders
condition|)
block|{
name|parseHeader
argument_list|(
name|fragment
argument_list|)
expr_stmt|;
name|state
operator|=
name|ReadingDataState
expr_stmt|;
name|fragment
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// next fragment
name|bodyLength
operator|=
name|contentLength
argument_list|()
expr_stmt|;
comment|// cache the length
comment|// cache isChunked() since it is called often
name|chunkedTransferEncoding
operator|=
name|headerField
argument_list|(
literal|"transfer-encoding"
argument_list|)
operator|.
name|toLower
argument_list|()
operator|.
name|contains
argument_list|(
literal|"chunked"
argument_list|)
expr_stmt|;
comment|// cache isConnectionCloseEnabled since it is called often
name|QByteArray
name|connectionHeaderField
init|=
name|headerField
argument_list|(
literal|"connection"
argument_list|)
decl_stmt|;
comment|// check for explicit indication of close or the implicit connection close of HTTP/1.0
name|connectionCloseEnabled
operator|=
operator|(
name|connectionHeaderField
operator|.
name|toLower
argument_list|()
operator|.
name|contains
argument_list|(
literal|"close"
argument_list|)
operator|||
name|headerField
argument_list|(
literal|"proxy-connection"
argument_list|)
operator|.
name|toLower
argument_list|()
operator|.
name|contains
argument_list|(
literal|"close"
argument_list|)
operator|)
operator|||
operator|(
name|majorVersion
operator|==
literal|1
operator|&&
name|minorVersion
operator|==
literal|0
operator|&&
name|connectionHeaderField
operator|.
name|isEmpty
argument_list|()
operator|)
expr_stmt|;
block|}
return|return
name|bytes
return|;
block|}
end_function
begin_function
DECL|function|parseHeader
name|void
name|QHttpNetworkReplyPrivate
operator|::
name|parseHeader
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|header
parameter_list|)
block|{
comment|// see rfc2616, sec 4 for information about HTTP/1.1 headers.
comment|// allows relaxed parsing here, accepts both CRLF& LF line endings
specifier|const
name|QByteArrayMatcher
name|lf
argument_list|(
literal|"\n"
argument_list|)
decl_stmt|;
specifier|const
name|QByteArrayMatcher
name|colon
argument_list|(
literal|":"
argument_list|)
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|header
operator|.
name|count
argument_list|()
condition|)
block|{
name|int
name|j
init|=
name|colon
operator|.
name|indexIn
argument_list|(
name|header
argument_list|,
name|i
argument_list|)
decl_stmt|;
comment|// field-name
if|if
condition|(
name|j
operator|==
operator|-
literal|1
condition|)
break|break;
specifier|const
name|QByteArray
name|field
init|=
name|header
operator|.
name|mid
argument_list|(
name|i
argument_list|,
name|j
operator|-
name|i
argument_list|)
operator|.
name|trimmed
argument_list|()
decl_stmt|;
name|j
operator|++
expr_stmt|;
comment|// any number of LWS is allowed before and after the value
name|QByteArray
name|value
decl_stmt|;
do|do
block|{
name|i
operator|=
name|lf
operator|.
name|indexIn
argument_list|(
name|header
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
break|break;
if|if
condition|(
operator|!
name|value
operator|.
name|isEmpty
argument_list|()
condition|)
name|value
operator|+=
literal|' '
expr_stmt|;
comment|// check if we have CRLF or only LF
name|bool
name|hasCR
init|=
operator|(
name|i
operator|&&
name|header
index|[
name|i
operator|-
literal|1
index|]
operator|==
literal|'\r'
operator|)
decl_stmt|;
name|int
name|length
init|=
name|i
operator|-
operator|(
name|hasCR
condition|?
literal|1
else|:
literal|0
operator|)
operator|-
name|j
decl_stmt|;
name|value
operator|+=
name|header
operator|.
name|mid
argument_list|(
name|j
argument_list|,
name|length
argument_list|)
operator|.
name|trimmed
argument_list|()
expr_stmt|;
name|j
operator|=
operator|++
name|i
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|<
name|header
operator|.
name|count
argument_list|()
operator|&&
operator|(
name|header
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|==
literal|' '
operator|||
name|header
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|==
literal|'\t'
operator|)
condition|)
do|;
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
break|break;
comment|// something is wrong
name|fields
operator|.
name|append
argument_list|(
name|qMakePair
argument_list|(
name|field
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|isChunked
name|bool
name|QHttpNetworkReplyPrivate
operator|::
name|isChunked
parameter_list|()
block|{
return|return
name|chunkedTransferEncoding
return|;
block|}
end_function
begin_function
DECL|function|isConnectionCloseEnabled
name|bool
name|QHttpNetworkReplyPrivate
operator|::
name|isConnectionCloseEnabled
parameter_list|()
block|{
return|return
name|connectionCloseEnabled
operator|||
name|forceConnectionCloseEnabled
return|;
block|}
end_function
begin_comment
comment|// note this function can only be used for non-chunked, non-compressed with
end_comment
begin_comment
comment|// known content length
end_comment
begin_function
DECL|function|readBodyVeryFast
name|qint64
name|QHttpNetworkReplyPrivate
operator|::
name|readBodyVeryFast
parameter_list|(
name|QAbstractSocket
modifier|*
name|socket
parameter_list|,
name|char
modifier|*
name|b
parameter_list|)
block|{
comment|// This first read is to flush the buffer inside the socket
name|qint64
name|haveRead
init|=
literal|0
decl_stmt|;
name|haveRead
operator|=
name|socket
operator|->
name|read
argument_list|(
name|b
argument_list|,
name|bodyLength
operator|-
name|contentRead
argument_list|)
expr_stmt|;
if|if
condition|(
name|haveRead
operator|==
operator|-
literal|1
condition|)
block|{
return|return
literal|0
return|;
comment|// ### error checking here;
block|}
name|contentRead
operator|+=
name|haveRead
expr_stmt|;
if|if
condition|(
name|contentRead
operator|==
name|bodyLength
condition|)
block|{
name|state
operator|=
name|AllDoneState
expr_stmt|;
block|}
return|return
name|haveRead
return|;
block|}
end_function
begin_comment
comment|// note this function can only be used for non-chunked, non-compressed with
end_comment
begin_comment
comment|// known content length
end_comment
begin_function
DECL|function|readBodyFast
name|qint64
name|QHttpNetworkReplyPrivate
operator|::
name|readBodyFast
parameter_list|(
name|QAbstractSocket
modifier|*
name|socket
parameter_list|,
name|QByteDataBuffer
modifier|*
name|rb
parameter_list|)
block|{
name|qint64
name|toBeRead
init|=
name|qMin
argument_list|(
name|socket
operator|->
name|bytesAvailable
argument_list|()
argument_list|,
name|bodyLength
operator|-
name|contentRead
argument_list|)
decl_stmt|;
name|QByteArray
name|bd
decl_stmt|;
name|bd
operator|.
name|resize
argument_list|(
name|toBeRead
argument_list|)
expr_stmt|;
name|qint64
name|haveRead
init|=
name|socket
operator|->
name|read
argument_list|(
name|bd
operator|.
name|data
argument_list|()
argument_list|,
name|toBeRead
argument_list|)
decl_stmt|;
if|if
condition|(
name|haveRead
operator|==
operator|-
literal|1
condition|)
block|{
name|bd
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
comment|// ### error checking here;
block|}
name|bd
operator|.
name|resize
argument_list|(
name|haveRead
argument_list|)
expr_stmt|;
name|rb
operator|->
name|append
argument_list|(
name|bd
argument_list|)
expr_stmt|;
if|if
condition|(
name|contentRead
operator|+
name|haveRead
operator|==
name|bodyLength
condition|)
block|{
name|state
operator|=
name|AllDoneState
expr_stmt|;
block|}
name|contentRead
operator|+=
name|haveRead
expr_stmt|;
return|return
name|haveRead
return|;
block|}
end_function
begin_function
DECL|function|readBody
name|qint64
name|QHttpNetworkReplyPrivate
operator|::
name|readBody
parameter_list|(
name|QAbstractSocket
modifier|*
name|socket
parameter_list|,
name|QByteDataBuffer
modifier|*
name|out
parameter_list|)
block|{
name|qint64
name|bytes
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|isChunked
argument_list|()
condition|)
block|{
comment|// chunked transfer encoding (rfc 2616, sec 3.6)
name|bytes
operator|+=
name|readReplyBodyChunked
argument_list|(
name|socket
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bodyLength
operator|>
literal|0
condition|)
block|{
comment|// we have a Content-Length
name|bytes
operator|+=
name|readReplyBodyRaw
argument_list|(
name|socket
argument_list|,
name|out
argument_list|,
name|bodyLength
operator|-
name|contentRead
argument_list|)
expr_stmt|;
if|if
condition|(
name|contentRead
operator|+
name|bytes
operator|==
name|bodyLength
condition|)
name|state
operator|=
name|AllDoneState
expr_stmt|;
block|}
else|else
block|{
comment|// no content length. just read what's possible
name|bytes
operator|+=
name|readReplyBodyRaw
argument_list|(
name|socket
argument_list|,
name|out
argument_list|,
name|socket
operator|->
name|bytesAvailable
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|contentRead
operator|+=
name|bytes
expr_stmt|;
return|return
name|bytes
return|;
block|}
end_function
begin_function
DECL|function|readReplyBodyRaw
name|qint64
name|QHttpNetworkReplyPrivate
operator|::
name|readReplyBodyRaw
parameter_list|(
name|QAbstractSocket
modifier|*
name|socket
parameter_list|,
name|QByteDataBuffer
modifier|*
name|out
parameter_list|,
name|qint64
name|size
parameter_list|)
block|{
comment|// FIXME get rid of this function and just use readBodyFast and give it socket->bytesAvailable()
name|qint64
name|bytes
init|=
literal|0
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|socket
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|out
argument_list|)
expr_stmt|;
name|int
name|toBeRead
init|=
name|qMin
argument_list|<
name|qint64
argument_list|>
argument_list|(
literal|128
operator|*
literal|1024
argument_list|,
name|qMin
argument_list|<
name|qint64
argument_list|>
argument_list|(
name|size
argument_list|,
name|socket
operator|->
name|bytesAvailable
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
while|while
condition|(
name|toBeRead
operator|>
literal|0
condition|)
block|{
name|QByteArray
name|byteData
decl_stmt|;
name|byteData
operator|.
name|resize
argument_list|(
name|toBeRead
argument_list|)
expr_stmt|;
name|qint64
name|haveRead
init|=
name|socket
operator|->
name|read
argument_list|(
name|byteData
operator|.
name|data
argument_list|()
argument_list|,
name|byteData
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|haveRead
operator|<=
literal|0
condition|)
block|{
comment|// ### error checking here
name|byteData
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return
name|bytes
return|;
block|}
name|byteData
operator|.
name|resize
argument_list|(
name|haveRead
argument_list|)
expr_stmt|;
name|out
operator|->
name|append
argument_list|(
name|byteData
argument_list|)
expr_stmt|;
name|bytes
operator|+=
name|haveRead
expr_stmt|;
name|size
operator|-=
name|haveRead
expr_stmt|;
name|toBeRead
operator|=
name|qMin
argument_list|<
name|qint64
argument_list|>
argument_list|(
literal|128
operator|*
literal|1024
argument_list|,
name|qMin
argument_list|<
name|qint64
argument_list|>
argument_list|(
name|size
argument_list|,
name|socket
operator|->
name|bytesAvailable
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|bytes
return|;
block|}
end_function
begin_function
DECL|function|readReplyBodyChunked
name|qint64
name|QHttpNetworkReplyPrivate
operator|::
name|readReplyBodyChunked
parameter_list|(
name|QAbstractSocket
modifier|*
name|socket
parameter_list|,
name|QByteDataBuffer
modifier|*
name|out
parameter_list|)
block|{
name|qint64
name|bytes
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|socket
operator|->
name|bytesAvailable
argument_list|()
condition|)
block|{
if|if
condition|(
name|currentChunkRead
operator|>=
name|currentChunkSize
condition|)
block|{
comment|// For the first chunk and when we're done with a chunk
name|currentChunkSize
operator|=
literal|0
expr_stmt|;
name|currentChunkRead
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bytes
condition|)
block|{
comment|// After a chunk
name|char
name|crlf
index|[
literal|2
index|]
decl_stmt|;
comment|// read the "\r\n" after the chunk
name|qint64
name|haveRead
init|=
name|socket
operator|->
name|read
argument_list|(
name|crlf
argument_list|,
literal|2
argument_list|)
decl_stmt|;
comment|// FIXME: This code is slightly broken and not optimal. What if the 2 bytes are not available yet?!
comment|// For nice reasons (the toLong in getChunkSize accepting \n at the beginning
comment|// it right now still works, but we should definitely fix this.
if|if
condition|(
name|haveRead
operator|!=
literal|2
condition|)
return|return
name|bytes
return|;
comment|// FIXME
name|bytes
operator|+=
name|haveRead
expr_stmt|;
block|}
comment|// Note that chunk size gets stored in currentChunkSize, what is returned is the bytes read
name|bytes
operator|+=
name|getChunkSize
argument_list|(
name|socket
argument_list|,
operator|&
name|currentChunkSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|currentChunkSize
operator|==
operator|-
literal|1
condition|)
break|break;
block|}
comment|// if the chunk size is 0, end of the stream
if|if
condition|(
name|currentChunkSize
operator|==
literal|0
condition|)
block|{
name|state
operator|=
name|AllDoneState
expr_stmt|;
break|break;
block|}
comment|// otherwise, try to begin reading this chunk / to read what is missing for this chunk
name|qint64
name|haveRead
init|=
name|readReplyBodyRaw
argument_list|(
name|socket
argument_list|,
name|out
argument_list|,
name|currentChunkSize
operator|-
name|currentChunkRead
argument_list|)
decl_stmt|;
name|currentChunkRead
operator|+=
name|haveRead
expr_stmt|;
name|bytes
operator|+=
name|haveRead
expr_stmt|;
comment|// ### error checking here
block|}
return|return
name|bytes
return|;
block|}
end_function
begin_function
DECL|function|getChunkSize
name|qint64
name|QHttpNetworkReplyPrivate
operator|::
name|getChunkSize
parameter_list|(
name|QAbstractSocket
modifier|*
name|socket
parameter_list|,
name|qint64
modifier|*
name|chunkSize
parameter_list|)
block|{
name|qint64
name|bytes
init|=
literal|0
decl_stmt|;
name|char
name|crlf
index|[
literal|2
index|]
decl_stmt|;
operator|*
name|chunkSize
operator|=
operator|-
literal|1
expr_stmt|;
name|int
name|bytesAvailable
init|=
name|socket
operator|->
name|bytesAvailable
argument_list|()
decl_stmt|;
comment|// FIXME rewrite to permanent loop without bytesAvailable
while|while
condition|(
name|bytesAvailable
operator|>
name|bytes
condition|)
block|{
name|qint64
name|sniffedBytes
init|=
name|socket
operator|->
name|peek
argument_list|(
name|crlf
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|int
name|fragmentSize
init|=
name|fragment
operator|.
name|size
argument_list|()
decl_stmt|;
comment|// check the next two bytes for a "\r\n", skip blank lines
if|if
condition|(
operator|(
name|fragmentSize
operator|&&
name|sniffedBytes
operator|==
literal|2
operator|&&
name|crlf
index|[
literal|0
index|]
operator|==
literal|'\r'
operator|&&
name|crlf
index|[
literal|1
index|]
operator|==
literal|'\n'
operator|)
operator|||
operator|(
name|fragmentSize
operator|>
literal|1
operator|&&
name|fragment
operator|.
name|endsWith
argument_list|(
literal|'\r'
argument_list|)
operator|&&
name|crlf
index|[
literal|0
index|]
operator|==
literal|'\n'
operator|)
condition|)
block|{
name|bytes
operator|+=
name|socket
operator|->
name|read
argument_list|(
name|crlf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|// read the \r or \n
if|if
condition|(
name|crlf
index|[
literal|0
index|]
operator|==
literal|'\r'
condition|)
name|bytes
operator|+=
name|socket
operator|->
name|read
argument_list|(
name|crlf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|// read the \n
name|bool
name|ok
init|=
literal|false
decl_stmt|;
comment|// ignore the chunk-extension
name|fragment
operator|=
name|fragment
operator|.
name|mid
argument_list|(
literal|0
argument_list|,
name|fragment
operator|.
name|indexOf
argument_list|(
literal|';'
argument_list|)
argument_list|)
operator|.
name|trimmed
argument_list|()
expr_stmt|;
operator|*
name|chunkSize
operator|=
name|fragment
operator|.
name|toLong
argument_list|(
operator|&
name|ok
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|fragment
operator|.
name|clear
argument_list|()
expr_stmt|;
break|break;
comment|// size done
block|}
else|else
block|{
comment|// read the fragment to the buffer
name|char
name|c
init|=
literal|0
decl_stmt|;
name|qint64
name|haveRead
init|=
name|socket
operator|->
name|read
argument_list|(
operator|&
name|c
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|haveRead
operator|<
literal|0
condition|)
block|{
return|return
operator|-
literal|1
return|;
comment|// FIXME
block|}
name|bytes
operator|+=
name|haveRead
expr_stmt|;
name|fragment
operator|.
name|append
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|bytes
return|;
block|}
end_function
begin_function
DECL|function|appendUncompressedReplyData
name|void
name|QHttpNetworkReplyPrivate
operator|::
name|appendUncompressedReplyData
parameter_list|(
name|QByteArray
modifier|&
name|qba
parameter_list|)
block|{
name|responseData
operator|.
name|append
argument_list|(
name|qba
argument_list|)
expr_stmt|;
comment|// clear the original! helps with implicit sharing and
comment|// avoiding memcpy when the user is reading the data
name|qba
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|appendUncompressedReplyData
name|void
name|QHttpNetworkReplyPrivate
operator|::
name|appendUncompressedReplyData
parameter_list|(
name|QByteDataBuffer
modifier|&
name|data
parameter_list|)
block|{
name|responseData
operator|.
name|append
argument_list|(
name|data
argument_list|)
expr_stmt|;
comment|// clear the original! helps with implicit sharing and
comment|// avoiding memcpy when the user is reading the data
name|data
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|appendCompressedReplyData
name|void
name|QHttpNetworkReplyPrivate
operator|::
name|appendCompressedReplyData
parameter_list|(
name|QByteDataBuffer
modifier|&
name|data
parameter_list|)
block|{
comment|// Work in progress: Later we will directly use a list of QByteArray or a QRingBuffer
comment|// instead of one QByteArray.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|data
operator|.
name|bufferCount
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|QByteArray
modifier|&
name|byteData
init|=
name|data
index|[
name|i
index|]
decl_stmt|;
name|compressedData
operator|.
name|append
argument_list|(
name|byteData
operator|.
name|constData
argument_list|()
argument_list|,
name|byteData
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|data
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|shouldEmitSignals
name|bool
name|QHttpNetworkReplyPrivate
operator|::
name|shouldEmitSignals
parameter_list|()
block|{
comment|// for 401& 407 don't emit the data signals. Content along with these
comment|// responses are send only if the authentication fails.
return|return
operator|(
name|statusCode
operator|!=
literal|401
operator|&&
name|statusCode
operator|!=
literal|407
operator|)
return|;
block|}
end_function
begin_function
DECL|function|expectContent
name|bool
name|QHttpNetworkReplyPrivate
operator|::
name|expectContent
parameter_list|()
block|{
comment|// check whether we can expect content after the headers (rfc 2616, sec4.4)
if|if
condition|(
operator|(
name|statusCode
operator|>=
literal|100
operator|&&
name|statusCode
operator|<
literal|200
operator|)
operator|||
name|statusCode
operator|==
literal|204
operator|||
name|statusCode
operator|==
literal|304
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|request
operator|.
name|operation
argument_list|()
operator|==
name|QHttpNetworkRequest
operator|::
name|Head
condition|)
return|return
operator|!
name|shouldEmitSignals
argument_list|()
return|;
name|qint64
name|expectedContentLength
init|=
name|contentLength
argument_list|()
decl_stmt|;
if|if
condition|(
name|expectedContentLength
operator|==
literal|0
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|expectedContentLength
operator|==
operator|-
literal|1
operator|&&
name|bodyLength
operator|==
literal|0
condition|)
block|{
comment|// The content-length header was stripped, but its value was 0.
comment|// This would be the case for an explicitly zero-length compressed response.
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|eraseData
name|void
name|QHttpNetworkReplyPrivate
operator|::
name|eraseData
parameter_list|()
block|{
name|compressedData
operator|.
name|clear
argument_list|()
expr_stmt|;
name|responseData
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|// SSL support below
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_OPENSSL
end_ifndef
begin_function
DECL|function|sslConfiguration
name|QSslConfiguration
name|QHttpNetworkReply
operator|::
name|sslConfiguration
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QHttpNetworkReply
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|connectionChannel
condition|)
return|return
name|QSslConfiguration
argument_list|()
return|;
name|QSslSocket
modifier|*
name|sslSocket
init|=
name|qobject_cast
argument_list|<
name|QSslSocket
operator|*
argument_list|>
argument_list|(
name|d
operator|->
name|connectionChannel
operator|->
name|socket
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sslSocket
condition|)
return|return
name|QSslConfiguration
argument_list|()
return|;
return|return
name|sslSocket
operator|->
name|sslConfiguration
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|setSslConfiguration
name|void
name|QHttpNetworkReply
operator|::
name|setSslConfiguration
parameter_list|(
specifier|const
name|QSslConfiguration
modifier|&
name|config
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QHttpNetworkReply
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|connection
condition|)
name|d
operator|->
name|connection
operator|->
name|setSslConfiguration
argument_list|(
name|config
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|ignoreSslErrors
name|void
name|QHttpNetworkReply
operator|::
name|ignoreSslErrors
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QHttpNetworkReply
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|connection
condition|)
name|d
operator|->
name|connection
operator|->
name|ignoreSslErrors
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|ignoreSslErrors
name|void
name|QHttpNetworkReply
operator|::
name|ignoreSslErrors
parameter_list|(
specifier|const
name|QList
argument_list|<
name|QSslError
argument_list|>
modifier|&
name|errors
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QHttpNetworkReply
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|connection
condition|)
name|d
operator|->
name|connection
operator|->
name|ignoreSslErrors
argument_list|(
name|errors
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//QT_NO_OPENSSL
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_HTTP
end_comment
end_unit
