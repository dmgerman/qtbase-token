begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2014 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtNetwork module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL21$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia. For licensing terms and ** conditions see http://qt.digia.com/licensing. For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 or version 3 as published by the Free ** Software Foundation and appearing in the file LICENSE.LGPLv21 and ** LICENSE.LGPLv3 included in the packaging of this file. Please review the ** following information to ensure the GNU Lesser General Public License ** requirements will be met: https://www.gnu.org/licenses/lgpl.html and ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights. These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_comment
comment|//#define QHTTPTHREADDELEGATE_DEBUG
end_comment
begin_include
include|#
directive|include
file|"qhttpthreaddelegate_p.h"
end_include
begin_include
include|#
directive|include
file|<QThread>
end_include
begin_include
include|#
directive|include
file|<QTimer>
end_include
begin_include
include|#
directive|include
file|<QAuthenticator>
end_include
begin_include
include|#
directive|include
file|<QEventLoop>
end_include
begin_include
include|#
directive|include
file|"private/qhttpnetworkreply_p.h"
end_include
begin_include
include|#
directive|include
file|"private/qnetworkaccesscache_p.h"
end_include
begin_include
include|#
directive|include
file|"private/qnoncontiguousbytedevice_p.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_HTTP
end_ifndef
begin_function
name|QT_BEGIN_NAMESPACE
DECL|function|statusCodeFromHttp
specifier|static
name|QNetworkReply
operator|::
name|NetworkError
name|statusCodeFromHttp
parameter_list|(
name|int
name|httpStatusCode
parameter_list|,
specifier|const
name|QUrl
modifier|&
name|url
parameter_list|)
block|{
name|QNetworkReply
operator|::
name|NetworkError
name|code
decl_stmt|;
comment|// we've got an error
switch|switch
condition|(
name|httpStatusCode
condition|)
block|{
case|case
literal|400
case|:
comment|// Bad Request
name|code
operator|=
name|QNetworkReply
operator|::
name|ProtocolInvalidOperationError
expr_stmt|;
break|break;
case|case
literal|401
case|:
comment|// Authorization required
name|code
operator|=
name|QNetworkReply
operator|::
name|AuthenticationRequiredError
expr_stmt|;
break|break;
case|case
literal|403
case|:
comment|// Access denied
name|code
operator|=
name|QNetworkReply
operator|::
name|ContentOperationNotPermittedError
expr_stmt|;
break|break;
case|case
literal|404
case|:
comment|// Not Found
name|code
operator|=
name|QNetworkReply
operator|::
name|ContentNotFoundError
expr_stmt|;
break|break;
case|case
literal|405
case|:
comment|// Method Not Allowed
name|code
operator|=
name|QNetworkReply
operator|::
name|ContentOperationNotPermittedError
expr_stmt|;
break|break;
case|case
literal|407
case|:
name|code
operator|=
name|QNetworkReply
operator|::
name|ProxyAuthenticationRequiredError
expr_stmt|;
break|break;
case|case
literal|409
case|:
comment|// Resource Conflict
name|code
operator|=
name|QNetworkReply
operator|::
name|ContentConflictError
expr_stmt|;
break|break;
case|case
literal|410
case|:
comment|// Content no longer available
name|code
operator|=
name|QNetworkReply
operator|::
name|ContentGoneError
expr_stmt|;
break|break;
case|case
literal|418
case|:
comment|// I'm a teapot
name|code
operator|=
name|QNetworkReply
operator|::
name|ProtocolInvalidOperationError
expr_stmt|;
break|break;
case|case
literal|500
case|:
comment|// Internal Server Error
name|code
operator|=
name|QNetworkReply
operator|::
name|InternalServerError
expr_stmt|;
break|break;
case|case
literal|501
case|:
comment|// Server does not support this functionality
name|code
operator|=
name|QNetworkReply
operator|::
name|OperationNotImplementedError
expr_stmt|;
break|break;
case|case
literal|503
case|:
comment|// Service unavailable
name|code
operator|=
name|QNetworkReply
operator|::
name|ServiceUnavailableError
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|httpStatusCode
operator|>
literal|500
condition|)
block|{
comment|// some kind of server error
name|code
operator|=
name|QNetworkReply
operator|::
name|UnknownServerError
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|httpStatusCode
operator|>=
literal|400
condition|)
block|{
comment|// content error we did not handle above
name|code
operator|=
name|QNetworkReply
operator|::
name|UnknownContentError
expr_stmt|;
block|}
else|else
block|{
name|qWarning
argument_list|(
literal|"QNetworkAccess: got HTTP status code %d which is not expected from url: \"%s\""
argument_list|,
name|httpStatusCode
argument_list|,
name|qPrintable
argument_list|(
name|url
operator|.
name|toString
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|code
operator|=
name|QNetworkReply
operator|::
name|ProtocolFailure
expr_stmt|;
block|}
block|}
return|return
name|code
return|;
block|}
end_function
begin_function
DECL|function|makeCacheKey
specifier|static
name|QByteArray
name|makeCacheKey
parameter_list|(
name|QUrl
modifier|&
name|url
parameter_list|,
name|QNetworkProxy
modifier|*
name|proxy
parameter_list|)
block|{
name|QString
name|result
decl_stmt|;
name|QUrl
name|copy
init|=
name|url
decl_stmt|;
name|QString
name|scheme
init|=
name|copy
operator|.
name|scheme
argument_list|()
operator|.
name|toLower
argument_list|()
decl_stmt|;
name|bool
name|isEncrypted
init|=
name|scheme
operator|==
name|QLatin1String
argument_list|(
literal|"https"
argument_list|)
decl_stmt|;
name|copy
operator|.
name|setPort
argument_list|(
name|copy
operator|.
name|port
argument_list|(
name|isEncrypted
condition|?
literal|443
else|:
literal|80
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|scheme
operator|==
name|QLatin1String
argument_list|(
literal|"preconnect-http"
argument_list|)
condition|)
block|{
name|copy
operator|.
name|setScheme
argument_list|(
name|QLatin1String
argument_list|(
literal|"http"
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scheme
operator|==
name|QLatin1String
argument_list|(
literal|"preconnect-https"
argument_list|)
condition|)
block|{
name|copy
operator|.
name|setScheme
argument_list|(
name|QLatin1String
argument_list|(
literal|"https"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|copy
operator|.
name|toString
argument_list|(
name|QUrl
operator|::
name|RemoveUserInfo
operator||
name|QUrl
operator|::
name|RemovePath
operator||
name|QUrl
operator|::
name|RemoveQuery
operator||
name|QUrl
operator|::
name|RemoveFragment
operator||
name|QUrl
operator|::
name|FullyEncoded
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
if|if
condition|(
name|proxy
operator|&&
name|proxy
operator|->
name|type
argument_list|()
operator|!=
name|QNetworkProxy
operator|::
name|NoProxy
condition|)
block|{
name|QUrl
name|key
decl_stmt|;
switch|switch
condition|(
name|proxy
operator|->
name|type
argument_list|()
condition|)
block|{
case|case
name|QNetworkProxy
operator|::
name|Socks5Proxy
case|:
name|key
operator|.
name|setScheme
argument_list|(
name|QLatin1String
argument_list|(
literal|"proxy-socks5"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|QNetworkProxy
operator|::
name|HttpProxy
case|:
case|case
name|QNetworkProxy
operator|::
name|HttpCachingProxy
case|:
name|key
operator|.
name|setScheme
argument_list|(
name|QLatin1String
argument_list|(
literal|"proxy-http"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
operator|!
name|key
operator|.
name|scheme
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|key
operator|.
name|setUserName
argument_list|(
name|proxy
operator|->
name|user
argument_list|()
argument_list|)
expr_stmt|;
name|key
operator|.
name|setHost
argument_list|(
name|proxy
operator|->
name|hostName
argument_list|()
argument_list|)
expr_stmt|;
name|key
operator|.
name|setPort
argument_list|(
name|proxy
operator|->
name|port
argument_list|()
argument_list|)
expr_stmt|;
name|key
operator|.
name|setQuery
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|result
operator|=
name|key
operator|.
name|toString
argument_list|(
name|QUrl
operator|::
name|FullyEncoded
argument_list|)
expr_stmt|;
block|}
block|}
else|#
directive|else
name|Q_UNUSED
argument_list|(
argument|proxy
argument_list|)
endif|#
directive|endif
return|return
literal|"http-connection:"
operator|+
name|result
operator|.
name|toLatin1
argument_list|()
return|;
block|}
end_function
begin_class
DECL|class|QNetworkAccessCachedHttpConnection
class|class
name|QNetworkAccessCachedHttpConnection
super|:
specifier|public
name|QHttpNetworkConnection
super|,
specifier|public
name|QNetworkAccessCache
operator|::
name|CacheableObject
block|{
comment|// Q_OBJECT
public|public:
ifdef|#
directive|ifdef
name|QT_NO_BEARERMANAGEMENT
DECL|function|QNetworkAccessCachedHttpConnection
name|QNetworkAccessCachedHttpConnection
parameter_list|(
specifier|const
name|QString
modifier|&
name|hostName
parameter_list|,
name|quint16
name|port
parameter_list|,
name|bool
name|encrypt
parameter_list|,
name|QHttpNetworkConnection
operator|::
name|ConnectionType
name|connectionType
parameter_list|)
member_init_list|:
name|QHttpNetworkConnection
argument_list|(
name|hostName
argument_list|,
name|port
argument_list|,
name|encrypt
argument_list|,
name|connectionType
argument_list|)
else|#
directive|else
name|QNetworkAccessCachedHttpConnection
argument_list|(
specifier|const
name|QString
operator|&
name|hostName
argument_list|,
name|quint16
name|port
argument_list|,
name|bool
name|encrypt
argument_list|,
name|QHttpNetworkConnection
operator|::
name|ConnectionType
name|connectionType
argument_list|,
name|QSharedPointer
argument_list|<
name|QNetworkSession
argument_list|>
name|networkSession
argument_list|)
public|:
name|QHttpNetworkConnection
argument_list|(
argument|hostName
argument_list|,
argument|port
argument_list|,
argument|encrypt
argument_list|,
argument|connectionType
argument_list|,
comment|/*parent=*/
literal|0
argument_list|,
argument|qMove(networkSession)
argument_list|)
endif|#
directive|endif
block|{
name|setExpires
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|setShareable
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
specifier|virtual
name|void
name|dispose
parameter_list|()
name|Q_DECL_OVERRIDE
block|{
if|#
directive|if
literal|0
comment|// sample code; do this right with the API
block|Q_ASSERT(!isWorking());
endif|#
directive|endif
operator|delete
name|this
expr_stmt|;
block|}
block|}
class|;
end_class
begin_decl_stmt
DECL|member|connections
name|QThreadStorage
argument_list|<
name|QNetworkAccessCache
modifier|*
argument_list|>
name|QHttpThreadDelegate
operator|::
name|connections
decl_stmt|;
end_decl_stmt
begin_destructor
DECL|function|~QHttpThreadDelegate
name|QHttpThreadDelegate
operator|::
name|~
name|QHttpThreadDelegate
parameter_list|()
block|{
comment|// It could be that the main thread has asked us to shut down, so we need to delete the HTTP reply
if|if
condition|(
name|httpReply
condition|)
block|{
operator|delete
name|httpReply
expr_stmt|;
block|}
comment|// Get the object cache that stores our QHttpNetworkConnection objects
comment|// and release the entry for this QHttpNetworkConnection
if|if
condition|(
name|connections
operator|.
name|hasLocalData
argument_list|()
operator|&&
operator|!
name|cacheKey
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|connections
operator|.
name|localData
argument_list|()
operator|->
name|releaseEntry
argument_list|(
name|cacheKey
argument_list|)
expr_stmt|;
block|}
block|}
end_destructor
begin_constructor
DECL|function|QHttpThreadDelegate
name|QHttpThreadDelegate
operator|::
name|QHttpThreadDelegate
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
name|parent
argument_list|)
member_init_list|,
name|ssl
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|downloadBufferMaximumSize
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|readBufferMaxSize
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|bytesEmitted
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|pendingDownloadData
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|pendingDownloadProgress
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|synchronous
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|incomingStatusCode
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|isPipeliningUsed
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|isSpdyUsed
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|incomingContentLength
argument_list|(
operator|-
literal|1
argument_list|)
member_init_list|,
name|incomingErrorCode
argument_list|(
name|QNetworkReply
operator|::
name|NoError
argument_list|)
member_init_list|,
name|downloadBuffer
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|httpConnection
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|httpReply
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|synchronousRequestLoop
argument_list|(
literal|0
argument_list|)
block|{ }
end_constructor
begin_comment
comment|// This is invoked as BlockingQueuedConnection from QNetworkAccessHttpBackend in the user thread
end_comment
begin_function
DECL|function|startRequestSynchronously
name|void
name|QHttpThreadDelegate
operator|::
name|startRequestSynchronously
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|QHTTPTHREADDELEGATE_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QHttpThreadDelegate::startRequestSynchronously() thread="
operator|<<
name|QThread
operator|::
name|currentThreadId
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|synchronous
operator|=
literal|true
expr_stmt|;
name|QEventLoop
name|synchronousRequestLoop
decl_stmt|;
name|this
operator|->
name|synchronousRequestLoop
operator|=
operator|&
name|synchronousRequestLoop
expr_stmt|;
comment|// Worst case timeout
name|QTimer
operator|::
name|singleShot
argument_list|(
literal|30
operator|*
literal|1000
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|abortRequest
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|this
argument_list|,
literal|"startRequest"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
name|synchronousRequestLoop
operator|.
name|exec
argument_list|()
expr_stmt|;
name|connections
operator|.
name|localData
argument_list|()
operator|->
name|releaseEntry
argument_list|(
name|cacheKey
argument_list|)
expr_stmt|;
name|connections
operator|.
name|setLocalData
argument_list|(
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QHTTPTHREADDELEGATE_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QHttpThreadDelegate::startRequestSynchronously() thread="
operator|<<
name|QThread
operator|::
name|currentThreadId
argument_list|()
operator|<<
literal|"finished"
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|// This is invoked as QueuedConnection from QNetworkAccessHttpBackend in the user thread
end_comment
begin_function
DECL|function|startRequest
name|void
name|QHttpThreadDelegate
operator|::
name|startRequest
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|QHTTPTHREADDELEGATE_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QHttpThreadDelegate::startRequest() thread="
operator|<<
name|QThread
operator|::
name|currentThreadId
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|// Check QThreadStorage for the QNetworkAccessCache
comment|// If not there, create this connection cache
if|if
condition|(
operator|!
name|connections
operator|.
name|hasLocalData
argument_list|()
condition|)
block|{
name|connections
operator|.
name|setLocalData
argument_list|(
operator|new
name|QNetworkAccessCache
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// check if we have an open connection to this host
name|QUrl
name|urlCopy
init|=
name|httpRequest
operator|.
name|url
argument_list|()
decl_stmt|;
name|urlCopy
operator|.
name|setPort
argument_list|(
name|urlCopy
operator|.
name|port
argument_list|(
name|ssl
condition|?
literal|443
else|:
literal|80
argument_list|)
argument_list|)
expr_stmt|;
name|QHttpNetworkConnection
operator|::
name|ConnectionType
name|connectionType
init|=
name|QHttpNetworkConnection
operator|::
name|ConnectionTypeHTTP
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_SSL
if|if
condition|(
name|httpRequest
operator|.
name|isSPDYAllowed
argument_list|()
operator|&&
name|ssl
condition|)
block|{
name|connectionType
operator|=
name|QHttpNetworkConnection
operator|::
name|ConnectionTypeSPDY
expr_stmt|;
name|urlCopy
operator|.
name|setScheme
argument_list|(
name|QStringLiteral
argument_list|(
literal|"spdy"
argument_list|)
argument_list|)
expr_stmt|;
comment|// to differentiate SPDY requests from HTTPS requests
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|nextProtocols
decl_stmt|;
name|nextProtocols
operator|<<
name|QSslConfiguration
operator|::
name|NextProtocolSpdy3_0
operator|<<
name|QSslConfiguration
operator|::
name|NextProtocolHttp1_1
expr_stmt|;
name|incomingSslConfiguration
operator|.
name|setAllowedNextProtocols
argument_list|(
name|nextProtocols
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|// QT_NO_SSL
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
if|if
condition|(
name|transparentProxy
operator|.
name|type
argument_list|()
operator|!=
name|QNetworkProxy
operator|::
name|NoProxy
condition|)
name|cacheKey
operator|=
name|makeCacheKey
argument_list|(
name|urlCopy
argument_list|,
operator|&
name|transparentProxy
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cacheProxy
operator|.
name|type
argument_list|()
operator|!=
name|QNetworkProxy
operator|::
name|NoProxy
condition|)
name|cacheKey
operator|=
name|makeCacheKey
argument_list|(
name|urlCopy
argument_list|,
operator|&
name|cacheProxy
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|cacheKey
operator|=
name|makeCacheKey
argument_list|(
name|urlCopy
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// the http object is actually a QHttpNetworkConnection
name|httpConnection
operator|=
cast|static_cast
argument_list|<
name|QNetworkAccessCachedHttpConnection
operator|*
argument_list|>
argument_list|(
name|connections
operator|.
name|localData
argument_list|()
operator|->
name|requestEntryNow
argument_list|(
name|cacheKey
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|httpConnection
operator|==
literal|0
condition|)
block|{
comment|// no entry in cache; create an object
comment|// the http object is actually a QHttpNetworkConnection
ifdef|#
directive|ifdef
name|QT_NO_BEARERMANAGEMENT
name|httpConnection
operator|=
operator|new
name|QNetworkAccessCachedHttpConnection
argument_list|(
name|urlCopy
operator|.
name|host
argument_list|()
argument_list|,
name|urlCopy
operator|.
name|port
argument_list|()
argument_list|,
name|ssl
argument_list|,
name|connectionType
argument_list|)
expr_stmt|;
else|#
directive|else
name|httpConnection
operator|=
operator|new
name|QNetworkAccessCachedHttpConnection
argument_list|(
name|urlCopy
operator|.
name|host
argument_list|()
argument_list|,
name|urlCopy
operator|.
name|port
argument_list|()
argument_list|,
name|ssl
argument_list|,
name|connectionType
argument_list|,
name|networkSession
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_SSL
comment|// Set the QSslConfiguration from this QNetworkRequest.
if|if
condition|(
name|ssl
operator|&&
name|incomingSslConfiguration
operator|!=
name|QSslConfiguration
operator|::
name|defaultConfiguration
argument_list|()
condition|)
block|{
name|httpConnection
operator|->
name|setSslConfiguration
argument_list|(
name|incomingSslConfiguration
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
name|httpConnection
operator|->
name|setTransparentProxy
argument_list|(
name|transparentProxy
argument_list|)
expr_stmt|;
name|httpConnection
operator|->
name|setCacheProxy
argument_list|(
name|cacheProxy
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// cache the QHttpNetworkConnection corresponding to this cache key
name|connections
operator|.
name|localData
argument_list|()
operator|->
name|addEntry
argument_list|(
name|cacheKey
argument_list|,
name|httpConnection
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|httpRequest
operator|.
name|withCredentials
argument_list|()
condition|)
block|{
name|QNetworkAuthenticationCredential
name|credential
init|=
name|authenticationManager
operator|->
name|fetchCachedCredentials
argument_list|(
name|httpRequest
operator|.
name|url
argument_list|()
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|credential
operator|.
name|user
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|credential
operator|.
name|password
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QAuthenticator
name|auth
decl_stmt|;
name|auth
operator|.
name|setUser
argument_list|(
name|credential
operator|.
name|user
argument_list|)
expr_stmt|;
name|auth
operator|.
name|setPassword
argument_list|(
name|credential
operator|.
name|password
argument_list|)
expr_stmt|;
name|httpConnection
operator|->
name|d_func
argument_list|()
operator|->
name|copyCredentials
argument_list|(
operator|-
literal|1
argument_list|,
operator|&
name|auth
argument_list|,
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|// Send the request to the connection
name|httpReply
operator|=
name|httpConnection
operator|->
name|sendRequest
argument_list|(
name|httpRequest
argument_list|)
expr_stmt|;
name|httpReply
operator|->
name|setParent
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// Connect the reply signals that we need to handle and then forward
if|if
condition|(
name|synchronous
condition|)
block|{
name|connect
argument_list|(
name|httpReply
argument_list|,
name|SIGNAL
argument_list|(
name|headerChanged
argument_list|()
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|synchronousHeaderChangedSlot
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|httpReply
argument_list|,
name|SIGNAL
argument_list|(
name|finished
argument_list|()
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|synchronousFinishedSlot
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|httpReply
argument_list|,
name|SIGNAL
argument_list|(
name|finishedWithError
argument_list|(
name|QNetworkReply
operator|::
name|NetworkError
argument_list|,
name|QString
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|synchronousFinishedWithErrorSlot
argument_list|(
name|QNetworkReply
operator|::
name|NetworkError
argument_list|,
name|QString
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|httpReply
argument_list|,
name|SIGNAL
argument_list|(
name|authenticationRequired
argument_list|(
name|QHttpNetworkRequest
argument_list|,
name|QAuthenticator
operator|*
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|synchronousAuthenticationRequiredSlot
argument_list|(
name|QHttpNetworkRequest
argument_list|,
name|QAuthenticator
operator|*
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
name|connect
argument_list|(
name|httpReply
argument_list|,
name|SIGNAL
argument_list|(
name|proxyAuthenticationRequired
argument_list|(
name|QNetworkProxy
argument_list|,
name|QAuthenticator
operator|*
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|synchronousProxyAuthenticationRequiredSlot
argument_list|(
name|QNetworkProxy
argument_list|,
name|QAuthenticator
operator|*
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// Don't care about ignored SSL errors for now in the synchronous HTTP case.
block|}
elseif|else
if|if
condition|(
operator|!
name|synchronous
condition|)
block|{
name|connect
argument_list|(
name|httpReply
argument_list|,
name|SIGNAL
argument_list|(
name|headerChanged
argument_list|()
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|headerChangedSlot
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|httpReply
argument_list|,
name|SIGNAL
argument_list|(
name|finished
argument_list|()
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|finishedSlot
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|httpReply
argument_list|,
name|SIGNAL
argument_list|(
name|finishedWithError
argument_list|(
name|QNetworkReply
operator|::
name|NetworkError
argument_list|,
name|QString
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|finishedWithErrorSlot
argument_list|(
name|QNetworkReply
operator|::
name|NetworkError
argument_list|,
name|QString
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// some signals are only interesting when normal asynchronous style is used
name|connect
argument_list|(
name|httpReply
argument_list|,
name|SIGNAL
argument_list|(
name|readyRead
argument_list|()
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|readyReadSlot
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|httpReply
argument_list|,
name|SIGNAL
argument_list|(
name|dataReadProgress
argument_list|(
name|qint64
argument_list|,
name|qint64
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|dataReadProgressSlot
argument_list|(
name|qint64
argument_list|,
name|qint64
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_SSL
name|connect
argument_list|(
name|httpReply
argument_list|,
name|SIGNAL
argument_list|(
name|encrypted
argument_list|()
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|encryptedSlot
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|httpReply
argument_list|,
name|SIGNAL
argument_list|(
name|sslErrors
argument_list|(
name|QList
argument_list|<
name|QSslError
argument_list|>
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|sslErrorsSlot
argument_list|(
name|QList
argument_list|<
name|QSslError
argument_list|>
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// In the asynchronous HTTP case we can just forward those signals
comment|// Connect the reply signals that we can directly forward
name|connect
argument_list|(
name|httpReply
argument_list|,
name|SIGNAL
argument_list|(
name|authenticationRequired
argument_list|(
name|QHttpNetworkRequest
argument_list|,
name|QAuthenticator
operator|*
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SIGNAL
argument_list|(
name|authenticationRequired
argument_list|(
name|QHttpNetworkRequest
argument_list|,
name|QAuthenticator
operator|*
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
name|connect
argument_list|(
name|httpReply
argument_list|,
name|SIGNAL
argument_list|(
name|proxyAuthenticationRequired
argument_list|(
name|QNetworkProxy
argument_list|,
name|QAuthenticator
operator|*
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SIGNAL
argument_list|(
name|proxyAuthenticationRequired
argument_list|(
name|QNetworkProxy
argument_list|,
name|QAuthenticator
operator|*
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|connect
argument_list|(
name|httpReply
argument_list|,
name|SIGNAL
argument_list|(
name|cacheCredentials
argument_list|(
name|QHttpNetworkRequest
argument_list|,
name|QAuthenticator
operator|*
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|cacheCredentialsSlot
argument_list|(
name|QHttpNetworkRequest
argument_list|,
name|QAuthenticator
operator|*
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|// This gets called from the user thread or by the synchronous HTTP timeout timer
end_comment
begin_function
DECL|function|abortRequest
name|void
name|QHttpThreadDelegate
operator|::
name|abortRequest
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|QHTTPTHREADDELEGATE_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QHttpThreadDelegate::abortRequest() thread="
operator|<<
name|QThread
operator|::
name|currentThreadId
argument_list|()
operator|<<
literal|"sync="
operator|<<
name|synchronous
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|httpReply
condition|)
block|{
operator|delete
name|httpReply
expr_stmt|;
name|httpReply
operator|=
literal|0
expr_stmt|;
block|}
comment|// Got aborted by the timeout timer
if|if
condition|(
name|synchronous
condition|)
block|{
name|incomingErrorCode
operator|=
name|QNetworkReply
operator|::
name|TimeoutError
expr_stmt|;
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|synchronousRequestLoop
argument_list|,
literal|"quit"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|//only delete this for asynchronous mode or QNetworkAccessHttpBackend will crash - see QNetworkAccessHttpBackend::postRequest()
name|this
operator|->
name|deleteLater
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|readBufferSizeChanged
name|void
name|QHttpThreadDelegate
operator|::
name|readBufferSizeChanged
parameter_list|(
name|qint64
name|size
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QHTTPTHREADDELEGATE_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QHttpThreadDelegate::readBufferSizeChanged() size "
operator|<<
name|size
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|httpReply
condition|)
block|{
name|httpReply
operator|->
name|setDownstreamLimited
argument_list|(
name|size
operator|>
literal|0
argument_list|)
expr_stmt|;
name|httpReply
operator|->
name|setReadBufferSize
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|readBufferMaxSize
operator|=
name|size
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|readBufferFreed
name|void
name|QHttpThreadDelegate
operator|::
name|readBufferFreed
parameter_list|(
name|qint64
name|size
parameter_list|)
block|{
if|if
condition|(
name|readBufferMaxSize
condition|)
block|{
name|bytesEmitted
operator|-=
name|size
expr_stmt|;
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|this
argument_list|,
literal|"readyReadSlot"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|readyReadSlot
name|void
name|QHttpThreadDelegate
operator|::
name|readyReadSlot
parameter_list|()
block|{
if|if
condition|(
operator|!
name|httpReply
condition|)
return|return;
comment|// Don't do in zerocopy case
if|if
condition|(
operator|!
name|downloadBuffer
operator|.
name|isNull
argument_list|()
condition|)
return|return;
if|if
condition|(
name|readBufferMaxSize
condition|)
block|{
if|if
condition|(
name|bytesEmitted
operator|<
name|readBufferMaxSize
condition|)
block|{
name|qint64
name|sizeEmitted
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|httpReply
operator|->
name|readAnyAvailable
argument_list|()
operator|&&
operator|(
name|sizeEmitted
operator|<
operator|(
name|readBufferMaxSize
operator|-
name|bytesEmitted
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|httpReply
operator|->
name|sizeNextBlock
argument_list|()
operator|>
operator|(
name|readBufferMaxSize
operator|-
name|bytesEmitted
operator|)
condition|)
block|{
name|sizeEmitted
operator|=
name|readBufferMaxSize
operator|-
name|bytesEmitted
expr_stmt|;
name|bytesEmitted
operator|+=
name|sizeEmitted
expr_stmt|;
name|pendingDownloadData
operator|->
name|fetchAndAddRelease
argument_list|(
literal|1
argument_list|)
expr_stmt|;
emit|emit
name|downloadData
argument_list|(
name|httpReply
operator|->
name|read
argument_list|(
name|sizeEmitted
argument_list|)
argument_list|)
emit|;
block|}
else|else
block|{
name|sizeEmitted
operator|=
name|httpReply
operator|->
name|sizeNextBlock
argument_list|()
expr_stmt|;
name|bytesEmitted
operator|+=
name|sizeEmitted
expr_stmt|;
name|pendingDownloadData
operator|->
name|fetchAndAddRelease
argument_list|(
literal|1
argument_list|)
expr_stmt|;
emit|emit
name|downloadData
argument_list|(
name|httpReply
operator|->
name|readAny
argument_list|()
argument_list|)
emit|;
block|}
block|}
block|}
else|else
block|{
comment|// We need to wait until we empty data from the read buffer in the reply.
block|}
block|}
else|else
block|{
while|while
condition|(
name|httpReply
operator|->
name|readAnyAvailable
argument_list|()
condition|)
block|{
name|pendingDownloadData
operator|->
name|fetchAndAddRelease
argument_list|(
literal|1
argument_list|)
expr_stmt|;
emit|emit
name|downloadData
argument_list|(
name|httpReply
operator|->
name|readAny
argument_list|()
argument_list|)
emit|;
block|}
block|}
block|}
end_function
begin_function
DECL|function|finishedSlot
name|void
name|QHttpThreadDelegate
operator|::
name|finishedSlot
parameter_list|()
block|{
if|if
condition|(
operator|!
name|httpReply
condition|)
return|return;
ifdef|#
directive|ifdef
name|QHTTPTHREADDELEGATE_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QHttpThreadDelegate::finishedSlot() thread="
operator|<<
name|QThread
operator|::
name|currentThreadId
argument_list|()
operator|<<
literal|"result="
operator|<<
name|httpReply
operator|->
name|statusCode
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|// If there is still some data left emit that now
while|while
condition|(
name|httpReply
operator|->
name|readAnyAvailable
argument_list|()
condition|)
block|{
name|pendingDownloadData
operator|->
name|fetchAndAddRelease
argument_list|(
literal|1
argument_list|)
expr_stmt|;
emit|emit
name|downloadData
argument_list|(
name|httpReply
operator|->
name|readAny
argument_list|()
argument_list|)
emit|;
block|}
ifndef|#
directive|ifndef
name|QT_NO_SSL
if|if
condition|(
name|ssl
condition|)
emit|emit
name|sslConfigurationChanged
argument_list|(
name|httpReply
operator|->
name|sslConfiguration
argument_list|()
argument_list|)
emit|;
endif|#
directive|endif
if|if
condition|(
name|httpReply
operator|->
name|statusCode
argument_list|()
operator|>=
literal|400
condition|)
block|{
comment|// it's an error reply
name|QString
name|msg
init|=
name|QLatin1String
argument_list|(
name|QT_TRANSLATE_NOOP
argument_list|(
literal|"QNetworkReply"
argument_list|,
literal|"Error downloading %1 - server replied: %2"
argument_list|)
argument_list|)
decl_stmt|;
name|msg
operator|=
name|msg
operator|.
name|arg
argument_list|(
name|httpRequest
operator|.
name|url
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|httpReply
operator|->
name|reasonPhrase
argument_list|()
argument_list|)
expr_stmt|;
emit|emit
name|error
argument_list|(
name|statusCodeFromHttp
argument_list|(
name|httpReply
operator|->
name|statusCode
argument_list|()
argument_list|,
name|httpRequest
operator|.
name|url
argument_list|()
argument_list|)
argument_list|,
name|msg
argument_list|)
emit|;
block|}
emit|emit
name|downloadFinished
argument_list|()
emit|;
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|httpReply
argument_list|,
literal|"deleteLater"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|this
argument_list|,
literal|"deleteLater"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
name|httpReply
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_function
DECL|function|synchronousFinishedSlot
name|void
name|QHttpThreadDelegate
operator|::
name|synchronousFinishedSlot
parameter_list|()
block|{
if|if
condition|(
operator|!
name|httpReply
condition|)
return|return;
ifdef|#
directive|ifdef
name|QHTTPTHREADDELEGATE_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QHttpThreadDelegate::synchronousFinishedSlot() thread="
operator|<<
name|QThread
operator|::
name|currentThreadId
argument_list|()
operator|<<
literal|"result="
operator|<<
name|httpReply
operator|->
name|statusCode
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|httpReply
operator|->
name|statusCode
argument_list|()
operator|>=
literal|400
condition|)
block|{
comment|// it's an error reply
name|QString
name|msg
init|=
name|QLatin1String
argument_list|(
name|QT_TRANSLATE_NOOP
argument_list|(
literal|"QNetworkReply"
argument_list|,
literal|"Error downloading %1 - server replied: %2"
argument_list|)
argument_list|)
decl_stmt|;
name|incomingErrorDetail
operator|=
name|msg
operator|.
name|arg
argument_list|(
name|httpRequest
operator|.
name|url
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|,
name|httpReply
operator|->
name|reasonPhrase
argument_list|()
argument_list|)
expr_stmt|;
name|incomingErrorCode
operator|=
name|statusCodeFromHttp
argument_list|(
name|httpReply
operator|->
name|statusCode
argument_list|()
argument_list|,
name|httpRequest
operator|.
name|url
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|synchronousDownloadData
operator|=
name|httpReply
operator|->
name|readAll
argument_list|()
expr_stmt|;
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|httpReply
argument_list|,
literal|"deleteLater"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|synchronousRequestLoop
argument_list|,
literal|"quit"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
name|httpReply
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_function
DECL|function|finishedWithErrorSlot
name|void
name|QHttpThreadDelegate
operator|::
name|finishedWithErrorSlot
parameter_list|(
name|QNetworkReply
operator|::
name|NetworkError
name|errorCode
parameter_list|,
specifier|const
name|QString
modifier|&
name|detail
parameter_list|)
block|{
if|if
condition|(
operator|!
name|httpReply
condition|)
return|return;
ifdef|#
directive|ifdef
name|QHTTPTHREADDELEGATE_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QHttpThreadDelegate::finishedWithErrorSlot() thread="
operator|<<
name|QThread
operator|::
name|currentThreadId
argument_list|()
operator|<<
literal|"error="
operator|<<
name|errorCode
operator|<<
name|detail
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_SSL
if|if
condition|(
name|ssl
condition|)
emit|emit
name|sslConfigurationChanged
argument_list|(
name|httpReply
operator|->
name|sslConfiguration
argument_list|()
argument_list|)
emit|;
endif|#
directive|endif
emit|emit
name|error
argument_list|(
name|errorCode
argument_list|,
name|detail
argument_list|)
emit|;
emit|emit
name|downloadFinished
argument_list|()
emit|;
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|httpReply
argument_list|,
literal|"deleteLater"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|this
argument_list|,
literal|"deleteLater"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
name|httpReply
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_function
DECL|function|synchronousFinishedWithErrorSlot
name|void
name|QHttpThreadDelegate
operator|::
name|synchronousFinishedWithErrorSlot
parameter_list|(
name|QNetworkReply
operator|::
name|NetworkError
name|errorCode
parameter_list|,
specifier|const
name|QString
modifier|&
name|detail
parameter_list|)
block|{
if|if
condition|(
operator|!
name|httpReply
condition|)
return|return;
ifdef|#
directive|ifdef
name|QHTTPTHREADDELEGATE_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QHttpThreadDelegate::synchronousFinishedWithErrorSlot() thread="
operator|<<
name|QThread
operator|::
name|currentThreadId
argument_list|()
operator|<<
literal|"error="
operator|<<
name|errorCode
operator|<<
name|detail
expr_stmt|;
endif|#
directive|endif
name|incomingErrorCode
operator|=
name|errorCode
expr_stmt|;
name|incomingErrorDetail
operator|=
name|detail
expr_stmt|;
name|synchronousDownloadData
operator|=
name|httpReply
operator|->
name|readAll
argument_list|()
expr_stmt|;
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|httpReply
argument_list|,
literal|"deleteLater"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|synchronousRequestLoop
argument_list|,
literal|"quit"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
name|httpReply
operator|=
literal|0
expr_stmt|;
block|}
end_function
begin_function
DECL|function|downloadBufferDeleter
specifier|static
name|void
name|downloadBufferDeleter
parameter_list|(
name|char
modifier|*
name|ptr
parameter_list|)
block|{
operator|delete
index|[]
name|ptr
expr_stmt|;
block|}
end_function
begin_function
DECL|function|headerChangedSlot
name|void
name|QHttpThreadDelegate
operator|::
name|headerChangedSlot
parameter_list|()
block|{
if|if
condition|(
operator|!
name|httpReply
condition|)
return|return;
ifdef|#
directive|ifdef
name|QHTTPTHREADDELEGATE_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QHttpThreadDelegate::headerChangedSlot() thread="
operator|<<
name|QThread
operator|::
name|currentThreadId
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_SSL
if|if
condition|(
name|ssl
condition|)
emit|emit
name|sslConfigurationChanged
argument_list|(
name|httpReply
operator|->
name|sslConfiguration
argument_list|()
argument_list|)
emit|;
endif|#
directive|endif
comment|// Is using a zerocopy buffer allowed by user and possible with this reply?
if|if
condition|(
name|httpReply
operator|->
name|supportsUserProvidedDownloadBuffer
argument_list|()
operator|&&
operator|(
name|downloadBufferMaximumSize
operator|>
literal|0
operator|)
operator|&&
operator|(
name|httpReply
operator|->
name|contentLength
argument_list|()
operator|<=
name|downloadBufferMaximumSize
operator|)
condition|)
block|{
name|QT_TRY
block|{
name|char
modifier|*
name|buf
init|=
operator|new
name|char
index|[
name|httpReply
operator|->
name|contentLength
argument_list|()
index|]
decl_stmt|;
comment|// throws if allocation fails
if|if
condition|(
name|buf
condition|)
block|{
name|downloadBuffer
operator|=
name|QSharedPointer
argument_list|<
name|char
argument_list|>
argument_list|(
name|buf
argument_list|,
name|downloadBufferDeleter
argument_list|)
expr_stmt|;
name|httpReply
operator|->
name|setUserProvidedDownloadBuffer
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
name|QT_CATCH
argument_list|(
argument|const std::bad_alloc&
argument_list|)
block|{
comment|// in out of memory situations, don't use downloadbuffer.
block|}
block|}
comment|// We fetch this into our own
name|incomingHeaders
operator|=
name|httpReply
operator|->
name|header
argument_list|()
expr_stmt|;
name|incomingStatusCode
operator|=
name|httpReply
operator|->
name|statusCode
argument_list|()
expr_stmt|;
name|incomingReasonPhrase
operator|=
name|httpReply
operator|->
name|reasonPhrase
argument_list|()
expr_stmt|;
name|isPipeliningUsed
operator|=
name|httpReply
operator|->
name|isPipeliningUsed
argument_list|()
expr_stmt|;
name|incomingContentLength
operator|=
name|httpReply
operator|->
name|contentLength
argument_list|()
expr_stmt|;
name|isSpdyUsed
operator|=
name|httpReply
operator|->
name|isSpdyUsed
argument_list|()
expr_stmt|;
emit|emit
name|downloadMetaData
argument_list|(
name|incomingHeaders
argument_list|,
name|incomingStatusCode
argument_list|,
name|incomingReasonPhrase
argument_list|,
name|isPipeliningUsed
argument_list|,
name|downloadBuffer
argument_list|,
name|incomingContentLength
argument_list|,
name|isSpdyUsed
argument_list|)
emit|;
block|}
end_function
begin_function
DECL|function|synchronousHeaderChangedSlot
name|void
name|QHttpThreadDelegate
operator|::
name|synchronousHeaderChangedSlot
parameter_list|()
block|{
if|if
condition|(
operator|!
name|httpReply
condition|)
return|return;
ifdef|#
directive|ifdef
name|QHTTPTHREADDELEGATE_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QHttpThreadDelegate::synchronousHeaderChangedSlot() thread="
operator|<<
name|QThread
operator|::
name|currentThreadId
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|// Store the information we need in this object, the QNetworkAccessHttpBackend will later read it
name|incomingHeaders
operator|=
name|httpReply
operator|->
name|header
argument_list|()
expr_stmt|;
name|incomingStatusCode
operator|=
name|httpReply
operator|->
name|statusCode
argument_list|()
expr_stmt|;
name|incomingReasonPhrase
operator|=
name|httpReply
operator|->
name|reasonPhrase
argument_list|()
expr_stmt|;
name|isPipeliningUsed
operator|=
name|httpReply
operator|->
name|isPipeliningUsed
argument_list|()
expr_stmt|;
name|isSpdyUsed
operator|=
name|httpReply
operator|->
name|isSpdyUsed
argument_list|()
expr_stmt|;
name|incomingContentLength
operator|=
name|httpReply
operator|->
name|contentLength
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|dataReadProgressSlot
name|void
name|QHttpThreadDelegate
operator|::
name|dataReadProgressSlot
parameter_list|(
name|qint64
name|done
parameter_list|,
name|qint64
name|total
parameter_list|)
block|{
comment|// If we don't have a download buffer don't attempt to go this codepath
comment|// It is not used by QNetworkAccessHttpBackend
if|if
condition|(
name|downloadBuffer
operator|.
name|isNull
argument_list|()
condition|)
return|return;
name|pendingDownloadProgress
operator|->
name|fetchAndAddRelease
argument_list|(
literal|1
argument_list|)
expr_stmt|;
emit|emit
name|downloadProgress
argument_list|(
name|done
argument_list|,
name|total
argument_list|)
emit|;
block|}
end_function
begin_function
DECL|function|cacheCredentialsSlot
name|void
name|QHttpThreadDelegate
operator|::
name|cacheCredentialsSlot
parameter_list|(
specifier|const
name|QHttpNetworkRequest
modifier|&
name|request
parameter_list|,
name|QAuthenticator
modifier|*
name|authenticator
parameter_list|)
block|{
name|authenticationManager
operator|->
name|cacheCredentials
argument_list|(
name|request
operator|.
name|url
argument_list|()
argument_list|,
name|authenticator
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_SSL
end_ifndef
begin_function
DECL|function|encryptedSlot
name|void
name|QHttpThreadDelegate
operator|::
name|encryptedSlot
parameter_list|()
block|{
if|if
condition|(
operator|!
name|httpReply
condition|)
return|return;
emit|emit
name|sslConfigurationChanged
argument_list|(
name|httpReply
operator|->
name|sslConfiguration
argument_list|()
argument_list|)
emit|;
emit|emit
name|encrypted
argument_list|()
emit|;
block|}
end_function
begin_function
DECL|function|sslErrorsSlot
name|void
name|QHttpThreadDelegate
operator|::
name|sslErrorsSlot
parameter_list|(
specifier|const
name|QList
argument_list|<
name|QSslError
argument_list|>
modifier|&
name|errors
parameter_list|)
block|{
if|if
condition|(
operator|!
name|httpReply
condition|)
return|return;
emit|emit
name|sslConfigurationChanged
argument_list|(
name|httpReply
operator|->
name|sslConfiguration
argument_list|()
argument_list|)
emit|;
name|bool
name|ignoreAll
init|=
literal|false
decl_stmt|;
name|QList
argument_list|<
name|QSslError
argument_list|>
name|specificErrors
decl_stmt|;
emit|emit
name|sslErrors
argument_list|(
name|errors
argument_list|,
operator|&
name|ignoreAll
argument_list|,
operator|&
name|specificErrors
argument_list|)
emit|;
if|if
condition|(
name|ignoreAll
condition|)
name|httpReply
operator|->
name|ignoreSslErrors
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|specificErrors
operator|.
name|isEmpty
argument_list|()
condition|)
name|httpReply
operator|->
name|ignoreSslErrors
argument_list|(
name|specificErrors
argument_list|)
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|synchronousAuthenticationRequiredSlot
name|void
name|QHttpThreadDelegate
operator|::
name|synchronousAuthenticationRequiredSlot
parameter_list|(
specifier|const
name|QHttpNetworkRequest
modifier|&
name|request
parameter_list|,
name|QAuthenticator
modifier|*
name|a
parameter_list|)
block|{
if|if
condition|(
operator|!
name|httpReply
condition|)
return|return;
name|Q_UNUSED
argument_list|(
name|request
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QHTTPTHREADDELEGATE_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QHttpThreadDelegate::synchronousAuthenticationRequiredSlot() thread="
operator|<<
name|QThread
operator|::
name|currentThreadId
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|// Ask the credential cache
name|QNetworkAuthenticationCredential
name|credential
init|=
name|authenticationManager
operator|->
name|fetchCachedCredentials
argument_list|(
name|httpRequest
operator|.
name|url
argument_list|()
argument_list|,
name|a
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|credential
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|a
operator|->
name|setUser
argument_list|(
name|credential
operator|.
name|user
argument_list|)
expr_stmt|;
name|a
operator|->
name|setPassword
argument_list|(
name|credential
operator|.
name|password
argument_list|)
expr_stmt|;
block|}
comment|// Disconnect this connection now since we only want to ask the authentication cache once.
name|QObject
operator|::
name|disconnect
argument_list|(
name|httpReply
argument_list|,
name|SIGNAL
argument_list|(
name|authenticationRequired
argument_list|(
name|QHttpNetworkRequest
argument_list|,
name|QAuthenticator
operator|*
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|synchronousAuthenticationRequiredSlot
argument_list|(
name|QHttpNetworkRequest
argument_list|,
name|QAuthenticator
operator|*
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
end_ifndef
begin_function
DECL|function|synchronousProxyAuthenticationRequiredSlot
name|void
name|QHttpThreadDelegate
operator|::
name|synchronousProxyAuthenticationRequiredSlot
parameter_list|(
specifier|const
name|QNetworkProxy
modifier|&
name|p
parameter_list|,
name|QAuthenticator
modifier|*
name|a
parameter_list|)
block|{
if|if
condition|(
operator|!
name|httpReply
condition|)
return|return;
ifdef|#
directive|ifdef
name|QHTTPTHREADDELEGATE_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QHttpThreadDelegate::synchronousProxyAuthenticationRequiredSlot() thread="
operator|<<
name|QThread
operator|::
name|currentThreadId
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|// Ask the credential cache
name|QNetworkAuthenticationCredential
name|credential
init|=
name|authenticationManager
operator|->
name|fetchCachedProxyCredentials
argument_list|(
name|p
argument_list|,
name|a
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|credential
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|a
operator|->
name|setUser
argument_list|(
name|credential
operator|.
name|user
argument_list|)
expr_stmt|;
name|a
operator|->
name|setPassword
argument_list|(
name|credential
operator|.
name|password
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
comment|// Disconnect this connection now since we only want to ask the authentication cache once.
name|QObject
operator|::
name|disconnect
argument_list|(
name|httpReply
argument_list|,
name|SIGNAL
argument_list|(
name|proxyAuthenticationRequired
argument_list|(
name|QNetworkProxy
argument_list|,
name|QAuthenticator
operator|*
argument_list|)
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|synchronousProxyAuthenticationRequiredSlot
argument_list|(
name|QNetworkProxy
argument_list|,
name|QAuthenticator
operator|*
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_HTTP
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
