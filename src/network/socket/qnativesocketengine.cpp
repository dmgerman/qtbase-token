begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/ ** ** This file is part of the QtNetwork module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_comment
comment|//#define QNATIVESOCKETENGINE_DEBUG
end_comment
begin_comment
comment|/*! \class QNativeSocketEngine     \internal      \brief The QNativeSocketEngine class provides low level access to a socket.      \reentrant     \ingroup network     \inmodule QtNetwork      QtSocketLayer provides basic socket functionality provided by the     operating system. It also keeps track of what state the socket is     in, and which errors that occur.      The classes QTcpSocket, QUdpSocket and QTcpServer provide a     higher level API, and are in general more useful for the common     application.      There are two main ways of initializing the a QNativeSocketEngine; either     create a new socket by passing the socket type (TcpSocket or     UdpSocket) and network layer protocol (IPv4Protocol or     IPv6Protocol) to initialize(), or pass an existing socket     descriptor and have QNativeSocketEngine determine the type and protocol     itself. The native socket descriptor can later be fetched by     calling socketDescriptor(). The socket is made non-blocking, but     blocking behavior can still be achieved by calling waitForRead()     and waitForWrite(). isValid() can be called to check if the socket     has been successfully initialized and is ready to use.      To connect to a host, determine its address and pass this and the     port number to connectToHost(). The socket can then be used as a     TCP or UDP client. Otherwise; bind(), listen() and accept() are     used to have the socket function as a TCP or UDP server. Call     close() to close the socket.      bytesAvailable() is called to determine how much data is available     for reading. read() and write() are used by both TCP and UDP     clients to exchange data with the connected peer. UDP clients can     also call hasMoreDatagrams(), nextDatagramSize(),     readDatagram(), and writeDatagram().      Call state() to determine the state of the socket, for     example, ListeningState or ConnectedState. socketType() tells     whether the socket is a TCP socket or a UDP socket, or if the     socket type is unknown. protocol() is used to determine the     socket's network layer protocol.      localAddress(), localPort() are called to find the address and     port that are currently bound to the socket. If the socket is     connected, peerAddress() and peerPort() determine the address and     port of the connected peer.      Finally, if any function should fail, error() and     errorString() can be called to determine the cause of the error. */
end_comment
begin_include
include|#
directive|include
file|"qnativesocketengine_p.h"
end_include
begin_include
include|#
directive|include
file|<qabstracteventdispatcher.h>
end_include
begin_include
include|#
directive|include
file|<qsocketnotifier.h>
end_include
begin_include
include|#
directive|include
file|<qnetworkinterface.h>
end_include
begin_include
include|#
directive|include
file|<private/qthread_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qobject_p.h>
end_include
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_NETWORKPROXY
argument_list|)
end_if
begin_include
include|#
directive|include
file|"qnetworkproxy.h"
end_include
begin_include
include|#
directive|include
file|"qabstractsocket.h"
end_include
begin_include
include|#
directive|include
file|"qtcpserver.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_comment
comment|//#define QNATIVESOCKETENGINE_DEBUG
end_comment
begin_define
DECL|macro|Q_VOID
define|#
directive|define
name|Q_VOID
end_define
begin_comment
comment|// Common constructs
end_comment
begin_define
DECL|macro|Q_CHECK_VALID_SOCKETLAYER
define|#
directive|define
name|Q_CHECK_VALID_SOCKETLAYER
parameter_list|(
name|function
parameter_list|,
name|returnValue
parameter_list|)
value|do { \     if (!isValid()) { \         qWarning(""#function" was called on an uninitialized socket device"); \         return returnValue; \     } } while (0)
end_define
begin_define
DECL|macro|Q_CHECK_INVALID_SOCKETLAYER
define|#
directive|define
name|Q_CHECK_INVALID_SOCKETLAYER
parameter_list|(
name|function
parameter_list|,
name|returnValue
parameter_list|)
value|do { \     if (isValid()) { \         qWarning(""#function" was called on an already initialized socket device"); \         return returnValue; \     } } while (0)
end_define
begin_define
DECL|macro|Q_CHECK_STATE
define|#
directive|define
name|Q_CHECK_STATE
parameter_list|(
name|function
parameter_list|,
name|checkState
parameter_list|,
name|returnValue
parameter_list|)
value|do { \     if (d->socketState != (checkState)) { \         qWarning(""#function" was not called in "#checkState); \         return (returnValue); \     } } while (0)
end_define
begin_define
DECL|macro|Q_CHECK_NOT_STATE
define|#
directive|define
name|Q_CHECK_NOT_STATE
parameter_list|(
name|function
parameter_list|,
name|checkState
parameter_list|,
name|returnValue
parameter_list|)
value|do { \     if (d->socketState == (checkState)) { \         qWarning(""#function" was called in "#checkState); \         return (returnValue); \     } } while (0)
end_define
begin_define
DECL|macro|Q_CHECK_STATES
define|#
directive|define
name|Q_CHECK_STATES
parameter_list|(
name|function
parameter_list|,
name|state1
parameter_list|,
name|state2
parameter_list|,
name|returnValue
parameter_list|)
value|do { \     if (d->socketState != (state1)&& d->socketState != (state2)) { \         qWarning(""#function" was called" \                  " not in "#state1" or "#state2); \         return (returnValue); \     } } while (0)
end_define
begin_define
DECL|macro|Q_CHECK_TYPE
define|#
directive|define
name|Q_CHECK_TYPE
parameter_list|(
name|function
parameter_list|,
name|type
parameter_list|,
name|returnValue
parameter_list|)
value|do { \     if (d->socketType != (type)) { \         qWarning(#function" was called by a" \                  " socket other than "#type""); \         return (returnValue); \     } } while (0)
end_define
begin_define
DECL|macro|Q_TR
define|#
directive|define
name|Q_TR
parameter_list|(
name|a
parameter_list|)
value|QT_TRANSLATE_NOOP(QNativeSocketEngine, a)
end_define
begin_comment
comment|/*! \internal     Constructs the private class and initializes all data members.      On Windows, WSAStartup is called "recursively" for every     concurrent QNativeSocketEngine. This is safe, because WSAStartup and     WSACleanup are reference counted. */
end_comment
begin_constructor
DECL|function|QNativeSocketEnginePrivate
name|QNativeSocketEnginePrivate
operator|::
name|QNativeSocketEnginePrivate
parameter_list|()
member_init_list|:
name|socketDescriptor
argument_list|(
operator|-
literal|1
argument_list|)
member_init_list|,
name|readNotifier
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|writeNotifier
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|exceptNotifier
argument_list|(
literal|0
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*! \internal     Destructs the private class. */
end_comment
begin_destructor
DECL|function|~QNativeSocketEnginePrivate
name|QNativeSocketEnginePrivate
operator|::
name|~
name|QNativeSocketEnginePrivate
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*! \internal      Sets the error and error string if not set already. The only     interesting error is the first one that occurred, and not the last     one. */
end_comment
begin_function
DECL|function|setError
name|void
name|QNativeSocketEnginePrivate
operator|::
name|setError
parameter_list|(
name|QAbstractSocket
operator|::
name|SocketError
name|error
parameter_list|,
name|ErrorString
name|errorString
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|hasSetSocketError
condition|)
block|{
comment|// Only set socket errors once for one engine; expect the
comment|// socket to recreate its engine after an error. Note: There's
comment|// one exception: SocketError(11) bypasses this as it's purely
comment|// a temporary internal error condition.
comment|// Another exception is the way the waitFor*() functions set
comment|// an error when a timeout occurs. After the call to setError()
comment|// they reset the hasSetSocketError to false
return|return;
block|}
if|if
condition|(
name|error
operator|!=
name|QAbstractSocket
operator|::
name|SocketError
argument_list|(
literal|11
argument_list|)
condition|)
name|hasSetSocketError
operator|=
literal|true
expr_stmt|;
name|socketError
operator|=
name|error
expr_stmt|;
switch|switch
condition|(
name|errorString
condition|)
block|{
case|case
name|NonBlockingInitFailedErrorString
case|:
name|socketErrorString
operator|=
name|QNativeSocketEngine
operator|::
name|tr
argument_list|(
literal|"Unable to initialize non-blocking socket"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BroadcastingInitFailedErrorString
case|:
name|socketErrorString
operator|=
name|QNativeSocketEngine
operator|::
name|tr
argument_list|(
literal|"Unable to initialize broadcast socket"
argument_list|)
expr_stmt|;
break|break;
comment|// should not happen anymore
case|case
name|NoIpV6ErrorString
case|:
name|socketErrorString
operator|=
name|QNativeSocketEngine
operator|::
name|tr
argument_list|(
literal|"Attempt to use IPv6 socket on a platform with no IPv6 support"
argument_list|)
expr_stmt|;
break|break;
case|case
name|RemoteHostClosedErrorString
case|:
name|socketErrorString
operator|=
name|QNativeSocketEngine
operator|::
name|tr
argument_list|(
literal|"The remote host closed the connection"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TimeOutErrorString
case|:
name|socketErrorString
operator|=
name|QNativeSocketEngine
operator|::
name|tr
argument_list|(
literal|"Network operation timed out"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ResourceErrorString
case|:
name|socketErrorString
operator|=
name|QNativeSocketEngine
operator|::
name|tr
argument_list|(
literal|"Out of resources"
argument_list|)
expr_stmt|;
break|break;
case|case
name|OperationUnsupportedErrorString
case|:
name|socketErrorString
operator|=
name|QNativeSocketEngine
operator|::
name|tr
argument_list|(
literal|"Unsupported socket operation"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ProtocolUnsupportedErrorString
case|:
name|socketErrorString
operator|=
name|QNativeSocketEngine
operator|::
name|tr
argument_list|(
literal|"Protocol type not supported"
argument_list|)
expr_stmt|;
break|break;
case|case
name|InvalidSocketErrorString
case|:
name|socketErrorString
operator|=
name|QNativeSocketEngine
operator|::
name|tr
argument_list|(
literal|"Invalid socket descriptor"
argument_list|)
expr_stmt|;
break|break;
case|case
name|HostUnreachableErrorString
case|:
name|socketErrorString
operator|=
name|QNativeSocketEngine
operator|::
name|tr
argument_list|(
literal|"Host unreachable"
argument_list|)
expr_stmt|;
break|break;
case|case
name|NetworkUnreachableErrorString
case|:
name|socketErrorString
operator|=
name|QNativeSocketEngine
operator|::
name|tr
argument_list|(
literal|"Network unreachable"
argument_list|)
expr_stmt|;
break|break;
case|case
name|AccessErrorString
case|:
name|socketErrorString
operator|=
name|QNativeSocketEngine
operator|::
name|tr
argument_list|(
literal|"Permission denied"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ConnectionTimeOutErrorString
case|:
name|socketErrorString
operator|=
name|QNativeSocketEngine
operator|::
name|tr
argument_list|(
literal|"Connection timed out"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ConnectionRefusedErrorString
case|:
name|socketErrorString
operator|=
name|QNativeSocketEngine
operator|::
name|tr
argument_list|(
literal|"Connection refused"
argument_list|)
expr_stmt|;
break|break;
case|case
name|AddressInuseErrorString
case|:
name|socketErrorString
operator|=
name|QNativeSocketEngine
operator|::
name|tr
argument_list|(
literal|"The bound address is already in use"
argument_list|)
expr_stmt|;
break|break;
case|case
name|AddressNotAvailableErrorString
case|:
name|socketErrorString
operator|=
name|QNativeSocketEngine
operator|::
name|tr
argument_list|(
literal|"The address is not available"
argument_list|)
expr_stmt|;
break|break;
case|case
name|AddressProtectedErrorString
case|:
name|socketErrorString
operator|=
name|QNativeSocketEngine
operator|::
name|tr
argument_list|(
literal|"The address is protected"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DatagramTooLargeErrorString
case|:
name|socketErrorString
operator|=
name|QNativeSocketEngine
operator|::
name|tr
argument_list|(
literal|"Datagram was too large to send"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SendDatagramErrorString
case|:
name|socketErrorString
operator|=
name|QNativeSocketEngine
operator|::
name|tr
argument_list|(
literal|"Unable to send a message"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ReceiveDatagramErrorString
case|:
name|socketErrorString
operator|=
name|QNativeSocketEngine
operator|::
name|tr
argument_list|(
literal|"Unable to receive a message"
argument_list|)
expr_stmt|;
break|break;
case|case
name|WriteErrorString
case|:
name|socketErrorString
operator|=
name|QNativeSocketEngine
operator|::
name|tr
argument_list|(
literal|"Unable to write"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ReadErrorString
case|:
name|socketErrorString
operator|=
name|QNativeSocketEngine
operator|::
name|tr
argument_list|(
literal|"Network error"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PortInuseErrorString
case|:
name|socketErrorString
operator|=
name|QNativeSocketEngine
operator|::
name|tr
argument_list|(
literal|"Another socket is already listening on the same port"
argument_list|)
expr_stmt|;
break|break;
case|case
name|NotSocketErrorString
case|:
name|socketErrorString
operator|=
name|QNativeSocketEngine
operator|::
name|tr
argument_list|(
literal|"Operation on non-socket"
argument_list|)
expr_stmt|;
break|break;
case|case
name|InvalidProxyTypeString
case|:
name|socketErrorString
operator|=
name|QNativeSocketEngine
operator|::
name|tr
argument_list|(
literal|"The proxy type is invalid for this operation"
argument_list|)
expr_stmt|;
break|break;
case|case
name|UnknownSocketErrorString
case|:
name|socketErrorString
operator|=
name|QNativeSocketEngine
operator|::
name|tr
argument_list|(
literal|"Unknown error"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function
begin_function
DECL|function|checkProxy
name|bool
name|QNativeSocketEnginePrivate
operator|::
name|checkProxy
parameter_list|(
specifier|const
name|QHostAddress
modifier|&
name|address
parameter_list|)
block|{
if|if
condition|(
name|address
operator|.
name|isLoopback
argument_list|()
condition|)
return|return
literal|true
return|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_NETWORKPROXY
argument_list|)
name|QObject
modifier|*
name|parent
init|=
name|q_func
argument_list|()
operator|->
name|parent
argument_list|()
decl_stmt|;
name|QNetworkProxy
name|proxy
decl_stmt|;
if|if
condition|(
name|QAbstractSocket
modifier|*
name|socket
init|=
name|qobject_cast
argument_list|<
name|QAbstractSocket
operator|*
argument_list|>
argument_list|(
name|parent
argument_list|)
condition|)
block|{
name|proxy
operator|=
name|socket
operator|->
name|proxy
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|QTcpServer
modifier|*
name|server
init|=
name|qobject_cast
argument_list|<
name|QTcpServer
operator|*
argument_list|>
argument_list|(
name|parent
argument_list|)
condition|)
block|{
name|proxy
operator|=
name|server
operator|->
name|proxy
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// no parent -> no proxy
return|return
literal|true
return|;
block|}
if|if
condition|(
name|proxy
operator|.
name|type
argument_list|()
operator|==
name|QNetworkProxy
operator|::
name|DefaultProxy
condition|)
name|proxy
operator|=
name|QNetworkProxy
operator|::
name|applicationProxy
argument_list|()
expr_stmt|;
if|if
condition|(
name|proxy
operator|.
name|type
argument_list|()
operator|!=
name|QNetworkProxy
operator|::
name|DefaultProxy
operator|&&
name|proxy
operator|.
name|type
argument_list|()
operator|!=
name|QNetworkProxy
operator|::
name|NoProxy
condition|)
block|{
comment|// QNativeSocketEngine doesn't do proxies
name|setError
argument_list|(
name|QAbstractSocket
operator|::
name|UnsupportedSocketOperationError
argument_list|,
name|QNativeSocketEnginePrivate
operator|::
name|InvalidProxyTypeString
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
endif|#
directive|endif
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     Constructs a QNativeSocketEngine.      \sa initialize() */
end_comment
begin_constructor
DECL|function|QNativeSocketEngine
name|QNativeSocketEngine
operator|::
name|QNativeSocketEngine
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QAbstractSocketEngine
argument_list|(
operator|*
operator|new
name|QNativeSocketEnginePrivate
argument_list|()
argument_list|,
name|parent
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Destructs a QNativeSocketEngine. */
end_comment
begin_destructor
DECL|function|~QNativeSocketEngine
name|QNativeSocketEngine
operator|::
name|~
name|QNativeSocketEngine
parameter_list|()
block|{
name|close
argument_list|()
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     Initializes a QNativeSocketEngine by creating a new socket of type \a     socketType and network layer protocol \a protocol. Returns true on     success; otherwise returns false.      If the socket was already initialized, this function closes the     socket before reeinitializing it.      The new socket is non-blocking, and for UDP sockets it's also     broadcast enabled. */
end_comment
begin_function
DECL|function|initialize
name|bool
name|QNativeSocketEngine
operator|::
name|initialize
parameter_list|(
name|QAbstractSocket
operator|::
name|SocketType
name|socketType
parameter_list|,
name|QAbstractSocket
operator|::
name|NetworkLayerProtocol
name|protocol
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QNativeSocketEngine
argument_list|)
expr_stmt|;
if|if
condition|(
name|isValid
argument_list|()
condition|)
name|close
argument_list|()
expr_stmt|;
comment|// Create the socket
if|if
condition|(
operator|!
name|d
operator|->
name|createNewSocket
argument_list|(
name|socketType
argument_list|,
name|protocol
argument_list|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|QNATIVESOCKETENGINE_DEBUG
argument_list|)
name|QString
name|typeStr
init|=
name|QLatin1String
argument_list|(
literal|"UnknownSocketType"
argument_list|)
decl_stmt|;
if|if
condition|(
name|socketType
operator|==
name|QAbstractSocket
operator|::
name|TcpSocket
condition|)
name|typeStr
operator|=
name|QLatin1String
argument_list|(
literal|"TcpSocket"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|socketType
operator|==
name|QAbstractSocket
operator|::
name|UdpSocket
condition|)
name|typeStr
operator|=
name|QLatin1String
argument_list|(
literal|"UdpSocket"
argument_list|)
expr_stmt|;
name|QString
name|protocolStr
init|=
name|QLatin1String
argument_list|(
literal|"UnknownProtocol"
argument_list|)
decl_stmt|;
if|if
condition|(
name|protocol
operator|==
name|QAbstractSocket
operator|::
name|IPv4Protocol
condition|)
name|protocolStr
operator|=
name|QLatin1String
argument_list|(
literal|"IPv4Protocol"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|protocol
operator|==
name|QAbstractSocket
operator|::
name|IPv6Protocol
condition|)
name|protocolStr
operator|=
name|QLatin1String
argument_list|(
literal|"IPv6Protocol"
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"QNativeSocketEngine::initialize(type == %s, protocol == %s) failed: %s"
argument_list|,
name|typeStr
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|protocolStr
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|d
operator|->
name|socketErrorString
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|false
return|;
block|}
comment|// Make the socket nonblocking.
if|if
condition|(
operator|!
name|setOption
argument_list|(
name|NonBlockingSocketOption
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|d
operator|->
name|setError
argument_list|(
name|QAbstractSocket
operator|::
name|UnsupportedSocketOperationError
argument_list|,
name|QNativeSocketEnginePrivate
operator|::
name|NonBlockingInitFailedErrorString
argument_list|)
expr_stmt|;
name|close
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// Set the broadcasting flag if it's a UDP socket.
if|if
condition|(
name|socketType
operator|==
name|QAbstractSocket
operator|::
name|UdpSocket
operator|&&
operator|!
name|setOption
argument_list|(
name|BroadcastSocketOption
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|d
operator|->
name|setError
argument_list|(
name|QAbstractSocket
operator|::
name|UnsupportedSocketOperationError
argument_list|,
name|QNativeSocketEnginePrivate
operator|::
name|BroadcastingInitFailedErrorString
argument_list|)
expr_stmt|;
name|close
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// Make sure we receive out-of-band data
if|if
condition|(
name|socketType
operator|==
name|QAbstractSocket
operator|::
name|TcpSocket
operator|&&
operator|!
name|setOption
argument_list|(
name|ReceiveOutOfBandData
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"QNativeSocketEngine::initialize unable to inline out-of-band data"
argument_list|)
expr_stmt|;
block|}
comment|// Before Qt 4.6, we always set the send and receive buffer size to 49152 as
comment|// this was found to be an optimal value. However, modern OS
comment|// all have some kind of auto tuning for this and we therefore don't set
comment|// this explictly anymore.
comment|// If it introduces any performance regressions for Qt 4.6.x (x> 0) then
comment|// it will be put back in.
comment|//
comment|// You can use tests/manual/qhttpnetworkconnection to test HTTP download speed
comment|// with this.
comment|//
comment|// pre-4.6:
comment|// setReceiveBufferSize(49152);
comment|// setSendBufferSize(49152);
name|d
operator|->
name|socketType
operator|=
name|socketType
expr_stmt|;
name|d
operator|->
name|socketProtocol
operator|=
name|protocol
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*! \overload      Initializes the socket using \a socketDescriptor instead of     creating a new one. The socket type and network layer protocol are     determined automatically. The socket's state is set to \a     socketState.      If the socket type is either TCP or UDP, it is made non-blocking.     UDP sockets are also broadcast enabled.  */
end_comment
begin_function
DECL|function|initialize
name|bool
name|QNativeSocketEngine
operator|::
name|initialize
parameter_list|(
name|qintptr
name|socketDescriptor
parameter_list|,
name|QAbstractSocket
operator|::
name|SocketState
name|socketState
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QNativeSocketEngine
argument_list|)
expr_stmt|;
if|if
condition|(
name|isValid
argument_list|()
condition|)
name|close
argument_list|()
expr_stmt|;
name|d
operator|->
name|socketDescriptor
operator|=
name|socketDescriptor
expr_stmt|;
comment|// determine socket type and protocol
if|if
condition|(
operator|!
name|d
operator|->
name|fetchConnectionParameters
argument_list|()
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|QNATIVESOCKETENGINE_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QNativeSocketEngine::initialize(socketDescriptor == %i) failed: %s"
argument_list|,
name|socketDescriptor
argument_list|,
name|d
operator|->
name|socketErrorString
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|socketDescriptor
operator|=
operator|-
literal|1
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|d
operator|->
name|socketType
operator|!=
name|QAbstractSocket
operator|::
name|UnknownSocketType
condition|)
block|{
comment|// Make the socket nonblocking.
if|if
condition|(
operator|!
name|setOption
argument_list|(
name|NonBlockingSocketOption
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|d
operator|->
name|setError
argument_list|(
name|QAbstractSocket
operator|::
name|UnsupportedSocketOperationError
argument_list|,
name|QNativeSocketEnginePrivate
operator|::
name|NonBlockingInitFailedErrorString
argument_list|)
expr_stmt|;
name|close
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// Set the broadcasting flag if it's a UDP socket.
if|if
condition|(
name|d
operator|->
name|socketType
operator|==
name|QAbstractSocket
operator|::
name|UdpSocket
operator|&&
operator|!
name|setOption
argument_list|(
name|BroadcastSocketOption
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|d
operator|->
name|setError
argument_list|(
name|QAbstractSocket
operator|::
name|UnsupportedSocketOperationError
argument_list|,
name|QNativeSocketEnginePrivate
operator|::
name|BroadcastingInitFailedErrorString
argument_list|)
expr_stmt|;
name|close
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
name|d
operator|->
name|socketState
operator|=
name|socketState
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the socket is valid; otherwise returns false. A     socket is valid if it has not been successfully initialized, or if     it has been closed. */
end_comment
begin_function
DECL|function|isValid
name|bool
name|QNativeSocketEngine
operator|::
name|isValid
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QNativeSocketEngine
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|socketDescriptor
operator|!=
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the native socket descriptor. Any use of this descriptor     stands the risk of being non-portable. */
end_comment
begin_function
DECL|function|socketDescriptor
name|qintptr
name|QNativeSocketEngine
operator|::
name|socketDescriptor
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QNativeSocketEngine
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|socketDescriptor
return|;
block|}
end_function
begin_comment
comment|/*!     Connects to the IP address and port specified by \a address and \a     port. If the connection is established, this function returns true     and the socket enters ConnectedState. Otherwise, false is     returned.      If false is returned, state() should be called to see if the     socket is in ConnectingState. If so, a delayed TCP connection is     taking place, and connectToHost() must be called again later to     determine if the connection was established successfully or     not. The second connection attempt must be made when the socket is     ready for writing. This state can be determined either by     connecting a QSocketNotifier to the socket descriptor returned by     socketDescriptor(), or by calling the blocking function     waitForWrite().      Example:     \snippet code/src_network_socket_qnativesocketengine.cpp 0      Otherwise, error() should be called to determine the cause of the     error. */
end_comment
begin_function
DECL|function|connectToHost
name|bool
name|QNativeSocketEngine
operator|::
name|connectToHost
parameter_list|(
specifier|const
name|QHostAddress
modifier|&
name|address
parameter_list|,
name|quint16
name|port
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QNativeSocketEngine
argument_list|)
expr_stmt|;
name|Q_CHECK_VALID_SOCKETLAYER
argument_list|(
name|QNativeSocketEngine
operator|::
name|connectToHost
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|checkProxy
argument_list|(
name|address
argument_list|)
condition|)
return|return
literal|false
return|;
name|Q_CHECK_STATES
argument_list|(
name|QNativeSocketEngine
operator|::
name|connectToHost
argument_list|()
argument_list|,
name|QAbstractSocket
operator|::
name|UnconnectedState
argument_list|,
name|QAbstractSocket
operator|::
name|ConnectingState
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|d
operator|->
name|peerAddress
operator|=
name|address
expr_stmt|;
name|d
operator|->
name|peerPort
operator|=
name|port
expr_stmt|;
name|bool
name|connected
init|=
name|d
operator|->
name|nativeConnect
argument_list|(
name|address
argument_list|,
name|port
argument_list|)
decl_stmt|;
if|if
condition|(
name|connected
condition|)
name|d
operator|->
name|fetchConnectionParameters
argument_list|()
expr_stmt|;
return|return
name|connected
return|;
block|}
end_function
begin_comment
comment|/*!     If there's a connection activity on the socket, process it. Then     notify our parent if there really was activity. */
end_comment
begin_function
DECL|function|connectionNotification
name|void
name|QNativeSocketEngine
operator|::
name|connectionNotification
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QNativeSocketEngine
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|state
argument_list|()
operator|==
name|QAbstractSocket
operator|::
name|ConnectingState
argument_list|)
expr_stmt|;
name|connectToHost
argument_list|(
name|d
operator|->
name|peerAddress
argument_list|,
name|d
operator|->
name|peerPort
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
argument_list|()
operator|!=
name|QAbstractSocket
operator|::
name|ConnectingState
condition|)
block|{
comment|// we changed states
name|QAbstractSocketEngine
operator|::
name|connectionNotification
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Connects to the remote host name given by \a name on port \a     port. When this function is called, the upper-level will not     perform a hostname lookup.      The native socket engine does not support this operation,     but some other socket engines (notably proxy-based ones) do. */
end_comment
begin_function
DECL|function|connectToHostByName
name|bool
name|QNativeSocketEngine
operator|::
name|connectToHostByName
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
name|quint16
name|port
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|Q_D
argument_list|(
name|QNativeSocketEngine
argument_list|)
expr_stmt|;
name|d
operator|->
name|setError
argument_list|(
name|QAbstractSocket
operator|::
name|UnsupportedSocketOperationError
argument_list|,
name|QNativeSocketEnginePrivate
operator|::
name|OperationUnsupportedErrorString
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Binds the socket to the address \a address and port \a     port. Returns true on success; otherwise false is returned. The     port may be 0, in which case an arbitrary unused port is assigned     automatically by the operating system.      Servers call this function to set up the server's address and     port. TCP servers must in addition call listen() after bind(). */
end_comment
begin_function
DECL|function|bind
name|bool
name|QNativeSocketEngine
operator|::
name|bind
parameter_list|(
specifier|const
name|QHostAddress
modifier|&
name|address
parameter_list|,
name|quint16
name|port
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QNativeSocketEngine
argument_list|)
expr_stmt|;
name|Q_CHECK_VALID_SOCKETLAYER
argument_list|(
name|QNativeSocketEngine
operator|::
name|bind
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|checkProxy
argument_list|(
name|address
argument_list|)
condition|)
return|return
literal|false
return|;
name|Q_CHECK_STATE
argument_list|(
name|QNativeSocketEngine
operator|::
name|bind
argument_list|()
argument_list|,
name|QAbstractSocket
operator|::
name|UnconnectedState
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|nativeBind
argument_list|(
name|address
argument_list|,
name|port
argument_list|)
condition|)
return|return
literal|false
return|;
name|d
operator|->
name|fetchConnectionParameters
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     Prepares a TCP server for accepting incoming connections. This     function must be called after bind(), and only by TCP sockets.      After this function has been called, pending client connections     are detected by checking if the socket is ready for reading. This     can be done by either creating a QSocketNotifier, passing the     socket descriptor returned by socketDescriptor(), or by calling     the blocking function waitForRead().      Example:     \snippet code/src_network_socket_qnativesocketengine.cpp 1      \sa bind(), accept() */
end_comment
begin_function
DECL|function|listen
name|bool
name|QNativeSocketEngine
operator|::
name|listen
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QNativeSocketEngine
argument_list|)
expr_stmt|;
name|Q_CHECK_VALID_SOCKETLAYER
argument_list|(
name|QNativeSocketEngine
operator|::
name|listen
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|Q_CHECK_STATE
argument_list|(
name|QNativeSocketEngine
operator|::
name|listen
argument_list|()
argument_list|,
name|QAbstractSocket
operator|::
name|BoundState
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|Q_CHECK_TYPE
argument_list|(
name|QNativeSocketEngine
operator|::
name|listen
argument_list|()
argument_list|,
name|QAbstractSocket
operator|::
name|TcpSocket
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// We're using a backlog of 50. Most modern kernels support TCP
comment|// syncookies by default, and if they do, the backlog is ignored.
comment|// When there is no support for TCP syncookies, this value is
comment|// fine.
return|return
name|d
operator|->
name|nativeListen
argument_list|(
literal|50
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Accepts a pending connection from the socket, which must be in     ListeningState, and returns its socket descriptor. If no pending     connections are available, -1 is returned.      \sa bind(), listen() */
end_comment
begin_function
DECL|function|accept
name|int
name|QNativeSocketEngine
operator|::
name|accept
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QNativeSocketEngine
argument_list|)
expr_stmt|;
name|Q_CHECK_VALID_SOCKETLAYER
argument_list|(
name|QNativeSocketEngine
operator|::
name|accept
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Q_CHECK_STATE
argument_list|(
name|QNativeSocketEngine
operator|::
name|accept
argument_list|()
argument_list|,
name|QAbstractSocket
operator|::
name|ListeningState
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|Q_CHECK_TYPE
argument_list|(
name|QNativeSocketEngine
operator|::
name|accept
argument_list|()
argument_list|,
name|QAbstractSocket
operator|::
name|TcpSocket
argument_list|,
literal|false
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|nativeAccept
argument_list|()
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_NETWORKINTERFACE
end_ifndef
begin_comment
comment|/*!     \since 4.8 */
end_comment
begin_function
DECL|function|joinMulticastGroup
name|bool
name|QNativeSocketEngine
operator|::
name|joinMulticastGroup
parameter_list|(
specifier|const
name|QHostAddress
modifier|&
name|groupAddress
parameter_list|,
specifier|const
name|QNetworkInterface
modifier|&
name|iface
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QNativeSocketEngine
argument_list|)
expr_stmt|;
name|Q_CHECK_VALID_SOCKETLAYER
argument_list|(
name|QNativeSocketEngine
operator|::
name|joinMulticastGroup
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|Q_CHECK_STATE
argument_list|(
name|QNativeSocketEngine
operator|::
name|joinMulticastGroup
argument_list|()
argument_list|,
name|QAbstractSocket
operator|::
name|BoundState
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|Q_CHECK_TYPE
argument_list|(
name|QNativeSocketEngine
operator|::
name|joinMulticastGroup
argument_list|()
argument_list|,
name|QAbstractSocket
operator|::
name|UdpSocket
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// if the user binds a socket to an IPv6 address (or QHostAddress::Any) and
comment|// then attempts to join an IPv4 multicast group, this won't work on
comment|// Windows. In order to make this cross-platform, we warn& fail on all
comment|// platforms.
if|if
condition|(
name|groupAddress
operator|.
name|protocol
argument_list|()
operator|==
name|QAbstractSocket
operator|::
name|IPv4Protocol
operator|&&
operator|(
name|d
operator|->
name|socketProtocol
operator|==
name|QAbstractSocket
operator|::
name|IPv6Protocol
operator|||
name|d
operator|->
name|socketProtocol
operator|==
name|QAbstractSocket
operator|::
name|AnyIPProtocol
operator|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"QAbstractSocket: cannot bind to QHostAddress::Any (or an IPv6 address) and join an IPv4 multicast group"
argument_list|)
expr_stmt|;
name|qWarning
argument_list|(
literal|"QAbstractSocket: bind to QHostAddress::AnyIPv4 instead if you want to do this"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
name|d
operator|->
name|nativeJoinMulticastGroup
argument_list|(
name|groupAddress
argument_list|,
name|iface
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.8 */
end_comment
begin_function
DECL|function|leaveMulticastGroup
name|bool
name|QNativeSocketEngine
operator|::
name|leaveMulticastGroup
parameter_list|(
specifier|const
name|QHostAddress
modifier|&
name|groupAddress
parameter_list|,
specifier|const
name|QNetworkInterface
modifier|&
name|iface
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QNativeSocketEngine
argument_list|)
expr_stmt|;
name|Q_CHECK_VALID_SOCKETLAYER
argument_list|(
name|QNativeSocketEngine
operator|::
name|leaveMulticastGroup
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|Q_CHECK_STATE
argument_list|(
name|QNativeSocketEngine
operator|::
name|leaveMulticastGroup
argument_list|()
argument_list|,
name|QAbstractSocket
operator|::
name|BoundState
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|Q_CHECK_TYPE
argument_list|(
name|QNativeSocketEngine
operator|::
name|leaveMulticastGroup
argument_list|()
argument_list|,
name|QAbstractSocket
operator|::
name|UdpSocket
argument_list|,
literal|false
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|nativeLeaveMulticastGroup
argument_list|(
name|groupAddress
argument_list|,
name|iface
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \since 4.8 */
end_comment
begin_function
DECL|function|multicastInterface
name|QNetworkInterface
name|QNativeSocketEngine
operator|::
name|multicastInterface
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QNativeSocketEngine
argument_list|)
expr_stmt|;
name|Q_CHECK_VALID_SOCKETLAYER
argument_list|(
name|QNativeSocketEngine
operator|::
name|multicastInterface
argument_list|()
argument_list|,
name|QNetworkInterface
argument_list|()
argument_list|)
expr_stmt|;
name|Q_CHECK_TYPE
argument_list|(
name|QNativeSocketEngine
operator|::
name|multicastInterface
argument_list|()
argument_list|,
name|QAbstractSocket
operator|::
name|UdpSocket
argument_list|,
name|QNetworkInterface
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|nativeMulticastInterface
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*! \since 4.8 */
end_comment
begin_function
DECL|function|setMulticastInterface
name|bool
name|QNativeSocketEngine
operator|::
name|setMulticastInterface
parameter_list|(
specifier|const
name|QNetworkInterface
modifier|&
name|iface
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QNativeSocketEngine
argument_list|)
expr_stmt|;
name|Q_CHECK_VALID_SOCKETLAYER
argument_list|(
name|QNativeSocketEngine
operator|::
name|setMulticastInterface
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|Q_CHECK_TYPE
argument_list|(
name|QNativeSocketEngine
operator|::
name|setMulticastInterface
argument_list|()
argument_list|,
name|QAbstractSocket
operator|::
name|UdpSocket
argument_list|,
literal|false
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|nativeSetMulticastInterface
argument_list|(
name|iface
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_NETWORKINTERFACE
end_comment
begin_comment
comment|/*!     Returns the number of bytes that are currently available for     reading. On error, -1 is returned.      For UDP sockets, this function returns the accumulated size of all     pending datagrams, and it is therefore more useful for UDP sockets     to call hasPendingDatagrams() and pendingDatagramSize(). */
end_comment
begin_function
DECL|function|bytesAvailable
name|qint64
name|QNativeSocketEngine
operator|::
name|bytesAvailable
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QNativeSocketEngine
argument_list|)
expr_stmt|;
name|Q_CHECK_VALID_SOCKETLAYER
argument_list|(
name|QNativeSocketEngine
operator|::
name|bytesAvailable
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Q_CHECK_NOT_STATE
argument_list|(
name|QNativeSocketEngine
operator|::
name|bytesAvailable
argument_list|()
argument_list|,
name|QAbstractSocket
operator|::
name|UnconnectedState
argument_list|,
literal|false
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|nativeBytesAvailable
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if there is at least one datagram pending. This     function is only called by UDP sockets, where a datagram can have     a size of 0. TCP sockets call bytesAvailable(). */
end_comment
begin_function
DECL|function|hasPendingDatagrams
name|bool
name|QNativeSocketEngine
operator|::
name|hasPendingDatagrams
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QNativeSocketEngine
argument_list|)
expr_stmt|;
name|Q_CHECK_VALID_SOCKETLAYER
argument_list|(
name|QNativeSocketEngine
operator|::
name|hasPendingDatagrams
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|Q_CHECK_NOT_STATE
argument_list|(
name|QNativeSocketEngine
operator|::
name|hasPendingDatagrams
argument_list|()
argument_list|,
name|QAbstractSocket
operator|::
name|UnconnectedState
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|Q_CHECK_TYPE
argument_list|(
name|QNativeSocketEngine
operator|::
name|hasPendingDatagrams
argument_list|()
argument_list|,
name|QAbstractSocket
operator|::
name|UdpSocket
argument_list|,
literal|false
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|nativeHasPendingDatagrams
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the size of the pending datagram, or -1 if no datagram is     pending. A datagram size of 0 is perfectly valid. This function is     called by UDP sockets before receiveMessage(). For TCP sockets,     call bytesAvailable(). */
end_comment
begin_function
DECL|function|pendingDatagramSize
name|qint64
name|QNativeSocketEngine
operator|::
name|pendingDatagramSize
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QNativeSocketEngine
argument_list|)
expr_stmt|;
name|Q_CHECK_VALID_SOCKETLAYER
argument_list|(
name|QNativeSocketEngine
operator|::
name|pendingDatagramSize
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Q_CHECK_TYPE
argument_list|(
name|QNativeSocketEngine
operator|::
name|pendingDatagramSize
argument_list|()
argument_list|,
name|QAbstractSocket
operator|::
name|UdpSocket
argument_list|,
literal|false
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|nativePendingDatagramSize
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Reads up to \a maxSize bytes of a datagram from the socket,     stores it in \a data and returns the number of bytes read. The     address and port of the sender are stored in \a address and \a     port. If either of these pointers is 0, the corresponding value is     discarded.      To avoid unnecessarily loss of data, call pendingDatagramSize() to     determine the size of the pending message before reading it. If \a     maxSize is too small, the rest of the datagram will be lost.      Returns -1 if an error occurred.      \sa hasPendingDatagrams() */
end_comment
begin_function
DECL|function|readDatagram
name|qint64
name|QNativeSocketEngine
operator|::
name|readDatagram
parameter_list|(
name|char
modifier|*
name|data
parameter_list|,
name|qint64
name|maxSize
parameter_list|,
name|QHostAddress
modifier|*
name|address
parameter_list|,
name|quint16
modifier|*
name|port
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QNativeSocketEngine
argument_list|)
expr_stmt|;
name|Q_CHECK_VALID_SOCKETLAYER
argument_list|(
name|QNativeSocketEngine
operator|::
name|readDatagram
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Q_CHECK_TYPE
argument_list|(
name|QNativeSocketEngine
operator|::
name|readDatagram
argument_list|()
argument_list|,
name|QAbstractSocket
operator|::
name|UdpSocket
argument_list|,
literal|false
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|nativeReceiveDatagram
argument_list|(
name|data
argument_list|,
name|maxSize
argument_list|,
name|address
argument_list|,
name|port
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Writes a UDP datagram of size \a size bytes to the socket from     \a data to the address \a host on port \a port, and returns the     number of bytes written, or -1 if an error occurred.      Only one datagram is sent, and if there is too much data to fit     into a single datagram, the operation will fail and error()     will return QAbstractSocket::DatagramTooLargeError. Operating systems impose an     upper limit to the size of a datagram, but this size is different     on almost all platforms. Sending large datagrams is in general     disadvised, as even if they are sent successfully, they are likely     to be fragmented before arriving at their destination.      Experience has shown that it is in general safe to send datagrams     no larger than 512 bytes.      \sa readDatagram() */
end_comment
begin_function
DECL|function|writeDatagram
name|qint64
name|QNativeSocketEngine
operator|::
name|writeDatagram
parameter_list|(
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|qint64
name|size
parameter_list|,
specifier|const
name|QHostAddress
modifier|&
name|host
parameter_list|,
name|quint16
name|port
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QNativeSocketEngine
argument_list|)
expr_stmt|;
name|Q_CHECK_VALID_SOCKETLAYER
argument_list|(
name|QNativeSocketEngine
operator|::
name|writeDatagram
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Q_CHECK_TYPE
argument_list|(
name|QNativeSocketEngine
operator|::
name|writeDatagram
argument_list|()
argument_list|,
name|QAbstractSocket
operator|::
name|UdpSocket
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|nativeSendDatagram
argument_list|(
name|data
argument_list|,
name|size
argument_list|,
name|host
argument_list|,
name|port
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Writes a block of \a size bytes from \a data to the socket.     Returns the number of bytes written, or -1 if an error occurred. */
end_comment
begin_function
DECL|function|write
name|qint64
name|QNativeSocketEngine
operator|::
name|write
parameter_list|(
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|qint64
name|size
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QNativeSocketEngine
argument_list|)
expr_stmt|;
name|Q_CHECK_VALID_SOCKETLAYER
argument_list|(
name|QNativeSocketEngine
operator|::
name|write
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Q_CHECK_STATE
argument_list|(
name|QNativeSocketEngine
operator|::
name|write
argument_list|()
argument_list|,
name|QAbstractSocket
operator|::
name|ConnectedState
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|nativeWrite
argument_list|(
name|data
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|bytesToWrite
name|qint64
name|QNativeSocketEngine
operator|::
name|bytesToWrite
parameter_list|()
specifier|const
block|{
return|return
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     Reads up to \a maxSize bytes into \a data from the socket.     Returns the number of bytes read, or -1 if an error occurred. */
end_comment
begin_function
DECL|function|read
name|qint64
name|QNativeSocketEngine
operator|::
name|read
parameter_list|(
name|char
modifier|*
name|data
parameter_list|,
name|qint64
name|maxSize
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QNativeSocketEngine
argument_list|)
expr_stmt|;
name|Q_CHECK_VALID_SOCKETLAYER
argument_list|(
name|QNativeSocketEngine
operator|::
name|read
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Q_CHECK_STATES
argument_list|(
name|QNativeSocketEngine
operator|::
name|read
argument_list|()
argument_list|,
name|QAbstractSocket
operator|::
name|ConnectedState
argument_list|,
name|QAbstractSocket
operator|::
name|BoundState
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|qint64
name|readBytes
init|=
name|d
operator|->
name|nativeRead
argument_list|(
name|data
argument_list|,
name|maxSize
argument_list|)
decl_stmt|;
comment|// Handle remote close
if|if
condition|(
name|readBytes
operator|==
literal|0
operator|&&
name|d
operator|->
name|socketType
operator|==
name|QAbstractSocket
operator|::
name|TcpSocket
condition|)
block|{
name|d
operator|->
name|setError
argument_list|(
name|QAbstractSocket
operator|::
name|RemoteHostClosedError
argument_list|,
name|QNativeSocketEnginePrivate
operator|::
name|RemoteHostClosedErrorString
argument_list|)
expr_stmt|;
name|close
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|readBytes
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|hasSetSocketError
condition|)
block|{
name|d
operator|->
name|hasSetSocketError
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|socketError
operator|=
name|QAbstractSocket
operator|::
name|NetworkError
expr_stmt|;
name|d
operator|->
name|socketErrorString
operator|=
name|qt_error_string
argument_list|()
expr_stmt|;
block|}
name|close
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
name|readBytes
return|;
block|}
end_function
begin_comment
comment|/*!     Closes the socket. In order to use the socket again, initialize()     must be called. */
end_comment
begin_function
DECL|function|close
name|void
name|QNativeSocketEngine
operator|::
name|close
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QNativeSocketEngine
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|readNotifier
condition|)
name|d
operator|->
name|readNotifier
operator|->
name|setEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|writeNotifier
condition|)
name|d
operator|->
name|writeNotifier
operator|->
name|setEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|exceptNotifier
condition|)
name|d
operator|->
name|exceptNotifier
operator|->
name|setEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|socketDescriptor
operator|!=
operator|-
literal|1
condition|)
block|{
name|d
operator|->
name|nativeClose
argument_list|()
expr_stmt|;
name|d
operator|->
name|socketDescriptor
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|d
operator|->
name|socketState
operator|=
name|QAbstractSocket
operator|::
name|UnconnectedState
expr_stmt|;
name|d
operator|->
name|hasSetSocketError
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|localPort
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|localAddress
operator|.
name|clear
argument_list|()
expr_stmt|;
name|d
operator|->
name|peerPort
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|peerAddress
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|readNotifier
condition|)
block|{
name|qDeleteInEventHandler
argument_list|(
name|d
operator|->
name|readNotifier
argument_list|)
expr_stmt|;
name|d
operator|->
name|readNotifier
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|->
name|writeNotifier
condition|)
block|{
name|qDeleteInEventHandler
argument_list|(
name|d
operator|->
name|writeNotifier
argument_list|)
expr_stmt|;
name|d
operator|->
name|writeNotifier
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|->
name|exceptNotifier
condition|)
block|{
name|qDeleteInEventHandler
argument_list|(
name|d
operator|->
name|exceptNotifier
argument_list|)
expr_stmt|;
name|d
operator|->
name|exceptNotifier
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Waits for \a msecs milliseconds or until the socket is ready for     reading. If \a timedOut is not 0 and \a msecs milliseconds have     passed, the value of \a timedOut is set to true.      Returns true if data is available for reading; otherwise returns     false.      This is a blocking function call; its use is disadvised in a     single threaded application, as the whole thread will stop     responding until the function returns. waitForRead() is most     useful when there is no event loop available. The general approach     is to create a QSocketNotifier, passing the socket descriptor     returned by socketDescriptor() to its constructor. */
end_comment
begin_function
DECL|function|waitForRead
name|bool
name|QNativeSocketEngine
operator|::
name|waitForRead
parameter_list|(
name|int
name|msecs
parameter_list|,
name|bool
modifier|*
name|timedOut
parameter_list|)
block|{
name|Q_D
argument_list|(
specifier|const
name|QNativeSocketEngine
argument_list|)
expr_stmt|;
name|Q_CHECK_VALID_SOCKETLAYER
argument_list|(
name|QNativeSocketEngine
operator|::
name|waitForRead
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|Q_CHECK_NOT_STATE
argument_list|(
name|QNativeSocketEngine
operator|::
name|waitForRead
argument_list|()
argument_list|,
name|QAbstractSocket
operator|::
name|UnconnectedState
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|timedOut
condition|)
operator|*
name|timedOut
operator|=
literal|false
expr_stmt|;
name|int
name|ret
init|=
name|d
operator|->
name|nativeSelect
argument_list|(
name|msecs
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|timedOut
condition|)
operator|*
name|timedOut
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|setError
argument_list|(
name|QAbstractSocket
operator|::
name|SocketTimeoutError
argument_list|,
name|QNativeSocketEnginePrivate
operator|::
name|TimeOutErrorString
argument_list|)
expr_stmt|;
name|d
operator|->
name|hasSetSocketError
operator|=
literal|false
expr_stmt|;
comment|// A timeout error is temporary in waitFor functions
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|state
argument_list|()
operator|==
name|QAbstractSocket
operator|::
name|ConnectingState
condition|)
block|{
name|connectToHost
argument_list|(
name|d
operator|->
name|peerAddress
argument_list|,
name|d
operator|->
name|peerPort
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
operator|>
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     Waits for \a msecs milliseconds or until the socket is ready for     writing. If \a timedOut is not 0 and \a msecs milliseconds have     passed, the value of \a timedOut is set to true.      Returns true if data is available for writing; otherwise returns     false.      This is a blocking function call; its use is disadvised in a     single threaded application, as the whole thread will stop     responding until the function returns. waitForWrite() is most     useful when there is no event loop available. The general approach     is to create a QSocketNotifier, passing the socket descriptor     returned by socketDescriptor() to its constructor. */
end_comment
begin_function
DECL|function|waitForWrite
name|bool
name|QNativeSocketEngine
operator|::
name|waitForWrite
parameter_list|(
name|int
name|msecs
parameter_list|,
name|bool
modifier|*
name|timedOut
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QNativeSocketEngine
argument_list|)
expr_stmt|;
name|Q_CHECK_VALID_SOCKETLAYER
argument_list|(
name|QNativeSocketEngine
operator|::
name|waitForWrite
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|Q_CHECK_NOT_STATE
argument_list|(
name|QNativeSocketEngine
operator|::
name|waitForWrite
argument_list|()
argument_list|,
name|QAbstractSocket
operator|::
name|UnconnectedState
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|timedOut
condition|)
operator|*
name|timedOut
operator|=
literal|false
expr_stmt|;
name|int
name|ret
init|=
name|d
operator|->
name|nativeSelect
argument_list|(
name|msecs
argument_list|,
literal|false
argument_list|)
decl_stmt|;
comment|// On Windows, the socket is in connected state if a call to
comment|// select(writable) is successful. In this case we should not
comment|// issue a second call to WSAConnect()
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
if|if
condition|(
name|ret
operator|>
literal|0
condition|)
block|{
name|setState
argument_list|(
name|QAbstractSocket
operator|::
name|ConnectedState
argument_list|)
expr_stmt|;
name|d_func
argument_list|()
operator|->
name|fetchConnectionParameters
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
name|int
name|value
init|=
literal|0
decl_stmt|;
name|int
name|valueSize
init|=
sizeof|sizeof
argument_list|(
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
operator|::
name|getsockopt
argument_list|(
name|d
operator|->
name|socketDescriptor
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_ERROR
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|value
argument_list|,
operator|&
name|valueSize
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|value
operator|==
name|WSAECONNREFUSED
condition|)
block|{
name|d
operator|->
name|setError
argument_list|(
name|QAbstractSocket
operator|::
name|ConnectionRefusedError
argument_list|,
name|QNativeSocketEnginePrivate
operator|::
name|ConnectionRefusedErrorString
argument_list|)
expr_stmt|;
name|d
operator|->
name|socketState
operator|=
name|QAbstractSocket
operator|::
name|UnconnectedState
expr_stmt|;
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|==
name|WSAETIMEDOUT
condition|)
block|{
name|d
operator|->
name|setError
argument_list|(
name|QAbstractSocket
operator|::
name|NetworkError
argument_list|,
name|QNativeSocketEnginePrivate
operator|::
name|ConnectionTimeOutErrorString
argument_list|)
expr_stmt|;
name|d
operator|->
name|socketState
operator|=
name|QAbstractSocket
operator|::
name|UnconnectedState
expr_stmt|;
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|==
name|WSAEHOSTUNREACH
condition|)
block|{
name|d
operator|->
name|setError
argument_list|(
name|QAbstractSocket
operator|::
name|NetworkError
argument_list|,
name|QNativeSocketEnginePrivate
operator|::
name|HostUnreachableErrorString
argument_list|)
expr_stmt|;
name|d
operator|->
name|socketState
operator|=
name|QAbstractSocket
operator|::
name|UnconnectedState
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|timedOut
condition|)
operator|*
name|timedOut
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|setError
argument_list|(
name|QAbstractSocket
operator|::
name|SocketTimeoutError
argument_list|,
name|QNativeSocketEnginePrivate
operator|::
name|TimeOutErrorString
argument_list|)
expr_stmt|;
name|d
operator|->
name|hasSetSocketError
operator|=
literal|false
expr_stmt|;
comment|// A timeout error is temporary in waitFor functions
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|state
argument_list|()
operator|==
name|QAbstractSocket
operator|::
name|ConnectingState
condition|)
block|{
name|connectToHost
argument_list|(
name|d
operator|->
name|peerAddress
argument_list|,
name|d
operator|->
name|peerPort
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
operator|>
literal|0
return|;
block|}
end_function
begin_function
DECL|function|waitForReadOrWrite
name|bool
name|QNativeSocketEngine
operator|::
name|waitForReadOrWrite
parameter_list|(
name|bool
modifier|*
name|readyToRead
parameter_list|,
name|bool
modifier|*
name|readyToWrite
parameter_list|,
name|bool
name|checkRead
parameter_list|,
name|bool
name|checkWrite
parameter_list|,
name|int
name|msecs
parameter_list|,
name|bool
modifier|*
name|timedOut
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QNativeSocketEngine
argument_list|)
expr_stmt|;
name|Q_CHECK_VALID_SOCKETLAYER
argument_list|(
name|QNativeSocketEngine
operator|::
name|waitForWrite
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|Q_CHECK_NOT_STATE
argument_list|(
name|QNativeSocketEngine
operator|::
name|waitForReadOrWrite
argument_list|()
argument_list|,
name|QAbstractSocket
operator|::
name|UnconnectedState
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|int
name|ret
init|=
name|d
operator|->
name|nativeSelect
argument_list|(
name|msecs
argument_list|,
name|checkRead
argument_list|,
name|checkWrite
argument_list|,
name|readyToRead
argument_list|,
name|readyToWrite
argument_list|)
decl_stmt|;
comment|// On Windows, the socket is in connected state if a call to
comment|// select(writable) is successful. In this case we should not
comment|// issue a second call to WSAConnect()
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
if|if
condition|(
name|checkWrite
operator|&&
operator|(
operator|(
name|readyToWrite
operator|&&
operator|*
name|readyToWrite
operator|)
operator|||
operator|!
name|readyToWrite
operator|)
operator|&&
name|ret
operator|>
literal|0
condition|)
block|{
name|setState
argument_list|(
name|QAbstractSocket
operator|::
name|ConnectedState
argument_list|)
expr_stmt|;
name|d_func
argument_list|()
operator|->
name|fetchConnectionParameters
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
else|else
block|{
name|int
name|value
init|=
literal|0
decl_stmt|;
name|int
name|valueSize
init|=
sizeof|sizeof
argument_list|(
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
operator|::
name|getsockopt
argument_list|(
name|d
operator|->
name|socketDescriptor
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_ERROR
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|value
argument_list|,
operator|&
name|valueSize
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|value
operator|==
name|WSAECONNREFUSED
condition|)
block|{
name|d
operator|->
name|setError
argument_list|(
name|QAbstractSocket
operator|::
name|ConnectionRefusedError
argument_list|,
name|QNativeSocketEnginePrivate
operator|::
name|ConnectionRefusedErrorString
argument_list|)
expr_stmt|;
name|d
operator|->
name|socketState
operator|=
name|QAbstractSocket
operator|::
name|UnconnectedState
expr_stmt|;
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|==
name|WSAETIMEDOUT
condition|)
block|{
name|d
operator|->
name|setError
argument_list|(
name|QAbstractSocket
operator|::
name|NetworkError
argument_list|,
name|QNativeSocketEnginePrivate
operator|::
name|ConnectionTimeOutErrorString
argument_list|)
expr_stmt|;
name|d
operator|->
name|socketState
operator|=
name|QAbstractSocket
operator|::
name|UnconnectedState
expr_stmt|;
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|value
operator|==
name|WSAEHOSTUNREACH
condition|)
block|{
name|d
operator|->
name|setError
argument_list|(
name|QAbstractSocket
operator|::
name|NetworkError
argument_list|,
name|QNativeSocketEnginePrivate
operator|::
name|HostUnreachableErrorString
argument_list|)
expr_stmt|;
name|d
operator|->
name|socketState
operator|=
name|QAbstractSocket
operator|::
name|UnconnectedState
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|timedOut
condition|)
operator|*
name|timedOut
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|setError
argument_list|(
name|QAbstractSocket
operator|::
name|SocketTimeoutError
argument_list|,
name|QNativeSocketEnginePrivate
operator|::
name|TimeOutErrorString
argument_list|)
expr_stmt|;
name|d
operator|->
name|hasSetSocketError
operator|=
literal|false
expr_stmt|;
comment|// A timeout error is temporary in waitFor functions
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|state
argument_list|()
operator|==
name|QAbstractSocket
operator|::
name|ConnectingState
condition|)
block|{
name|connectToHost
argument_list|(
name|d
operator|->
name|peerAddress
argument_list|,
name|d
operator|->
name|peerPort
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
operator|>
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the size of the operating system's socket receive     buffer. Depending on the operating system, this size may be     different from what has been set earlier with     setReceiveBufferSize(). */
end_comment
begin_function
DECL|function|receiveBufferSize
name|qint64
name|QNativeSocketEngine
operator|::
name|receiveBufferSize
parameter_list|()
specifier|const
block|{
name|Q_CHECK_VALID_SOCKETLAYER
argument_list|(
name|QNativeSocketEngine
operator|::
name|receiveBufferSize
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|option
argument_list|(
name|ReceiveBufferSocketOption
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the size of the operating system receive buffer to \a size.      For clients, this should be set before connectToHost() is called;     otherwise it will have no effect. For servers, it should be called     before listen().      The operating system receive buffer size effectively limits two     things: how much data can be in transit at any one moment, and how     much data can be received in one iteration of the main event loop.     Setting the size of the receive buffer may have an impact on the     socket's performance.      The default value is operating system-dependent. */
end_comment
begin_function
DECL|function|setReceiveBufferSize
name|void
name|QNativeSocketEngine
operator|::
name|setReceiveBufferSize
parameter_list|(
name|qint64
name|size
parameter_list|)
block|{
name|Q_CHECK_VALID_SOCKETLAYER
argument_list|(
name|QNativeSocketEngine
operator|::
name|setReceiveBufferSize
argument_list|()
argument_list|,
name|Q_VOID
argument_list|)
expr_stmt|;
name|setOption
argument_list|(
name|ReceiveBufferSocketOption
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the size of the operating system send buffer. Depending on     the operating system, this size may be different from what has     been set earlier with setSendBufferSize(). */
end_comment
begin_function
DECL|function|sendBufferSize
name|qint64
name|QNativeSocketEngine
operator|::
name|sendBufferSize
parameter_list|()
specifier|const
block|{
name|Q_CHECK_VALID_SOCKETLAYER
argument_list|(
name|QNativeSocketEngine
operator|::
name|setSendBufferSize
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|option
argument_list|(
name|SendBufferSocketOption
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the size of the operating system send buffer to \a size.      The operating system send buffer size effectively limits how much     data can be in transit at any one moment. Setting the size of the     send buffer may have an impact on the socket's performance.      The default value is operating system-dependent. */
end_comment
begin_function
DECL|function|setSendBufferSize
name|void
name|QNativeSocketEngine
operator|::
name|setSendBufferSize
parameter_list|(
name|qint64
name|size
parameter_list|)
block|{
name|Q_CHECK_VALID_SOCKETLAYER
argument_list|(
name|QNativeSocketEngine
operator|::
name|setSendBufferSize
argument_list|()
argument_list|,
name|Q_VOID
argument_list|)
expr_stmt|;
name|setOption
argument_list|(
name|SendBufferSocketOption
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the option \a option to the value \a value. */
end_comment
begin_function
DECL|function|setOption
name|bool
name|QNativeSocketEngine
operator|::
name|setOption
parameter_list|(
name|SocketOption
name|option
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QNativeSocketEngine
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|setOption
argument_list|(
name|option
argument_list|,
name|value
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the value of the option \a socketOption. */
end_comment
begin_function
DECL|function|option
name|int
name|QNativeSocketEngine
operator|::
name|option
parameter_list|(
name|SocketOption
name|socketOption
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QNativeSocketEngine
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|option
argument_list|(
name|socketOption
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|isReadNotificationEnabled
name|bool
name|QNativeSocketEngine
operator|::
name|isReadNotificationEnabled
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QNativeSocketEngine
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|readNotifier
operator|&&
name|d
operator|->
name|readNotifier
operator|->
name|isEnabled
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*   \internal   \class QReadNotifier   \brief The QReadNotifer class is used to improve performance.    QReadNotifier is a private class used for performance reasons vs   connecting to the QSocketNotifier activated() signal.  */
end_comment
begin_class
DECL|class|QReadNotifier
class|class
name|QReadNotifier
super|:
specifier|public
name|QSocketNotifier
block|{
public|public:
DECL|function|QReadNotifier
name|QReadNotifier
parameter_list|(
name|qintptr
name|fd
parameter_list|,
name|QNativeSocketEngine
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QSocketNotifier
argument_list|(
name|fd
argument_list|,
name|QSocketNotifier
operator|::
name|Read
argument_list|,
name|parent
argument_list|)
block|{
name|engine
operator|=
name|parent
expr_stmt|;
block|}
protected|protected:
name|bool
name|event
parameter_list|(
name|QEvent
modifier|*
parameter_list|)
function_decl|;
DECL|member|engine
name|QNativeSocketEngine
modifier|*
name|engine
decl_stmt|;
block|}
class|;
end_class
begin_function
DECL|function|event
name|bool
name|QReadNotifier
operator|::
name|event
parameter_list|(
name|QEvent
modifier|*
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|SockAct
condition|)
block|{
name|engine
operator|->
name|readNotification
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
elseif|else
if|if
condition|(
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|SockClose
condition|)
block|{
name|engine
operator|->
name|closeNotification
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
name|QSocketNotifier
operator|::
name|event
argument_list|(
name|e
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*   \internal   \class QWriteNotifier   \brief The QWriteNotifer class is used to improve performance.    QWriteNotifier is a private class used for performance reasons vs   connecting to the QSocketNotifier activated() signal.  */
end_comment
begin_class
DECL|class|QWriteNotifier
class|class
name|QWriteNotifier
super|:
specifier|public
name|QSocketNotifier
block|{
public|public:
DECL|function|QWriteNotifier
name|QWriteNotifier
parameter_list|(
name|int
name|fd
parameter_list|,
name|QNativeSocketEngine
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QSocketNotifier
argument_list|(
name|fd
argument_list|,
name|QSocketNotifier
operator|::
name|Write
argument_list|,
name|parent
argument_list|)
block|{
name|engine
operator|=
name|parent
expr_stmt|;
block|}
protected|protected:
name|bool
name|event
parameter_list|(
name|QEvent
modifier|*
parameter_list|)
function_decl|;
DECL|member|engine
name|QNativeSocketEngine
modifier|*
name|engine
decl_stmt|;
block|}
class|;
end_class
begin_function
DECL|function|event
name|bool
name|QWriteNotifier
operator|::
name|event
parameter_list|(
name|QEvent
modifier|*
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|SockAct
condition|)
block|{
if|if
condition|(
name|engine
operator|->
name|state
argument_list|()
operator|==
name|QAbstractSocket
operator|::
name|ConnectingState
condition|)
name|engine
operator|->
name|connectionNotification
argument_list|()
expr_stmt|;
else|else
name|engine
operator|->
name|writeNotification
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
name|QSocketNotifier
operator|::
name|event
argument_list|(
name|e
argument_list|)
return|;
block|}
end_function
begin_class
DECL|class|QExceptionNotifier
class|class
name|QExceptionNotifier
super|:
specifier|public
name|QSocketNotifier
block|{
public|public:
DECL|function|QExceptionNotifier
name|QExceptionNotifier
parameter_list|(
name|int
name|fd
parameter_list|,
name|QNativeSocketEngine
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QSocketNotifier
argument_list|(
name|fd
argument_list|,
name|QSocketNotifier
operator|::
name|Exception
argument_list|,
name|parent
argument_list|)
block|{
name|engine
operator|=
name|parent
expr_stmt|;
block|}
protected|protected:
name|bool
name|event
parameter_list|(
name|QEvent
modifier|*
parameter_list|)
function_decl|;
DECL|member|engine
name|QNativeSocketEngine
modifier|*
name|engine
decl_stmt|;
block|}
class|;
end_class
begin_function
DECL|function|event
name|bool
name|QExceptionNotifier
operator|::
name|event
parameter_list|(
name|QEvent
modifier|*
name|e
parameter_list|)
block|{
if|if
condition|(
name|e
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|SockAct
condition|)
block|{
if|if
condition|(
name|engine
operator|->
name|state
argument_list|()
operator|==
name|QAbstractSocket
operator|::
name|ConnectingState
condition|)
name|engine
operator|->
name|connectionNotification
argument_list|()
expr_stmt|;
else|else
name|engine
operator|->
name|exceptionNotification
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
name|QSocketNotifier
operator|::
name|event
argument_list|(
name|e
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|setReadNotificationEnabled
name|void
name|QNativeSocketEngine
operator|::
name|setReadNotificationEnabled
parameter_list|(
name|bool
name|enable
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QNativeSocketEngine
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|readNotifier
condition|)
block|{
name|d
operator|->
name|readNotifier
operator|->
name|setEnabled
argument_list|(
name|enable
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|enable
operator|&&
name|d
operator|->
name|threadData
operator|->
name|eventDispatcher
condition|)
block|{
name|d
operator|->
name|readNotifier
operator|=
operator|new
name|QReadNotifier
argument_list|(
name|d
operator|->
name|socketDescriptor
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|d
operator|->
name|readNotifier
operator|->
name|setEnabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|isWriteNotificationEnabled
name|bool
name|QNativeSocketEngine
operator|::
name|isWriteNotificationEnabled
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QNativeSocketEngine
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|writeNotifier
operator|&&
name|d
operator|->
name|writeNotifier
operator|->
name|isEnabled
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|setWriteNotificationEnabled
name|void
name|QNativeSocketEngine
operator|::
name|setWriteNotificationEnabled
parameter_list|(
name|bool
name|enable
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QNativeSocketEngine
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|writeNotifier
condition|)
block|{
name|d
operator|->
name|writeNotifier
operator|->
name|setEnabled
argument_list|(
name|enable
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|enable
operator|&&
name|d
operator|->
name|threadData
operator|->
name|eventDispatcher
condition|)
block|{
name|d
operator|->
name|writeNotifier
operator|=
operator|new
name|QWriteNotifier
argument_list|(
name|d
operator|->
name|socketDescriptor
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|d
operator|->
name|writeNotifier
operator|->
name|setEnabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|isExceptionNotificationEnabled
name|bool
name|QNativeSocketEngine
operator|::
name|isExceptionNotificationEnabled
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QNativeSocketEngine
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|exceptNotifier
operator|&&
name|d
operator|->
name|exceptNotifier
operator|->
name|isEnabled
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|setExceptionNotificationEnabled
name|void
name|QNativeSocketEngine
operator|::
name|setExceptionNotificationEnabled
parameter_list|(
name|bool
name|enable
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QNativeSocketEngine
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|exceptNotifier
condition|)
block|{
name|d
operator|->
name|exceptNotifier
operator|->
name|setEnabled
argument_list|(
name|enable
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|enable
operator|&&
name|d
operator|->
name|threadData
operator|->
name|eventDispatcher
condition|)
block|{
name|d
operator|->
name|exceptNotifier
operator|=
operator|new
name|QExceptionNotifier
argument_list|(
name|d
operator|->
name|socketDescriptor
argument_list|,
name|this
argument_list|)
expr_stmt|;
name|d
operator|->
name|exceptNotifier
operator|->
name|setEnabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
