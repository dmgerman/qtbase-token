begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2014 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtNetwork module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL21$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia. For licensing terms and ** conditions see http://qt.digia.com/licensing. For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 or version 3 as published by the Free ** Software Foundation and appearing in the file LICENSE.LGPLv21 and ** LICENSE.LGPLv3 included in the packaging of this file. Please review the ** following information to ensure the GNU Lesser General Public License ** requirements will be met: https://www.gnu.org/licenses/lgpl.html and ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights. These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_comment
comment|//#define QTCPSERVER_DEBUG
end_comment
begin_comment
comment|/*! \class QTcpServer      \brief The QTcpServer class provides a TCP-based server.      \reentrant     \ingroup network     \inmodule QtNetwork      This class makes it possible to accept incoming TCP connections.     You can specify the port or have QTcpServer pick one     automatically. You can listen on a specific address or on all the     machine's addresses.      Call listen() to have the server listen for incoming connections.     The newConnection() signal is then emitted each time a client     connects to the server.      Call nextPendingConnection() to accept the pending connection as     a connected QTcpSocket. The function returns a pointer to a     QTcpSocket in QAbstractSocket::ConnectedState that you can use for     communicating with the client.      If an error occurs, serverError() returns the type of error, and     errorString() can be called to get a human readable description of     what happened.      When listening for connections, the address and port on which the     server is listening are available as serverAddress() and     serverPort().      Calling close() makes QTcpServer stop listening for incoming     connections.      Although QTcpServer is mostly designed for use with an event     loop, it's possible to use it without one. In that case, you must     use waitForNewConnection(), which blocks until either a     connection is available or a timeout expires.      \sa QTcpSocket, {Fortune Server Example}, {Threaded Fortune Server Example},         {Loopback Example}, {Torrent Example} */
end_comment
begin_comment
comment|/*! \fn void QTcpServer::newConnection()      This signal is emitted every time a new connection is available.      \sa hasPendingConnections(), nextPendingConnection() */
end_comment
begin_comment
comment|/*! \fn void QTcpServer::acceptError(QAbstractSocket::SocketError socketError)     \since 5.0      This signal is emitted when accepting a new connection results in an error.     The \a socketError parameter describes the type of error that occurred.      \sa pauseAccepting(), resumeAccepting() */
end_comment
begin_include
include|#
directive|include
file|"qtcpserver.h"
end_include
begin_include
include|#
directive|include
file|"private/qobject_p.h"
end_include
begin_include
include|#
directive|include
file|"qalgorithms.h"
end_include
begin_include
include|#
directive|include
file|"qhostaddress.h"
end_include
begin_include
include|#
directive|include
file|"qlist.h"
end_include
begin_include
include|#
directive|include
file|"qpointer.h"
end_include
begin_include
include|#
directive|include
file|"qabstractsocketengine_p.h"
end_include
begin_include
include|#
directive|include
file|"qtcpsocket.h"
end_include
begin_include
include|#
directive|include
file|"qnetworkproxy.h"
end_include
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_define
DECL|macro|Q_CHECK_SOCKETENGINE
define|#
directive|define
name|Q_CHECK_SOCKETENGINE
parameter_list|(
name|returnValue
parameter_list|)
value|do { \     if (!d->socketEngine) { \         return returnValue; \     } } while (0)
end_define
begin_class
DECL|class|QTcpServerPrivate
class|class
name|QTcpServerPrivate
super|:
specifier|public
name|QObjectPrivate
super|,
specifier|public
name|QAbstractSocketEngineReceiver
block|{
name|Q_DECLARE_PUBLIC
parameter_list|(
name|QTcpServer
parameter_list|)
specifier|public
private|:
name|QTcpServerPrivate
parameter_list|()
constructor_decl|;
name|~
name|QTcpServerPrivate
parameter_list|()
destructor_decl|;
DECL|member|pendingConnections
name|QList
argument_list|<
name|QTcpSocket
modifier|*
argument_list|>
name|pendingConnections
decl_stmt|;
DECL|member|port
name|quint16
name|port
decl_stmt|;
DECL|member|address
name|QHostAddress
name|address
decl_stmt|;
DECL|member|state
name|QAbstractSocket
operator|::
name|SocketState
name|state
decl_stmt|;
DECL|member|socketEngine
name|QAbstractSocketEngine
modifier|*
name|socketEngine
decl_stmt|;
DECL|member|serverSocketError
name|QAbstractSocket
operator|::
name|SocketError
name|serverSocketError
decl_stmt|;
DECL|member|serverSocketErrorString
name|QString
name|serverSocketErrorString
decl_stmt|;
DECL|member|maxConnections
name|int
name|maxConnections
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
DECL|member|proxy
name|QNetworkProxy
name|proxy
decl_stmt|;
name|QNetworkProxy
name|resolveProxy
parameter_list|(
specifier|const
name|QHostAddress
modifier|&
name|address
parameter_list|,
name|quint16
name|port
parameter_list|)
function_decl|;
endif|#
directive|endif
comment|// from QAbstractSocketEngineReceiver
DECL|member|Q_DECL_OVERRIDE
name|void
name|readNotification
parameter_list|()
name|Q_DECL_OVERRIDE
function_decl|;
name|void
name|closeNotification
parameter_list|()
name|Q_DECL_OVERRIDE
block|{
name|readNotification
argument_list|()
expr_stmt|;
block|}
DECL|function|writeNotification
specifier|inline
name|void
name|writeNotification
parameter_list|()
block|{}
DECL|function|exceptionNotification
specifier|inline
name|void
name|exceptionNotification
parameter_list|()
block|{}
DECL|function|connectionNotification
specifier|inline
name|void
name|connectionNotification
parameter_list|()
block|{}
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
DECL|function|proxyAuthenticationRequired
specifier|inline
name|void
name|proxyAuthenticationRequired
parameter_list|(
specifier|const
name|QNetworkProxy
modifier|&
parameter_list|,
name|QAuthenticator
modifier|*
parameter_list|)
block|{}
endif|#
directive|endif
block|}
class|;
end_class
begin_comment
comment|/*! \internal */
end_comment
begin_constructor
DECL|function|QTcpServerPrivate
name|QTcpServerPrivate
operator|::
name|QTcpServerPrivate
parameter_list|()
member_init_list|:
name|port
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|state
argument_list|(
name|QAbstractSocket
operator|::
name|UnconnectedState
argument_list|)
member_init_list|,
name|socketEngine
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|serverSocketError
argument_list|(
name|QAbstractSocket
operator|::
name|UnknownSocketError
argument_list|)
member_init_list|,
name|maxConnections
argument_list|(
literal|30
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*! \internal */
end_comment
begin_destructor
DECL|function|~QTcpServerPrivate
name|QTcpServerPrivate
operator|::
name|~
name|QTcpServerPrivate
parameter_list|()
block|{ }
end_destructor
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
end_ifndef
begin_comment
comment|/*! \internal      Resolve the proxy to its final value. */
end_comment
begin_function
DECL|function|resolveProxy
name|QNetworkProxy
name|QTcpServerPrivate
operator|::
name|resolveProxy
parameter_list|(
specifier|const
name|QHostAddress
modifier|&
name|address
parameter_list|,
name|quint16
name|port
parameter_list|)
block|{
if|if
condition|(
name|address
operator|.
name|isLoopback
argument_list|()
condition|)
return|return
name|QNetworkProxy
operator|::
name|NoProxy
return|;
name|QList
argument_list|<
name|QNetworkProxy
argument_list|>
name|proxies
decl_stmt|;
if|if
condition|(
name|proxy
operator|.
name|type
argument_list|()
operator|!=
name|QNetworkProxy
operator|::
name|DefaultProxy
condition|)
block|{
comment|// a non-default proxy was set with setProxy
name|proxies
operator|<<
name|proxy
expr_stmt|;
block|}
else|else
block|{
comment|// try the application settings instead
name|QNetworkProxyQuery
name|query
argument_list|(
name|port
argument_list|,
name|QString
argument_list|()
argument_list|,
name|QNetworkProxyQuery
operator|::
name|TcpServer
argument_list|)
decl_stmt|;
name|proxies
operator|=
name|QNetworkProxyFactory
operator|::
name|proxyForQuery
argument_list|(
name|query
argument_list|)
expr_stmt|;
block|}
comment|// return the first that we can use
foreach|foreach
control|(
specifier|const
name|QNetworkProxy
modifier|&
name|p
decl|,
name|proxies
control|)
block|{
if|if
condition|(
name|p
operator|.
name|capabilities
argument_list|()
operator|&
name|QNetworkProxy
operator|::
name|ListeningCapability
condition|)
return|return
name|p
return|;
block|}
comment|// no proxy found
comment|// DefaultProxy will raise an error
return|return
name|QNetworkProxy
argument_list|(
name|QNetworkProxy
operator|::
name|DefaultProxy
argument_list|)
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*! \internal */
end_comment
begin_function
DECL|function|readNotification
name|void
name|QTcpServerPrivate
operator|::
name|readNotification
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QTcpServer
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|pendingConnections
operator|.
name|count
argument_list|()
operator|>=
name|maxConnections
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|QTCPSERVER_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QTcpServerPrivate::_q_processIncomingConnection() too many connections"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|socketEngine
operator|->
name|isReadNotificationEnabled
argument_list|()
condition|)
name|socketEngine
operator|->
name|setReadNotificationEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
return|return;
block|}
name|int
name|descriptor
init|=
name|socketEngine
operator|->
name|accept
argument_list|()
decl_stmt|;
if|if
condition|(
name|descriptor
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|socketEngine
operator|->
name|error
argument_list|()
operator|!=
name|QAbstractSocket
operator|::
name|TemporaryError
condition|)
block|{
name|q
operator|->
name|pauseAccepting
argument_list|()
expr_stmt|;
name|serverSocketError
operator|=
name|socketEngine
operator|->
name|error
argument_list|()
expr_stmt|;
name|serverSocketErrorString
operator|=
name|socketEngine
operator|->
name|errorString
argument_list|()
expr_stmt|;
emit|emit
name|q
operator|->
name|acceptError
argument_list|(
name|serverSocketError
argument_list|)
emit|;
block|}
break|break;
block|}
if|#
directive|if
name|defined
argument_list|(
name|QTCPSERVER_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QTcpServerPrivate::_q_processIncomingConnection() accepted socket %i"
argument_list|,
name|descriptor
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|q
operator|->
name|incomingConnection
argument_list|(
name|descriptor
argument_list|)
expr_stmt|;
name|QPointer
argument_list|<
name|QTcpServer
argument_list|>
name|that
init|=
name|q
decl_stmt|;
emit|emit
name|q
operator|->
name|newConnection
argument_list|()
emit|;
if|if
condition|(
operator|!
name|that
operator|||
operator|!
name|q
operator|->
name|isListening
argument_list|()
condition|)
return|return;
block|}
block|}
end_function
begin_comment
comment|/*!     Constructs a QTcpServer object.      \a parent is passed to the QObject constructor.      \sa listen(), setSocketDescriptor() */
end_comment
begin_constructor
DECL|function|QTcpServer
name|QTcpServer
operator|::
name|QTcpServer
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QObject
argument_list|(
operator|*
operator|new
name|QTcpServerPrivate
argument_list|,
name|parent
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Destroys the QTcpServer object. If the server is listening for     connections, the socket is automatically closed.      Any client \l{QTcpSocket}s that are still connected must either     disconnect or be reparented before the server is deleted.      \sa close() */
end_comment
begin_destructor
DECL|function|~QTcpServer
name|QTcpServer
operator|::
name|~
name|QTcpServer
parameter_list|()
block|{
name|close
argument_list|()
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     Tells the server to listen for incoming connections on address \a     address and port \a port. If \a port is 0, a port is chosen     automatically. If \a address is QHostAddress::Any, the server     will listen on all network interfaces.      Returns \c true on success; otherwise returns \c false.      \sa isListening() */
end_comment
begin_function
DECL|function|listen
name|bool
name|QTcpServer
operator|::
name|listen
parameter_list|(
specifier|const
name|QHostAddress
modifier|&
name|address
parameter_list|,
name|quint16
name|port
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTcpServer
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|state
operator|==
name|QAbstractSocket
operator|::
name|ListeningState
condition|)
block|{
name|qWarning
argument_list|(
literal|"QTcpServer::listen() called when already listening"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|QAbstractSocket
operator|::
name|NetworkLayerProtocol
name|proto
init|=
name|address
operator|.
name|protocol
argument_list|()
decl_stmt|;
name|QHostAddress
name|addr
init|=
name|address
decl_stmt|;
ifdef|#
directive|ifdef
name|QT_NO_NETWORKPROXY
specifier|static
specifier|const
name|QNetworkProxy
modifier|&
name|proxy
init|=
operator|*
operator|(
name|QNetworkProxy
operator|*
operator|)
literal|0
decl_stmt|;
else|#
directive|else
name|QNetworkProxy
name|proxy
init|=
name|d
operator|->
name|resolveProxy
argument_list|(
name|addr
argument_list|,
name|port
argument_list|)
decl_stmt|;
endif|#
directive|endif
operator|delete
name|d
operator|->
name|socketEngine
expr_stmt|;
name|d
operator|->
name|socketEngine
operator|=
name|QAbstractSocketEngine
operator|::
name|createSocketEngine
argument_list|(
name|QAbstractSocket
operator|::
name|TcpSocket
argument_list|,
name|proxy
argument_list|,
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|socketEngine
condition|)
block|{
name|d
operator|->
name|serverSocketError
operator|=
name|QAbstractSocket
operator|::
name|UnsupportedSocketOperationError
expr_stmt|;
name|d
operator|->
name|serverSocketErrorString
operator|=
name|tr
argument_list|(
literal|"Operation on socket is not supported"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
ifndef|#
directive|ifndef
name|QT_NO_BEARERMANAGEMENT
comment|//copy network session down to the socket engine (if it has been set)
name|d
operator|->
name|socketEngine
operator|->
name|setProperty
argument_list|(
literal|"_q_networksession"
argument_list|,
name|property
argument_list|(
literal|"_q_networksession"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|d
operator|->
name|socketEngine
operator|->
name|initialize
argument_list|(
name|QAbstractSocket
operator|::
name|TcpSocket
argument_list|,
name|proto
argument_list|)
condition|)
block|{
name|d
operator|->
name|serverSocketError
operator|=
name|d
operator|->
name|socketEngine
operator|->
name|error
argument_list|()
expr_stmt|;
name|d
operator|->
name|serverSocketErrorString
operator|=
name|d
operator|->
name|socketEngine
operator|->
name|errorString
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
name|proto
operator|=
name|d
operator|->
name|socketEngine
operator|->
name|protocol
argument_list|()
expr_stmt|;
if|if
condition|(
name|addr
operator|.
name|protocol
argument_list|()
operator|==
name|QAbstractSocket
operator|::
name|AnyIPProtocol
operator|&&
name|proto
operator|==
name|QAbstractSocket
operator|::
name|IPv4Protocol
condition|)
name|addr
operator|=
name|QHostAddress
operator|::
name|AnyIPv4
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_UNIX
argument_list|)
comment|// Under Unix, we want to be able to bind to the port, even if a socket on
comment|// the same address-port is in TIME_WAIT. Under Windows this is possible
comment|// anyway -- furthermore, the meaning of reusable on Windows is different:
comment|// it means that you can use the same address-port for multiple listening
comment|// sockets.
comment|// Don't abort though if we can't set that option. For example the socks
comment|// engine doesn't support that option, but that shouldn't prevent us from
comment|// trying to bind/listen.
name|d
operator|->
name|socketEngine
operator|->
name|setOption
argument_list|(
name|QAbstractSocketEngine
operator|::
name|AddressReusable
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|d
operator|->
name|socketEngine
operator|->
name|bind
argument_list|(
name|addr
argument_list|,
name|port
argument_list|)
condition|)
block|{
name|d
operator|->
name|serverSocketError
operator|=
name|d
operator|->
name|socketEngine
operator|->
name|error
argument_list|()
expr_stmt|;
name|d
operator|->
name|serverSocketErrorString
operator|=
name|d
operator|->
name|socketEngine
operator|->
name|errorString
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|d
operator|->
name|socketEngine
operator|->
name|listen
argument_list|()
condition|)
block|{
name|d
operator|->
name|serverSocketError
operator|=
name|d
operator|->
name|socketEngine
operator|->
name|error
argument_list|()
expr_stmt|;
name|d
operator|->
name|serverSocketErrorString
operator|=
name|d
operator|->
name|socketEngine
operator|->
name|errorString
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
name|d
operator|->
name|socketEngine
operator|->
name|setReceiver
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|socketEngine
operator|->
name|setReadNotificationEnabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|d
operator|->
name|state
operator|=
name|QAbstractSocket
operator|::
name|ListeningState
expr_stmt|;
name|d
operator|->
name|address
operator|=
name|d
operator|->
name|socketEngine
operator|->
name|localAddress
argument_list|()
expr_stmt|;
name|d
operator|->
name|port
operator|=
name|d
operator|->
name|socketEngine
operator|->
name|localPort
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QTCPSERVER_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QTcpServer::listen(%i, \"%s\") == true (listening on port %i)"
argument_list|,
name|port
argument_list|,
name|address
operator|.
name|toString
argument_list|()
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|d
operator|->
name|socketEngine
operator|->
name|localPort
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     Returns \c true if the server is currently listening for incoming     connections; otherwise returns \c false.      \sa listen() */
end_comment
begin_function
DECL|function|isListening
name|bool
name|QTcpServer
operator|::
name|isListening
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTcpServer
argument_list|)
expr_stmt|;
name|Q_CHECK_SOCKETENGINE
argument_list|(
literal|false
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|socketEngine
operator|->
name|state
argument_list|()
operator|==
name|QAbstractSocket
operator|::
name|ListeningState
return|;
block|}
end_function
begin_comment
comment|/*!     Closes the server. The server will no longer listen for incoming     connections.      \sa listen() */
end_comment
begin_function
DECL|function|close
name|void
name|QTcpServer
operator|::
name|close
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QTcpServer
argument_list|)
expr_stmt|;
name|qDeleteAll
argument_list|(
name|d
operator|->
name|pendingConnections
argument_list|)
expr_stmt|;
name|d
operator|->
name|pendingConnections
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|socketEngine
condition|)
block|{
name|d
operator|->
name|socketEngine
operator|->
name|close
argument_list|()
expr_stmt|;
name|QT_TRY
block|{
name|d
operator|->
name|socketEngine
operator|->
name|deleteLater
argument_list|()
expr_stmt|;
block|}
name|QT_CATCH
argument_list|(
argument|const std::bad_alloc&
argument_list|)
block|{
comment|// in out of memory situations, the socketEngine
comment|// will be deleted in ~QTcpServer (it's a child-object of this)
block|}
name|d
operator|->
name|socketEngine
operator|=
literal|0
expr_stmt|;
block|}
name|d
operator|->
name|state
operator|=
name|QAbstractSocket
operator|::
name|UnconnectedState
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the native socket descriptor the server uses to listen     for incoming instructions, or -1 if the server is not listening.      If the server is using QNetworkProxy, the returned descriptor may     not be usable with native socket functions.      \sa setSocketDescriptor(), isListening() */
end_comment
begin_function
DECL|function|socketDescriptor
name|qintptr
name|QTcpServer
operator|::
name|socketDescriptor
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTcpServer
argument_list|)
expr_stmt|;
name|Q_CHECK_SOCKETENGINE
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|socketEngine
operator|->
name|socketDescriptor
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the socket descriptor this server should use when listening     for incoming connections to \a socketDescriptor. Returns \c true if     the socket is set successfully; otherwise returns \c false.      The socket is assumed to be in listening state.      \sa socketDescriptor(), isListening() */
end_comment
begin_function
DECL|function|setSocketDescriptor
name|bool
name|QTcpServer
operator|::
name|setSocketDescriptor
parameter_list|(
name|qintptr
name|socketDescriptor
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTcpServer
argument_list|)
expr_stmt|;
if|if
condition|(
name|isListening
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QTcpServer::setSocketDescriptor() called when already listening"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|d
operator|->
name|socketEngine
condition|)
operator|delete
name|d
operator|->
name|socketEngine
expr_stmt|;
name|d
operator|->
name|socketEngine
operator|=
name|QAbstractSocketEngine
operator|::
name|createSocketEngine
argument_list|(
name|socketDescriptor
argument_list|,
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|socketEngine
condition|)
block|{
name|d
operator|->
name|serverSocketError
operator|=
name|QAbstractSocket
operator|::
name|UnsupportedSocketOperationError
expr_stmt|;
name|d
operator|->
name|serverSocketErrorString
operator|=
name|tr
argument_list|(
literal|"Operation on socket is not supported"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
ifndef|#
directive|ifndef
name|QT_NO_BEARERMANAGEMENT
comment|//copy network session down to the socket engine (if it has been set)
name|d
operator|->
name|socketEngine
operator|->
name|setProperty
argument_list|(
literal|"_q_networksession"
argument_list|,
name|property
argument_list|(
literal|"_q_networksession"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|d
operator|->
name|socketEngine
operator|->
name|initialize
argument_list|(
name|socketDescriptor
argument_list|,
name|QAbstractSocket
operator|::
name|ListeningState
argument_list|)
condition|)
block|{
name|d
operator|->
name|serverSocketError
operator|=
name|d
operator|->
name|socketEngine
operator|->
name|error
argument_list|()
expr_stmt|;
name|d
operator|->
name|serverSocketErrorString
operator|=
name|d
operator|->
name|socketEngine
operator|->
name|errorString
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QTCPSERVER_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QTcpServer::setSocketDescriptor(%i) failed (%s)"
argument_list|,
name|socketDescriptor
argument_list|,
name|d
operator|->
name|serverSocketErrorString
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|false
return|;
block|}
name|d
operator|->
name|socketEngine
operator|->
name|setReceiver
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|socketEngine
operator|->
name|setReadNotificationEnabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|d
operator|->
name|state
operator|=
name|d
operator|->
name|socketEngine
operator|->
name|state
argument_list|()
expr_stmt|;
name|d
operator|->
name|address
operator|=
name|d
operator|->
name|socketEngine
operator|->
name|localAddress
argument_list|()
expr_stmt|;
name|d
operator|->
name|port
operator|=
name|d
operator|->
name|socketEngine
operator|->
name|localPort
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QTCPSERVER_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QTcpServer::setSocketDescriptor(%i) succeeded."
argument_list|,
name|socketDescriptor
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the server's port if the server is listening for     connections; otherwise returns 0.      \sa serverAddress(), listen() */
end_comment
begin_function
DECL|function|serverPort
name|quint16
name|QTcpServer
operator|::
name|serverPort
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTcpServer
argument_list|)
expr_stmt|;
name|Q_CHECK_SOCKETENGINE
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|socketEngine
operator|->
name|localPort
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the server's address if the server is listening for     connections; otherwise returns QHostAddress::Null.      \sa serverPort(), listen() */
end_comment
begin_function
DECL|function|serverAddress
name|QHostAddress
name|QTcpServer
operator|::
name|serverAddress
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTcpServer
argument_list|)
expr_stmt|;
name|Q_CHECK_SOCKETENGINE
argument_list|(
name|QHostAddress
argument_list|(
name|QHostAddress
operator|::
name|Null
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|socketEngine
operator|->
name|localAddress
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Waits for at most \a msec milliseconds or until an incoming     connection is available. Returns \c true if a connection is     available; otherwise returns \c false. If the operation timed out     and \a timedOut is not 0, *\a timedOut will be set to true.      This is a blocking function call. Its use is disadvised in a     single-threaded GUI application, since the whole application will     stop responding until the function returns.     waitForNewConnection() is mostly useful when there is no event     loop available.      The non-blocking alternative is to connect to the newConnection()     signal.      If msec is -1, this function will not time out.      \sa hasPendingConnections(), nextPendingConnection() */
end_comment
begin_function
DECL|function|waitForNewConnection
name|bool
name|QTcpServer
operator|::
name|waitForNewConnection
parameter_list|(
name|int
name|msec
parameter_list|,
name|bool
modifier|*
name|timedOut
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTcpServer
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|state
operator|!=
name|QAbstractSocket
operator|::
name|ListeningState
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|!
name|d
operator|->
name|socketEngine
operator|->
name|waitForRead
argument_list|(
name|msec
argument_list|,
name|timedOut
argument_list|)
condition|)
block|{
name|d
operator|->
name|serverSocketError
operator|=
name|d
operator|->
name|socketEngine
operator|->
name|error
argument_list|()
expr_stmt|;
name|d
operator|->
name|serverSocketErrorString
operator|=
name|d
operator|->
name|socketEngine
operator|->
name|errorString
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|timedOut
operator|&&
operator|*
name|timedOut
condition|)
return|return
literal|false
return|;
name|d
operator|->
name|readNotification
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     Returns \c true if the server has a pending connection; otherwise     returns \c false.      \sa nextPendingConnection(), setMaxPendingConnections() */
end_comment
begin_function
DECL|function|hasPendingConnections
name|bool
name|QTcpServer
operator|::
name|hasPendingConnections
parameter_list|()
specifier|const
block|{
return|return
operator|!
name|d_func
argument_list|()
operator|->
name|pendingConnections
operator|.
name|isEmpty
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the next pending connection as a connected QTcpSocket     object.      The socket is created as a child of the server, which means that     it is automatically deleted when the QTcpServer object is     destroyed. It is still a good idea to delete the object     explicitly when you are done with it, to avoid wasting memory.      0 is returned if this function is called when there are no pending     connections.      \note The returned QTcpSocket object cannot be used from another     thread. If you want to use an incoming connection from another thread,     you need to override incomingConnection().      \sa hasPendingConnections() */
end_comment
begin_function
DECL|function|nextPendingConnection
name|QTcpSocket
modifier|*
name|QTcpServer
operator|::
name|nextPendingConnection
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QTcpServer
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|pendingConnections
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|d
operator|->
name|socketEngine
operator|->
name|isReadNotificationEnabled
argument_list|()
condition|)
name|d
operator|->
name|socketEngine
operator|->
name|setReadNotificationEnabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|pendingConnections
operator|.
name|takeFirst
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     This virtual function is called by QTcpServer when a new     connection is available. The \a socketDescriptor argument is the     native socket descriptor for the accepted connection.      The base implementation creates a QTcpSocket, sets the socket     descriptor and then stores the QTcpSocket in an internal list of     pending connections. Finally newConnection() is emitted.      Reimplement this function to alter the server's behavior when a     connection is available.      If this server is using QNetworkProxy then the \a socketDescriptor     may not be usable with native socket functions, and should only be     used with QTcpSocket::setSocketDescriptor().      \note If you want to handle an incoming connection as a new QTcpSocket     object in another thread you have to pass the socketDescriptor     to the other thread and create the QTcpSocket object there and     use its setSocketDescriptor() method.      \sa newConnection(), nextPendingConnection(), addPendingConnection() */
end_comment
begin_function
DECL|function|incomingConnection
name|void
name|QTcpServer
operator|::
name|incomingConnection
parameter_list|(
name|qintptr
name|socketDescriptor
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|QTCPSERVER_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QTcpServer::incomingConnection(%i)"
argument_list|,
name|socketDescriptor
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|QTcpSocket
modifier|*
name|socket
init|=
operator|new
name|QTcpSocket
argument_list|(
name|this
argument_list|)
decl_stmt|;
name|socket
operator|->
name|setSocketDescriptor
argument_list|(
name|socketDescriptor
argument_list|)
expr_stmt|;
name|addPendingConnection
argument_list|(
name|socket
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     This function is called by QTcpServer::incomingConnection()     to add the \a socket to the list of pending incoming connections.      \note Don't forget to call this member from reimplemented     incomingConnection() if you do not want to break the     Pending Connections mechanism.      \sa incomingConnection()     \since 4.7 */
end_comment
begin_function
DECL|function|addPendingConnection
name|void
name|QTcpServer
operator|::
name|addPendingConnection
parameter_list|(
name|QTcpSocket
modifier|*
name|socket
parameter_list|)
block|{
name|d_func
argument_list|()
operator|->
name|pendingConnections
operator|.
name|append
argument_list|(
name|socket
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the maximum number of pending accepted connections to \a     numConnections. QTcpServer will accept no more than \a     numConnections incoming connections before     nextPendingConnection() is called. By default, the limit is 30     pending connections.      Clients may still able to connect after the server has reached     its maximum number of pending connections (i.e., QTcpSocket can     still emit the connected() signal). QTcpServer will stop     accepting the new connections, but the operating system may     still keep them in queue.      \sa maxPendingConnections(), hasPendingConnections() */
end_comment
begin_function
DECL|function|setMaxPendingConnections
name|void
name|QTcpServer
operator|::
name|setMaxPendingConnections
parameter_list|(
name|int
name|numConnections
parameter_list|)
block|{
name|d_func
argument_list|()
operator|->
name|maxConnections
operator|=
name|numConnections
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the maximum number of pending accepted connections. The     default is 30.      \sa setMaxPendingConnections(), hasPendingConnections() */
end_comment
begin_function
DECL|function|maxPendingConnections
name|int
name|QTcpServer
operator|::
name|maxPendingConnections
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|maxConnections
return|;
block|}
end_function
begin_comment
comment|/*!     Returns an error code for the last error that occurred.      \sa errorString() */
end_comment
begin_function
DECL|function|serverError
name|QAbstractSocket
operator|::
name|SocketError
name|QTcpServer
operator|::
name|serverError
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|serverSocketError
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a human readable description of the last error that     occurred.      \sa serverError() */
end_comment
begin_function
DECL|function|errorString
name|QString
name|QTcpServer
operator|::
name|errorString
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|serverSocketErrorString
return|;
block|}
end_function
begin_comment
comment|/*!     \since 5.0      Pauses accepting new connections. Queued connections will remain in queue.      \sa resumeAccepting() */
end_comment
begin_function
DECL|function|pauseAccepting
name|void
name|QTcpServer
operator|::
name|pauseAccepting
parameter_list|()
block|{
name|d_func
argument_list|()
operator|->
name|socketEngine
operator|->
name|setReadNotificationEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 5.0      Resumes accepting new connections.      \sa pauseAccepting() */
end_comment
begin_function
DECL|function|resumeAccepting
name|void
name|QTcpServer
operator|::
name|resumeAccepting
parameter_list|()
block|{
name|d_func
argument_list|()
operator|->
name|socketEngine
operator|->
name|setReadNotificationEnabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
end_ifndef
begin_comment
comment|/*!     \since 4.1      Sets the explicit network proxy for this socket to \a networkProxy.      To disable the use of a proxy for this socket, use the     QNetworkProxy::NoProxy proxy type:      \snippet code/src_network_socket_qtcpserver.cpp 0      \sa proxy(), QNetworkProxy */
end_comment
begin_function
DECL|function|setProxy
name|void
name|QTcpServer
operator|::
name|setProxy
parameter_list|(
specifier|const
name|QNetworkProxy
modifier|&
name|networkProxy
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QTcpServer
argument_list|)
expr_stmt|;
name|d
operator|->
name|proxy
operator|=
name|networkProxy
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.1      Returns the network proxy for this socket.     By default QNetworkProxy::DefaultProxy is used.      \sa setProxy(), QNetworkProxy */
end_comment
begin_function
DECL|function|proxy
name|QNetworkProxy
name|QTcpServer
operator|::
name|proxy
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QTcpServer
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|proxy
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_NETWORKPROXY
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_include
include|#
directive|include
file|"moc_qtcpserver.cpp"
end_include
end_unit
