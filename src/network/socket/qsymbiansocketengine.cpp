begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the QtNetwork module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** No Commercial Usage ** This file contains pre-release code and may not be distributed. ** You may use this file in accordance with the terms and conditions ** contained in the Technology Preview License Agreement accompanying ** this package. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights.  These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** If you have questions regarding the use of this file, please contact ** Nokia at qt-info@nokia.com. ** ** ** ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_comment
comment|//#define QNATIVESOCKETENGINE_DEBUG
end_comment
begin_include
include|#
directive|include
file|"qsymbiansocketengine_p.h"
end_include
begin_include
include|#
directive|include
file|"qiodevice.h"
end_include
begin_include
include|#
directive|include
file|"qhostaddress.h"
end_include
begin_include
include|#
directive|include
file|"qelapsedtimer.h"
end_include
begin_include
include|#
directive|include
file|"qvarlengtharray.h"
end_include
begin_include
include|#
directive|include
file|"qnetworkinterface.h"
end_include
begin_include
include|#
directive|include
file|<private/qnetworksession_p.h>
end_include
begin_include
include|#
directive|include
file|<es_sock.h>
end_include
begin_include
include|#
directive|include
file|<in_sock.h>
end_include
begin_include
include|#
directive|include
file|<net/if.h>
end_include
begin_include
include|#
directive|include
file|<private/qcore_symbian_p.h>
end_include
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_NETWORKPROXY
argument_list|)
end_if
begin_include
include|#
directive|include
file|"qnetworkproxy.h"
end_include
begin_include
include|#
directive|include
file|"qabstractsocket.h"
end_include
begin_include
include|#
directive|include
file|"qtcpserver.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<QCoreApplication>
end_include
begin_include
include|#
directive|include
file|<qabstracteventdispatcher.h>
end_include
begin_include
include|#
directive|include
file|<private/qeventdispatcher_symbian_p.h>
end_include
begin_include
include|#
directive|include
file|<qsocketnotifier.h>
end_include
begin_include
include|#
directive|include
file|<qnetworkinterface.h>
end_include
begin_include
include|#
directive|include
file|<private/qthread_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qobject_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qsystemerror_p.h>
end_include
begin_if
if|#
directive|if
name|defined
name|QNATIVESOCKETENGINE_DEBUG
end_if
begin_include
include|#
directive|include
file|<qstring.h>
end_include
begin_include
include|#
directive|include
file|<ctype.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_function
name|QT_BEGIN_NAMESPACE
DECL|macro|Q_VOID
define|#
directive|define
name|Q_VOID
comment|// Common constructs
DECL|macro|Q_CHECK_VALID_SOCKETLAYER
define|#
directive|define
name|Q_CHECK_VALID_SOCKETLAYER
parameter_list|(
name|function
parameter_list|,
name|returnValue
parameter_list|)
value|do { \     if (!isValid()) { \         qWarning(""#function" was called on an uninitialized socket device"); \         return returnValue; \     } } while (0)
DECL|macro|Q_CHECK_INVALID_SOCKETLAYER
define|#
directive|define
name|Q_CHECK_INVALID_SOCKETLAYER
parameter_list|(
name|function
parameter_list|,
name|returnValue
parameter_list|)
value|do { \     if (isValid()) { \         qWarning(""#function" was called on an already initialized socket device"); \         return returnValue; \     } } while (0)
DECL|macro|Q_CHECK_STATE
define|#
directive|define
name|Q_CHECK_STATE
parameter_list|(
name|function
parameter_list|,
name|checkState
parameter_list|,
name|returnValue
parameter_list|)
value|do { \     if (d->socketState != (checkState)) { \         qWarning(""#function" was not called in "#checkState); \         return (returnValue); \     } } while (0)
DECL|macro|Q_CHECK_NOT_STATE
define|#
directive|define
name|Q_CHECK_NOT_STATE
parameter_list|(
name|function
parameter_list|,
name|checkState
parameter_list|,
name|returnValue
parameter_list|)
value|do { \     if (d->socketState == (checkState)) { \         qWarning(""#function" was called in "#checkState); \         return (returnValue); \     } } while (0)
DECL|macro|Q_CHECK_STATES
define|#
directive|define
name|Q_CHECK_STATES
parameter_list|(
name|function
parameter_list|,
name|state1
parameter_list|,
name|state2
parameter_list|,
name|returnValue
parameter_list|)
value|do { \     if (d->socketState != (state1)&& d->socketState != (state2)) { \         qWarning(""#function" was called" \                  " not in "#state1" or "#state2); \         return (returnValue); \     } } while (0)
DECL|macro|Q_CHECK_TYPE
define|#
directive|define
name|Q_CHECK_TYPE
parameter_list|(
name|function
parameter_list|,
name|type
parameter_list|,
name|returnValue
parameter_list|)
value|do { \     if (d->socketType != (type)) { \         qWarning(#function" was called by a" \                  " socket other than "#type""); \         return (returnValue); \     } } while (0)
if|#
directive|if
name|defined
name|QNATIVESOCKETENGINE_DEBUG
comment|/*     Returns a human readable representation of the first \a len     characters in \a data. */
DECL|function|qt_prettyDebug
specifier|static
name|QByteArray
name|qt_prettyDebug
parameter_list|(
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|maxSize
parameter_list|)
block|{
if|if
condition|(
operator|!
name|data
condition|)
return|return
literal|"(null)"
return|;
name|QByteArray
name|out
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
name|char
name|c
init|=
name|data
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|isprint
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|out
operator|+=
name|c
expr_stmt|;
block|}
else|else
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
name|out
operator|+=
literal|"\\n"
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|out
operator|+=
literal|"\\r"
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|out
operator|+=
literal|"\\t"
expr_stmt|;
break|break;
default|default:
name|QString
name|tmp
decl_stmt|;
name|tmp
operator|.
name|sprintf
argument_list|(
literal|"\\%o"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|out
operator|+=
name|tmp
operator|.
name|toLatin1
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|len
operator|<
name|maxSize
condition|)
name|out
operator|+=
literal|"..."
expr_stmt|;
return|return
name|out
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|getPortAndAddress
name|void
name|QSymbianSocketEnginePrivate
operator|::
name|getPortAndAddress
parameter_list|(
specifier|const
name|TInetAddr
modifier|&
name|a
parameter_list|,
name|quint16
modifier|*
name|port
parameter_list|,
name|QHostAddress
modifier|*
name|addr
parameter_list|)
block|{
if|if
condition|(
name|a
operator|.
name|Family
argument_list|()
operator|==
name|KAfInet6
operator|&&
operator|!
name|a
operator|.
name|IsV4Compat
argument_list|()
operator|&&
operator|!
name|a
operator|.
name|IsV4Mapped
argument_list|()
condition|)
block|{
name|Q_IPV6ADDR
name|tmp
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|tmp
argument_list|,
name|a
operator|.
name|Ip6Address
argument_list|()
operator|.
name|u
operator|.
name|iAddr8
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
condition|)
block|{
name|QHostAddress
name|tmpAddress
decl_stmt|;
name|tmpAddress
operator|.
name|setAddress
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
operator|*
name|addr
operator|=
name|tmpAddress
expr_stmt|;
name|TPckgBuf
argument_list|<
name|TSoInetIfQuery
argument_list|>
name|query
decl_stmt|;
name|query
argument_list|()
operator|.
name|iSrcAddr
operator|=
name|a
expr_stmt|;
name|TInt
name|err
init|=
name|nativeSocket
operator|.
name|GetOpt
argument_list|(
name|KSoInetIfQueryBySrcAddr
argument_list|,
name|KSolInetIfQuery
argument_list|,
name|query
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
name|addr
operator|->
name|setScopeId
argument_list|(
name|qt_TDesC2QString
argument_list|(
name|query
argument_list|()
operator|.
name|iName
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|addr
operator|->
name|setScopeId
argument_list|(
name|QString
operator|::
name|number
argument_list|(
name|a
operator|.
name|Scope
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|port
condition|)
operator|*
name|port
operator|=
name|a
operator|.
name|Port
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|port
condition|)
operator|*
name|port
operator|=
name|a
operator|.
name|Port
argument_list|()
expr_stmt|;
if|if
condition|(
name|addr
condition|)
block|{
name|QHostAddress
name|tmpAddress
decl_stmt|;
name|tmpAddress
operator|.
name|setAddress
argument_list|(
name|a
operator|.
name|Address
argument_list|()
argument_list|)
expr_stmt|;
operator|*
name|addr
operator|=
name|tmpAddress
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*! \internal      Creates and returns a new socket descriptor of type \a socketType     and \a socketProtocol.  Returns -1 on failure. */
end_comment
begin_function
DECL|function|createNewSocket
name|bool
name|QSymbianSocketEnginePrivate
operator|::
name|createNewSocket
parameter_list|(
name|QAbstractSocket
operator|::
name|SocketType
name|socketType
parameter_list|,
name|QAbstractSocket
operator|::
name|NetworkLayerProtocol
name|socketProtocol
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QSymbianSocketEngine
argument_list|)
expr_stmt|;
name|TUint
name|family
init|=
name|KAfInet
decl_stmt|;
comment|// KAfInet6 is only used as an address family, not as a protocol family
name|TUint
name|type
init|=
operator|(
name|socketType
operator|==
name|QAbstractSocket
operator|::
name|UdpSocket
operator|)
condition|?
name|KSockDatagram
else|:
name|KSockStream
decl_stmt|;
name|TUint
name|protocol
init|=
operator|(
name|socketType
operator|==
name|QAbstractSocket
operator|::
name|UdpSocket
operator|)
condition|?
name|KProtocolInetUdp
else|:
name|KProtocolInetTcp
decl_stmt|;
comment|//Check if there is a user specified session
name|QVariant
name|v
argument_list|(
name|q
operator|->
name|property
argument_list|(
literal|"_q_networksession"
argument_list|)
argument_list|)
decl_stmt|;
name|TInt
name|err
decl_stmt|;
if|if
condition|(
name|v
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|QSharedPointer
argument_list|<
name|QNetworkSession
argument_list|>
name|s
init|=
name|qvariant_cast
argument_list|<
name|QSharedPointer
argument_list|<
name|QNetworkSession
argument_list|>
argument_list|>
argument_list|(
name|v
argument_list|)
decl_stmt|;
name|err
operator|=
name|QNetworkSessionPrivate
operator|::
name|nativeOpenSocket
argument_list|(
operator|*
name|s
argument_list|,
name|nativeSocket
argument_list|,
name|family
argument_list|,
name|type
argument_list|,
name|protocol
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QNATIVESOCKETENGINE_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QSymbianSocketEnginePrivate::createNewSocket - _q_networksession was set"
operator|<<
name|err
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|err
operator|=
name|nativeSocket
operator|.
name|Open
argument_list|(
name|socketServer
argument_list|,
name|family
argument_list|,
name|type
argument_list|,
name|protocol
argument_list|)
expr_stmt|;
comment|//TODO: FIXME - deprecated API, make sure we always have a connection instead
if|if
condition|(
name|err
operator|!=
name|KErrNone
condition|)
block|{
switch|switch
condition|(
name|err
condition|)
block|{
case|case
name|KErrNotSupported
case|:
case|case
name|KErrNotFound
case|:
name|setError
argument_list|(
name|QAbstractSocket
operator|::
name|UnsupportedSocketOperationError
argument_list|,
name|ProtocolUnsupportedErrorString
argument_list|)
expr_stmt|;
break|break;
default|default:
name|setError
argument_list|(
name|err
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|false
return|;
block|}
ifdef|#
directive|ifdef
name|QNATIVESOCKETENGINE_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QSymbianSocketEnginePrivate::createNewSocket - created"
operator|<<
name|nativeSocket
operator|.
name|SubSessionHandle
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|socketDescriptor
operator|=
name|QSymbianSocketManager
operator|::
name|instance
argument_list|()
operator|.
name|addSocket
argument_list|(
name|nativeSocket
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QNATIVESOCKETENGINE_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|" - allocated socket descriptor"
operator|<<
name|socketDescriptor
expr_stmt|;
endif|#
directive|endif
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|setPortAndAddress
name|void
name|QSymbianSocketEnginePrivate
operator|::
name|setPortAndAddress
parameter_list|(
name|TInetAddr
modifier|&
name|nativeAddr
parameter_list|,
name|quint16
name|port
parameter_list|,
specifier|const
name|QHostAddress
modifier|&
name|addr
parameter_list|)
block|{
name|nativeAddr
operator|.
name|SetPort
argument_list|(
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|.
name|protocol
argument_list|()
operator|==
name|QAbstractSocket
operator|::
name|IPv6Protocol
condition|)
block|{
name|TPckgBuf
argument_list|<
name|TSoInetIfQuery
argument_list|>
name|query
decl_stmt|;
name|query
argument_list|()
operator|.
name|iName
operator|=
name|qt_QString2TPtrC
argument_list|(
name|addr
operator|.
name|scopeId
argument_list|()
argument_list|)
expr_stmt|;
name|TInt
name|err
init|=
name|nativeSocket
operator|.
name|GetOpt
argument_list|(
name|KSoInetIfQueryByName
argument_list|,
name|KSolInetIfQuery
argument_list|,
name|query
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
name|nativeAddr
operator|.
name|SetScope
argument_list|(
name|query
argument_list|()
operator|.
name|iIndex
argument_list|)
expr_stmt|;
else|else
name|nativeAddr
operator|.
name|SetScope
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|Q_IPV6ADDR
name|ip6
init|=
name|addr
operator|.
name|toIPv6Address
argument_list|()
decl_stmt|;
name|TIp6Addr
name|v6addr
decl_stmt|;
name|memcpy
argument_list|(
name|v6addr
operator|.
name|u
operator|.
name|iAddr8
argument_list|,
name|ip6
operator|.
name|c
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|nativeAddr
operator|.
name|SetAddress
argument_list|(
name|v6addr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|addr
operator|.
name|protocol
argument_list|()
operator|==
name|QAbstractSocket
operator|::
name|IPv4Protocol
condition|)
block|{
name|nativeAddr
operator|.
name|SetAddress
argument_list|(
name|addr
operator|.
name|toIPv4Address
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|qWarning
argument_list|(
literal|"unsupported network protocol (%d)"
argument_list|,
name|addr
operator|.
name|protocol
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_constructor
DECL|function|QSymbianSocketEnginePrivate
name|QSymbianSocketEnginePrivate
operator|::
name|QSymbianSocketEnginePrivate
parameter_list|()
member_init_list|:
name|socketDescriptor
argument_list|(
operator|-
literal|1
argument_list|)
member_init_list|,
name|socketServer
argument_list|(
name|QSymbianSocketManager
operator|::
name|instance
argument_list|()
operator|.
name|getSocketServer
argument_list|()
argument_list|)
member_init_list|,
name|readNotificationsEnabled
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|writeNotificationsEnabled
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|exceptNotificationsEnabled
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|asyncSelect
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|hasReceivedBufferedDatagram
argument_list|(
literal|false
argument_list|)
block|{ }
end_constructor
begin_destructor
DECL|function|~QSymbianSocketEnginePrivate
name|QSymbianSocketEnginePrivate
operator|::
name|~
name|QSymbianSocketEnginePrivate
parameter_list|()
block|{ }
end_destructor
begin_constructor
DECL|function|QSymbianSocketEngine
name|QSymbianSocketEngine
operator|::
name|QSymbianSocketEngine
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QAbstractSocketEngine
argument_list|(
operator|*
operator|new
name|QSymbianSocketEnginePrivate
argument_list|()
argument_list|,
name|parent
argument_list|)
block|{ }
end_constructor
begin_destructor
DECL|function|~QSymbianSocketEngine
name|QSymbianSocketEngine
operator|::
name|~
name|QSymbianSocketEngine
parameter_list|()
block|{
name|close
argument_list|()
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     Initializes a QSymbianSocketEngine by creating a new socket of type \a     socketType and network layer protocol \a protocol. Returns true on     success; otherwise returns false.      If the socket was already initialized, this function closes the     socket before reeinitializing it.      The new socket is non-blocking, and for UDP sockets it's also     broadcast enabled. */
end_comment
begin_function
DECL|function|initialize
name|bool
name|QSymbianSocketEngine
operator|::
name|initialize
parameter_list|(
name|QAbstractSocket
operator|::
name|SocketType
name|socketType
parameter_list|,
name|QAbstractSocket
operator|::
name|NetworkLayerProtocol
name|protocol
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSymbianSocketEngine
argument_list|)
expr_stmt|;
if|if
condition|(
name|isValid
argument_list|()
condition|)
name|close
argument_list|()
expr_stmt|;
comment|// Create the socket
if|if
condition|(
operator|!
name|d
operator|->
name|createNewSocket
argument_list|(
name|socketType
argument_list|,
name|protocol
argument_list|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|QNATIVESOCKETENGINE_DEBUG
argument_list|)
name|QString
name|typeStr
init|=
name|QLatin1String
argument_list|(
literal|"UnknownSocketType"
argument_list|)
decl_stmt|;
if|if
condition|(
name|socketType
operator|==
name|QAbstractSocket
operator|::
name|TcpSocket
condition|)
name|typeStr
operator|=
name|QLatin1String
argument_list|(
literal|"TcpSocket"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|socketType
operator|==
name|QAbstractSocket
operator|::
name|UdpSocket
condition|)
name|typeStr
operator|=
name|QLatin1String
argument_list|(
literal|"UdpSocket"
argument_list|)
expr_stmt|;
name|QString
name|protocolStr
init|=
name|QLatin1String
argument_list|(
literal|"UnknownProtocol"
argument_list|)
decl_stmt|;
if|if
condition|(
name|protocol
operator|==
name|QAbstractSocket
operator|::
name|IPv4Protocol
condition|)
name|protocolStr
operator|=
name|QLatin1String
argument_list|(
literal|"IPv4Protocol"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|protocol
operator|==
name|QAbstractSocket
operator|::
name|IPv6Protocol
condition|)
name|protocolStr
operator|=
name|QLatin1String
argument_list|(
literal|"IPv6Protocol"
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"QSymbianSocketEngine::initialize(type == %s, protocol == %s) failed: %s"
argument_list|,
name|typeStr
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|protocolStr
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|d
operator|->
name|socketErrorString
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|false
return|;
block|}
comment|// Make the socket nonblocking.
if|if
condition|(
operator|!
name|setOption
argument_list|(
name|NonBlockingSocketOption
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|d
operator|->
name|setError
argument_list|(
name|QAbstractSocket
operator|::
name|UnsupportedSocketOperationError
argument_list|,
name|d
operator|->
name|NonBlockingInitFailedErrorString
argument_list|)
expr_stmt|;
name|close
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// Set the broadcasting flag if it's a UDP socket.
if|if
condition|(
name|socketType
operator|==
name|QAbstractSocket
operator|::
name|UdpSocket
operator|&&
operator|!
name|setOption
argument_list|(
name|BroadcastSocketOption
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|d
operator|->
name|setError
argument_list|(
name|QAbstractSocket
operator|::
name|UnsupportedSocketOperationError
argument_list|,
name|d
operator|->
name|BroadcastingInitFailedErrorString
argument_list|)
expr_stmt|;
name|close
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// Make sure we receive out-of-band data
if|if
condition|(
name|socketType
operator|==
name|QAbstractSocket
operator|::
name|TcpSocket
operator|&&
operator|!
name|setOption
argument_list|(
name|ReceiveOutOfBandData
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"QSymbianSocketEngine::initialize unable to inline out-of-band data"
argument_list|)
expr_stmt|;
block|}
name|d
operator|->
name|socketType
operator|=
name|socketType
expr_stmt|;
name|d
operator|->
name|socketProtocol
operator|=
name|protocol
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*! \overload      Initializes the socket using \a socketDescriptor instead of     creating a new one. The socket type and network layer protocol are     determined automatically. The socket's state is set to \a     socketState.      If the socket type is either TCP or UDP, it is made non-blocking.     UDP sockets are also broadcast enabled.  */
end_comment
begin_function
DECL|function|initialize
name|bool
name|QSymbianSocketEngine
operator|::
name|initialize
parameter_list|(
name|int
name|socketDescriptor
parameter_list|,
name|QAbstractSocket
operator|::
name|SocketState
name|socketState
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSymbianSocketEngine
argument_list|)
expr_stmt|;
if|if
condition|(
name|isValid
argument_list|()
condition|)
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|QSymbianSocketManager
operator|::
name|instance
argument_list|()
operator|.
name|lookupSocket
argument_list|(
name|socketDescriptor
argument_list|,
name|d
operator|->
name|nativeSocket
argument_list|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"QSymbianSocketEngine::initialize - socket descriptor not found"
argument_list|)
expr_stmt|;
name|d
operator|->
name|setError
argument_list|(
name|QAbstractSocket
operator|::
name|UnsupportedSocketOperationError
argument_list|,
name|QSymbianSocketEnginePrivate
operator|::
name|InvalidSocketErrorString
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
ifdef|#
directive|ifdef
name|QNATIVESOCKETENGINE_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QSymbianSocketEngine::initialize - attached to"
operator|<<
name|d
operator|->
name|nativeSocket
operator|.
name|SubSessionHandle
argument_list|()
operator|<<
name|socketDescriptor
expr_stmt|;
endif|#
directive|endif
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|socketDescriptor
operator|==
name|socketDescriptor
operator|||
name|d
operator|->
name|socketDescriptor
operator|==
operator|-
literal|1
argument_list|)
expr_stmt|;
name|d
operator|->
name|socketDescriptor
operator|=
name|socketDescriptor
expr_stmt|;
comment|// determine socket type and protocol
if|if
condition|(
operator|!
name|d
operator|->
name|fetchConnectionParameters
argument_list|()
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|QNATIVESOCKETENGINE_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QSymbianSocketEngine::initialize(socketDescriptor == %i) failed: %s"
argument_list|,
name|socketDescriptor
argument_list|,
name|d
operator|->
name|socketErrorString
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|socketDescriptor
operator|=
operator|-
literal|1
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|d
operator|->
name|socketType
operator|!=
name|QAbstractSocket
operator|::
name|UnknownSocketType
condition|)
block|{
comment|// Make the socket nonblocking.
if|if
condition|(
operator|!
name|setOption
argument_list|(
name|NonBlockingSocketOption
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|d
operator|->
name|setError
argument_list|(
name|QAbstractSocket
operator|::
name|UnsupportedSocketOperationError
argument_list|,
name|d
operator|->
name|NonBlockingInitFailedErrorString
argument_list|)
expr_stmt|;
name|close
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// Set the broadcasting flag if it's a UDP socket.
if|if
condition|(
name|d
operator|->
name|socketType
operator|==
name|QAbstractSocket
operator|::
name|UdpSocket
operator|&&
operator|!
name|setOption
argument_list|(
name|BroadcastSocketOption
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|d
operator|->
name|setError
argument_list|(
name|QAbstractSocket
operator|::
name|UnsupportedSocketOperationError
argument_list|,
name|d
operator|->
name|BroadcastingInitFailedErrorString
argument_list|)
expr_stmt|;
name|close
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
comment|// Make sure we receive out-of-band data
if|if
condition|(
name|d
operator|->
name|socketType
operator|==
name|QAbstractSocket
operator|::
name|TcpSocket
operator|&&
operator|!
name|setOption
argument_list|(
name|ReceiveOutOfBandData
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"QSymbianSocketEngine::initialize unable to inline out-of-band data"
argument_list|)
expr_stmt|;
block|}
block|}
name|d
operator|->
name|socketState
operator|=
name|socketState
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the socket is valid; otherwise returns false. A     socket is valid if it has not been successfully initialized, or if     it has been closed. */
end_comment
begin_function
DECL|function|isValid
name|bool
name|QSymbianSocketEngine
operator|::
name|isValid
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSymbianSocketEngine
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|socketDescriptor
operator|!=
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the native socket descriptor. Any use of this descriptor     stands the risk of being non-portable. */
end_comment
begin_function
DECL|function|socketDescriptor
name|int
name|QSymbianSocketEngine
operator|::
name|socketDescriptor
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSymbianSocketEngine
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|socketDescriptor
return|;
block|}
end_function
begin_comment
comment|/*     Sets the socket option \a opt to \a v. */
end_comment
begin_function
DECL|function|setOption
name|bool
name|QSymbianSocketEngine
operator|::
name|setOption
parameter_list|(
name|QAbstractSocketEngine
operator|::
name|SocketOption
name|opt
parameter_list|,
name|int
name|v
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSymbianSocketEngine
argument_list|)
expr_stmt|;
name|Q_CHECK_VALID_SOCKETLAYER
argument_list|(
name|QSymbianSocketEngine
operator|::
name|setOption
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|TUint
name|n
init|=
literal|0
decl_stmt|;
name|TUint
name|level
init|=
name|KSOLSocket
decl_stmt|;
comment|// default
if|if
condition|(
operator|!
name|QSymbianSocketEnginePrivate
operator|::
name|translateSocketOption
argument_list|(
name|opt
argument_list|,
name|n
argument_list|,
name|level
argument_list|)
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|!
name|level
operator|&&
operator|!
name|n
condition|)
return|return
literal|true
return|;
return|return
operator|(
name|KErrNone
operator|==
name|d
operator|->
name|nativeSocket
operator|.
name|SetOpt
argument_list|(
name|n
argument_list|,
name|level
argument_list|,
name|v
argument_list|)
operator|)
return|;
block|}
end_function
begin_comment
comment|/*     Returns the value of the socket option \a opt. */
end_comment
begin_function
DECL|function|option
name|int
name|QSymbianSocketEngine
operator|::
name|option
parameter_list|(
name|QAbstractSocketEngine
operator|::
name|SocketOption
name|opt
parameter_list|)
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSymbianSocketEngine
argument_list|)
expr_stmt|;
name|Q_CHECK_VALID_SOCKETLAYER
argument_list|(
name|QSymbianSocketEngine
operator|::
name|option
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|TUint
name|n
decl_stmt|;
name|TUint
name|level
init|=
name|KSOLSocket
decl_stmt|;
comment|// default
if|if
condition|(
operator|!
name|QSymbianSocketEnginePrivate
operator|::
name|translateSocketOption
argument_list|(
name|opt
argument_list|,
name|n
argument_list|,
name|level
argument_list|)
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|!
name|level
operator|&&
operator|!
name|n
condition|)
return|return
literal|1
return|;
name|int
name|v
init|=
operator|-
literal|1
decl_stmt|;
comment|//GetOpt() is non const
name|TInt
name|err
init|=
name|d
operator|->
name|nativeSocket
operator|.
name|GetOpt
argument_list|(
name|n
argument_list|,
name|level
argument_list|,
name|v
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
return|return
name|v
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function
begin_function
DECL|function|translateSocketOption
name|bool
name|QSymbianSocketEnginePrivate
operator|::
name|translateSocketOption
parameter_list|(
name|QAbstractSocketEngine
operator|::
name|SocketOption
name|opt
parameter_list|,
name|TUint
modifier|&
name|n
parameter_list|,
name|TUint
modifier|&
name|level
parameter_list|)
block|{
switch|switch
condition|(
name|opt
condition|)
block|{
case|case
name|QAbstractSocketEngine
operator|::
name|ReceiveBufferSocketOption
case|:
name|n
operator|=
name|KSORecvBuf
expr_stmt|;
break|break;
case|case
name|QAbstractSocketEngine
operator|::
name|SendBufferSocketOption
case|:
name|n
operator|=
name|KSOSendBuf
expr_stmt|;
break|break;
case|case
name|QAbstractSocketEngine
operator|::
name|NonBlockingSocketOption
case|:
name|n
operator|=
name|KSONonBlockingIO
expr_stmt|;
break|break;
case|case
name|QAbstractSocketEngine
operator|::
name|AddressReusable
case|:
name|level
operator|=
name|KSolInetIp
expr_stmt|;
name|n
operator|=
name|KSoReuseAddr
expr_stmt|;
break|break;
case|case
name|QAbstractSocketEngine
operator|::
name|BroadcastSocketOption
case|:
case|case
name|QAbstractSocketEngine
operator|::
name|BindExclusively
case|:
name|level
operator|=
literal|0
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
return|return
literal|true
return|;
case|case
name|QAbstractSocketEngine
operator|::
name|ReceiveOutOfBandData
case|:
name|level
operator|=
name|KSolInetTcp
expr_stmt|;
name|n
operator|=
name|KSoTcpOobInline
expr_stmt|;
break|break;
case|case
name|QAbstractSocketEngine
operator|::
name|LowDelayOption
case|:
name|level
operator|=
name|KSolInetTcp
expr_stmt|;
name|n
operator|=
name|KSoTcpNoDelay
expr_stmt|;
break|break;
case|case
name|QAbstractSocketEngine
operator|::
name|KeepAliveOption
case|:
name|level
operator|=
name|KSolInetTcp
expr_stmt|;
name|n
operator|=
name|KSoTcpKeepAlive
expr_stmt|;
break|break;
case|case
name|QAbstractSocketEngine
operator|::
name|MulticastLoopbackOption
case|:
name|level
operator|=
name|KSolInetIp
expr_stmt|;
name|n
operator|=
name|KSoIp6MulticastLoop
expr_stmt|;
break|break;
case|case
name|QAbstractSocketEngine
operator|::
name|MulticastTtlOption
case|:
name|level
operator|=
name|KSolInetIp
expr_stmt|;
name|n
operator|=
name|KSoIp6MulticastHops
expr_stmt|;
break|break;
default|default:
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|receiveBufferSize
name|qint64
name|QSymbianSocketEngine
operator|::
name|receiveBufferSize
parameter_list|()
specifier|const
block|{
name|Q_CHECK_VALID_SOCKETLAYER
argument_list|(
name|QSymbianSocketEngine
operator|::
name|receiveBufferSize
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|option
argument_list|(
name|ReceiveBufferSocketOption
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|setReceiveBufferSize
name|void
name|QSymbianSocketEngine
operator|::
name|setReceiveBufferSize
parameter_list|(
name|qint64
name|size
parameter_list|)
block|{
name|Q_CHECK_VALID_SOCKETLAYER
argument_list|(
name|QSymbianSocketEngine
operator|::
name|setReceiveBufferSize
argument_list|()
argument_list|,
name|Q_VOID
argument_list|)
expr_stmt|;
name|setOption
argument_list|(
name|ReceiveBufferSocketOption
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|sendBufferSize
name|qint64
name|QSymbianSocketEngine
operator|::
name|sendBufferSize
parameter_list|()
specifier|const
block|{
name|Q_CHECK_VALID_SOCKETLAYER
argument_list|(
name|QSymbianSocketEngine
operator|::
name|setSendBufferSize
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|option
argument_list|(
name|SendBufferSocketOption
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|setSendBufferSize
name|void
name|QSymbianSocketEngine
operator|::
name|setSendBufferSize
parameter_list|(
name|qint64
name|size
parameter_list|)
block|{
name|Q_CHECK_VALID_SOCKETLAYER
argument_list|(
name|QSymbianSocketEngine
operator|::
name|setSendBufferSize
argument_list|()
argument_list|,
name|Q_VOID
argument_list|)
expr_stmt|;
name|setOption
argument_list|(
name|SendBufferSocketOption
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Connects to the remote host name given by \a name on port \a     port. When this function is called, the upper-level will not     perform a hostname lookup.      The native socket engine does not support this operation,     but some other socket engines (notably proxy-based ones) do. */
end_comment
begin_function
DECL|function|connectToHostByName
name|bool
name|QSymbianSocketEngine
operator|::
name|connectToHostByName
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|,
name|quint16
name|port
parameter_list|)
block|{
name|Q_UNUSED
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|Q_UNUSED
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|Q_D
argument_list|(
name|QSymbianSocketEngine
argument_list|)
expr_stmt|;
name|d
operator|->
name|setError
argument_list|(
name|QAbstractSocket
operator|::
name|UnsupportedSocketOperationError
argument_list|,
name|QSymbianSocketEnginePrivate
operator|::
name|OperationUnsupportedErrorString
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     If there's a connection activity on the socket, process it. Then     notify our parent if there really was activity. */
end_comment
begin_function
DECL|function|connectionNotification
name|void
name|QSymbianSocketEngine
operator|::
name|connectionNotification
parameter_list|()
block|{
comment|// FIXME check if we really need to do it like that in Symbian
name|Q_D
argument_list|(
name|QSymbianSocketEngine
argument_list|)
expr_stmt|;
name|Q_ASSERT
argument_list|(
name|state
argument_list|()
operator|==
name|QAbstractSocket
operator|::
name|ConnectingState
argument_list|)
expr_stmt|;
name|connectToHost
argument_list|(
name|d
operator|->
name|peerAddress
argument_list|,
name|d
operator|->
name|peerPort
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
argument_list|()
operator|!=
name|QAbstractSocket
operator|::
name|ConnectingState
condition|)
block|{
comment|// we changed states
name|QAbstractSocketEngine
operator|::
name|connectionNotification
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|connectToHost
name|bool
name|QSymbianSocketEngine
operator|::
name|connectToHost
parameter_list|(
specifier|const
name|QHostAddress
modifier|&
name|addr
parameter_list|,
name|quint16
name|port
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSymbianSocketEngine
argument_list|)
expr_stmt|;
name|Q_CHECK_VALID_SOCKETLAYER
argument_list|(
name|QSymbianSocketEngine
operator|::
name|connectToHost
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QNATIVESOCKETENGINE_DEBUG
name|qDebug
argument_list|(
literal|"QSymbianSocketEngine::connectToHost() : %d "
argument_list|,
name|d
operator|->
name|socketDescriptor
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|d
operator|->
name|checkProxy
argument_list|(
name|addr
argument_list|)
condition|)
return|return
literal|false
return|;
name|d
operator|->
name|peerAddress
operator|=
name|addr
expr_stmt|;
name|d
operator|->
name|peerPort
operator|=
name|port
expr_stmt|;
name|TInetAddr
name|nativeAddr
decl_stmt|;
name|d
operator|->
name|setPortAndAddress
argument_list|(
name|nativeAddr
argument_list|,
name|port
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|TRequestStatus
name|status
decl_stmt|;
name|d
operator|->
name|nativeSocket
operator|.
name|Connect
argument_list|(
name|nativeAddr
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|User
operator|::
name|WaitForRequest
argument_list|(
name|status
argument_list|)
expr_stmt|;
name|TInt
name|err
init|=
name|status
operator|.
name|Int
argument_list|()
decl_stmt|;
comment|//For non blocking connect, KErrAlreadyExists is returned from the second Connect() to indicate
comment|//the connection is up. So treat this the same as KErrNone which would be returned from the first
comment|//call if it wouldn't block. (e.g. winsock wrapper in the emulator ignores the nonblocking flag)
if|if
condition|(
name|err
operator|&&
name|err
operator|!=
name|KErrAlreadyExists
condition|)
block|{
switch|switch
condition|(
name|err
condition|)
block|{
case|case
name|KErrWouldBlock
case|:
name|d
operator|->
name|socketState
operator|=
name|QAbstractSocket
operator|::
name|ConnectingState
expr_stmt|;
break|break;
default|default:
name|d
operator|->
name|setError
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|d
operator|->
name|socketState
operator|=
name|QAbstractSocket
operator|::
name|UnconnectedState
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|d
operator|->
name|socketState
operator|!=
name|QAbstractSocket
operator|::
name|ConnectedState
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|QNATIVESOCKETENGINE_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QSymbianSocketEngine::connectToHost(%s, %i) == false (%s)"
argument_list|,
name|addr
operator|.
name|toString
argument_list|()
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|port
argument_list|,
name|d
operator|->
name|socketState
operator|==
name|QAbstractSocket
operator|::
name|ConnectingState
condition|?
literal|"Connection in progress"
else|:
name|d
operator|->
name|socketErrorString
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|false
return|;
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|QNATIVESOCKETENGINE_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QSymbianSocketEngine::Connect(%s, %i) == true"
argument_list|,
name|addr
operator|.
name|toString
argument_list|()
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|port
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|socketState
operator|=
name|QAbstractSocket
operator|::
name|ConnectedState
expr_stmt|;
name|d
operator|->
name|fetchConnectionParameters
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|bind
name|bool
name|QSymbianSocketEngine
operator|::
name|bind
parameter_list|(
specifier|const
name|QHostAddress
modifier|&
name|address
parameter_list|,
name|quint16
name|port
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSymbianSocketEngine
argument_list|)
expr_stmt|;
name|Q_CHECK_VALID_SOCKETLAYER
argument_list|(
name|QSymbianSocketEngine
operator|::
name|bind
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|checkProxy
argument_list|(
name|address
argument_list|)
condition|)
return|return
literal|false
return|;
name|Q_CHECK_STATE
argument_list|(
name|QSymbianSocketEngine
operator|::
name|bind
argument_list|()
argument_list|,
name|QAbstractSocket
operator|::
name|UnconnectedState
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|TInetAddr
name|nativeAddr
decl_stmt|;
if|if
condition|(
name|address
operator|==
name|QHostAddress
operator|::
name|Any
operator|||
name|address
operator|==
name|QHostAddress
operator|::
name|AnyIPv6
condition|)
block|{
comment|//Should allow both IPv4 and IPv6
comment|//Listening on "0.0.0.0" accepts ONLY ipv4 connections
comment|//Listening on "::" accepts ONLY ipv6 connections
name|nativeAddr
operator|.
name|SetFamily
argument_list|(
name|KAFUnspec
argument_list|)
expr_stmt|;
name|nativeAddr
operator|.
name|SetPort
argument_list|(
name|port
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|setPortAndAddress
argument_list|(
name|nativeAddr
argument_list|,
name|port
argument_list|,
name|address
argument_list|)
expr_stmt|;
block|}
name|TInt
name|err
init|=
name|d
operator|->
name|nativeSocket
operator|.
name|Bind
argument_list|(
name|nativeAddr
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|__WINS__
if|if
condition|(
name|err
operator|==
name|KErrArgument
condition|)
comment|// winsock prt returns wrong error code
name|err
operator|=
name|KErrInUse
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|err
condition|)
block|{
switch|switch
condition|(
name|err
condition|)
block|{
case|case
name|KErrNotFound
case|:
comment|// the specified interface was not found - use the error code expected
name|d
operator|->
name|setError
argument_list|(
name|QAbstractSocket
operator|::
name|SocketAddressNotAvailableError
argument_list|,
name|QSymbianSocketEnginePrivate
operator|::
name|AddressNotAvailableErrorString
argument_list|)
expr_stmt|;
break|break;
default|default:
name|d
operator|->
name|setError
argument_list|(
name|err
argument_list|)
expr_stmt|;
break|break;
block|}
if|#
directive|if
name|defined
argument_list|(
name|QNATIVESOCKETENGINE_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QSymbianSocketEngine::bind(%s, %i) == false (%s)"
argument_list|,
name|address
operator|.
name|toString
argument_list|()
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|port
argument_list|,
name|d
operator|->
name|socketErrorString
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|false
return|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|QNATIVESOCKETENGINE_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QSymbianSocketEngine::bind(%s, %i) == true"
argument_list|,
name|address
operator|.
name|toString
argument_list|()
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|port
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|socketState
operator|=
name|QAbstractSocket
operator|::
name|BoundState
expr_stmt|;
name|d
operator|->
name|fetchConnectionParameters
argument_list|()
expr_stmt|;
comment|// When we bind to unspecified address (to get a dual mode socket), report back the
comment|// same type of address that was requested. This is required for SOCKS proxy to work.
if|if
condition|(
name|nativeAddr
operator|.
name|Family
argument_list|()
operator|==
name|KAFUnspec
condition|)
name|d
operator|->
name|localAddress
operator|=
name|address
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|listen
name|bool
name|QSymbianSocketEngine
operator|::
name|listen
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QSymbianSocketEngine
argument_list|)
expr_stmt|;
name|Q_CHECK_VALID_SOCKETLAYER
argument_list|(
name|QSymbianSocketEngine
operator|::
name|listen
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|Q_CHECK_STATE
argument_list|(
name|QSymbianSocketEngine
operator|::
name|listen
argument_list|()
argument_list|,
name|QAbstractSocket
operator|::
name|BoundState
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|Q_CHECK_TYPE
argument_list|(
name|QSymbianSocketEngine
operator|::
name|listen
argument_list|()
argument_list|,
name|QAbstractSocket
operator|::
name|TcpSocket
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|TInt
name|err
init|=
name|d
operator|->
name|nativeSocket
operator|.
name|Listen
argument_list|(
literal|50
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|d
operator|->
name|setError
argument_list|(
name|err
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QNATIVESOCKETENGINE_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QSymbianSocketEngine::listen() == false (%s)"
argument_list|,
name|d
operator|->
name|socketErrorString
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|false
return|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|QNATIVESOCKETENGINE_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QSymbianSocketEngine::listen() == true"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|socketState
operator|=
name|QAbstractSocket
operator|::
name|ListeningState
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|accept
name|int
name|QSymbianSocketEngine
operator|::
name|accept
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QSymbianSocketEngine
argument_list|)
expr_stmt|;
name|Q_CHECK_VALID_SOCKETLAYER
argument_list|(
name|QSymbianSocketEngine
operator|::
name|accept
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Q_CHECK_STATE
argument_list|(
name|QSymbianSocketEngine
operator|::
name|accept
argument_list|()
argument_list|,
name|QAbstractSocket
operator|::
name|ListeningState
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|Q_CHECK_TYPE
argument_list|(
name|QSymbianSocketEngine
operator|::
name|accept
argument_list|()
argument_list|,
name|QAbstractSocket
operator|::
name|TcpSocket
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|RSocket
name|blankSocket
decl_stmt|;
name|blankSocket
operator|.
name|Open
argument_list|(
name|d
operator|->
name|socketServer
argument_list|)
expr_stmt|;
name|TRequestStatus
name|status
decl_stmt|;
name|d
operator|->
name|nativeSocket
operator|.
name|Accept
argument_list|(
name|blankSocket
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|User
operator|::
name|WaitForRequest
argument_list|(
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|.
name|Int
argument_list|()
condition|)
block|{
name|blankSocket
operator|.
name|Close
argument_list|()
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|KErrWouldBlock
condition|)
name|qWarning
argument_list|(
literal|"QSymbianSocketEngine::accept() - error %d"
argument_list|,
name|status
operator|.
name|Int
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
ifdef|#
directive|ifdef
name|QNATIVESOCKETENGINE_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QSymbianSocketEnginePrivate::accept - created"
operator|<<
name|blankSocket
operator|.
name|SubSessionHandle
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|int
name|fd
init|=
name|QSymbianSocketManager
operator|::
name|instance
argument_list|()
operator|.
name|addSocket
argument_list|(
name|blankSocket
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|QNATIVESOCKETENGINE_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|" - allocated socket descriptor"
operator|<<
name|fd
expr_stmt|;
endif|#
directive|endif
return|return
name|fd
return|;
block|}
end_function
begin_function
DECL|function|bytesAvailable
name|qint64
name|QSymbianSocketEngine
operator|::
name|bytesAvailable
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSymbianSocketEngine
argument_list|)
expr_stmt|;
name|Q_CHECK_VALID_SOCKETLAYER
argument_list|(
name|QSymbianSocketEngine
operator|::
name|bytesAvailable
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Q_CHECK_NOT_STATE
argument_list|(
name|QSymbianSocketEngine
operator|::
name|bytesAvailable
argument_list|()
argument_list|,
name|QAbstractSocket
operator|::
name|UnconnectedState
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|int
name|nbytes
init|=
literal|0
decl_stmt|;
name|qint64
name|available
init|=
literal|0
decl_stmt|;
name|TInt
name|err
init|=
name|d
operator|->
name|nativeSocket
operator|.
name|GetOpt
argument_list|(
name|KSOReadBytesPending
argument_list|,
name|KSOLSocket
argument_list|,
name|nbytes
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
condition|)
return|return
literal|0
return|;
name|available
operator|=
operator|(
name|qint64
operator|)
name|nbytes
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QNATIVESOCKETENGINE_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QSymbianSocketEngine::bytesAvailable() == %lli"
argument_list|,
name|available
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|available
return|;
block|}
end_function
begin_function
DECL|function|hasPendingDatagrams
name|bool
name|QSymbianSocketEngine
operator|::
name|hasPendingDatagrams
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSymbianSocketEngine
argument_list|)
expr_stmt|;
name|Q_CHECK_VALID_SOCKETLAYER
argument_list|(
name|QSymbianSocketEngine
operator|::
name|hasPendingDatagrams
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|Q_CHECK_NOT_STATE
argument_list|(
name|QSymbianSocketEngine
operator|::
name|hasPendingDatagrams
argument_list|()
argument_list|,
name|QAbstractSocket
operator|::
name|UnconnectedState
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|Q_CHECK_TYPE
argument_list|(
name|QSymbianSocketEngine
operator|::
name|hasPendingDatagrams
argument_list|()
argument_list|,
name|QAbstractSocket
operator|::
name|UdpSocket
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|int
name|nbytes
decl_stmt|;
name|TInt
name|err
init|=
name|d
operator|->
name|nativeSocket
operator|.
name|GetOpt
argument_list|(
name|KSOReadBytesPending
argument_list|,
name|KSOLSocket
argument_list|,
name|nbytes
argument_list|)
decl_stmt|;
return|return
name|err
operator|==
name|KErrNone
operator|&&
name|nbytes
operator|>
literal|0
return|;
block|}
end_function
begin_function
DECL|function|pendingDatagramSize
name|qint64
name|QSymbianSocketEngine
operator|::
name|pendingDatagramSize
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSymbianSocketEngine
argument_list|)
expr_stmt|;
name|Q_CHECK_VALID_SOCKETLAYER
argument_list|(
name|QSymbianSocketEngine
operator|::
name|pendingDatagramSize
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|Q_CHECK_TYPE
argument_list|(
name|QSymbianSocketEngine
operator|::
name|hasPendingDatagrams
argument_list|()
argument_list|,
name|QAbstractSocket
operator|::
name|UdpSocket
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|//can only buffer one datagram at a time
if|if
condition|(
name|d
operator|->
name|hasReceivedBufferedDatagram
condition|)
return|return
name|d
operator|->
name|receivedDataBuffer
operator|.
name|size
argument_list|()
return|;
name|int
name|nbytes
init|=
literal|0
decl_stmt|;
name|TInt
name|err
init|=
name|d
operator|->
name|nativeSocket
operator|.
name|GetOpt
argument_list|(
name|KSOReadBytesPending
argument_list|,
name|KSOLSocket
argument_list|,
name|nbytes
argument_list|)
decl_stmt|;
if|if
condition|(
name|nbytes
operator|>
literal|0
condition|)
block|{
comment|//nbytes includes IP header, which is of variable length (IPv4 with or without options, IPv6...)
comment|//therefore read the datagram into a buffer to find its true size
name|d
operator|->
name|receivedDataBuffer
operator|.
name|resize
argument_list|(
name|nbytes
argument_list|)
expr_stmt|;
name|TPtr8
name|buffer
argument_list|(
operator|(
name|TUint8
operator|*
operator|)
name|d
operator|->
name|receivedDataBuffer
operator|.
name|data
argument_list|()
argument_list|,
name|nbytes
argument_list|)
decl_stmt|;
comment|//nbytes = size including IP header, buffer is a pointer descriptor backed by the receivedDataBuffer
name|TInetAddr
name|addr
decl_stmt|;
name|TRequestStatus
name|status
decl_stmt|;
comment|//RecvFrom copies only the payload (we don't want the header so don't specify the option to retrieve it)
name|d
operator|->
name|nativeSocket
operator|.
name|RecvFrom
argument_list|(
name|buffer
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|User
operator|::
name|WaitForRequest
argument_list|(
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|KErrNone
condition|)
block|{
name|d
operator|->
name|receivedDataBuffer
operator|.
name|clear
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
name|nbytes
operator|=
name|buffer
operator|.
name|Length
argument_list|()
expr_stmt|;
comment|//nbytes = size of payload, resize the receivedDataBuffer to the final size
name|d
operator|->
name|receivedDataBuffer
operator|.
name|resize
argument_list|(
name|nbytes
argument_list|)
expr_stmt|;
name|d
operator|->
name|hasReceivedBufferedDatagram
operator|=
literal|true
expr_stmt|;
comment|//now receivedDataBuffer contains one datagram, which has been removed from the socket's internal buffer
if|#
directive|if
name|defined
argument_list|(
name|QNATIVESOCKETENGINE_DEBUG
argument_list|)
name|qDebug
argument_list|()
operator|<<
literal|"QSymbianSocketEngine::pendingDatagramSize buffering"
operator|<<
name|nbytes
operator|<<
literal|"bytes"
expr_stmt|;
endif|#
directive|endif
block|}
return|return
name|qint64
argument_list|(
name|nbytes
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|readDatagram
name|qint64
name|QSymbianSocketEngine
operator|::
name|readDatagram
parameter_list|(
name|char
modifier|*
name|data
parameter_list|,
name|qint64
name|maxSize
parameter_list|,
name|QHostAddress
modifier|*
name|address
parameter_list|,
name|quint16
modifier|*
name|port
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSymbianSocketEngine
argument_list|)
expr_stmt|;
name|Q_CHECK_VALID_SOCKETLAYER
argument_list|(
name|QSymbianSocketEngine
operator|::
name|readDatagram
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Q_CHECK_TYPE
argument_list|(
name|QSymbianSocketEngine
operator|::
name|readDatagram
argument_list|()
argument_list|,
name|QAbstractSocket
operator|::
name|UdpSocket
argument_list|,
literal|false
argument_list|)
expr_stmt|;
comment|// if a datagram was buffered in pendingDatagramSize(), return it now
if|if
condition|(
name|d
operator|->
name|hasReceivedBufferedDatagram
condition|)
block|{
name|qint64
name|size
init|=
name|qMin
argument_list|(
name|maxSize
argument_list|,
operator|(
name|qint64
operator|)
name|d
operator|->
name|receivedDataBuffer
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|data
argument_list|,
name|d
operator|->
name|receivedDataBuffer
operator|.
name|constData
argument_list|()
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|d
operator|->
name|receivedDataBuffer
operator|.
name|clear
argument_list|()
expr_stmt|;
name|d
operator|->
name|hasReceivedBufferedDatagram
operator|=
literal|false
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QNATIVESOCKETENGINE_DEBUG
argument_list|)
name|qDebug
argument_list|()
operator|<<
literal|"QSymbianSocketEngine::readDatagram returning"
operator|<<
name|size
operator|<<
literal|"bytes from buffer"
expr_stmt|;
endif|#
directive|endif
return|return
name|size
return|;
block|}
name|TPtr8
name|buffer
argument_list|(
operator|(
name|TUint8
operator|*
operator|)
name|data
argument_list|,
operator|(
name|int
operator|)
name|maxSize
argument_list|)
decl_stmt|;
name|TInetAddr
name|addr
decl_stmt|;
name|TRequestStatus
name|status
decl_stmt|;
name|d
operator|->
name|nativeSocket
operator|.
name|RecvFrom
argument_list|(
name|buffer
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|User
operator|::
name|WaitForRequest
argument_list|(
name|status
argument_list|)
expr_stmt|;
comment|//Non blocking receive
if|if
condition|(
name|status
operator|.
name|Int
argument_list|()
condition|)
block|{
name|d
operator|->
name|setError
argument_list|(
name|QAbstractSocket
operator|::
name|NetworkError
argument_list|,
name|d
operator|->
name|ReceiveDatagramErrorString
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|port
operator|||
name|address
condition|)
block|{
name|d
operator|->
name|getPortAndAddress
argument_list|(
name|addr
argument_list|,
name|port
argument_list|,
name|address
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|QNATIVESOCKETENGINE_DEBUG
argument_list|)
name|int
name|len
init|=
name|buffer
operator|.
name|Length
argument_list|()
decl_stmt|;
name|qDebug
argument_list|(
literal|"QSymbianSocketEngine::receiveDatagram(%p \"%s\", %lli, %s, %i) == %lli"
argument_list|,
name|data
argument_list|,
name|qt_prettyDebug
argument_list|(
name|data
argument_list|,
name|qMin
argument_list|(
name|len
argument_list|,
name|ssize_t
argument_list|(
literal|16
argument_list|)
argument_list|)
argument_list|,
name|len
argument_list|)
operator|.
name|data
argument_list|()
argument_list|,
name|maxSize
argument_list|,
name|address
condition|?
name|address
operator|->
name|toString
argument_list|()
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
else|:
literal|"(nil)"
argument_list|,
name|port
condition|?
operator|*
name|port
else|:
literal|0
argument_list|,
operator|(
name|qint64
operator|)
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|status
operator|.
name|Int
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|qint64
argument_list|(
name|buffer
operator|.
name|Length
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|writeDatagram
name|qint64
name|QSymbianSocketEngine
operator|::
name|writeDatagram
parameter_list|(
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|qint64
name|len
parameter_list|,
specifier|const
name|QHostAddress
modifier|&
name|host
parameter_list|,
name|quint16
name|port
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSymbianSocketEngine
argument_list|)
expr_stmt|;
name|Q_CHECK_VALID_SOCKETLAYER
argument_list|(
name|QSymbianSocketEngine
operator|::
name|writeDatagram
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Q_CHECK_TYPE
argument_list|(
name|QSymbianSocketEngine
operator|::
name|writeDatagram
argument_list|()
argument_list|,
name|QAbstractSocket
operator|::
name|UdpSocket
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|TPtrC8
name|buffer
argument_list|(
operator|(
name|TUint8
operator|*
operator|)
name|data
argument_list|,
operator|(
name|int
operator|)
name|len
argument_list|)
decl_stmt|;
name|TInetAddr
name|addr
decl_stmt|;
name|d
operator|->
name|setPortAndAddress
argument_list|(
name|addr
argument_list|,
name|port
argument_list|,
name|host
argument_list|)
expr_stmt|;
name|TSockXfrLength
name|sentBytes
decl_stmt|;
name|TRequestStatus
name|status
decl_stmt|;
name|d
operator|->
name|nativeSocket
operator|.
name|SendTo
argument_list|(
name|buffer
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|,
name|status
argument_list|,
name|sentBytes
argument_list|)
expr_stmt|;
name|User
operator|::
name|WaitForRequest
argument_list|(
name|status
argument_list|)
expr_stmt|;
comment|//Non blocking send
name|TInt
name|err
init|=
name|status
operator|.
name|Int
argument_list|()
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QNATIVESOCKETENGINE_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QSymbianSocketEngine::writeDatagram(%p \"%s\", %lli, \"%s\", %i) == %lli (err=%d)"
argument_list|,
name|data
argument_list|,
name|qt_prettyDebug
argument_list|(
name|data
argument_list|,
name|qMin
argument_list|<
name|int
argument_list|>
argument_list|(
name|len
argument_list|,
literal|16
argument_list|)
argument_list|,
name|len
argument_list|)
operator|.
name|data
argument_list|()
argument_list|,
name|len
argument_list|,
name|host
operator|.
name|toString
argument_list|()
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|port
argument_list|,
operator|(
name|qint64
operator|)
name|sentBytes
argument_list|()
argument_list|,
name|err
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|err
condition|)
block|{
switch|switch
condition|(
name|err
condition|)
block|{
case|case
name|KErrWouldBlock
case|:
comment|// do not error the socket. (otherwise socket layer is reset)
comment|// On symbian^1 and earlier, KErrWouldBlock is returned when interface is not up yet
comment|// On symbian^3, KErrNone is returned but sentBytes = 0
return|return
literal|0
return|;
case|case
name|KErrTooBig
case|:
name|d
operator|->
name|setError
argument_list|(
name|QAbstractSocket
operator|::
name|DatagramTooLargeError
argument_list|,
name|d
operator|->
name|DatagramTooLargeErrorString
argument_list|)
expr_stmt|;
break|break;
default|default:
name|d
operator|->
name|setError
argument_list|(
name|QAbstractSocket
operator|::
name|NetworkError
argument_list|,
name|d
operator|->
name|SendDatagramErrorString
argument_list|)
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|QSysInfo
operator|::
name|s60Version
argument_list|()
operator|<=
name|QSysInfo
operator|::
name|SV_S60_5_0
condition|)
block|{
comment|// This is evil hack, but for some reason native RSocket::SendTo returns 0,
comment|// for large datagrams (such as 600 bytes). Based on comments from Open C team
comment|// this should happen only in platforms<= S60 5.0.
return|return
name|len
return|;
block|}
return|return
name|sentBytes
argument_list|()
return|;
block|}
end_function
begin_comment
comment|// FIXME check where the native socket engine called that..
end_comment
begin_function
DECL|function|fetchConnectionParameters
name|bool
name|QSymbianSocketEnginePrivate
operator|::
name|fetchConnectionParameters
parameter_list|()
block|{
name|localPort
operator|=
literal|0
expr_stmt|;
name|localAddress
operator|.
name|clear
argument_list|()
expr_stmt|;
name|peerPort
operator|=
literal|0
expr_stmt|;
name|peerAddress
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|socketDescriptor
operator|==
operator|-
literal|1
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|!
name|nativeSocket
operator|.
name|SubSessionHandle
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|QSymbianSocketManager
operator|::
name|instance
argument_list|()
operator|.
name|lookupSocket
argument_list|(
name|socketDescriptor
argument_list|,
name|nativeSocket
argument_list|)
condition|)
block|{
name|setError
argument_list|(
name|QAbstractSocket
operator|::
name|UnsupportedSocketOperationError
argument_list|,
name|InvalidSocketErrorString
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
comment|// Determine local address
name|TSockAddr
name|addr
decl_stmt|;
name|nativeSocket
operator|.
name|LocalName
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|getPortAndAddress
argument_list|(
name|addr
argument_list|,
operator|&
name|localPort
argument_list|,
operator|&
name|localAddress
argument_list|)
expr_stmt|;
comment|// Determine protocol family
name|socketProtocol
operator|=
name|localAddress
operator|.
name|protocol
argument_list|()
expr_stmt|;
comment|// Determine the remote address
name|nativeSocket
operator|.
name|RemoteName
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|getPortAndAddress
argument_list|(
name|addr
argument_list|,
operator|&
name|peerPort
argument_list|,
operator|&
name|peerAddress
argument_list|)
expr_stmt|;
comment|// Determine the socket type (UDP/TCP)
name|TProtocolDesc
name|protocol
decl_stmt|;
name|TInt
name|err
init|=
name|nativeSocket
operator|.
name|Info
argument_list|(
name|protocol
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|setError
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
else|else
block|{
switch|switch
condition|(
name|protocol
operator|.
name|iProtocol
condition|)
block|{
case|case
name|KProtocolInetTcp
case|:
name|socketType
operator|=
name|QAbstractSocket
operator|::
name|TcpSocket
expr_stmt|;
break|break;
case|case
name|KProtocolInetUdp
case|:
name|socketType
operator|=
name|QAbstractSocket
operator|::
name|UdpSocket
expr_stmt|;
break|break;
default|default:
name|socketType
operator|=
name|QAbstractSocket
operator|::
name|UnknownSocketType
expr_stmt|;
break|break;
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|QNATIVESOCKETENGINE_DEBUG
argument_list|)
name|QString
name|socketProtocolStr
init|=
name|QLatin1String
argument_list|(
literal|"UnknownProtocol"
argument_list|)
decl_stmt|;
if|if
condition|(
name|socketProtocol
operator|==
name|QAbstractSocket
operator|::
name|IPv4Protocol
condition|)
name|socketProtocolStr
operator|=
name|QLatin1String
argument_list|(
literal|"IPv4Protocol"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|socketProtocol
operator|==
name|QAbstractSocket
operator|::
name|IPv6Protocol
condition|)
name|socketProtocolStr
operator|=
name|QLatin1String
argument_list|(
literal|"IPv6Protocol"
argument_list|)
expr_stmt|;
name|QString
name|socketTypeStr
init|=
name|QLatin1String
argument_list|(
literal|"UnknownSocketType"
argument_list|)
decl_stmt|;
if|if
condition|(
name|socketType
operator|==
name|QAbstractSocket
operator|::
name|TcpSocket
condition|)
name|socketTypeStr
operator|=
name|QLatin1String
argument_list|(
literal|"TcpSocket"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|socketType
operator|==
name|QAbstractSocket
operator|::
name|UdpSocket
condition|)
name|socketTypeStr
operator|=
name|QLatin1String
argument_list|(
literal|"UdpSocket"
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"QSymbianSocketEnginePrivate::fetchConnectionParameters() local == %s:%i,"
literal|" peer == %s:%i, socket == %s - %s"
argument_list|,
name|localAddress
operator|.
name|toString
argument_list|()
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|localPort
argument_list|,
name|peerAddress
operator|.
name|toString
argument_list|()
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|peerPort
argument_list|,
name|socketTypeStr
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|socketProtocolStr
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|close
name|void
name|QSymbianSocketEngine
operator|::
name|close
parameter_list|()
block|{
if|if
condition|(
operator|!
name|isValid
argument_list|()
condition|)
return|return;
name|Q_D
argument_list|(
name|QSymbianSocketEngine
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QNATIVESOCKETENGINE_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QSymbianSocketEngine::close()"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|readNotificationsEnabled
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|writeNotificationsEnabled
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|exceptNotificationsEnabled
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|asyncSelect
condition|)
block|{
name|d
operator|->
name|asyncSelect
operator|->
name|deleteLater
argument_list|()
expr_stmt|;
name|d
operator|->
name|asyncSelect
operator|=
literal|0
expr_stmt|;
block|}
comment|//TODO: call nativeSocket.Shutdown(EImmediate) in some cases?
if|if
condition|(
name|d
operator|->
name|socketType
operator|==
name|QAbstractSocket
operator|::
name|UdpSocket
condition|)
block|{
comment|//TODO: Close hangs without this, but only for UDP - why?
name|TRequestStatus
name|stat
decl_stmt|;
name|d
operator|->
name|nativeSocket
operator|.
name|Shutdown
argument_list|(
name|RSocket
operator|::
name|EImmediate
argument_list|,
name|stat
argument_list|)
expr_stmt|;
name|User
operator|::
name|WaitForRequest
argument_list|(
name|stat
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|QNATIVESOCKETENGINE_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QSymbianSocketEngine::close - closing socket"
operator|<<
name|d
operator|->
name|nativeSocket
operator|.
name|SubSessionHandle
argument_list|()
operator|<<
name|d
operator|->
name|socketDescriptor
expr_stmt|;
endif|#
directive|endif
comment|//remove must come before close to avoid a race where another thread gets the old subsession handle
comment|//reused& asserts when calling QSymbianSocketManager::instance->addSocket
name|QSymbianSocketManager
operator|::
name|instance
argument_list|()
operator|.
name|removeSocket
argument_list|(
name|d
operator|->
name|nativeSocket
argument_list|)
expr_stmt|;
name|d
operator|->
name|nativeSocket
operator|.
name|Close
argument_list|()
expr_stmt|;
name|d
operator|->
name|socketDescriptor
operator|=
operator|-
literal|1
expr_stmt|;
name|d
operator|->
name|socketState
operator|=
name|QAbstractSocket
operator|::
name|UnconnectedState
expr_stmt|;
name|d
operator|->
name|hasSetSocketError
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|localPort
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|localAddress
operator|.
name|clear
argument_list|()
expr_stmt|;
name|d
operator|->
name|peerPort
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|peerAddress
operator|.
name|clear
argument_list|()
expr_stmt|;
name|d
operator|->
name|hasReceivedBufferedDatagram
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|receivedDataBuffer
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|write
name|qint64
name|QSymbianSocketEngine
operator|::
name|write
parameter_list|(
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|qint64
name|len
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSymbianSocketEngine
argument_list|)
expr_stmt|;
name|Q_CHECK_VALID_SOCKETLAYER
argument_list|(
name|QSymbianSocketEngine
operator|::
name|write
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Q_CHECK_STATE
argument_list|(
name|QSymbianSocketEngine
operator|::
name|write
argument_list|()
argument_list|,
name|QAbstractSocket
operator|::
name|ConnectedState
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|TPtrC8
name|buffer
argument_list|(
operator|(
name|TUint8
operator|*
operator|)
name|data
argument_list|,
operator|(
name|int
operator|)
name|len
argument_list|)
decl_stmt|;
name|TSockXfrLength
name|sentBytes
init|=
literal|0
decl_stmt|;
name|TRequestStatus
name|status
decl_stmt|;
name|d
operator|->
name|nativeSocket
operator|.
name|Send
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|status
argument_list|,
name|sentBytes
argument_list|)
expr_stmt|;
name|User
operator|::
name|WaitForRequest
argument_list|(
name|status
argument_list|)
expr_stmt|;
comment|//TODO: on emulator this blocks for write>16kB (non blocking IO not implemented properly?)
name|TInt
name|err
init|=
name|status
operator|.
name|Int
argument_list|()
decl_stmt|;
if|if
condition|(
name|err
condition|)
block|{
switch|switch
condition|(
name|err
condition|)
block|{
case|case
name|KErrDisconnected
case|:
case|case
name|KErrEof
case|:
name|sentBytes
operator|=
operator|-
literal|1
expr_stmt|;
name|d
operator|->
name|setError
argument_list|(
name|QAbstractSocket
operator|::
name|RemoteHostClosedError
argument_list|,
name|d
operator|->
name|RemoteHostClosedErrorString
argument_list|)
expr_stmt|;
name|close
argument_list|()
expr_stmt|;
break|break;
case|case
name|KErrTooBig
case|:
name|d
operator|->
name|setError
argument_list|(
name|QAbstractSocket
operator|::
name|DatagramTooLargeError
argument_list|,
name|d
operator|->
name|DatagramTooLargeErrorString
argument_list|)
expr_stmt|;
break|break;
case|case
name|KErrWouldBlock
case|:
break|break;
default|default:
name|sentBytes
operator|=
operator|-
literal|1
expr_stmt|;
name|d
operator|->
name|setError
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|close
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|QNATIVESOCKETENGINE_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QSymbianSocketEngine::write(%p \"%s\", %llu) == %i"
argument_list|,
name|data
argument_list|,
name|qt_prettyDebug
argument_list|(
name|data
argument_list|,
name|qMin
argument_list|(
operator|(
name|int
operator|)
name|len
argument_list|,
literal|16
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|len
argument_list|)
operator|.
name|data
argument_list|()
argument_list|,
name|len
argument_list|,
operator|(
name|int
operator|)
name|sentBytes
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|qint64
argument_list|(
name|sentBytes
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/* */
end_comment
begin_function
DECL|function|read
name|qint64
name|QSymbianSocketEngine
operator|::
name|read
parameter_list|(
name|char
modifier|*
name|data
parameter_list|,
name|qint64
name|maxSize
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSymbianSocketEngine
argument_list|)
expr_stmt|;
name|Q_CHECK_VALID_SOCKETLAYER
argument_list|(
name|QSymbianSocketEngine
operator|::
name|read
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Q_CHECK_STATES
argument_list|(
name|QSymbianSocketEngine
operator|::
name|read
argument_list|()
argument_list|,
name|QAbstractSocket
operator|::
name|ConnectedState
argument_list|,
name|QAbstractSocket
operator|::
name|BoundState
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|// if a datagram was buffered in pendingDatagramSize(), return it now
if|if
condition|(
name|d
operator|->
name|hasReceivedBufferedDatagram
condition|)
block|{
name|qint64
name|size
init|=
name|qMin
argument_list|(
name|maxSize
argument_list|,
operator|(
name|qint64
operator|)
name|d
operator|->
name|receivedDataBuffer
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|data
argument_list|,
name|d
operator|->
name|receivedDataBuffer
operator|.
name|constData
argument_list|()
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|d
operator|->
name|receivedDataBuffer
operator|.
name|clear
argument_list|()
expr_stmt|;
name|d
operator|->
name|hasReceivedBufferedDatagram
operator|=
literal|false
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QNATIVESOCKETENGINE_DEBUG
argument_list|)
name|qDebug
argument_list|()
operator|<<
literal|"QSymbianSocketEngine::read returning"
operator|<<
name|size
operator|<<
literal|"bytes from buffer"
expr_stmt|;
endif|#
directive|endif
return|return
name|size
return|;
block|}
name|TPtr8
name|buffer
argument_list|(
operator|(
name|TUint8
operator|*
operator|)
name|data
argument_list|,
operator|(
name|int
operator|)
name|maxSize
argument_list|)
decl_stmt|;
name|TSockXfrLength
name|received
init|=
literal|0
decl_stmt|;
name|TRequestStatus
name|status
decl_stmt|;
name|TSockAddr
name|dummy
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|socketType
operator|==
name|QAbstractSocket
operator|::
name|UdpSocket
condition|)
block|{
comment|//RecvOneOrMore() can only be used with stream-interfaced connected sockets; datagram interface sockets will return KErrNotSupported.
name|d
operator|->
name|nativeSocket
operator|.
name|RecvFrom
argument_list|(
name|buffer
argument_list|,
name|dummy
argument_list|,
literal|0
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|nativeSocket
operator|.
name|RecvOneOrMore
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|status
argument_list|,
name|received
argument_list|)
expr_stmt|;
block|}
name|User
operator|::
name|WaitForRequest
argument_list|(
name|status
argument_list|)
expr_stmt|;
comment|//Non blocking receive
name|TInt
name|err
init|=
name|status
operator|.
name|Int
argument_list|()
decl_stmt|;
name|int
name|r
init|=
name|buffer
operator|.
name|Length
argument_list|()
decl_stmt|;
if|if
condition|(
name|err
operator|==
name|KErrWouldBlock
condition|)
block|{
comment|// No data was available for reading
name|r
operator|=
operator|-
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|err
operator|!=
name|KErrNone
condition|)
block|{
name|d
operator|->
name|setError
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|close
argument_list|()
expr_stmt|;
name|r
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|QNATIVESOCKETENGINE_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QSymbianSocketEngine::read(%p \"%s\", %llu) == %i (err = %d)"
argument_list|,
name|data
argument_list|,
name|qt_prettyDebug
argument_list|(
name|data
argument_list|,
name|qMin
argument_list|(
name|r
argument_list|,
name|ssize_t
argument_list|(
literal|16
argument_list|)
argument_list|)
argument_list|,
name|r
argument_list|)
operator|.
name|data
argument_list|()
argument_list|,
name|maxSize
argument_list|,
name|r
argument_list|,
name|err
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|qint64
argument_list|(
name|r
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|nativeSelect
name|int
name|QSymbianSocketEnginePrivate
operator|::
name|nativeSelect
parameter_list|(
name|int
name|timeout
parameter_list|,
name|bool
name|selectForRead
parameter_list|)
specifier|const
block|{
name|bool
name|readyRead
init|=
literal|false
decl_stmt|;
name|bool
name|readyWrite
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|selectForRead
condition|)
return|return
name|nativeSelect
argument_list|(
name|timeout
argument_list|,
literal|true
argument_list|,
literal|false
argument_list|,
operator|&
name|readyRead
argument_list|,
operator|&
name|readyWrite
argument_list|)
return|;
else|else
return|return
name|nativeSelect
argument_list|(
name|timeout
argument_list|,
literal|false
argument_list|,
literal|true
argument_list|,
operator|&
name|readyRead
argument_list|,
operator|&
name|readyWrite
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!  \internal  \param timeout timeout in milliseconds  \param checkRead caller is interested if the socket is ready to read  \param checkWrite caller is interested if the socket is ready for write  \param selectForRead (out) should set to true if ready to read  \param selectForWrite (out) should set to true if ready to write  \return 0 on timeout,>0 on success,<0 on error  */
end_comment
begin_function
DECL|function|nativeSelect
name|int
name|QSymbianSocketEnginePrivate
operator|::
name|nativeSelect
parameter_list|(
name|int
name|timeout
parameter_list|,
name|bool
name|checkRead
parameter_list|,
name|bool
name|checkWrite
parameter_list|,
name|bool
modifier|*
name|selectForRead
parameter_list|,
name|bool
modifier|*
name|selectForWrite
parameter_list|)
specifier|const
block|{
comment|//cancel asynchronous notifier (only one IOCTL allowed at a time)
if|if
condition|(
name|asyncSelect
condition|)
name|asyncSelect
operator|->
name|Cancel
argument_list|()
expr_stmt|;
name|TPckgBuf
argument_list|<
name|TUint
argument_list|>
name|selectFlags
decl_stmt|;
name|selectFlags
argument_list|()
operator|=
name|KSockSelectExcept
expr_stmt|;
if|if
condition|(
name|checkRead
condition|)
name|selectFlags
argument_list|()
operator||=
name|KSockSelectRead
expr_stmt|;
if|if
condition|(
name|checkWrite
condition|)
name|selectFlags
argument_list|()
operator||=
name|KSockSelectWrite
expr_stmt|;
name|TInt
name|err
decl_stmt|;
if|if
condition|(
name|timeout
operator|==
literal|0
condition|)
block|{
comment|//if timeout is zero, poll
name|err
operator|=
name|nativeSocket
operator|.
name|GetOpt
argument_list|(
name|KSOSelectPoll
argument_list|,
name|KSOLSocket
argument_list|,
name|selectFlags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TRequestStatus
name|selectStat
decl_stmt|;
name|nativeSocket
operator|.
name|Ioctl
argument_list|(
name|KIOctlSelect
argument_list|,
name|selectStat
argument_list|,
operator|&
name|selectFlags
argument_list|,
name|KSOLSocket
argument_list|)
expr_stmt|;
if|if
condition|(
name|timeout
operator|<
literal|0
condition|)
name|User
operator|::
name|WaitForRequest
argument_list|(
name|selectStat
argument_list|)
expr_stmt|;
comment|//negative means no timeout
else|else
block|{
if|if
condition|(
operator|!
name|selectTimer
operator|.
name|Handle
argument_list|()
condition|)
name|qt_symbian_throwIfError
argument_list|(
name|selectTimer
operator|.
name|CreateLocal
argument_list|()
argument_list|)
expr_stmt|;
name|TRequestStatus
name|timerStat
decl_stmt|;
name|selectTimer
operator|.
name|HighRes
argument_list|(
name|timerStat
argument_list|,
name|timeout
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|User
operator|::
name|WaitForRequest
argument_list|(
name|timerStat
argument_list|,
name|selectStat
argument_list|)
expr_stmt|;
if|if
condition|(
name|selectStat
operator|==
name|KRequestPending
condition|)
block|{
name|nativeSocket
operator|.
name|CancelIoctl
argument_list|()
expr_stmt|;
comment|//CancelIoctl completes the request (most likely with KErrCancel)
comment|//We need to wait for this to keep the thread semaphore balanced (or active scheduler will panic)
name|User
operator|::
name|WaitForRequest
argument_list|(
name|selectStat
argument_list|)
expr_stmt|;
comment|//restart asynchronous notifier (only one IOCTL allowed at a time)
if|if
condition|(
name|asyncSelect
condition|)
name|asyncSelect
operator|->
name|IssueRequest
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|QNATIVESOCKETENGINE_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QSymbianSocketEnginePrivate::nativeSelect: select timeout"
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
comment|//timeout
block|}
else|else
block|{
name|selectTimer
operator|.
name|Cancel
argument_list|()
expr_stmt|;
name|User
operator|::
name|WaitForRequest
argument_list|(
name|timerStat
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|QNATIVESOCKETENGINE_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QSymbianSocketEnginePrivate::nativeSelect: select status"
operator|<<
name|selectStat
operator|.
name|Int
argument_list|()
operator|<<
operator|(
name|int
operator|)
name|selectFlags
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|err
operator|=
name|selectStat
operator|.
name|Int
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|err
operator|&&
operator|(
name|selectFlags
argument_list|()
operator|&
name|KSockSelectExcept
operator|)
condition|)
block|{
name|nativeSocket
operator|.
name|GetOpt
argument_list|(
name|KSOSelectLastError
argument_list|,
name|KSOLSocket
argument_list|,
name|err
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QNATIVESOCKETENGINE_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QSymbianSocketEnginePrivate::nativeSelect: select last error"
operator|<<
name|err
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|err
condition|)
block|{
comment|//TODO: avoidable cast?
comment|//set the error here, because read won't always return the same error again as select.
cast|const_cast
argument_list|<
name|QSymbianSocketEnginePrivate
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
operator|->
name|setError
argument_list|(
name|err
argument_list|)
expr_stmt|;
comment|//restart asynchronous notifier (only one IOCTL allowed at a time)
if|if
condition|(
name|asyncSelect
condition|)
name|asyncSelect
operator|->
name|IssueRequest
argument_list|()
expr_stmt|;
comment|//TODO: in error case should we restart or not?
return|return
name|err
return|;
block|}
if|if
condition|(
name|checkRead
operator|&&
operator|(
name|selectFlags
argument_list|()
operator|&
name|KSockSelectRead
operator|)
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|selectForRead
argument_list|)
expr_stmt|;
operator|*
name|selectForRead
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
name|checkWrite
operator|&&
operator|(
name|selectFlags
argument_list|()
operator|&
name|KSockSelectWrite
operator|)
condition|)
block|{
name|Q_ASSERT
argument_list|(
name|selectForWrite
argument_list|)
expr_stmt|;
operator|*
name|selectForWrite
operator|=
literal|true
expr_stmt|;
block|}
comment|//restart asynchronous notifier (only one IOCTL allowed at a time)
if|if
condition|(
name|asyncSelect
condition|)
name|asyncSelect
operator|->
name|IssueRequest
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function
begin_function
DECL|function|joinMulticastGroup
name|bool
name|QSymbianSocketEngine
operator|::
name|joinMulticastGroup
parameter_list|(
specifier|const
name|QHostAddress
modifier|&
name|groupAddress
parameter_list|,
specifier|const
name|QNetworkInterface
modifier|&
name|iface
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSymbianSocketEngine
argument_list|)
expr_stmt|;
name|Q_CHECK_VALID_SOCKETLAYER
argument_list|(
name|QSymbianSocketEngine
operator|::
name|joinMulticastGroup
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|Q_CHECK_STATE
argument_list|(
name|QSymbianSocketEngine
operator|::
name|joinMulticastGroup
argument_list|()
argument_list|,
name|QAbstractSocket
operator|::
name|BoundState
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|Q_CHECK_TYPE
argument_list|(
name|QSymbianSocketEngine
operator|::
name|joinMulticastGroup
argument_list|()
argument_list|,
name|QAbstractSocket
operator|::
name|UdpSocket
argument_list|,
literal|false
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|multicastGroupMembershipHelper
argument_list|(
name|groupAddress
argument_list|,
name|iface
argument_list|,
name|KSoIp6JoinGroup
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|leaveMulticastGroup
name|bool
name|QSymbianSocketEngine
operator|::
name|leaveMulticastGroup
parameter_list|(
specifier|const
name|QHostAddress
modifier|&
name|groupAddress
parameter_list|,
specifier|const
name|QNetworkInterface
modifier|&
name|iface
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSymbianSocketEngine
argument_list|)
expr_stmt|;
name|Q_CHECK_VALID_SOCKETLAYER
argument_list|(
name|QSymbianSocketEngine
operator|::
name|leaveMulticastGroup
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|Q_CHECK_STATE
argument_list|(
name|QSymbianSocketEngine
operator|::
name|leaveMulticastGroup
argument_list|()
argument_list|,
name|QAbstractSocket
operator|::
name|BoundState
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|Q_CHECK_TYPE
argument_list|(
name|QSymbianSocketEngine
operator|::
name|leaveMulticastGroup
argument_list|()
argument_list|,
name|QAbstractSocket
operator|::
name|UdpSocket
argument_list|,
literal|false
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|multicastGroupMembershipHelper
argument_list|(
name|groupAddress
argument_list|,
name|iface
argument_list|,
name|KSoIp6LeaveGroup
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|multicastGroupMembershipHelper
name|bool
name|QSymbianSocketEnginePrivate
operator|::
name|multicastGroupMembershipHelper
parameter_list|(
specifier|const
name|QHostAddress
modifier|&
name|groupAddress
parameter_list|,
specifier|const
name|QNetworkInterface
modifier|&
name|iface
parameter_list|,
name|TUint
name|operation
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|QNATIVESOCKETENGINE_DEBUG
argument_list|)
name|qDebug
argument_list|()
operator|<<
literal|"QSymbianSocketEnginePrivate::multicastGroupMembershipHelper"
operator|<<
name|groupAddress
operator|<<
name|iface
operator|<<
name|operation
expr_stmt|;
endif|#
directive|endif
comment|//translate address
name|TPckgBuf
argument_list|<
name|TIp6Mreq
argument_list|>
name|option
decl_stmt|;
if|if
condition|(
name|groupAddress
operator|.
name|protocol
argument_list|()
operator|==
name|QAbstractSocket
operator|::
name|IPv6Protocol
condition|)
block|{
name|Q_IPV6ADDR
name|ip6
init|=
name|groupAddress
operator|.
name|toIPv6Address
argument_list|()
decl_stmt|;
name|memcpy
argument_list|(
name|option
argument_list|()
operator|.
name|iAddr
operator|.
name|u
operator|.
name|iAddr8
argument_list|,
name|ip6
operator|.
name|c
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TInetAddr
name|wrapped
decl_stmt|;
name|wrapped
operator|.
name|SetAddress
argument_list|(
name|groupAddress
operator|.
name|toIPv4Address
argument_list|()
argument_list|)
expr_stmt|;
name|wrapped
operator|.
name|ConvertToV4Mapped
argument_list|()
expr_stmt|;
name|option
argument_list|()
operator|.
name|iAddr
operator|=
name|wrapped
operator|.
name|Ip6Address
argument_list|()
expr_stmt|;
block|}
name|option
argument_list|()
operator|.
name|iInterface
operator|=
name|iface
operator|.
name|index
argument_list|()
expr_stmt|;
comment|//join or leave group
name|TInt
name|err
init|=
name|nativeSocket
operator|.
name|SetOpt
argument_list|(
name|operation
argument_list|,
name|KSolInetIp
argument_list|,
name|option
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QNATIVESOCKETENGINE_DEBUG
argument_list|)
name|qDebug
argument_list|()
operator|<<
literal|"address"
operator|<<
name|qt_prettyDebug
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
operator|(
name|option
argument_list|()
operator|.
name|iAddr
operator|.
name|u
operator|.
name|iAddr8
operator|)
argument_list|,
literal|16
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|qDebug
argument_list|()
operator|<<
literal|"interface"
operator|<<
name|option
argument_list|()
operator|.
name|iInterface
expr_stmt|;
name|qDebug
argument_list|()
operator|<<
literal|"error"
operator|<<
name|err
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|err
condition|)
block|{
name|setError
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|KErrNone
operator|==
name|err
operator|)
return|;
block|}
end_function
begin_function
DECL|function|multicastInterface
name|QNetworkInterface
name|QSymbianSocketEngine
operator|::
name|multicastInterface
parameter_list|()
specifier|const
block|{
comment|//TODO
specifier|const
name|Q_D
argument_list|(
name|QSymbianSocketEngine
argument_list|)
expr_stmt|;
name|Q_CHECK_VALID_SOCKETLAYER
argument_list|(
name|QSymbianSocketEngine
operator|::
name|multicastInterface
argument_list|()
argument_list|,
name|QNetworkInterface
argument_list|()
argument_list|)
expr_stmt|;
name|Q_CHECK_TYPE
argument_list|(
name|QSymbianSocketEngine
operator|::
name|multicastInterface
argument_list|()
argument_list|,
name|QAbstractSocket
operator|::
name|UdpSocket
argument_list|,
name|QNetworkInterface
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|QNetworkInterface
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|setMulticastInterface
name|bool
name|QSymbianSocketEngine
operator|::
name|setMulticastInterface
parameter_list|(
specifier|const
name|QNetworkInterface
modifier|&
name|iface
parameter_list|)
block|{
comment|//TODO - this is possibly a unix'ism as the RConnection on which the socket was created is probably controlling this
name|Q_D
argument_list|(
name|QSymbianSocketEngine
argument_list|)
expr_stmt|;
name|Q_CHECK_VALID_SOCKETLAYER
argument_list|(
name|QSymbianSocketEngine
operator|::
name|setMulticastInterface
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|Q_CHECK_TYPE
argument_list|(
name|QSymbianSocketEngine
operator|::
name|setMulticastInterface
argument_list|()
argument_list|,
name|QAbstractSocket
operator|::
name|UdpSocket
argument_list|,
literal|false
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|checkProxy
name|bool
name|QSymbianSocketEnginePrivate
operator|::
name|checkProxy
parameter_list|(
specifier|const
name|QHostAddress
modifier|&
name|address
parameter_list|)
block|{
if|if
condition|(
name|address
operator|==
name|QHostAddress
operator|::
name|LocalHost
operator|||
name|address
operator|==
name|QHostAddress
operator|::
name|LocalHostIPv6
condition|)
return|return
literal|true
return|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|QT_NO_NETWORKPROXY
argument_list|)
name|QObject
modifier|*
name|parent
init|=
name|q_func
argument_list|()
operator|->
name|parent
argument_list|()
decl_stmt|;
name|QNetworkProxy
name|proxy
decl_stmt|;
if|if
condition|(
name|QAbstractSocket
modifier|*
name|socket
init|=
name|qobject_cast
argument_list|<
name|QAbstractSocket
operator|*
argument_list|>
argument_list|(
name|parent
argument_list|)
condition|)
block|{
name|proxy
operator|=
name|socket
operator|->
name|proxy
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|QTcpServer
modifier|*
name|server
init|=
name|qobject_cast
argument_list|<
name|QTcpServer
operator|*
argument_list|>
argument_list|(
name|parent
argument_list|)
condition|)
block|{
name|proxy
operator|=
name|server
operator|->
name|proxy
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// no parent -> no proxy
return|return
literal|true
return|;
block|}
if|if
condition|(
name|proxy
operator|.
name|type
argument_list|()
operator|==
name|QNetworkProxy
operator|::
name|DefaultProxy
condition|)
name|proxy
operator|=
name|QNetworkProxy
operator|::
name|applicationProxy
argument_list|()
expr_stmt|;
if|if
condition|(
name|proxy
operator|.
name|type
argument_list|()
operator|!=
name|QNetworkProxy
operator|::
name|DefaultProxy
operator|&&
name|proxy
operator|.
name|type
argument_list|()
operator|!=
name|QNetworkProxy
operator|::
name|NoProxy
condition|)
block|{
comment|// QSymbianSocketEngine doesn't do proxies
name|setError
argument_list|(
name|QAbstractSocket
operator|::
name|UnsupportedSocketOperationError
argument_list|,
name|InvalidProxyTypeString
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
endif|#
directive|endif
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|// FIXME this is also in QNativeSocketEngine, unify it
end_comment
begin_comment
comment|/*! \internal      Sets the error and error string if not set already. The only     interesting error is the first one that occurred, and not the last     one. */
end_comment
begin_function
DECL|function|setError
name|void
name|QSymbianSocketEnginePrivate
operator|::
name|setError
parameter_list|(
name|QAbstractSocket
operator|::
name|SocketError
name|error
parameter_list|,
name|ErrorString
name|errorString
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|hasSetSocketError
condition|)
block|{
comment|// Only set socket errors once for one engine; expect the
comment|// socket to recreate its engine after an error. Note: There's
comment|// one exception: SocketError(11) bypasses this as it's purely
comment|// a temporary internal error condition.
comment|// Another exception is the way the waitFor*() functions set
comment|// an error when a timeout occurs. After the call to setError()
comment|// they reset the hasSetSocketError to false
return|return;
block|}
if|if
condition|(
name|error
operator|!=
name|QAbstractSocket
operator|::
name|SocketError
argument_list|(
literal|11
argument_list|)
condition|)
name|hasSetSocketError
operator|=
literal|true
expr_stmt|;
name|socketError
operator|=
name|error
expr_stmt|;
switch|switch
condition|(
name|errorString
condition|)
block|{
case|case
name|NonBlockingInitFailedErrorString
case|:
name|socketErrorString
operator|=
name|QSymbianSocketEngine
operator|::
name|tr
argument_list|(
literal|"Unable to initialize non-blocking socket"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BroadcastingInitFailedErrorString
case|:
name|socketErrorString
operator|=
name|QSymbianSocketEngine
operator|::
name|tr
argument_list|(
literal|"Unable to initialize broadcast socket"
argument_list|)
expr_stmt|;
break|break;
case|case
name|NoIpV6ErrorString
case|:
name|socketErrorString
operator|=
name|QSymbianSocketEngine
operator|::
name|tr
argument_list|(
literal|"Attempt to use IPv6 socket on a platform with no IPv6 support"
argument_list|)
expr_stmt|;
break|break;
case|case
name|RemoteHostClosedErrorString
case|:
name|socketErrorString
operator|=
name|QSymbianSocketEngine
operator|::
name|tr
argument_list|(
literal|"The remote host closed the connection"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TimeOutErrorString
case|:
name|socketErrorString
operator|=
name|QSymbianSocketEngine
operator|::
name|tr
argument_list|(
literal|"Network operation timed out"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ResourceErrorString
case|:
name|socketErrorString
operator|=
name|QSymbianSocketEngine
operator|::
name|tr
argument_list|(
literal|"Out of resources"
argument_list|)
expr_stmt|;
break|break;
case|case
name|OperationUnsupportedErrorString
case|:
name|socketErrorString
operator|=
name|QSymbianSocketEngine
operator|::
name|tr
argument_list|(
literal|"Unsupported socket operation"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ProtocolUnsupportedErrorString
case|:
name|socketErrorString
operator|=
name|QSymbianSocketEngine
operator|::
name|tr
argument_list|(
literal|"Protocol type not supported"
argument_list|)
expr_stmt|;
break|break;
case|case
name|InvalidSocketErrorString
case|:
name|socketErrorString
operator|=
name|QSymbianSocketEngine
operator|::
name|tr
argument_list|(
literal|"Invalid socket descriptor"
argument_list|)
expr_stmt|;
break|break;
case|case
name|HostUnreachableErrorString
case|:
name|socketErrorString
operator|=
name|QSymbianSocketEngine
operator|::
name|tr
argument_list|(
literal|"Host unreachable"
argument_list|)
expr_stmt|;
break|break;
case|case
name|NetworkUnreachableErrorString
case|:
name|socketErrorString
operator|=
name|QSymbianSocketEngine
operator|::
name|tr
argument_list|(
literal|"Network unreachable"
argument_list|)
expr_stmt|;
break|break;
case|case
name|AccessErrorString
case|:
name|socketErrorString
operator|=
name|QSymbianSocketEngine
operator|::
name|tr
argument_list|(
literal|"Permission denied"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ConnectionTimeOutErrorString
case|:
name|socketErrorString
operator|=
name|QSymbianSocketEngine
operator|::
name|tr
argument_list|(
literal|"Connection timed out"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ConnectionRefusedErrorString
case|:
name|socketErrorString
operator|=
name|QSymbianSocketEngine
operator|::
name|tr
argument_list|(
literal|"Connection refused"
argument_list|)
expr_stmt|;
break|break;
case|case
name|AddressInuseErrorString
case|:
name|socketErrorString
operator|=
name|QSymbianSocketEngine
operator|::
name|tr
argument_list|(
literal|"The bound address is already in use"
argument_list|)
expr_stmt|;
break|break;
case|case
name|AddressNotAvailableErrorString
case|:
name|socketErrorString
operator|=
name|QSymbianSocketEngine
operator|::
name|tr
argument_list|(
literal|"The address is not available"
argument_list|)
expr_stmt|;
break|break;
case|case
name|AddressProtectedErrorString
case|:
name|socketErrorString
operator|=
name|QSymbianSocketEngine
operator|::
name|tr
argument_list|(
literal|"The address is protected"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DatagramTooLargeErrorString
case|:
name|socketErrorString
operator|=
name|QSymbianSocketEngine
operator|::
name|tr
argument_list|(
literal|"Datagram was too large to send"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SendDatagramErrorString
case|:
name|socketErrorString
operator|=
name|QSymbianSocketEngine
operator|::
name|tr
argument_list|(
literal|"Unable to send a message"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ReceiveDatagramErrorString
case|:
name|socketErrorString
operator|=
name|QSymbianSocketEngine
operator|::
name|tr
argument_list|(
literal|"Unable to receive a message"
argument_list|)
expr_stmt|;
break|break;
case|case
name|WriteErrorString
case|:
name|socketErrorString
operator|=
name|QSymbianSocketEngine
operator|::
name|tr
argument_list|(
literal|"Unable to write"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ReadErrorString
case|:
name|socketErrorString
operator|=
name|QSymbianSocketEngine
operator|::
name|tr
argument_list|(
literal|"Network error"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PortInuseErrorString
case|:
name|socketErrorString
operator|=
name|QSymbianSocketEngine
operator|::
name|tr
argument_list|(
literal|"Another socket is already listening on the same port"
argument_list|)
expr_stmt|;
break|break;
case|case
name|NotSocketErrorString
case|:
name|socketErrorString
operator|=
name|QSymbianSocketEngine
operator|::
name|tr
argument_list|(
literal|"Operation on non-socket"
argument_list|)
expr_stmt|;
break|break;
case|case
name|InvalidProxyTypeString
case|:
name|socketErrorString
operator|=
name|QSymbianSocketEngine
operator|::
name|tr
argument_list|(
literal|"The proxy type is invalid for this operation"
argument_list|)
expr_stmt|;
break|break;
case|case
name|InvalidAddressErrorString
case|:
name|socketErrorString
operator|=
name|QSymbianSocketEngine
operator|::
name|tr
argument_list|(
literal|"The address is invalid for this operation"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SessionNotOpenErrorString
case|:
name|socketErrorString
operator|=
name|QSymbianSocketEngine
operator|::
name|tr
argument_list|(
literal|"The specified network session is not opened"
argument_list|)
expr_stmt|;
break|break;
case|case
name|UnknownSocketErrorString
case|:
name|socketErrorString
operator|=
name|QSymbianSocketEngine
operator|::
name|tr
argument_list|(
literal|"Unknown error"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function
begin_function
DECL|function|setError
name|void
name|QSymbianSocketEnginePrivate
operator|::
name|setError
parameter_list|(
name|TInt
name|symbianError
parameter_list|)
block|{
switch|switch
condition|(
name|symbianError
condition|)
block|{
case|case
name|KErrDisconnected
case|:
case|case
name|KErrEof
case|:
case|case
name|KErrConnectionTerminated
case|:
comment|//interface stopped externally - RConnection::Stop(EStopAuthoritative)
name|setError
argument_list|(
name|QAbstractSocket
operator|::
name|RemoteHostClosedError
argument_list|,
name|QSymbianSocketEnginePrivate
operator|::
name|RemoteHostClosedErrorString
argument_list|)
expr_stmt|;
break|break;
case|case
name|KErrNetUnreach
case|:
name|setError
argument_list|(
name|QAbstractSocket
operator|::
name|NetworkError
argument_list|,
name|QSymbianSocketEnginePrivate
operator|::
name|NetworkUnreachableErrorString
argument_list|)
expr_stmt|;
break|break;
case|case
name|KErrHostUnreach
case|:
name|setError
argument_list|(
name|QAbstractSocket
operator|::
name|NetworkError
argument_list|,
name|QSymbianSocketEnginePrivate
operator|::
name|HostUnreachableErrorString
argument_list|)
expr_stmt|;
break|break;
case|case
name|KErrNoProtocolOpt
case|:
name|setError
argument_list|(
name|QAbstractSocket
operator|::
name|NetworkError
argument_list|,
name|QSymbianSocketEnginePrivate
operator|::
name|ProtocolUnsupportedErrorString
argument_list|)
expr_stmt|;
break|break;
case|case
name|KErrInUse
case|:
name|setError
argument_list|(
name|QAbstractSocket
operator|::
name|AddressInUseError
argument_list|,
name|AddressInuseErrorString
argument_list|)
expr_stmt|;
break|break;
case|case
name|KErrPermissionDenied
case|:
name|setError
argument_list|(
name|QAbstractSocket
operator|::
name|SocketAccessError
argument_list|,
name|AccessErrorString
argument_list|)
expr_stmt|;
break|break;
case|case
name|KErrNotSupported
case|:
name|setError
argument_list|(
name|QAbstractSocket
operator|::
name|UnsupportedSocketOperationError
argument_list|,
name|OperationUnsupportedErrorString
argument_list|)
expr_stmt|;
break|break;
case|case
name|KErrNoMemory
case|:
name|setError
argument_list|(
name|QAbstractSocket
operator|::
name|SocketResourceError
argument_list|,
name|ResourceErrorString
argument_list|)
expr_stmt|;
break|break;
case|case
name|KErrCouldNotConnect
case|:
name|setError
argument_list|(
name|QAbstractSocket
operator|::
name|ConnectionRefusedError
argument_list|,
name|ConnectionRefusedErrorString
argument_list|)
expr_stmt|;
break|break;
case|case
name|KErrTimedOut
case|:
name|setError
argument_list|(
name|QAbstractSocket
operator|::
name|NetworkError
argument_list|,
name|ConnectionTimeOutErrorString
argument_list|)
expr_stmt|;
break|break;
case|case
name|KErrBadName
case|:
name|setError
argument_list|(
name|QAbstractSocket
operator|::
name|NetworkError
argument_list|,
name|InvalidAddressErrorString
argument_list|)
expr_stmt|;
break|break;
default|default:
name|socketError
operator|=
name|QAbstractSocket
operator|::
name|NetworkError
expr_stmt|;
name|socketErrorString
operator|=
name|QSystemError
argument_list|(
name|symbianError
argument_list|,
name|QSystemError
operator|::
name|NativeError
argument_list|)
operator|.
name|toString
argument_list|()
expr_stmt|;
break|break;
block|}
name|hasSetSocketError
operator|=
literal|true
expr_stmt|;
block|}
end_function
begin_function
DECL|function|startNotifications
name|void
name|QSymbianSocketEngine
operator|::
name|startNotifications
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QSymbianSocketEngine
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QNATIVESOCKETENGINE_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QSymbianSocketEngine::startNotifications"
operator|<<
name|d
operator|->
name|readNotificationsEnabled
operator|<<
name|d
operator|->
name|writeNotificationsEnabled
operator|<<
name|d
operator|->
name|exceptNotificationsEnabled
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|d
operator|->
name|asyncSelect
operator|&&
operator|(
name|d
operator|->
name|readNotificationsEnabled
operator|||
name|d
operator|->
name|writeNotificationsEnabled
operator|||
name|d
operator|->
name|exceptNotificationsEnabled
operator|)
condition|)
block|{
name|Q_CHECK_VALID_SOCKETLAYER
argument_list|(
name|QSymbianSocketEngine
operator|::
name|startNotifications
argument_list|()
argument_list|,
name|Q_VOID
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|threadData
operator|->
name|eventDispatcher
condition|)
block|{
name|d
operator|->
name|asyncSelect
operator|=
name|q_check_ptr
argument_list|(
operator|new
name|QAsyncSelect
argument_list|(
cast|static_cast
argument_list|<
name|QEventDispatcherSymbian
operator|*
argument_list|>
argument_list|(
name|d
operator|->
name|threadData
operator|->
name|eventDispatcher
argument_list|)
argument_list|,
name|d
operator|->
name|nativeSocket
argument_list|,
name|this
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// call again when event dispatcher has been created
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|this
argument_list|,
literal|"startNotifications"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|d
operator|->
name|asyncSelect
condition|)
name|d
operator|->
name|asyncSelect
operator|->
name|IssueRequest
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|isReadNotificationEnabled
name|bool
name|QSymbianSocketEngine
operator|::
name|isReadNotificationEnabled
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSymbianSocketEngine
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|readNotificationsEnabled
return|;
block|}
end_function
begin_function
DECL|function|setReadNotificationEnabled
name|void
name|QSymbianSocketEngine
operator|::
name|setReadNotificationEnabled
parameter_list|(
name|bool
name|enable
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSymbianSocketEngine
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QNATIVESOCKETENGINE_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QSymbianSocketEngine::setReadNotificationEnabled"
operator|<<
name|enable
operator|<<
literal|"socket"
operator|<<
name|d
operator|->
name|socketDescriptor
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|readNotificationsEnabled
operator|=
name|enable
expr_stmt|;
name|startNotifications
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|isWriteNotificationEnabled
name|bool
name|QSymbianSocketEngine
operator|::
name|isWriteNotificationEnabled
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSymbianSocketEngine
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|writeNotificationsEnabled
return|;
block|}
end_function
begin_function
DECL|function|setWriteNotificationEnabled
name|void
name|QSymbianSocketEngine
operator|::
name|setWriteNotificationEnabled
parameter_list|(
name|bool
name|enable
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSymbianSocketEngine
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QNATIVESOCKETENGINE_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QSymbianSocketEngine::setWriteNotificationEnabled"
operator|<<
name|enable
operator|<<
literal|"socket"
operator|<<
name|d
operator|->
name|socketDescriptor
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|writeNotificationsEnabled
operator|=
name|enable
expr_stmt|;
name|startNotifications
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|isExceptionNotificationEnabled
name|bool
name|QSymbianSocketEngine
operator|::
name|isExceptionNotificationEnabled
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSymbianSocketEngine
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|exceptNotificationsEnabled
return|;
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|setExceptionNotificationEnabled
name|void
name|QSymbianSocketEngine
operator|::
name|setExceptionNotificationEnabled
parameter_list|(
name|bool
name|enable
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSymbianSocketEngine
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QNATIVESOCKETENGINE_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QSymbianSocketEngine::setExceptionNotificationEnabled"
operator|<<
name|enable
operator|<<
literal|"socket"
operator|<<
name|d
operator|->
name|socketDescriptor
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|exceptNotificationsEnabled
operator|=
name|enable
expr_stmt|;
name|startNotifications
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|waitForRead
name|bool
name|QSymbianSocketEngine
operator|::
name|waitForRead
parameter_list|(
name|int
name|msecs
parameter_list|,
name|bool
modifier|*
name|timedOut
parameter_list|)
block|{
name|Q_D
argument_list|(
specifier|const
name|QSymbianSocketEngine
argument_list|)
expr_stmt|;
name|Q_CHECK_VALID_SOCKETLAYER
argument_list|(
name|QSymbianSocketEngine
operator|::
name|waitForRead
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|Q_CHECK_NOT_STATE
argument_list|(
name|QSymbianSocketEngine
operator|::
name|waitForRead
argument_list|()
argument_list|,
name|QAbstractSocket
operator|::
name|UnconnectedState
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|timedOut
condition|)
operator|*
name|timedOut
operator|=
literal|false
expr_stmt|;
name|int
name|ret
init|=
name|d
operator|->
name|nativeSelect
argument_list|(
name|msecs
argument_list|,
literal|true
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|timedOut
condition|)
operator|*
name|timedOut
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|setError
argument_list|(
name|QAbstractSocket
operator|::
name|SocketTimeoutError
argument_list|,
name|d
operator|->
name|TimeOutErrorString
argument_list|)
expr_stmt|;
name|d
operator|->
name|hasSetSocketError
operator|=
literal|false
expr_stmt|;
comment|// A timeout error is temporary in waitFor functions
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|state
argument_list|()
operator|==
name|QAbstractSocket
operator|::
name|ConnectingState
condition|)
block|{
name|connectToHost
argument_list|(
name|d
operator|->
name|peerAddress
argument_list|,
name|d
operator|->
name|peerPort
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
operator|>
literal|0
return|;
block|}
end_function
begin_function
DECL|function|waitForWrite
name|bool
name|QSymbianSocketEngine
operator|::
name|waitForWrite
parameter_list|(
name|int
name|msecs
parameter_list|,
name|bool
modifier|*
name|timedOut
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSymbianSocketEngine
argument_list|)
expr_stmt|;
name|Q_CHECK_VALID_SOCKETLAYER
argument_list|(
name|QSymbianSocketEngine
operator|::
name|waitForWrite
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|Q_CHECK_NOT_STATE
argument_list|(
name|QSymbianSocketEngine
operator|::
name|waitForWrite
argument_list|()
argument_list|,
name|QAbstractSocket
operator|::
name|UnconnectedState
argument_list|,
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|timedOut
condition|)
operator|*
name|timedOut
operator|=
literal|false
expr_stmt|;
name|int
name|ret
init|=
name|d
operator|->
name|nativeSelect
argument_list|(
name|msecs
argument_list|,
literal|false
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|timedOut
condition|)
operator|*
name|timedOut
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|setError
argument_list|(
name|QAbstractSocket
operator|::
name|SocketTimeoutError
argument_list|,
name|d
operator|->
name|TimeOutErrorString
argument_list|)
expr_stmt|;
name|d
operator|->
name|hasSetSocketError
operator|=
literal|false
expr_stmt|;
comment|// A timeout error is temporary in waitFor functions
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|state
argument_list|()
operator|==
name|QAbstractSocket
operator|::
name|ConnectingState
condition|)
block|{
name|connectToHost
argument_list|(
name|d
operator|->
name|peerAddress
argument_list|,
name|d
operator|->
name|peerPort
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
operator|>
literal|0
return|;
block|}
end_function
begin_function
DECL|function|waitForReadOrWrite
name|bool
name|QSymbianSocketEngine
operator|::
name|waitForReadOrWrite
parameter_list|(
name|bool
modifier|*
name|readyToRead
parameter_list|,
name|bool
modifier|*
name|readyToWrite
parameter_list|,
name|bool
name|checkRead
parameter_list|,
name|bool
name|checkWrite
parameter_list|,
name|int
name|msecs
parameter_list|,
name|bool
modifier|*
name|timedOut
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSymbianSocketEngine
argument_list|)
expr_stmt|;
name|Q_CHECK_VALID_SOCKETLAYER
argument_list|(
name|QSymbianSocketEngine
operator|::
name|waitForWrite
argument_list|()
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|Q_CHECK_NOT_STATE
argument_list|(
name|QSymbianSocketEngine
operator|::
name|waitForReadOrWrite
argument_list|()
argument_list|,
name|QAbstractSocket
operator|::
name|UnconnectedState
argument_list|,
literal|false
argument_list|)
expr_stmt|;
name|int
name|ret
init|=
name|d
operator|->
name|nativeSelect
argument_list|(
name|msecs
argument_list|,
name|checkRead
argument_list|,
name|checkWrite
argument_list|,
name|readyToRead
argument_list|,
name|readyToWrite
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|timedOut
condition|)
operator|*
name|timedOut
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|setError
argument_list|(
name|QAbstractSocket
operator|::
name|SocketTimeoutError
argument_list|,
name|d
operator|->
name|TimeOutErrorString
argument_list|)
expr_stmt|;
name|d
operator|->
name|hasSetSocketError
operator|=
literal|false
expr_stmt|;
comment|// A timeout error is temporary in waitFor functions
return|return
literal|false
return|;
block|}
elseif|else
if|if
condition|(
name|state
argument_list|()
operator|==
name|QAbstractSocket
operator|::
name|ConnectingState
condition|)
block|{
name|connectToHost
argument_list|(
name|d
operator|->
name|peerAddress
argument_list|,
name|d
operator|->
name|peerPort
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
operator|>
literal|0
return|;
block|}
end_function
begin_function
DECL|function|bytesToWrite
name|qint64
name|QSymbianSocketEngine
operator|::
name|bytesToWrite
parameter_list|()
specifier|const
block|{
comment|// This is what the QNativeSocketEngine does
return|return
literal|0
return|;
block|}
end_function
begin_function
DECL|function|event
name|bool
name|QSymbianSocketEngine
operator|::
name|event
parameter_list|(
name|QEvent
modifier|*
name|ev
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSymbianSocketEngine
argument_list|)
expr_stmt|;
if|if
condition|(
name|ev
operator|->
name|type
argument_list|()
operator|==
name|QEvent
operator|::
name|ThreadChange
condition|)
block|{
ifdef|#
directive|ifdef
name|QNATIVESOCKETENGINE_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QSymbianSocketEngine::event - ThreadChange"
operator|<<
name|d
operator|->
name|readNotificationsEnabled
operator|<<
name|d
operator|->
name|writeNotificationsEnabled
operator|<<
name|d
operator|->
name|exceptNotificationsEnabled
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|d
operator|->
name|asyncSelect
condition|)
block|{
operator|delete
name|d
operator|->
name|asyncSelect
expr_stmt|;
name|d
operator|->
name|asyncSelect
operator|=
literal|0
expr_stmt|;
comment|// recreate select in new thread (because it is queued, the method is called in the new thread context)
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|this
argument_list|,
literal|"startNotifications"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
block|}
name|d
operator|->
name|selectTimer
operator|.
name|Close
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
name|QAbstractSocketEngine
operator|::
name|event
argument_list|(
name|ev
argument_list|)
return|;
block|}
end_function
begin_constructor
DECL|function|QAsyncSelect
name|QAsyncSelect
operator|::
name|QAsyncSelect
parameter_list|(
name|QEventDispatcherSymbian
modifier|*
name|dispatcher
parameter_list|,
name|RSocket
modifier|&
name|sock
parameter_list|,
name|QSymbianSocketEngine
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QActiveObject
argument_list|(
name|CActive
operator|::
name|EPriorityStandard
argument_list|,
name|dispatcher
argument_list|)
member_init_list|,
name|m_inSocketEvent
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|m_deleteLater
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|m_socket
argument_list|(
name|sock
argument_list|)
member_init_list|,
name|m_selectFlags
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|engine
argument_list|(
name|parent
argument_list|)
block|{
name|CActiveScheduler
operator|::
name|Add
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QAsyncSelect
name|QAsyncSelect
operator|::
name|~
name|QAsyncSelect
parameter_list|()
block|{
name|Cancel
argument_list|()
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|DoCancel
name|void
name|QAsyncSelect
operator|::
name|DoCancel
parameter_list|()
block|{
name|m_socket
operator|.
name|CancelIoctl
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|RunL
name|void
name|QAsyncSelect
operator|::
name|RunL
parameter_list|()
block|{
name|QT_TRYCATCH_LEAVING
argument_list|(
name|run
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|//RunError is called by the active scheduler if RunL leaves.
end_comment
begin_comment
comment|//Typically this will happen if a std::bad_alloc propagates down from the application
end_comment
begin_function
DECL|function|RunError
name|TInt
name|QAsyncSelect
operator|::
name|RunError
parameter_list|(
name|TInt
name|aError
parameter_list|)
block|{
if|if
condition|(
name|engine
condition|)
block|{
name|QT_TRY
block|{
name|engine
operator|->
name|d_func
argument_list|()
operator|->
name|setError
argument_list|(
name|aError
argument_list|)
expr_stmt|;
if|if
condition|(
name|engine
operator|->
name|isExceptionNotificationEnabled
argument_list|()
condition|)
name|engine
operator|->
name|exceptionNotification
argument_list|()
expr_stmt|;
if|if
condition|(
name|engine
operator|->
name|isReadNotificationEnabled
argument_list|()
condition|)
name|engine
operator|->
name|readNotification
argument_list|()
expr_stmt|;
block|}
name|QT_CATCH
argument_list|(
argument|...
argument_list|)
block|{}
block|}
ifdef|#
directive|ifdef
name|QNATIVESOCKETENGINE_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QAsyncSelect::RunError"
operator|<<
name|aError
expr_stmt|;
endif|#
directive|endif
return|return
name|KErrNone
return|;
block|}
end_function
begin_function
DECL|function|run
name|void
name|QAsyncSelect
operator|::
name|run
parameter_list|()
block|{
comment|//when event loop disabled socket events, defer until later
if|if
condition|(
name|maybeDeferSocketEvent
argument_list|()
condition|)
return|return;
if|#
directive|if
name|defined
argument_list|(
name|QNATIVESOCKETENGINE_DEBUG
argument_list|)
name|qDebug
argument_list|()
operator|<<
literal|"QAsyncSelect::run"
operator|<<
name|m_selectBuf
argument_list|()
operator|<<
name|m_selectFlags
expr_stmt|;
endif|#
directive|endif
name|m_inSocketEvent
operator|=
literal|true
expr_stmt|;
name|m_selectBuf
argument_list|()
operator|&=
name|m_selectFlags
expr_stmt|;
comment|//the select ioctl reports everything, so mask to only what we requested
comment|//KSockSelectReadContinuation is for reading datagrams in a mode that doesn't discard when the
comment|//datagram is larger than the read buffer - Qt doesn't need to use this.
if|if
condition|(
name|engine
operator|&&
name|engine
operator|->
name|isReadNotificationEnabled
argument_list|()
operator|&&
operator|(
operator|(
name|m_selectBuf
argument_list|()
operator|&
name|KSockSelectRead
operator|)
operator|||
name|iStatus
operator|!=
name|KErrNone
operator|)
condition|)
block|{
name|engine
operator|->
name|readNotification
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|engine
operator|&&
name|engine
operator|->
name|isWriteNotificationEnabled
argument_list|()
operator|&&
operator|(
operator|(
name|m_selectBuf
argument_list|()
operator|&
name|KSockSelectWrite
operator|)
operator|||
name|iStatus
operator|!=
name|KErrNone
operator|)
condition|)
block|{
if|if
condition|(
name|engine
operator|->
name|state
argument_list|()
operator|==
name|QAbstractSocket
operator|::
name|ConnectingState
condition|)
name|engine
operator|->
name|connectionNotification
argument_list|()
expr_stmt|;
else|else
name|engine
operator|->
name|writeNotification
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|engine
operator|&&
name|engine
operator|->
name|isExceptionNotificationEnabled
argument_list|()
operator|&&
operator|(
operator|(
name|m_selectBuf
argument_list|()
operator|&
name|KSockSelectExcept
operator|)
operator|||
name|iStatus
operator|!=
name|KErrNone
operator|)
condition|)
block|{
name|engine
operator|->
name|exceptionNotification
argument_list|()
expr_stmt|;
block|}
name|m_inSocketEvent
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|m_deleteLater
condition|)
block|{
operator|delete
name|this
expr_stmt|;
return|return;
block|}
comment|// select again (unless disabled by one of the callbacks)
name|IssueRequest
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|deleteLater
name|void
name|QAsyncSelect
operator|::
name|deleteLater
parameter_list|()
block|{
if|if
condition|(
name|m_inSocketEvent
condition|)
block|{
name|engine
operator|=
literal|0
expr_stmt|;
name|m_deleteLater
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
operator|delete
name|this
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|IssueRequest
name|void
name|QAsyncSelect
operator|::
name|IssueRequest
parameter_list|()
block|{
if|if
condition|(
name|m_inSocketEvent
condition|)
return|return;
comment|//prevent thrashing during a callback - socket engine enables/disables multiple notifiers
name|TUint
name|selectFlags
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|engine
operator|->
name|isReadNotificationEnabled
argument_list|()
condition|)
name|selectFlags
operator||=
name|KSockSelectRead
expr_stmt|;
if|if
condition|(
name|engine
operator|->
name|isWriteNotificationEnabled
argument_list|()
condition|)
name|selectFlags
operator||=
name|KSockSelectWrite
expr_stmt|;
if|if
condition|(
name|engine
operator|->
name|isExceptionNotificationEnabled
argument_list|()
condition|)
name|selectFlags
operator||=
name|KSockSelectExcept
expr_stmt|;
if|if
condition|(
name|selectFlags
operator|!=
name|m_selectFlags
condition|)
block|{
ifdef|#
directive|ifdef
name|QNATIVESOCKETENGINE_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QAsyncSelect::IssueRequest() - select flags"
operator|<<
name|m_selectFlags
operator|<<
literal|"->"
operator|<<
name|selectFlags
expr_stmt|;
endif|#
directive|endif
name|Cancel
argument_list|()
expr_stmt|;
name|m_selectFlags
operator|=
name|selectFlags
expr_stmt|;
block|}
if|if
condition|(
name|m_selectFlags
operator|&&
operator|!
name|IsActive
argument_list|()
condition|)
block|{
comment|//always request errors (write notification does not complete on connect errors)
name|m_selectBuf
argument_list|()
operator|=
name|m_selectFlags
operator||
name|KSockSelectExcept
expr_stmt|;
name|m_socket
operator|.
name|Ioctl
argument_list|(
name|KIOctlSelect
argument_list|,
name|iStatus
argument_list|,
operator|&
name|m_selectBuf
argument_list|,
name|KSOLSocket
argument_list|)
expr_stmt|;
name|SetActive
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|QNATIVESOCKETENGINE_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QAsyncSelect::IssueRequest() - IsActive"
operator|<<
name|IsActive
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
