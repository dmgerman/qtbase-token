begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2015 The Qt Company Ltd. ** Contact: http://www.qt.io/licensing/ ** ** This file is part of the QtNetwork module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL21$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and The Qt Company. For licensing terms ** and conditions see http://www.qt.io/terms-conditions. For further ** information use the contact form at http://www.qt.io/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 or version 3 as published by the Free ** Software Foundation and appearing in the file LICENSE.LGPLv21 and ** LICENSE.LGPLv3 included in the packaging of this file. Please review the ** following information to ensure the GNU Lesser General Public License ** requirements will be met: https://www.gnu.org/licenses/lgpl.html and ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** As a special exception, The Qt Company gives you certain additional ** rights. These rights are described in The Qt Company LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_comment
comment|//#define QABSTRACTSOCKET_DEBUG
end_comment
begin_comment
comment|/*!     \class QAbstractSocket      \brief The QAbstractSocket class provides the base functionality     common to all socket types.      \reentrant     \ingroup network     \inmodule QtNetwork      QAbstractSocket is the base class for QTcpSocket and QUdpSocket     and contains all common functionality of these two classes. If     you need a socket, you have two options:      \list     \li  Instantiate QTcpSocket or QUdpSocket.     \li  Create a native socket descriptor, instantiate         QAbstractSocket, and call setSocketDescriptor() to wrap the         native socket.     \endlist      TCP (Transmission Control Protocol) is a reliable,     stream-oriented, connection-oriented transport protocol. UDP     (User Datagram Protocol) is an unreliable, datagram-oriented,     connectionless protocol. In practice, this means that TCP is     better suited for continuous transmission of data, whereas the     more lightweight UDP can be used when reliability isn't     important.      QAbstractSocket's API unifies most of the differences between the     two protocols. For example, although UDP is connectionless,     connectToHost() establishes a virtual connection for UDP sockets,     enabling you to use QAbstractSocket in more or less the same way     regardless of the underlying protocol. Internally,     QAbstractSocket remembers the address and port passed to     connectToHost(), and functions like read() and write() use these     values.      At any time, QAbstractSocket has a state (returned by     state()). The initial state is UnconnectedState. After     calling connectToHost(), the socket first enters     HostLookupState. If the host is found, QAbstractSocket enters     ConnectingState and emits the hostFound() signal. When the     connection has been established, it enters ConnectedState and     emits connected(). If an error occurs at any stage, error() is     emitted. Whenever the state changes, stateChanged() is emitted.     For convenience, isValid() returns \c true if the socket is ready for     reading and writing, but note that the socket's state must be     ConnectedState before reading and writing can occur.      Read or write data by calling read() or write(), or use the     convenience functions readLine() and readAll(). QAbstractSocket     also inherits getChar(), putChar(), and ungetChar() from     QIODevice, which work on single bytes. The bytesWritten() signal     is emitted when data has been written to the socket. Note that Qt does     not limit the write buffer size. You can monitor its size by listening     to this signal.      The readyRead() signal is emitted every time a new chunk of data     has arrived. bytesAvailable() then returns the number of bytes     that are available for reading. Typically, you would connect the     readyRead() signal to a slot and read all available data there.     If you don't read all the data at once, the remaining data will     still be available later, and any new incoming data will be     appended to QAbstractSocket's internal read buffer. To limit the     size of the read buffer, call setReadBufferSize().      To close the socket, call disconnectFromHost(). QAbstractSocket enters     QAbstractSocket::ClosingState. After all pending data has been written to     the socket, QAbstractSocket actually closes the socket, enters     QAbstractSocket::ClosedState, and emits disconnected(). If you want to     abort a connection immediately, discarding all pending data, call abort()     instead. If the remote host closes the connection, QAbstractSocket will     emit error(QAbstractSocket::RemoteHostClosedError), during which the socket     state will still be ConnectedState, and then the disconnected() signal     will be emitted.      The port and address of the connected peer is fetched by calling     peerPort() and peerAddress(). peerName() returns the host name of     the peer, as passed to connectToHost(). localPort() and     localAddress() return the port and address of the local socket.      QAbstractSocket provides a set of functions that suspend the     calling thread until certain signals are emitted. These functions     can be used to implement blocking sockets:      \list     \li waitForConnected() blocks until a connection has been established.      \li waitForReadyRead() blocks until new data is available for     reading.      \li waitForBytesWritten() blocks until one payload of data has been     written to the socket.      \li waitForDisconnected() blocks until the connection has closed.     \endlist      We show an example:      \snippet network/tcpwait.cpp 0      If \l{QIODevice::}{waitForReadyRead()} returns \c false, the     connection has been closed or an error has occurred.      Programming with a blocking socket is radically different from     programming with a non-blocking socket. A blocking socket doesn't     require an event loop and typically leads to simpler code.     However, in a GUI application, blocking sockets should only be     used in non-GUI threads, to avoid freezing the user interface.     See the \l fortuneclient and \l blockingfortuneclient     examples for an overview of both approaches.      \note We discourage the use of the blocking functions together     with signals. One of the two possibilities should be used.      QAbstractSocket can be used with QTextStream and QDataStream's     stream operators (operator<<() and operator>>()). There is one     issue to be aware of, though: You must make sure that enough data     is available before attempting to read it using operator>>().      \sa QNetworkAccessManager, QTcpServer */
end_comment
begin_comment
comment|/*!     \fn void QAbstractSocket::hostFound()      This signal is emitted after connectToHost() has been called and     the host lookup has succeeded.      \note Since Qt 4.6.3 QAbstractSocket may emit hostFound()     directly from the connectToHost() call since a DNS result could have been     cached.      \sa connected() */
end_comment
begin_comment
comment|/*!     \fn void QAbstractSocket::connected()      This signal is emitted after connectToHost() has been called and     a connection has been successfully established.      \note On some operating systems the connected() signal may     be directly emitted from the connectToHost() call for connections     to the localhost.      \sa connectToHost(), disconnected() */
end_comment
begin_comment
comment|/*!     \fn void QAbstractSocket::disconnected()      This signal is emitted when the socket has been disconnected.      \warning If you need to delete the sender() of this signal in a slot connected     to it, use the \l{QObject::deleteLater()}{deleteLater()} function.      \sa connectToHost(), disconnectFromHost(), abort() */
end_comment
begin_comment
comment|/*!     \fn void QAbstractSocket::error(QAbstractSocket::SocketError socketError)      This signal is emitted after an error occurred. The \a socketError     parameter describes the type of error that occurred.      When this signal is emitted, the socket may not be ready for a reconnect     attempt. In that case, attempts to reconnect should be done from the event     loop. For example, use a QTimer::singleShot() with 0 as the timeout.      QAbstractSocket::SocketError is not a registered metatype, so for queued     connections, you will have to register it with Q_DECLARE_METATYPE() and     qRegisterMetaType().      \sa error(), errorString(), {Creating Custom Qt Types} */
end_comment
begin_comment
comment|/*!     \fn void QAbstractSocket::stateChanged(QAbstractSocket::SocketState socketState)      This signal is emitted whenever QAbstractSocket's state changes.     The \a socketState parameter is the new state.      QAbstractSocket::SocketState is not a registered metatype, so for queued     connections, you will have to register it with Q_DECLARE_METATYPE() and     qRegisterMetaType().      \sa state(), {Creating Custom Qt Types} */
end_comment
begin_comment
comment|/*!     \fn void QAbstractSocket::proxyAuthenticationRequired(const QNetworkProxy&proxy, QAuthenticator *authenticator)     \since 4.3      This signal can be emitted when a \a proxy that requires     authentication is used. The \a authenticator object can then be     filled in with the required details to allow authentication and     continue the connection.      \note It is not possible to use a QueuedConnection to connect to     this signal, as the connection will fail if the authenticator has     not been filled in with new information when the signal returns.      \sa QAuthenticator, QNetworkProxy */
end_comment
begin_comment
comment|/*!     \enum QAbstractSocket::NetworkLayerProtocol      This enum describes the network layer protocol values used in Qt.      \value IPv4Protocol IPv4     \value IPv6Protocol IPv6     \value AnyIPProtocol Either IPv4 or IPv6     \value UnknownNetworkLayerProtocol Other than IPv4 and IPv6      \sa QHostAddress::protocol() */
end_comment
begin_comment
comment|/*!     \enum QAbstractSocket::SocketType      This enum describes the transport layer protocol.      \value TcpSocket TCP     \value UdpSocket UDP     \value UnknownSocketType Other than TCP and UDP      \sa QAbstractSocket::socketType() */
end_comment
begin_comment
comment|/*!     \enum QAbstractSocket::SocketError      This enum describes the socket errors that can occur.      \value ConnectionRefusedError The connection was refused by the            peer (or timed out).     \value RemoteHostClosedError The remote host closed the            connection. Note that the client socket (i.e., this socket)            will be closed after the remote close notification has            been sent.     \value HostNotFoundError The host address was not found.     \value SocketAccessError The socket operation failed because the            application lacked the required privileges.     \value SocketResourceError The local system ran out of resources            (e.g., too many sockets).     \value SocketTimeoutError The socket operation timed out.     \value DatagramTooLargeError The datagram was larger than the            operating system's limit (which can be as low as 8192            bytes).     \value NetworkError An error occurred with the network (e.g., the            network cable was accidentally plugged out).     \value AddressInUseError The address specified to QAbstractSocket::bind() is            already in use and was set to be exclusive.     \value SocketAddressNotAvailableError The address specified to            QAbstractSocket::bind() does not belong to the host.     \value UnsupportedSocketOperationError The requested socket operation is            not supported by the local operating system (e.g., lack of            IPv6 support).     \value ProxyAuthenticationRequiredError The socket is using a proxy, and            the proxy requires authentication.     \value SslHandshakeFailedError The SSL/TLS handshake failed, so            the connection was closed (only used in QSslSocket)     \value UnfinishedSocketOperationError Used by QAbstractSocketEngine only,            The last operation attempted has not finished yet (still in progress in             the background).     \value ProxyConnectionRefusedError Could not contact the proxy server because            the connection to that server was denied     \value ProxyConnectionClosedError The connection to the proxy server was closed            unexpectedly (before the connection to the final peer was established)     \value ProxyConnectionTimeoutError The connection to the proxy server timed out            or the proxy server stopped responding in the authentication phase.     \value ProxyNotFoundError The proxy address set with setProxy() (or the application            proxy) was not found.     \value ProxyProtocolError The connection negotiation with the proxy server failed,            because the response from the proxy server could not be understood.     \value OperationError An operation was attempted while the socket was in a state that            did not permit it.     \value SslInternalError The SSL library being used reported an internal error. This is            probably the result of a bad installation or misconfiguration of the library.     \value SslInvalidUserDataError Invalid data (certificate, key, cypher, etc.) was            provided and its use resulted in an error in the SSL library.     \value TemporaryError A temporary error occurred (e.g., operation would block and socket            is non-blocking).      \value UnknownSocketError An unidentified error occurred.     \sa QAbstractSocket::error() */
end_comment
begin_comment
comment|/*!     \enum QAbstractSocket::SocketState      This enum describes the different states in which a socket can be.      \value UnconnectedState The socket is not connected.     \value HostLookupState The socket is performing a host name lookup.     \value ConnectingState The socket has started establishing a connection.     \value ConnectedState A connection is established.     \value BoundState The socket is bound to an address and port.     \value ClosingState The socket is about to close (data may still     be waiting to be written).     \value ListeningState For internal use only.      \sa QAbstractSocket::state() */
end_comment
begin_comment
comment|/*!     \enum QAbstractSocket::SocketOption     \since 4.6      This enum represents the options that can be set on a socket.  If     desired, they can be set after having received the connected()     signal from the socket or after having received a new socket from     a QTcpServer.      \value LowDelayOption Try to optimize the socket for low     latency. For a QTcpSocket this would set the TCP_NODELAY option     and disable Nagle's algorithm. Set this to 1 to enable.      \value KeepAliveOption Set this to 1 to enable the SO_KEEPALIVE     socket option      \value MulticastTtlOption Set this to an integer value to set     IP_MULTICAST_TTL (TTL for multicast datagrams) socket option.      \value MulticastLoopbackOption Set this to 1 to enable the     IP_MULTICAST_LOOP (multicast loopback) socket option.      \value TypeOfServiceOption This option is not supported on     Windows. This maps to the IP_TOS socket option. For possible values,     see table below.      \value SendBufferSizeSocketOption Sets the socket send buffer size     in bytes at the OS level. This maps to the SO_SNDBUF socket option.     This option does not affect the QIODevice or QAbstractSocket buffers.     This enum value has been introduced in Qt 5.3.      \value ReceiveBufferSizeSocketOption Sets the socket receive     buffer size in bytes at the OS level.     This maps to the SO_RCVBUF socket option.     This option does not affect the QIODevice or QAbstractSocket buffers     (see \l{QAbstractSocket::}{setReadBufferSize()}).     This enum value has been introduced in Qt 5.3.      Possible values for \e{TypeOfServiceOption} are:      \table     \header \li Value \li Description     \row \li 224 \li Network control     \row \li 192 \li Internetwork control     \row \li 160 \li CRITIC/ECP     \row \li 128 \li Flash override     \row \li 96 \li Flash     \row \li 64 \li Immediate     \row \li 32 \li Priority     \row \li 0 \li Routine     \endtable      \sa QAbstractSocket::setSocketOption(), QAbstractSocket::socketOption() */
end_comment
begin_comment
comment|/*! \enum QAbstractSocket::BindFlag     \since 5.0      This enum describes the different flags you can pass to modify the     behavior of QAbstractSocket::bind().      \value ShareAddress Allow other services to bind to the same address     and port. This is useful when multiple processes share     the load of a single service by listening to the same address and port     (e.g., a web server with several pre-forked listeners can greatly     improve response time). However, because any service is allowed to     rebind, this option is subject to certain security considerations.     Note that by combining this option with ReuseAddressHint, you will     also allow your service to rebind an existing shared address. On     Unix, this is equivalent to the SO_REUSEADDR socket option. On Windows,     this option is ignored.      \value DontShareAddress Bind the address and port exclusively, so that     no other services are allowed to rebind. By passing this option to     QAbstractSocket::bind(), you are guaranteed that on successs, your service     is the only one that listens to the address and port. No services are     allowed to rebind, even if they pass ReuseAddressHint. This option     provides more security than ShareAddress, but on certain operating     systems, it requires you to run the server with administrator privileges.     On Unix and Mac OS X, not sharing is the default behavior for binding     an address and port, so this option is ignored. On Windows, this     option uses the SO_EXCLUSIVEADDRUSE socket option.      \value ReuseAddressHint Provides a hint to QAbstractSocket that it should try     to rebind the service even if the address and port are already bound by     another socket. On Windows, this is equivalent to the SO_REUSEADDR     socket option. On Unix, this option is ignored.      \value DefaultForPlatform The default option for the current platform.     On Unix and Mac OS X, this is equivalent to (DontShareAddress     + ReuseAddressHint), and on Windows, its equivalent to ShareAddress. */
end_comment
begin_comment
comment|/*! \enum QAbstractSocket::PauseMode     \since 5.0      This enum describes the behavior of when the socket should hold     back with continuing data transfer.     The only notification currently supported is QSslSocket::sslErrors().      \value PauseNever Do not pause data transfer on the socket. This is the     default and matches the behaviour of Qt 4.     \value PauseOnSslErrors Pause data transfer on the socket upon receiving an     SSL error notification. I.E. QSslSocket::sslErrors(). */
end_comment
begin_include
include|#
directive|include
file|"qabstractsocket.h"
end_include
begin_include
include|#
directive|include
file|"qabstractsocket_p.h"
end_include
begin_include
include|#
directive|include
file|"private/qhostinfo_p.h"
end_include
begin_include
include|#
directive|include
file|"private/qnetworksession_p.h"
end_include
begin_include
include|#
directive|include
file|<qabstracteventdispatcher.h>
end_include
begin_include
include|#
directive|include
file|<qhostaddress.h>
end_include
begin_include
include|#
directive|include
file|<qhostinfo.h>
end_include
begin_include
include|#
directive|include
file|<qmetaobject.h>
end_include
begin_include
include|#
directive|include
file|<qpointer.h>
end_include
begin_include
include|#
directive|include
file|<qtimer.h>
end_include
begin_include
include|#
directive|include
file|<qelapsedtimer.h>
end_include
begin_include
include|#
directive|include
file|<qscopedvaluerollback.h>
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_SSL
end_ifndef
begin_include
include|#
directive|include
file|<QtNetwork/qsslsocket.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<private/qthread_p.h>
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|QABSTRACTSOCKET_DEBUG
end_ifdef
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|<time.h>
end_include
begin_define
DECL|macro|Q_CHECK_SOCKETENGINE
define|#
directive|define
name|Q_CHECK_SOCKETENGINE
parameter_list|(
name|returnValue
parameter_list|)
value|do { \     if (!d->socketEngine) { \         return returnValue; \     } } while (0)
end_define
begin_ifndef
ifndef|#
directive|ifndef
name|QABSTRACTSOCKET_BUFFERSIZE
end_ifndef
begin_define
DECL|macro|QABSTRACTSOCKET_BUFFERSIZE
define|#
directive|define
name|QABSTRACTSOCKET_BUFFERSIZE
value|32768
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_define
DECL|macro|QT_CONNECT_TIMEOUT
define|#
directive|define
name|QT_CONNECT_TIMEOUT
value|30000
end_define
begin_define
DECL|macro|QT_TRANSFER_TIMEOUT
define|#
directive|define
name|QT_TRANSFER_TIMEOUT
value|120000
end_define
begin_function
name|QT_BEGIN_NAMESPACE
if|#
directive|if
name|defined
name|QABSTRACTSOCKET_DEBUG
name|QT_BEGIN_INCLUDE_NAMESPACE
include|#
directive|include
file|<qstring.h>
include|#
directive|include
file|<ctype.h>
name|QT_END_INCLUDE_NAMESPACE
comment|/*     Returns a human readable representation of the first \a len     characters in \a data. */
DECL|function|qt_prettyDebug
specifier|static
name|QByteArray
name|qt_prettyDebug
parameter_list|(
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|maxLength
parameter_list|)
block|{
if|if
condition|(
operator|!
name|data
condition|)
return|return
literal|"(null)"
return|;
name|QByteArray
name|out
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|qMin
argument_list|(
name|len
argument_list|,
name|maxLength
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|char
name|c
init|=
name|data
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|isprint
argument_list|(
name|int
argument_list|(
name|uchar
argument_list|(
name|c
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
name|out
operator|+=
name|c
expr_stmt|;
block|}
else|else
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
name|out
operator|+=
literal|"\\n"
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|out
operator|+=
literal|"\\r"
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|out
operator|+=
literal|"\\t"
expr_stmt|;
break|break;
default|default:
name|QString
name|tmp
decl_stmt|;
name|tmp
operator|.
name|sprintf
argument_list|(
literal|"\\%o"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|out
operator|+=
name|tmp
operator|.
name|toLatin1
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|len
operator|<
name|maxLength
condition|)
name|out
operator|+=
literal|"..."
expr_stmt|;
return|return
name|out
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|isProxyError
specifier|static
name|bool
name|isProxyError
parameter_list|(
name|QAbstractSocket
operator|::
name|SocketError
name|error
parameter_list|)
block|{
switch|switch
condition|(
name|error
condition|)
block|{
case|case
name|QAbstractSocket
operator|::
name|ProxyAuthenticationRequiredError
case|:
case|case
name|QAbstractSocket
operator|::
name|ProxyConnectionRefusedError
case|:
case|case
name|QAbstractSocket
operator|::
name|ProxyConnectionClosedError
case|:
case|case
name|QAbstractSocket
operator|::
name|ProxyConnectionTimeoutError
case|:
case|case
name|QAbstractSocket
operator|::
name|ProxyNotFoundError
case|:
case|case
name|QAbstractSocket
operator|::
name|ProxyProtocolError
case|:
return|return
literal|true
return|;
default|default:
return|return
literal|false
return|;
block|}
block|}
end_function
begin_comment
comment|/*! \internal      Constructs a QAbstractSocketPrivate. Initializes all members. */
end_comment
begin_constructor
DECL|function|QAbstractSocketPrivate
name|QAbstractSocketPrivate
operator|::
name|QAbstractSocketPrivate
parameter_list|()
member_init_list|:
name|readSocketNotifierCalled
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|readSocketNotifierState
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|readSocketNotifierStateSet
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|emittedReadyRead
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|emittedBytesWritten
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|abortCalled
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|closeCalled
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|pendingClose
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|pauseMode
argument_list|(
name|QAbstractSocket
operator|::
name|PauseNever
argument_list|)
member_init_list|,
name|port
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|localPort
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|peerPort
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|socketEngine
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|cachedSocketDescriptor
argument_list|(
operator|-
literal|1
argument_list|)
member_init_list|,
name|readBufferMaxSize
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|writeBuffer
argument_list|(
name|QABSTRACTSOCKET_BUFFERSIZE
argument_list|)
member_init_list|,
name|isBuffered
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|blockingTimeout
argument_list|(
literal|30000
argument_list|)
member_init_list|,
name|connectTimer
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|disconnectTimer
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|connectTimeElapsed
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|hostLookupId
argument_list|(
operator|-
literal|1
argument_list|)
member_init_list|,
name|socketType
argument_list|(
name|QAbstractSocket
operator|::
name|UnknownSocketType
argument_list|)
member_init_list|,
name|state
argument_list|(
name|QAbstractSocket
operator|::
name|UnconnectedState
argument_list|)
member_init_list|,
name|socketError
argument_list|(
name|QAbstractSocket
operator|::
name|UnknownSocketError
argument_list|)
member_init_list|,
name|preferredNetworkLayerProtocol
argument_list|(
name|QAbstractSocket
operator|::
name|UnknownNetworkLayerProtocol
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*! \internal      Destructs the QAbstractSocket. If the socket layer is open, it     will be reset. */
end_comment
begin_destructor
DECL|function|~QAbstractSocketPrivate
name|QAbstractSocketPrivate
operator|::
name|~
name|QAbstractSocketPrivate
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*! \internal      Resets the socket layer and deletes any socket notifiers. */
end_comment
begin_function
DECL|function|resetSocketLayer
name|void
name|QAbstractSocketPrivate
operator|::
name|resetSocketLayer
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|QABSTRACTSOCKET_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QAbstractSocketPrivate::resetSocketLayer()"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|socketEngine
condition|)
block|{
name|socketEngine
operator|->
name|close
argument_list|()
expr_stmt|;
name|socketEngine
operator|->
name|disconnect
argument_list|()
expr_stmt|;
operator|delete
name|socketEngine
expr_stmt|;
name|socketEngine
operator|=
literal|0
expr_stmt|;
name|cachedSocketDescriptor
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|connectTimer
condition|)
name|connectTimer
operator|->
name|stop
argument_list|()
expr_stmt|;
if|if
condition|(
name|disconnectTimer
condition|)
name|disconnectTimer
operator|->
name|stop
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \internal      Initializes the socket layer to by of type \a type, using the     network layer protocol \a protocol. Resets the socket layer first     if it's already initialized. Sets up the socket notifiers. */
end_comment
begin_function
DECL|function|initSocketLayer
name|bool
name|QAbstractSocketPrivate
operator|::
name|initSocketLayer
parameter_list|(
name|QAbstractSocket
operator|::
name|NetworkLayerProtocol
name|protocol
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|QT_NO_NETWORKPROXY
comment|// this is here to avoid a duplication of the call to createSocketEngine below
specifier|static
specifier|const
name|QNetworkProxy
modifier|&
name|proxyInUse
init|=
operator|*
operator|(
name|QNetworkProxy
operator|*
operator|)
literal|0
decl_stmt|;
endif|#
directive|endif
name|Q_Q
argument_list|(
name|QAbstractSocket
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QABSTRACTSOCKET_DEBUG
argument_list|)
name|QString
name|typeStr
decl_stmt|;
if|if
condition|(
name|q
operator|->
name|socketType
argument_list|()
operator|==
name|QAbstractSocket
operator|::
name|TcpSocket
condition|)
name|typeStr
operator|=
name|QLatin1String
argument_list|(
literal|"TcpSocket"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|q
operator|->
name|socketType
argument_list|()
operator|==
name|QAbstractSocket
operator|::
name|UdpSocket
condition|)
name|typeStr
operator|=
name|QLatin1String
argument_list|(
literal|"UdpSocket"
argument_list|)
expr_stmt|;
else|else
name|typeStr
operator|=
name|QLatin1String
argument_list|(
literal|"UnknownSocketType"
argument_list|)
expr_stmt|;
name|QString
name|protocolStr
decl_stmt|;
if|if
condition|(
name|protocol
operator|==
name|QAbstractSocket
operator|::
name|IPv4Protocol
condition|)
name|protocolStr
operator|=
name|QLatin1String
argument_list|(
literal|"IPv4Protocol"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|protocol
operator|==
name|QAbstractSocket
operator|::
name|IPv6Protocol
condition|)
name|protocolStr
operator|=
name|QLatin1String
argument_list|(
literal|"IPv6Protocol"
argument_list|)
expr_stmt|;
else|else
name|protocolStr
operator|=
name|QLatin1String
argument_list|(
literal|"UnknownNetworkLayerProtocol"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|resetSocketLayer
argument_list|()
expr_stmt|;
name|socketEngine
operator|=
name|QAbstractSocketEngine
operator|::
name|createSocketEngine
argument_list|(
name|q
operator|->
name|socketType
argument_list|()
argument_list|,
name|proxyInUse
argument_list|,
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|socketEngine
condition|)
block|{
name|socketError
operator|=
name|QAbstractSocket
operator|::
name|UnsupportedSocketOperationError
expr_stmt|;
name|q
operator|->
name|setErrorString
argument_list|(
name|QAbstractSocket
operator|::
name|tr
argument_list|(
literal|"Operation on socket is not supported"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
ifndef|#
directive|ifndef
name|QT_NO_BEARERMANAGEMENT
comment|//copy network session down to the socket engine (if it has been set)
name|socketEngine
operator|->
name|setProperty
argument_list|(
literal|"_q_networksession"
argument_list|,
name|q
operator|->
name|property
argument_list|(
literal|"_q_networksession"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|socketEngine
operator|->
name|initialize
argument_list|(
name|q
operator|->
name|socketType
argument_list|()
argument_list|,
name|protocol
argument_list|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|QABSTRACTSOCKET_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QAbstractSocketPrivate::initSocketLayer(%s, %s) failed (%s)"
argument_list|,
name|typeStr
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|protocolStr
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|socketEngine
operator|->
name|errorString
argument_list|()
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|socketError
operator|=
name|socketEngine
operator|->
name|error
argument_list|()
expr_stmt|;
name|q
operator|->
name|setErrorString
argument_list|(
name|socketEngine
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|threadData
operator|->
name|hasEventDispatcher
argument_list|()
condition|)
name|socketEngine
operator|->
name|setReceiver
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QABSTRACTSOCKET_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QAbstractSocketPrivate::initSocketLayer(%s, %s) success"
argument_list|,
name|typeStr
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|protocolStr
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*! \internal      Slot connected to the read socket notifier. This slot is called     when new data is available for reading, or when the socket has     been closed. Handles recursive calls. */
end_comment
begin_function
DECL|function|canReadNotification
name|bool
name|QAbstractSocketPrivate
operator|::
name|canReadNotification
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QAbstractSocket
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QABSTRACTSOCKET_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QAbstractSocketPrivate::canReadNotification()"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// Prevent recursive calls
if|if
condition|(
name|readSocketNotifierCalled
condition|)
block|{
if|if
condition|(
operator|!
name|readSocketNotifierStateSet
condition|)
block|{
name|readSocketNotifierStateSet
operator|=
literal|true
expr_stmt|;
name|readSocketNotifierState
operator|=
name|socketEngine
operator|->
name|isReadNotificationEnabled
argument_list|()
expr_stmt|;
name|socketEngine
operator|->
name|setReadNotificationEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
name|QScopedValueRollback
argument_list|<
name|bool
argument_list|>
name|rsncrollback
argument_list|(
name|readSocketNotifierCalled
argument_list|)
decl_stmt|;
name|readSocketNotifierCalled
operator|=
literal|true
expr_stmt|;
if|if
condition|(
operator|!
name|isBuffered
condition|)
name|socketEngine
operator|->
name|setReadNotificationEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
comment|// If buffered, read data from the socket into the read buffer
name|qint64
name|newBytes
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|isBuffered
condition|)
block|{
comment|// Return if there is no space in the buffer
if|if
condition|(
name|readBufferMaxSize
operator|&&
name|buffer
operator|.
name|size
argument_list|()
operator|>=
name|readBufferMaxSize
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|QABSTRACTSOCKET_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QAbstractSocketPrivate::canReadNotification() buffer is full"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|false
return|;
block|}
comment|// If reading from the socket fails after getting a read
comment|// notification, close the socket.
name|newBytes
operator|=
name|buffer
operator|.
name|size
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|readFromSocket
argument_list|()
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|QABSTRACTSOCKET_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QAbstractSocketPrivate::canReadNotification() disconnecting socket"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|q
operator|->
name|disconnectFromHost
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
name|newBytes
operator|=
name|buffer
operator|.
name|size
argument_list|()
operator|-
name|newBytes
expr_stmt|;
comment|// If read buffer is full, disable the read socket notifier.
if|if
condition|(
name|readBufferMaxSize
operator|&&
name|buffer
operator|.
name|size
argument_list|()
operator|==
name|readBufferMaxSize
condition|)
block|{
name|socketEngine
operator|->
name|setReadNotificationEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
block|}
comment|// only emit readyRead() when not recursing, and only if there is data available
name|bool
name|hasData
init|=
name|newBytes
operator|>
literal|0
ifndef|#
directive|ifndef
name|QT_NO_UDPSOCKET
operator|||
operator|(
operator|!
name|isBuffered
operator|&&
name|socketType
operator|!=
name|QAbstractSocket
operator|::
name|TcpSocket
operator|&&
name|socketEngine
operator|&&
name|socketEngine
operator|->
name|hasPendingDatagrams
argument_list|()
operator|)
endif|#
directive|endif
operator|||
operator|(
operator|!
name|isBuffered
operator|&&
name|socketType
operator|==
name|QAbstractSocket
operator|::
name|TcpSocket
operator|&&
name|socketEngine
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|emittedReadyRead
operator|&&
name|hasData
condition|)
block|{
name|QScopedValueRollback
argument_list|<
name|bool
argument_list|>
name|r
argument_list|(
name|emittedReadyRead
argument_list|)
decl_stmt|;
name|emittedReadyRead
operator|=
literal|true
expr_stmt|;
emit|emit
name|q
operator|->
name|readyRead
argument_list|()
emit|;
block|}
comment|// If we were closed as a result of the readyRead() signal,
comment|// return.
if|if
condition|(
name|state
operator|==
name|QAbstractSocket
operator|::
name|UnconnectedState
operator|||
name|state
operator|==
name|QAbstractSocket
operator|::
name|ClosingState
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|QABSTRACTSOCKET_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QAbstractSocketPrivate::canReadNotification() socket is closing - returning"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|true
return|;
block|}
if|if
condition|(
name|socketEngine
condition|)
block|{
comment|// turn the socket engine off if we've either:
comment|// - got pending datagrams
comment|// - reached the buffer size limit
if|if
condition|(
name|isBuffered
condition|)
name|socketEngine
operator|->
name|setReadNotificationEnabled
argument_list|(
name|readBufferMaxSize
operator|==
literal|0
operator|||
name|readBufferMaxSize
operator|>
name|q
operator|->
name|bytesAvailable
argument_list|()
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|socketType
operator|!=
name|QAbstractSocket
operator|::
name|TcpSocket
condition|)
name|socketEngine
operator|->
name|setReadNotificationEnabled
argument_list|(
operator|!
name|socketEngine
operator|->
name|hasPendingDatagrams
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// reset the read socket notifier state if we reentered inside the
comment|// readyRead() connected slot.
if|if
condition|(
name|readSocketNotifierStateSet
operator|&&
name|socketEngine
operator|&&
name|readSocketNotifierState
operator|!=
name|socketEngine
operator|->
name|isReadNotificationEnabled
argument_list|()
condition|)
block|{
name|socketEngine
operator|->
name|setReadNotificationEnabled
argument_list|(
name|readSocketNotifierState
argument_list|)
expr_stmt|;
name|readSocketNotifierStateSet
operator|=
literal|false
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*! \internal      Slot connected to the close socket notifier. It's called when the     socket is closed. */
end_comment
begin_function
DECL|function|canCloseNotification
name|void
name|QAbstractSocketPrivate
operator|::
name|canCloseNotification
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QAbstractSocket
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QABSTRACTSOCKET_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QAbstractSocketPrivate::canCloseNotification()"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|qint64
name|newBytes
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|isBuffered
condition|)
block|{
comment|// Try to read to the buffer, if the read fail we can close the socket.
name|newBytes
operator|=
name|buffer
operator|.
name|size
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|readFromSocket
argument_list|()
condition|)
block|{
name|q
operator|->
name|disconnectFromHost
argument_list|()
expr_stmt|;
return|return;
block|}
name|newBytes
operator|=
name|buffer
operator|.
name|size
argument_list|()
operator|-
name|newBytes
expr_stmt|;
if|if
condition|(
name|newBytes
condition|)
block|{
comment|// If there was still some data to be read from the socket
comment|// then we could get another FD_READ. The disconnect will
comment|// then occur when we read from the socket again and fail
comment|// in canReadNotification or by the manually created
comment|// closeNotification below.
emit|emit
name|q
operator|->
name|readyRead
argument_list|()
emit|;
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|socketEngine
argument_list|,
literal|"closeNotification"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|socketType
operator|==
name|QAbstractSocket
operator|::
name|TcpSocket
operator|&&
name|socketEngine
condition|)
block|{
emit|emit
name|q
operator|->
name|readyRead
argument_list|()
emit|;
block|}
block|}
end_function
begin_comment
comment|/*! \internal      Slot connected to the write socket notifier. It's called during a     delayed connect or when the socket is ready for writing. */
end_comment
begin_function
DECL|function|canWriteNotification
name|bool
name|QAbstractSocketPrivate
operator|::
name|canWriteNotification
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
if|if
condition|(
name|socketEngine
operator|&&
name|socketEngine
operator|->
name|isWriteNotificationEnabled
argument_list|()
condition|)
name|socketEngine
operator|->
name|setWriteNotificationEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|QABSTRACTSOCKET_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QAbstractSocketPrivate::canWriteNotification() flushing"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|int
name|tmp
init|=
name|writeBuffer
operator|.
name|size
argument_list|()
decl_stmt|;
name|flush
argument_list|()
expr_stmt|;
if|if
condition|(
name|socketEngine
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
if|if
condition|(
operator|!
name|writeBuffer
operator|.
name|isEmpty
argument_list|()
condition|)
name|socketEngine
operator|->
name|setWriteNotificationEnabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|writeBuffer
operator|.
name|isEmpty
argument_list|()
operator|&&
name|socketEngine
operator|->
name|bytesToWrite
argument_list|()
operator|==
literal|0
condition|)
name|socketEngine
operator|->
name|setWriteNotificationEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
operator|(
name|writeBuffer
operator|.
name|size
argument_list|()
operator|<
name|tmp
operator|)
return|;
block|}
end_function
begin_comment
comment|/*! \internal      Slot connected to a notification of connection status     change. Either we finished connecting or we failed to connect. */
end_comment
begin_function
DECL|function|connectionNotification
name|void
name|QAbstractSocketPrivate
operator|::
name|connectionNotification
parameter_list|()
block|{
comment|// If in connecting state, check if the connection has been
comment|// established, otherwise flush pending data.
if|if
condition|(
name|state
operator|==
name|QAbstractSocket
operator|::
name|ConnectingState
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|QABSTRACTSOCKET_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QAbstractSocketPrivate::connectionNotification() testing connection"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|_q_testConnection
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*! \internal      Writes pending data in the write buffers to the socket. The     function writes as much as it can without blocking.      It is usually invoked by canWriteNotification after one or more     calls to write().      Emits bytesWritten(). */
end_comment
begin_function
DECL|function|flush
name|bool
name|QAbstractSocketPrivate
operator|::
name|flush
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QAbstractSocket
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|socketEngine
operator|||
operator|!
name|socketEngine
operator|->
name|isValid
argument_list|()
operator|||
operator|(
name|writeBuffer
operator|.
name|isEmpty
argument_list|()
operator|&&
name|socketEngine
operator|->
name|bytesToWrite
argument_list|()
operator|==
literal|0
operator|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|QABSTRACTSOCKET_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QAbstractSocketPrivate::flush() nothing to do: valid ? %s, writeBuffer.isEmpty() ? %s"
argument_list|,
operator|(
name|socketEngine
operator|&&
name|socketEngine
operator|->
name|isValid
argument_list|()
operator|)
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|,
name|writeBuffer
operator|.
name|isEmpty
argument_list|()
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// this covers the case when the buffer was empty, but we had to wait for the socket engine to finish
if|if
condition|(
name|state
operator|==
name|QAbstractSocket
operator|::
name|ClosingState
condition|)
name|q
operator|->
name|disconnectFromHost
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
name|int
name|nextSize
init|=
name|writeBuffer
operator|.
name|nextDataBlockSize
argument_list|()
decl_stmt|;
specifier|const
name|char
modifier|*
name|ptr
init|=
name|writeBuffer
operator|.
name|readPointer
argument_list|()
decl_stmt|;
comment|// Attempt to write it all in one chunk.
name|qint64
name|written
init|=
name|socketEngine
operator|->
name|write
argument_list|(
name|ptr
argument_list|,
name|nextSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|written
operator|<
literal|0
condition|)
block|{
name|socketError
operator|=
name|socketEngine
operator|->
name|error
argument_list|()
expr_stmt|;
name|q
operator|->
name|setErrorString
argument_list|(
name|socketEngine
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QABSTRACTSOCKET_DEBUG
argument_list|)
name|qDebug
argument_list|()
operator|<<
literal|"QAbstractSocketPrivate::flush() write error, aborting."
operator|<<
name|socketEngine
operator|->
name|errorString
argument_list|()
expr_stmt|;
endif|#
directive|endif
emit|emit
name|q
operator|->
name|error
argument_list|(
name|socketError
argument_list|)
emit|;
comment|// an unexpected error so close the socket.
name|q
operator|->
name|abort
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|QABSTRACTSOCKET_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QAbstractSocketPrivate::flush() %lld bytes written to the network"
argument_list|,
name|written
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// Remove what we wrote so far.
name|writeBuffer
operator|.
name|free
argument_list|(
name|written
argument_list|)
expr_stmt|;
if|if
condition|(
name|written
operator|>
literal|0
condition|)
block|{
comment|// Don't emit bytesWritten() recursively.
if|if
condition|(
operator|!
name|emittedBytesWritten
condition|)
block|{
name|QScopedValueRollback
argument_list|<
name|bool
argument_list|>
name|r
argument_list|(
name|emittedBytesWritten
argument_list|)
decl_stmt|;
name|emittedBytesWritten
operator|=
literal|true
expr_stmt|;
emit|emit
name|q
operator|->
name|bytesWritten
argument_list|(
name|written
argument_list|)
emit|;
block|}
block|}
if|if
condition|(
name|writeBuffer
operator|.
name|isEmpty
argument_list|()
operator|&&
name|socketEngine
operator|&&
name|socketEngine
operator|->
name|isWriteNotificationEnabled
argument_list|()
operator|&&
operator|!
name|socketEngine
operator|->
name|bytesToWrite
argument_list|()
condition|)
name|socketEngine
operator|->
name|setWriteNotificationEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|QAbstractSocket
operator|::
name|ClosingState
condition|)
name|q
operator|->
name|disconnectFromHost
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
end_ifndef
begin_comment
comment|/*! \internal      Resolve the proxy to its final value. */
end_comment
begin_function
DECL|function|resolveProxy
name|void
name|QAbstractSocketPrivate
operator|::
name|resolveProxy
parameter_list|(
specifier|const
name|QString
modifier|&
name|hostname
parameter_list|,
name|quint16
name|port
parameter_list|)
block|{
name|QList
argument_list|<
name|QNetworkProxy
argument_list|>
name|proxies
decl_stmt|;
if|if
condition|(
name|proxy
operator|.
name|type
argument_list|()
operator|!=
name|QNetworkProxy
operator|::
name|DefaultProxy
condition|)
block|{
comment|// a non-default proxy was set with setProxy
name|proxies
operator|<<
name|proxy
expr_stmt|;
block|}
else|else
block|{
comment|// try the application settings instead
name|QNetworkProxyQuery
name|query
argument_list|(
name|hostname
argument_list|,
name|port
argument_list|,
name|QString
argument_list|()
argument_list|,
name|socketType
operator|==
name|QAbstractSocket
operator|::
name|TcpSocket
condition|?
name|QNetworkProxyQuery
operator|::
name|TcpSocket
else|:
name|QNetworkProxyQuery
operator|::
name|UdpSocket
argument_list|)
decl_stmt|;
name|proxies
operator|=
name|QNetworkProxyFactory
operator|::
name|proxyForQuery
argument_list|(
name|query
argument_list|)
expr_stmt|;
block|}
comment|// return the first that we can use
foreach|foreach
control|(
specifier|const
name|QNetworkProxy
modifier|&
name|p
decl|,
name|proxies
control|)
block|{
if|if
condition|(
name|socketType
operator|==
name|QAbstractSocket
operator|::
name|UdpSocket
operator|&&
operator|(
name|p
operator|.
name|capabilities
argument_list|()
operator|&
name|QNetworkProxy
operator|::
name|UdpTunnelingCapability
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|socketType
operator|==
name|QAbstractSocket
operator|::
name|TcpSocket
operator|&&
operator|(
name|p
operator|.
name|capabilities
argument_list|()
operator|&
name|QNetworkProxy
operator|::
name|TunnelingCapability
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|proxyInUse
operator|=
name|p
expr_stmt|;
return|return;
block|}
comment|// no proxy found
comment|// DefaultProxy here will raise an error
name|proxyInUse
operator|=
name|QNetworkProxy
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal      Starts the connection to \a host, like _q_startConnecting below,     but without hostname resolution. */
end_comment
begin_function
DECL|function|startConnectingByName
name|void
name|QAbstractSocketPrivate
operator|::
name|startConnectingByName
parameter_list|(
specifier|const
name|QString
modifier|&
name|host
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QAbstractSocket
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|QAbstractSocket
operator|::
name|ConnectingState
operator|||
name|state
operator|==
name|QAbstractSocket
operator|::
name|ConnectedState
condition|)
return|return;
if|#
directive|if
name|defined
argument_list|(
name|QABSTRACTSOCKET_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QAbstractSocketPrivate::startConnectingByName(host == %s)"
argument_list|,
name|qPrintable
argument_list|(
name|host
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// ### Let the socket engine drive this?
name|state
operator|=
name|QAbstractSocket
operator|::
name|ConnectingState
expr_stmt|;
emit|emit
name|q
operator|->
name|stateChanged
argument_list|(
name|state
argument_list|)
emit|;
name|connectTimeElapsed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|initSocketLayer
argument_list|(
name|QAbstractSocket
operator|::
name|UnknownNetworkLayerProtocol
argument_list|)
condition|)
block|{
if|if
condition|(
name|socketEngine
operator|->
name|connectToHostByName
argument_list|(
name|host
argument_list|,
name|port
argument_list|)
operator|||
name|socketEngine
operator|->
name|state
argument_list|()
operator|==
name|QAbstractSocket
operator|::
name|ConnectingState
condition|)
block|{
name|cachedSocketDescriptor
operator|=
name|socketEngine
operator|->
name|socketDescriptor
argument_list|()
expr_stmt|;
return|return;
block|}
comment|// failed to connect
name|socketError
operator|=
name|socketEngine
operator|->
name|error
argument_list|()
expr_stmt|;
name|q
operator|->
name|setErrorString
argument_list|(
name|socketEngine
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|state
operator|=
name|QAbstractSocket
operator|::
name|UnconnectedState
expr_stmt|;
emit|emit
name|q
operator|->
name|error
argument_list|(
name|socketError
argument_list|)
emit|;
emit|emit
name|q
operator|->
name|stateChanged
argument_list|(
name|state
argument_list|)
emit|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*! \internal      Slot connected to QHostInfo::lookupHost() in connectToHost(). This     function starts the process of connecting to any number of     candidate IP addresses for the host, if it was found. Calls     _q_connectToNextAddress(). */
end_comment
begin_function
DECL|function|_q_startConnecting
name|void
name|QAbstractSocketPrivate
operator|::
name|_q_startConnecting
parameter_list|(
specifier|const
name|QHostInfo
modifier|&
name|hostInfo
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QAbstractSocket
argument_list|)
expr_stmt|;
name|addresses
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|state
operator|!=
name|QAbstractSocket
operator|::
name|HostLookupState
condition|)
return|return;
if|if
condition|(
name|hostLookupId
operator|!=
operator|-
literal|1
operator|&&
name|hostLookupId
operator|!=
name|hostInfo
operator|.
name|lookupId
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QAbstractSocketPrivate::_q_startConnecting() received hostInfo for wrong lookup ID %d expected %d"
argument_list|,
name|hostInfo
operator|.
name|lookupId
argument_list|()
argument_list|,
name|hostLookupId
argument_list|)
expr_stmt|;
block|}
comment|// Only add the addresses for the preferred network layer.
comment|// Or all if preferred network layer is not set.
if|if
condition|(
name|preferredNetworkLayerProtocol
operator|==
name|QAbstractSocket
operator|::
name|UnknownNetworkLayerProtocol
operator|||
name|preferredNetworkLayerProtocol
operator|==
name|QAbstractSocket
operator|::
name|AnyIPProtocol
condition|)
block|{
name|addresses
operator|=
name|hostInfo
operator|.
name|addresses
argument_list|()
expr_stmt|;
block|}
else|else
block|{
foreach|foreach
control|(
specifier|const
name|QHostAddress
modifier|&
name|address
decl|,
name|hostInfo
operator|.
name|addresses
argument_list|()
control|)
if|if
condition|(
name|address
operator|.
name|protocol
argument_list|()
operator|==
name|preferredNetworkLayerProtocol
condition|)
name|addresses
operator|+=
name|address
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|QABSTRACTSOCKET_DEBUG
argument_list|)
name|QString
name|s
init|=
name|QLatin1String
argument_list|(
literal|"{"
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|addresses
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|s
operator|+=
name|QLatin1String
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|s
operator|+=
name|addresses
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|toString
argument_list|()
expr_stmt|;
block|}
name|s
operator|+=
name|QLatin1Char
argument_list|(
literal|'}'
argument_list|)
expr_stmt|;
name|qDebug
argument_list|(
literal|"QAbstractSocketPrivate::_q_startConnecting(hostInfo == %s)"
argument_list|,
name|s
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// Try all addresses twice.
name|addresses
operator|+=
name|addresses
expr_stmt|;
comment|// If there are no addresses in the host list, report this to the
comment|// user.
if|if
condition|(
name|addresses
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|QABSTRACTSOCKET_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QAbstractSocketPrivate::_q_startConnecting(), host not found"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|state
operator|=
name|QAbstractSocket
operator|::
name|UnconnectedState
expr_stmt|;
name|socketError
operator|=
name|QAbstractSocket
operator|::
name|HostNotFoundError
expr_stmt|;
name|q
operator|->
name|setErrorString
argument_list|(
name|QAbstractSocket
operator|::
name|tr
argument_list|(
literal|"Host not found"
argument_list|)
argument_list|)
expr_stmt|;
emit|emit
name|q
operator|->
name|stateChanged
argument_list|(
name|state
argument_list|)
emit|;
emit|emit
name|q
operator|->
name|error
argument_list|(
name|QAbstractSocket
operator|::
name|HostNotFoundError
argument_list|)
emit|;
return|return;
block|}
comment|// Enter Connecting state (see also sn_write, which is called by
comment|// the write socket notifier after connect())
name|state
operator|=
name|QAbstractSocket
operator|::
name|ConnectingState
expr_stmt|;
emit|emit
name|q
operator|->
name|stateChanged
argument_list|(
name|state
argument_list|)
emit|;
comment|// Report the successful host lookup
emit|emit
name|q
operator|->
name|hostFound
argument_list|()
emit|;
comment|// Reset the total time spent connecting.
name|connectTimeElapsed
operator|=
literal|0
expr_stmt|;
comment|// The addresses returned by the lookup will be tested one after
comment|// another by _q_connectToNextAddress().
name|_q_connectToNextAddress
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \internal      Called by a queued or direct connection from _q_startConnecting() or     _q_testConnection(), this function takes the first address of the     pending addresses list and tries to connect to it. If the     connection succeeds, QAbstractSocket will emit     connected(). Otherwise, error(ConnectionRefusedError) or     error(SocketTimeoutError) is emitted. */
end_comment
begin_function
DECL|function|_q_connectToNextAddress
name|void
name|QAbstractSocketPrivate
operator|::
name|_q_connectToNextAddress
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QAbstractSocket
argument_list|)
expr_stmt|;
do|do
block|{
comment|// Check for more pending addresses
if|if
condition|(
name|addresses
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|QABSTRACTSOCKET_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QAbstractSocketPrivate::_q_connectToNextAddress(), all addresses failed."
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|state
operator|=
name|QAbstractSocket
operator|::
name|UnconnectedState
expr_stmt|;
if|if
condition|(
name|socketEngine
condition|)
block|{
if|if
condition|(
operator|(
name|socketEngine
operator|->
name|error
argument_list|()
operator|==
name|QAbstractSocket
operator|::
name|UnknownSocketError
ifdef|#
directive|ifdef
name|Q_OS_AIX
comment|// On AIX, the second connect call will result in EINVAL and not
comment|// ECONNECTIONREFUSED; although the meaning is the same.
operator|||
name|socketEngine
operator|->
name|error
argument_list|()
operator|==
name|QAbstractSocket
operator|::
name|UnsupportedSocketOperationError
endif|#
directive|endif
operator|)
operator|&&
name|socketEngine
operator|->
name|state
argument_list|()
operator|==
name|QAbstractSocket
operator|::
name|ConnectingState
condition|)
block|{
name|socketError
operator|=
name|QAbstractSocket
operator|::
name|ConnectionRefusedError
expr_stmt|;
name|q
operator|->
name|setErrorString
argument_list|(
name|QAbstractSocket
operator|::
name|tr
argument_list|(
literal|"Connection refused"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|socketError
operator|=
name|socketEngine
operator|->
name|error
argument_list|()
expr_stmt|;
name|q
operator|->
name|setErrorString
argument_list|(
name|socketEngine
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|//                socketError = QAbstractSocket::ConnectionRefusedError;
comment|//                q->setErrorString(QAbstractSocket::tr("Connection refused"));
block|}
emit|emit
name|q
operator|->
name|stateChanged
argument_list|(
name|state
argument_list|)
emit|;
emit|emit
name|q
operator|->
name|error
argument_list|(
name|socketError
argument_list|)
emit|;
return|return;
block|}
comment|// Pick the first host address candidate
name|host
operator|=
name|addresses
operator|.
name|takeFirst
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QABSTRACTSOCKET_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QAbstractSocketPrivate::_q_connectToNextAddress(), connecting to %s:%i, %d left to try"
argument_list|,
name|host
operator|.
name|toString
argument_list|()
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|port
argument_list|,
name|addresses
operator|.
name|count
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|initSocketLayer
argument_list|(
name|host
operator|.
name|protocol
argument_list|()
argument_list|)
condition|)
block|{
comment|// hope that the next address is better
if|#
directive|if
name|defined
argument_list|(
name|QABSTRACTSOCKET_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QAbstractSocketPrivate::_q_connectToNextAddress(), failed to initialize sock layer"
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
comment|// Tries to connect to the address. If it succeeds immediately
comment|// (localhost address on BSD or any UDP connect), emit
comment|// connected() and return.
if|if
condition|(
name|socketEngine
operator|->
name|connectToHost
argument_list|(
name|host
argument_list|,
name|port
argument_list|)
condition|)
block|{
comment|//_q_testConnection();
name|fetchConnectionParameters
argument_list|()
expr_stmt|;
return|return;
block|}
comment|// cache the socket descriptor even if we're not fully connected yet
name|cachedSocketDescriptor
operator|=
name|socketEngine
operator|->
name|socketDescriptor
argument_list|()
expr_stmt|;
comment|// Check that we're in delayed connection state. If not, try
comment|// the next address
if|if
condition|(
name|socketEngine
operator|->
name|state
argument_list|()
operator|!=
name|QAbstractSocket
operator|::
name|ConnectingState
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|QABSTRACTSOCKET_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QAbstractSocketPrivate::_q_connectToNextAddress(), connection failed (%s)"
argument_list|,
name|socketEngine
operator|->
name|errorString
argument_list|()
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
comment|// Start the connect timer.
if|if
condition|(
name|threadData
operator|->
name|hasEventDispatcher
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|connectTimer
condition|)
block|{
name|connectTimer
operator|=
operator|new
name|QTimer
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|connectTimer
argument_list|,
name|SIGNAL
argument_list|(
name|timeout
argument_list|()
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_abortConnectionAttempt
argument_list|()
argument_list|)
argument_list|,
name|Qt
operator|::
name|DirectConnection
argument_list|)
expr_stmt|;
block|}
name|connectTimer
operator|->
name|start
argument_list|(
name|QT_CONNECT_TIMEOUT
argument_list|)
expr_stmt|;
block|}
comment|// Wait for a write notification that will eventually call
comment|// _q_testConnection().
name|socketEngine
operator|->
name|setWriteNotificationEnabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
break|break;
block|}
do|while
condition|(
name|state
operator|!=
name|QAbstractSocket
operator|::
name|ConnectedState
condition|)
do|;
block|}
end_function
begin_comment
comment|/*! \internal      Tests if a connection has been established. If it has, connected()     is emitted. Otherwise, _q_connectToNextAddress() is invoked. */
end_comment
begin_function
DECL|function|_q_testConnection
name|void
name|QAbstractSocketPrivate
operator|::
name|_q_testConnection
parameter_list|()
block|{
if|if
condition|(
name|socketEngine
condition|)
block|{
if|if
condition|(
name|threadData
operator|->
name|hasEventDispatcher
argument_list|()
condition|)
block|{
if|if
condition|(
name|connectTimer
condition|)
name|connectTimer
operator|->
name|stop
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|socketEngine
operator|->
name|state
argument_list|()
operator|==
name|QAbstractSocket
operator|::
name|ConnectedState
condition|)
block|{
comment|// Fetch the parameters if our connection is completed;
comment|// otherwise, fall out and try the next address.
name|fetchConnectionParameters
argument_list|()
expr_stmt|;
if|if
condition|(
name|pendingClose
condition|)
block|{
name|q_func
argument_list|()
operator|->
name|disconnectFromHost
argument_list|()
expr_stmt|;
name|pendingClose
operator|=
literal|false
expr_stmt|;
block|}
return|return;
block|}
comment|// don't retry the other addresses if we had a proxy error
if|if
condition|(
name|isProxyError
argument_list|(
name|socketEngine
operator|->
name|error
argument_list|()
argument_list|)
condition|)
name|addresses
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|threadData
operator|->
name|hasEventDispatcher
argument_list|()
condition|)
block|{
if|if
condition|(
name|connectTimer
condition|)
name|connectTimer
operator|->
name|stop
argument_list|()
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|QABSTRACTSOCKET_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QAbstractSocketPrivate::_q_testConnection() connection failed,"
literal|" checking for alternative addresses"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|_q_connectToNextAddress
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \internal      This function is called after a certain number of seconds has     passed while waiting for a connection. It simply tests the     connection, and continues to the next address if the connection     failed. */
end_comment
begin_function
DECL|function|_q_abortConnectionAttempt
name|void
name|QAbstractSocketPrivate
operator|::
name|_q_abortConnectionAttempt
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QAbstractSocket
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QABSTRACTSOCKET_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QAbstractSocketPrivate::_q_abortConnectionAttempt() (timed out)"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|socketEngine
condition|)
name|socketEngine
operator|->
name|setWriteNotificationEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|connectTimer
operator|->
name|stop
argument_list|()
expr_stmt|;
if|if
condition|(
name|addresses
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|state
operator|=
name|QAbstractSocket
operator|::
name|UnconnectedState
expr_stmt|;
name|socketError
operator|=
name|QAbstractSocket
operator|::
name|SocketTimeoutError
expr_stmt|;
name|q
operator|->
name|setErrorString
argument_list|(
name|QAbstractSocket
operator|::
name|tr
argument_list|(
literal|"Connection timed out"
argument_list|)
argument_list|)
expr_stmt|;
emit|emit
name|q
operator|->
name|stateChanged
argument_list|(
name|state
argument_list|)
emit|;
emit|emit
name|q
operator|->
name|error
argument_list|(
name|socketError
argument_list|)
emit|;
block|}
else|else
block|{
name|_q_connectToNextAddress
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|_q_forceDisconnect
name|void
name|QAbstractSocketPrivate
operator|::
name|_q_forceDisconnect
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QAbstractSocket
argument_list|)
expr_stmt|;
if|if
condition|(
name|socketEngine
operator|&&
name|socketEngine
operator|->
name|isValid
argument_list|()
operator|&&
name|state
operator|==
name|QAbstractSocket
operator|::
name|ClosingState
condition|)
block|{
name|socketEngine
operator|->
name|close
argument_list|()
expr_stmt|;
name|q
operator|->
name|disconnectFromHost
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*! \internal      Reads data from the socket layer into the read buffer. Returns     true on success; otherwise false. */
end_comment
begin_function
DECL|function|readFromSocket
name|bool
name|QAbstractSocketPrivate
operator|::
name|readFromSocket
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QAbstractSocket
argument_list|)
expr_stmt|;
comment|// Find how many bytes we can read from the socket layer.
name|qint64
name|bytesToRead
init|=
name|socketEngine
operator|->
name|bytesAvailable
argument_list|()
decl_stmt|;
if|if
condition|(
name|bytesToRead
operator|==
literal|0
condition|)
block|{
comment|// Under heavy load, certain conditions can trigger read notifications
comment|// for socket notifiers on which there is no activity. If we continue
comment|// to read 0 bytes from the socket, we will trigger behavior similar
comment|// to that which signals a remote close. When we hit this condition,
comment|// we try to read 4k of data from the socket, which will give us either
comment|// an EAGAIN/EWOULDBLOCK if the connection is alive (i.e., the remote
comment|// host has _not_ disappeared).
name|bytesToRead
operator|=
literal|4096
expr_stmt|;
block|}
if|if
condition|(
name|readBufferMaxSize
operator|&&
name|bytesToRead
operator|>
operator|(
name|readBufferMaxSize
operator|-
name|buffer
operator|.
name|size
argument_list|()
operator|)
condition|)
name|bytesToRead
operator|=
name|readBufferMaxSize
operator|-
name|buffer
operator|.
name|size
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QABSTRACTSOCKET_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QAbstractSocketPrivate::readFromSocket() about to read %d bytes"
argument_list|,
name|int
argument_list|(
name|bytesToRead
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// Read from the socket, store data in the read buffer.
name|char
modifier|*
name|ptr
init|=
name|buffer
operator|.
name|reserve
argument_list|(
name|bytesToRead
argument_list|)
decl_stmt|;
name|qint64
name|readBytes
init|=
name|socketEngine
operator|->
name|read
argument_list|(
name|ptr
argument_list|,
name|bytesToRead
argument_list|)
decl_stmt|;
if|if
condition|(
name|readBytes
operator|==
operator|-
literal|2
condition|)
block|{
comment|// No bytes currently available for reading.
name|buffer
operator|.
name|chop
argument_list|(
name|bytesToRead
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
name|buffer
operator|.
name|chop
argument_list|(
name|int
argument_list|(
name|bytesToRead
operator|-
operator|(
name|readBytes
operator|<
literal|0
condition|?
name|qint64
argument_list|(
literal|0
argument_list|)
else|:
name|readBytes
operator|)
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QABSTRACTSOCKET_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QAbstractSocketPrivate::readFromSocket() got %d bytes, buffer size = %d"
argument_list|,
name|int
argument_list|(
name|readBytes
argument_list|)
argument_list|,
name|buffer
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|socketEngine
operator|->
name|isValid
argument_list|()
condition|)
block|{
name|socketError
operator|=
name|socketEngine
operator|->
name|error
argument_list|()
expr_stmt|;
name|q
operator|->
name|setErrorString
argument_list|(
name|socketEngine
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
emit|emit
name|q
operator|->
name|error
argument_list|(
name|socketError
argument_list|)
emit|;
if|#
directive|if
name|defined
argument_list|(
name|QABSTRACTSOCKET_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QAbstractSocketPrivate::readFromSocket() read failed: %s"
argument_list|,
name|q
operator|->
name|errorString
argument_list|()
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|resetSocketLayer
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*! \internal      Sets up the internal state after the connection has succeeded. */
end_comment
begin_function
DECL|function|fetchConnectionParameters
name|void
name|QAbstractSocketPrivate
operator|::
name|fetchConnectionParameters
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QAbstractSocket
argument_list|)
expr_stmt|;
name|peerName
operator|=
name|hostName
expr_stmt|;
if|if
condition|(
name|socketEngine
condition|)
block|{
name|socketEngine
operator|->
name|setReadNotificationEnabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|socketEngine
operator|->
name|setWriteNotificationEnabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|localPort
operator|=
name|socketEngine
operator|->
name|localPort
argument_list|()
expr_stmt|;
name|peerPort
operator|=
name|socketEngine
operator|->
name|peerPort
argument_list|()
expr_stmt|;
name|localAddress
operator|=
name|socketEngine
operator|->
name|localAddress
argument_list|()
expr_stmt|;
name|peerAddress
operator|=
name|socketEngine
operator|->
name|peerAddress
argument_list|()
expr_stmt|;
name|cachedSocketDescriptor
operator|=
name|socketEngine
operator|->
name|socketDescriptor
argument_list|()
expr_stmt|;
block|}
name|state
operator|=
name|QAbstractSocket
operator|::
name|ConnectedState
expr_stmt|;
emit|emit
name|q
operator|->
name|stateChanged
argument_list|(
name|state
argument_list|)
emit|;
emit|emit
name|q
operator|->
name|connected
argument_list|()
emit|;
if|#
directive|if
name|defined
argument_list|(
name|QABSTRACTSOCKET_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QAbstractSocketPrivate::fetchConnectionParameters() connection to %s:%i established"
argument_list|,
name|host
operator|.
name|toString
argument_list|()
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|port
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_function
DECL|function|pauseSocketNotifiers
name|void
name|QAbstractSocketPrivate
operator|::
name|pauseSocketNotifiers
parameter_list|(
name|QAbstractSocket
modifier|*
name|socket
parameter_list|)
block|{
name|QAbstractSocketEngine
modifier|*
name|socketEngine
init|=
name|socket
operator|->
name|d_func
argument_list|()
operator|->
name|socketEngine
decl_stmt|;
if|if
condition|(
operator|!
name|socketEngine
condition|)
return|return;
name|socket
operator|->
name|d_func
argument_list|()
operator|->
name|prePauseReadSocketNotifierState
operator|=
name|socketEngine
operator|->
name|isReadNotificationEnabled
argument_list|()
expr_stmt|;
name|socket
operator|->
name|d_func
argument_list|()
operator|->
name|prePauseWriteSocketNotifierState
operator|=
name|socketEngine
operator|->
name|isWriteNotificationEnabled
argument_list|()
expr_stmt|;
name|socket
operator|->
name|d_func
argument_list|()
operator|->
name|prePauseExceptionSocketNotifierState
operator|=
name|socketEngine
operator|->
name|isExceptionNotificationEnabled
argument_list|()
expr_stmt|;
name|socketEngine
operator|->
name|setReadNotificationEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|socketEngine
operator|->
name|setWriteNotificationEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
name|socketEngine
operator|->
name|setExceptionNotificationEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|resumeSocketNotifiers
name|void
name|QAbstractSocketPrivate
operator|::
name|resumeSocketNotifiers
parameter_list|(
name|QAbstractSocket
modifier|*
name|socket
parameter_list|)
block|{
name|QAbstractSocketEngine
modifier|*
name|socketEngine
init|=
name|socket
operator|->
name|d_func
argument_list|()
operator|->
name|socketEngine
decl_stmt|;
if|if
condition|(
operator|!
name|socketEngine
condition|)
return|return;
name|socketEngine
operator|->
name|setReadNotificationEnabled
argument_list|(
name|socket
operator|->
name|d_func
argument_list|()
operator|->
name|prePauseReadSocketNotifierState
argument_list|)
expr_stmt|;
name|socketEngine
operator|->
name|setWriteNotificationEnabled
argument_list|(
name|socket
operator|->
name|d_func
argument_list|()
operator|->
name|prePauseWriteSocketNotifierState
argument_list|)
expr_stmt|;
name|socketEngine
operator|->
name|setExceptionNotificationEnabled
argument_list|(
name|socket
operator|->
name|d_func
argument_list|()
operator|->
name|prePauseExceptionSocketNotifierState
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|getSocketEngine
name|QAbstractSocketEngine
modifier|*
name|QAbstractSocketPrivate
operator|::
name|getSocketEngine
parameter_list|(
name|QAbstractSocket
modifier|*
name|socket
parameter_list|)
block|{
return|return
name|socket
operator|->
name|d_func
argument_list|()
operator|->
name|socketEngine
return|;
block|}
end_function
begin_comment
comment|/*! \internal      Constructs a new abstract socket of type \a socketType. The \a     parent argument is passed to QObject's constructor. */
end_comment
begin_constructor
DECL|function|QAbstractSocket
name|QAbstractSocket
operator|::
name|QAbstractSocket
parameter_list|(
name|SocketType
name|socketType
parameter_list|,
name|QAbstractSocketPrivate
modifier|&
name|dd
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QIODevice
argument_list|(
name|dd
argument_list|,
name|parent
argument_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractSocket
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QABSTRACTSOCKET_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QAbstractSocket::QAbstractSocket(%sSocket, QAbstractSocketPrivate == %p, parent == %p)"
argument_list|,
name|socketType
operator|==
name|TcpSocket
condition|?
literal|"Tcp"
else|:
name|socketType
operator|==
name|UdpSocket
condition|?
literal|"Udp"
else|:
literal|"Unknown"
argument_list|,
operator|&
name|dd
argument_list|,
name|parent
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|socketType
operator|=
name|socketType
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Creates a new abstract socket of type \a socketType. The \a     parent argument is passed to QObject's constructor.      \sa socketType(), QTcpSocket, QUdpSocket */
end_comment
begin_constructor
DECL|function|QAbstractSocket
name|QAbstractSocket
operator|::
name|QAbstractSocket
parameter_list|(
name|SocketType
name|socketType
parameter_list|,
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QIODevice
argument_list|(
operator|*
operator|new
name|QAbstractSocketPrivate
argument_list|,
name|parent
argument_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractSocket
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QABSTRACTSOCKET_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QAbstractSocket::QAbstractSocket(%p)"
argument_list|,
name|parent
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|socketType
operator|=
name|socketType
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Destroys the socket. */
end_comment
begin_destructor
DECL|function|~QAbstractSocket
name|QAbstractSocket
operator|::
name|~
name|QAbstractSocket
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QAbstractSocket
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QABSTRACTSOCKET_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QAbstractSocket::~QAbstractSocket()"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|d
operator|->
name|state
operator|!=
name|UnconnectedState
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     \since 5.0      Continues data transfer on the socket. This method should only be used     after the socket has been set to pause upon notifications and a     notification has been received.     The only notification currently supported is QSslSocket::sslErrors().     Calling this method if the socket is not paused results in undefined     behavior.      \sa pauseMode(), setPauseMode() */
end_comment
begin_function
DECL|function|resume
name|void
name|QAbstractSocket
operator|::
name|resume
parameter_list|()
block|{
name|QAbstractSocketPrivate
operator|::
name|resumeSocketNotifiers
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 5.0      Returns the pause mode of this socket.      \sa setPauseMode(), resume() */
end_comment
begin_function
DECL|function|pauseMode
name|QAbstractSocket
operator|::
name|PauseModes
name|QAbstractSocket
operator|::
name|pauseMode
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|pauseMode
return|;
block|}
end_function
begin_comment
comment|/*!     \since 5.0      Controls whether to pause upon receiving a notification. The \a pauseMode parameter     specifies the conditions in which the socket should be paused. The only notification     currently supported is QSslSocket::sslErrors(). If set to PauseOnSslErrors,     data transfer on the socket will be paused and needs to be enabled explicitly     again by calling resume().     By default this option is set to PauseNever.     This option must be called before connecting to the server, otherwise it will     result in undefined behavior.      \sa pauseMode(), resume() */
end_comment
begin_function
DECL|function|setPauseMode
name|void
name|QAbstractSocket
operator|::
name|setPauseMode
parameter_list|(
name|PauseModes
name|pauseMode
parameter_list|)
block|{
name|d_func
argument_list|()
operator|->
name|pauseMode
operator|=
name|pauseMode
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 5.0      Binds to \a address on port \a port, using the BindMode \a mode.      Binds this socket to the address \a address and the port \a port.      For UDP sockets, after binding, the signal QUdpSocket::readyRead() is emitted     whenever a UDP datagram arrives on the specified address and port.     Thus, This function is useful to write UDP servers.      For TCP sockets, this function may be used to specify which interface to use     for an outgoing connection, which is useful in case of multiple network     interfaces.      By default, the socket is bound using the DefaultForPlatform BindMode.     If a port is not specified, a random port is chosen.      On success, the functions returns \c true and the socket enters     BoundState; otherwise it returns \c false.  */
end_comment
begin_function
DECL|function|bind
name|bool
name|QAbstractSocket
operator|::
name|bind
parameter_list|(
specifier|const
name|QHostAddress
modifier|&
name|address
parameter_list|,
name|quint16
name|port
parameter_list|,
name|BindMode
name|mode
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractSocket
argument_list|)
expr_stmt|;
comment|// now check if the socket engine is initialized and to the right type
if|if
condition|(
operator|!
name|d
operator|->
name|socketEngine
operator|||
operator|!
name|d
operator|->
name|socketEngine
operator|->
name|isValid
argument_list|()
condition|)
block|{
name|QHostAddress
name|nullAddress
decl_stmt|;
name|d
operator|->
name|resolveProxy
argument_list|(
name|nullAddress
operator|.
name|toString
argument_list|()
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|QAbstractSocket
operator|::
name|NetworkLayerProtocol
name|protocol
init|=
name|address
operator|.
name|protocol
argument_list|()
decl_stmt|;
if|if
condition|(
name|protocol
operator|==
name|QAbstractSocket
operator|::
name|UnknownNetworkLayerProtocol
condition|)
name|protocol
operator|=
name|nullAddress
operator|.
name|protocol
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|initSocketLayer
argument_list|(
name|protocol
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
if|if
condition|(
name|mode
operator|!=
name|DefaultForPlatform
condition|)
block|{
ifdef|#
directive|ifdef
name|Q_OS_UNIX
if|if
condition|(
operator|(
name|mode
operator|&
name|ShareAddress
operator|)
operator|||
operator|(
name|mode
operator|&
name|ReuseAddressHint
operator|)
condition|)
name|d
operator|->
name|socketEngine
operator|->
name|setOption
argument_list|(
name|QAbstractSocketEngine
operator|::
name|AddressReusable
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|d
operator|->
name|socketEngine
operator|->
name|setOption
argument_list|(
name|QAbstractSocketEngine
operator|::
name|AddressReusable
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|Q_OS_WIN
if|if
condition|(
name|mode
operator|&
name|ReuseAddressHint
condition|)
name|d
operator|->
name|socketEngine
operator|->
name|setOption
argument_list|(
name|QAbstractSocketEngine
operator|::
name|AddressReusable
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|d
operator|->
name|socketEngine
operator|->
name|setOption
argument_list|(
name|QAbstractSocketEngine
operator|::
name|AddressReusable
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|DontShareAddress
condition|)
name|d
operator|->
name|socketEngine
operator|->
name|setOption
argument_list|(
name|QAbstractSocketEngine
operator|::
name|BindExclusively
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|d
operator|->
name|socketEngine
operator|->
name|setOption
argument_list|(
name|QAbstractSocketEngine
operator|::
name|BindExclusively
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|bool
name|result
init|=
name|d
operator|->
name|socketEngine
operator|->
name|bind
argument_list|(
name|address
argument_list|,
name|port
argument_list|)
decl_stmt|;
name|d
operator|->
name|cachedSocketDescriptor
operator|=
name|d
operator|->
name|socketEngine
operator|->
name|socketDescriptor
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
block|{
name|d
operator|->
name|socketError
operator|=
name|d
operator|->
name|socketEngine
operator|->
name|error
argument_list|()
expr_stmt|;
name|setErrorString
argument_list|(
name|d
operator|->
name|socketEngine
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
emit|emit
name|error
argument_list|(
name|d
operator|->
name|socketError
argument_list|)
emit|;
return|return
literal|false
return|;
block|}
name|d
operator|->
name|state
operator|=
name|BoundState
expr_stmt|;
name|d
operator|->
name|localAddress
operator|=
name|d
operator|->
name|socketEngine
operator|->
name|localAddress
argument_list|()
expr_stmt|;
name|d
operator|->
name|localPort
operator|=
name|d
operator|->
name|socketEngine
operator|->
name|localPort
argument_list|()
expr_stmt|;
emit|emit
name|stateChanged
argument_list|(
name|d
operator|->
name|state
argument_list|)
emit|;
name|d
operator|->
name|socketEngine
operator|->
name|setReadNotificationEnabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \since 5.0     \overload      Binds to QHostAddress:Any on port \a port, using the BindMode \a mode.      By default, the socket is bound using the DefaultForPlatform BindMode.     If a port is not specified, a random port is chosen. */
end_comment
begin_function
DECL|function|bind
name|bool
name|QAbstractSocket
operator|::
name|bind
parameter_list|(
name|quint16
name|port
parameter_list|,
name|BindMode
name|mode
parameter_list|)
block|{
return|return
name|bind
argument_list|(
name|QHostAddress
operator|::
name|Any
argument_list|,
name|port
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns \c true if the socket is valid and ready for use; otherwise     returns \c false.      \note The socket's state must be ConnectedState before reading and     writing can occur.      \sa state() */
end_comment
begin_function
DECL|function|isValid
name|bool
name|QAbstractSocket
operator|::
name|isValid
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|socketEngine
condition|?
name|d_func
argument_list|()
operator|->
name|socketEngine
operator|->
name|isValid
argument_list|()
else|:
name|isOpen
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Attempts to make a connection to \a hostName on the given \a port.     The \a protocol parameter can be used to specify which network     protocol to use (eg. IPv4 or IPv6).      The socket is opened in the given \a openMode and first enters     HostLookupState, then performs a host name lookup of \a hostName.     If the lookup succeeds, hostFound() is emitted and QAbstractSocket     enters ConnectingState. It then attempts to connect to the address     or addresses returned by the lookup. Finally, if a connection is     established, QAbstractSocket enters ConnectedState and     emits connected().      At any point, the socket can emit error() to signal that an error     occurred.      \a hostName may be an IP address in string form (e.g.,     "43.195.83.32"), or it may be a host name (e.g.,     "example.com"). QAbstractSocket will do a lookup only if     required. \a port is in native byte order.      \sa state(), peerName(), peerAddress(), peerPort(), waitForConnected() */
end_comment
begin_function
DECL|function|connectToHost
name|void
name|QAbstractSocket
operator|::
name|connectToHost
parameter_list|(
specifier|const
name|QString
modifier|&
name|hostName
parameter_list|,
name|quint16
name|port
parameter_list|,
name|OpenMode
name|openMode
parameter_list|,
name|NetworkLayerProtocol
name|protocol
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractSocket
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QABSTRACTSOCKET_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QAbstractSocket::connectToHost(\"%s\", %i, %i)..."
argument_list|,
name|qPrintable
argument_list|(
name|hostName
argument_list|)
argument_list|,
name|port
argument_list|,
operator|(
name|int
operator|)
name|openMode
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|d
operator|->
name|state
operator|==
name|ConnectedState
operator|||
name|d
operator|->
name|state
operator|==
name|ConnectingState
operator|||
name|d
operator|->
name|state
operator|==
name|ClosingState
operator|||
name|d
operator|->
name|state
operator|==
name|HostLookupState
condition|)
block|{
name|qWarning
argument_list|(
literal|"QAbstractSocket::connectToHost() called when already looking up or connecting/connected to \"%s\""
argument_list|,
name|qPrintable
argument_list|(
name|hostName
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|socketError
operator|=
name|QAbstractSocket
operator|::
name|OperationError
expr_stmt|;
name|setErrorString
argument_list|(
name|QAbstractSocket
operator|::
name|tr
argument_list|(
literal|"Trying to connect while connection is in progress"
argument_list|)
argument_list|)
expr_stmt|;
emit|emit
name|error
argument_list|(
name|d
operator|->
name|socketError
argument_list|)
emit|;
return|return;
block|}
name|d
operator|->
name|preferredNetworkLayerProtocol
operator|=
name|protocol
expr_stmt|;
name|d
operator|->
name|hostName
operator|=
name|hostName
expr_stmt|;
name|d
operator|->
name|port
operator|=
name|port
expr_stmt|;
name|d
operator|->
name|state
operator|=
name|UnconnectedState
expr_stmt|;
name|d
operator|->
name|buffer
operator|.
name|clear
argument_list|()
expr_stmt|;
name|d
operator|->
name|writeBuffer
operator|.
name|clear
argument_list|()
expr_stmt|;
name|d
operator|->
name|abortCalled
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|closeCalled
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|pendingClose
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|localPort
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|peerPort
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|localAddress
operator|.
name|clear
argument_list|()
expr_stmt|;
name|d
operator|->
name|peerAddress
operator|.
name|clear
argument_list|()
expr_stmt|;
name|d
operator|->
name|peerName
operator|=
name|hostName
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|hostLookupId
operator|!=
operator|-
literal|1
condition|)
block|{
name|QHostInfo
operator|::
name|abortHostLookup
argument_list|(
name|d
operator|->
name|hostLookupId
argument_list|)
expr_stmt|;
name|d
operator|->
name|hostLookupId
operator|=
operator|-
literal|1
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
comment|// Get the proxy information
name|d
operator|->
name|resolveProxy
argument_list|(
name|hostName
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|proxyInUse
operator|.
name|type
argument_list|()
operator|==
name|QNetworkProxy
operator|::
name|DefaultProxy
condition|)
block|{
comment|// failed to setup the proxy
name|d
operator|->
name|socketError
operator|=
name|QAbstractSocket
operator|::
name|UnsupportedSocketOperationError
expr_stmt|;
name|setErrorString
argument_list|(
name|QAbstractSocket
operator|::
name|tr
argument_list|(
literal|"Operation on socket is not supported"
argument_list|)
argument_list|)
expr_stmt|;
emit|emit
name|error
argument_list|(
name|d
operator|->
name|socketError
argument_list|)
emit|;
return|return;
block|}
endif|#
directive|endif
if|if
condition|(
name|openMode
operator|&
name|QIODevice
operator|::
name|Unbuffered
condition|)
name|d
operator|->
name|isBuffered
operator|=
literal|false
expr_stmt|;
comment|// Unbuffered QTcpSocket
elseif|else
if|if
condition|(
operator|!
name|d_func
argument_list|()
operator|->
name|isBuffered
condition|)
name|openMode
operator||=
name|QAbstractSocket
operator|::
name|Unbuffered
expr_stmt|;
comment|// QUdpSocket
name|QIODevice
operator|::
name|open
argument_list|(
name|openMode
argument_list|)
expr_stmt|;
name|d
operator|->
name|state
operator|=
name|HostLookupState
expr_stmt|;
emit|emit
name|stateChanged
argument_list|(
name|d
operator|->
name|state
argument_list|)
emit|;
name|QHostAddress
name|temp
decl_stmt|;
if|if
condition|(
name|temp
operator|.
name|setAddress
argument_list|(
name|hostName
argument_list|)
condition|)
block|{
name|QHostInfo
name|info
decl_stmt|;
name|info
operator|.
name|setAddresses
argument_list|(
name|QList
argument_list|<
name|QHostAddress
argument_list|>
argument_list|()
operator|<<
name|temp
argument_list|)
expr_stmt|;
name|d
operator|->
name|_q_startConnecting
argument_list|(
name|info
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|proxyInUse
operator|.
name|capabilities
argument_list|()
operator|&
name|QNetworkProxy
operator|::
name|HostNameLookupCapability
condition|)
block|{
comment|// the proxy supports connection by name, so use it
name|d
operator|->
name|startConnectingByName
argument_list|(
name|hostName
argument_list|)
expr_stmt|;
return|return;
endif|#
directive|endif
block|}
else|else
block|{
if|if
condition|(
name|d
operator|->
name|threadData
operator|->
name|hasEventDispatcher
argument_list|()
condition|)
block|{
comment|// this internal API for QHostInfo either immediately gives us the desired
comment|// QHostInfo from cache or later calls the _q_startConnecting slot.
name|bool
name|immediateResultValid
init|=
literal|false
decl_stmt|;
name|QHostInfo
name|hostInfo
init|=
name|qt_qhostinfo_lookup
argument_list|(
name|hostName
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|_q_startConnecting
argument_list|(
name|QHostInfo
argument_list|)
argument_list|)
argument_list|,
operator|&
name|immediateResultValid
argument_list|,
operator|&
name|d
operator|->
name|hostLookupId
argument_list|)
decl_stmt|;
if|if
condition|(
name|immediateResultValid
condition|)
block|{
name|d
operator|->
name|hostLookupId
operator|=
operator|-
literal|1
expr_stmt|;
name|d
operator|->
name|_q_startConnecting
argument_list|(
name|hostInfo
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|#
directive|if
name|defined
argument_list|(
name|QABSTRACTSOCKET_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QAbstractSocket::connectToHost(\"%s\", %i) == %s%s"
argument_list|,
name|hostName
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|port
argument_list|,
operator|(
name|d
operator|->
name|state
operator|==
name|ConnectedState
operator|)
condition|?
literal|"true"
else|:
literal|"false"
argument_list|,
operator|(
name|d
operator|->
name|state
operator|==
name|ConnectingState
operator|||
name|d
operator|->
name|state
operator|==
name|HostLookupState
operator|)
condition|?
literal|" (connection in progress)"
else|:
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*! \overload      Attempts to make a connection to \a address on port \a port. */
end_comment
begin_function
DECL|function|connectToHost
name|void
name|QAbstractSocket
operator|::
name|connectToHost
parameter_list|(
specifier|const
name|QHostAddress
modifier|&
name|address
parameter_list|,
name|quint16
name|port
parameter_list|,
name|OpenMode
name|openMode
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|QABSTRACTSOCKET_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QAbstractSocket::connectToHost([%s], %i, %i)..."
argument_list|,
name|address
operator|.
name|toString
argument_list|()
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|port
argument_list|,
operator|(
name|int
operator|)
name|openMode
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|connectToHost
argument_list|(
name|address
operator|.
name|toString
argument_list|()
argument_list|,
name|port
argument_list|,
name|openMode
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of bytes that are waiting to be written. The     bytes are written when control goes back to the event loop or     when flush() is called.      \sa bytesAvailable(), flush() */
end_comment
begin_function
DECL|function|bytesToWrite
name|qint64
name|QAbstractSocket
operator|::
name|bytesToWrite
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractSocket
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QABSTRACTSOCKET_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QAbstractSocket::bytesToWrite() == %i"
argument_list|,
name|d
operator|->
name|writeBuffer
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|qint64
operator|)
name|d
operator|->
name|writeBuffer
operator|.
name|size
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the number of incoming bytes that are waiting to be read.      \sa bytesToWrite(), read() */
end_comment
begin_function
DECL|function|bytesAvailable
name|qint64
name|QAbstractSocket
operator|::
name|bytesAvailable
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractSocket
argument_list|)
expr_stmt|;
name|qint64
name|available
init|=
name|QIODevice
operator|::
name|bytesAvailable
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|isBuffered
operator|&&
name|d
operator|->
name|socketEngine
operator|&&
name|d
operator|->
name|socketEngine
operator|->
name|isValid
argument_list|()
condition|)
name|available
operator|+=
name|d
operator|->
name|socketEngine
operator|->
name|bytesAvailable
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QABSTRACTSOCKET_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QAbstractSocket::bytesAvailable() == %llu"
argument_list|,
name|available
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|available
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the host port number (in native byte order) of the local     socket if available; otherwise returns 0.      \sa localAddress(), peerPort(), setLocalPort() */
end_comment
begin_function
DECL|function|localPort
name|quint16
name|QAbstractSocket
operator|::
name|localPort
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractSocket
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|localPort
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the host address of the local socket if available;     otherwise returns QHostAddress::Null.      This is normally the main IP address of the host, but can be     QHostAddress::LocalHost (127.0.0.1) for connections to the     local host.      \sa localPort(), peerAddress(), setLocalAddress() */
end_comment
begin_function
DECL|function|localAddress
name|QHostAddress
name|QAbstractSocket
operator|::
name|localAddress
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractSocket
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|localAddress
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the port of the connected peer if the socket is in     ConnectedState; otherwise returns 0.      \sa peerAddress(), localPort(), setPeerPort() */
end_comment
begin_function
DECL|function|peerPort
name|quint16
name|QAbstractSocket
operator|::
name|peerPort
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractSocket
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|peerPort
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the address of the connected peer if the socket is in     ConnectedState; otherwise returns QHostAddress::Null.      \sa peerName(), peerPort(), localAddress(), setPeerAddress() */
end_comment
begin_function
DECL|function|peerAddress
name|QHostAddress
name|QAbstractSocket
operator|::
name|peerAddress
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractSocket
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|peerAddress
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the name of the peer as specified by connectToHost(), or     an empty QString if connectToHost() has not been called.      \sa peerAddress(), peerPort(), setPeerName() */
end_comment
begin_function
DECL|function|peerName
name|QString
name|QAbstractSocket
operator|::
name|peerName
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractSocket
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|peerName
operator|.
name|isEmpty
argument_list|()
condition|?
name|d
operator|->
name|hostName
else|:
name|d
operator|->
name|peerName
return|;
block|}
end_function
begin_comment
comment|/*!     Returns \c true if a line of data can be read from the socket;     otherwise returns \c false.      \sa readLine() */
end_comment
begin_function
DECL|function|canReadLine
name|bool
name|QAbstractSocket
operator|::
name|canReadLine
parameter_list|()
specifier|const
block|{
name|bool
name|hasLine
init|=
name|d_func
argument_list|()
operator|->
name|buffer
operator|.
name|canReadLine
argument_list|()
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QABSTRACTSOCKET_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QAbstractSocket::canReadLine() == %s, buffer size = %d, size = %d"
argument_list|,
name|hasLine
condition|?
literal|"true"
else|:
literal|"false"
argument_list|,
name|d_func
argument_list|()
operator|->
name|buffer
operator|.
name|size
argument_list|()
argument_list|,
name|d_func
argument_list|()
operator|->
name|buffer
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|hasLine
operator|||
name|QIODevice
operator|::
name|canReadLine
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the native socket descriptor of the QAbstractSocket object     if this is available; otherwise returns -1.      If the socket is using QNetworkProxy, the returned descriptor     may not be usable with native socket functions.      The socket descriptor is not available when QAbstractSocket is in     UnconnectedState.      \sa setSocketDescriptor() */
end_comment
begin_function
DECL|function|socketDescriptor
name|qintptr
name|QAbstractSocket
operator|::
name|socketDescriptor
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractSocket
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|cachedSocketDescriptor
return|;
block|}
end_function
begin_comment
comment|/*!     Initializes QAbstractSocket with the native socket descriptor \a     socketDescriptor. Returns \c true if \a socketDescriptor is accepted     as a valid socket descriptor; otherwise returns \c false.     The socket is opened in the mode specified by \a openMode, and     enters the socket state specified by \a socketState.     Read and write buffers are cleared, discarding any pending data.      \b{Note:} It is not possible to initialize two abstract sockets     with the same native socket descriptor.      \sa socketDescriptor() */
end_comment
begin_function
DECL|function|setSocketDescriptor
name|bool
name|QAbstractSocket
operator|::
name|setSocketDescriptor
parameter_list|(
name|qintptr
name|socketDescriptor
parameter_list|,
name|SocketState
name|socketState
parameter_list|,
name|OpenMode
name|openMode
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractSocket
argument_list|)
expr_stmt|;
name|d
operator|->
name|resetSocketLayer
argument_list|()
expr_stmt|;
name|d
operator|->
name|writeBuffer
operator|.
name|clear
argument_list|()
expr_stmt|;
name|d
operator|->
name|buffer
operator|.
name|clear
argument_list|()
expr_stmt|;
name|d
operator|->
name|socketEngine
operator|=
name|QAbstractSocketEngine
operator|::
name|createSocketEngine
argument_list|(
name|socketDescriptor
argument_list|,
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|socketEngine
condition|)
block|{
name|d
operator|->
name|socketError
operator|=
name|UnsupportedSocketOperationError
expr_stmt|;
name|setErrorString
argument_list|(
name|tr
argument_list|(
literal|"Operation on socket is not supported"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
ifndef|#
directive|ifndef
name|QT_NO_BEARERMANAGEMENT
comment|//copy network session down to the socket engine (if it has been set)
name|d
operator|->
name|socketEngine
operator|->
name|setProperty
argument_list|(
literal|"_q_networksession"
argument_list|,
name|property
argument_list|(
literal|"_q_networksession"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bool
name|result
init|=
name|d
operator|->
name|socketEngine
operator|->
name|initialize
argument_list|(
name|socketDescriptor
argument_list|,
name|socketState
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
block|{
name|d
operator|->
name|socketError
operator|=
name|d
operator|->
name|socketEngine
operator|->
name|error
argument_list|()
expr_stmt|;
name|setErrorString
argument_list|(
name|d
operator|->
name|socketEngine
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|d
operator|->
name|threadData
operator|->
name|hasEventDispatcher
argument_list|()
condition|)
name|d
operator|->
name|socketEngine
operator|->
name|setReceiver
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|QIODevice
operator|::
name|open
argument_list|(
name|openMode
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|state
operator|!=
name|socketState
condition|)
block|{
name|d
operator|->
name|state
operator|=
name|socketState
expr_stmt|;
emit|emit
name|stateChanged
argument_list|(
name|d
operator|->
name|state
argument_list|)
emit|;
block|}
name|d
operator|->
name|pendingClose
operator|=
literal|false
expr_stmt|;
name|d
operator|->
name|socketEngine
operator|->
name|setReadNotificationEnabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
name|d
operator|->
name|localPort
operator|=
name|d
operator|->
name|socketEngine
operator|->
name|localPort
argument_list|()
expr_stmt|;
name|d
operator|->
name|peerPort
operator|=
name|d
operator|->
name|socketEngine
operator|->
name|peerPort
argument_list|()
expr_stmt|;
name|d
operator|->
name|localAddress
operator|=
name|d
operator|->
name|socketEngine
operator|->
name|localAddress
argument_list|()
expr_stmt|;
name|d
operator|->
name|peerAddress
operator|=
name|d
operator|->
name|socketEngine
operator|->
name|peerAddress
argument_list|()
expr_stmt|;
name|d
operator|->
name|cachedSocketDescriptor
operator|=
name|socketDescriptor
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.6     Sets the given \a option to the value described by \a value.      \note On Windows Runtime, QAbstractSocket::KeepAliveOption must be set     before the socket is connected.      \sa socketOption() */
end_comment
begin_function
DECL|function|setSocketOption
name|void
name|QAbstractSocket
operator|::
name|setSocketOption
parameter_list|(
name|QAbstractSocket
operator|::
name|SocketOption
name|option
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|value
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d_func
argument_list|()
operator|->
name|socketEngine
condition|)
return|return;
switch|switch
condition|(
name|option
condition|)
block|{
case|case
name|LowDelayOption
case|:
name|d_func
argument_list|()
operator|->
name|socketEngine
operator|->
name|setOption
argument_list|(
name|QAbstractSocketEngine
operator|::
name|LowDelayOption
argument_list|,
name|value
operator|.
name|toInt
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|KeepAliveOption
case|:
name|d_func
argument_list|()
operator|->
name|socketEngine
operator|->
name|setOption
argument_list|(
name|QAbstractSocketEngine
operator|::
name|KeepAliveOption
argument_list|,
name|value
operator|.
name|toInt
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|MulticastTtlOption
case|:
name|d_func
argument_list|()
operator|->
name|socketEngine
operator|->
name|setOption
argument_list|(
name|QAbstractSocketEngine
operator|::
name|MulticastTtlOption
argument_list|,
name|value
operator|.
name|toInt
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|MulticastLoopbackOption
case|:
name|d_func
argument_list|()
operator|->
name|socketEngine
operator|->
name|setOption
argument_list|(
name|QAbstractSocketEngine
operator|::
name|MulticastLoopbackOption
argument_list|,
name|value
operator|.
name|toInt
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|TypeOfServiceOption
case|:
name|d_func
argument_list|()
operator|->
name|socketEngine
operator|->
name|setOption
argument_list|(
name|QAbstractSocketEngine
operator|::
name|TypeOfServiceOption
argument_list|,
name|value
operator|.
name|toInt
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|SendBufferSizeSocketOption
case|:
name|d_func
argument_list|()
operator|->
name|socketEngine
operator|->
name|setOption
argument_list|(
name|QAbstractSocketEngine
operator|::
name|SendBufferSocketOption
argument_list|,
name|value
operator|.
name|toInt
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|ReceiveBufferSizeSocketOption
case|:
name|d_func
argument_list|()
operator|->
name|socketEngine
operator|->
name|setOption
argument_list|(
name|QAbstractSocketEngine
operator|::
name|ReceiveBufferSocketOption
argument_list|,
name|value
operator|.
name|toInt
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function
begin_comment
comment|/*!     \since 4.6     Returns the value of the \a option option.      \sa setSocketOption() */
end_comment
begin_function
DECL|function|socketOption
name|QVariant
name|QAbstractSocket
operator|::
name|socketOption
parameter_list|(
name|QAbstractSocket
operator|::
name|SocketOption
name|option
parameter_list|)
block|{
if|if
condition|(
operator|!
name|d_func
argument_list|()
operator|->
name|socketEngine
condition|)
return|return
name|QVariant
argument_list|()
return|;
name|int
name|ret
init|=
operator|-
literal|1
decl_stmt|;
switch|switch
condition|(
name|option
condition|)
block|{
case|case
name|LowDelayOption
case|:
name|ret
operator|=
name|d_func
argument_list|()
operator|->
name|socketEngine
operator|->
name|option
argument_list|(
name|QAbstractSocketEngine
operator|::
name|LowDelayOption
argument_list|)
expr_stmt|;
break|break;
case|case
name|KeepAliveOption
case|:
name|ret
operator|=
name|d_func
argument_list|()
operator|->
name|socketEngine
operator|->
name|option
argument_list|(
name|QAbstractSocketEngine
operator|::
name|KeepAliveOption
argument_list|)
expr_stmt|;
break|break;
case|case
name|MulticastTtlOption
case|:
name|ret
operator|=
name|d_func
argument_list|()
operator|->
name|socketEngine
operator|->
name|option
argument_list|(
name|QAbstractSocketEngine
operator|::
name|MulticastTtlOption
argument_list|)
expr_stmt|;
break|break;
case|case
name|MulticastLoopbackOption
case|:
name|ret
operator|=
name|d_func
argument_list|()
operator|->
name|socketEngine
operator|->
name|option
argument_list|(
name|QAbstractSocketEngine
operator|::
name|MulticastLoopbackOption
argument_list|)
expr_stmt|;
break|break;
case|case
name|TypeOfServiceOption
case|:
name|ret
operator|=
name|d_func
argument_list|()
operator|->
name|socketEngine
operator|->
name|option
argument_list|(
name|QAbstractSocketEngine
operator|::
name|TypeOfServiceOption
argument_list|)
expr_stmt|;
break|break;
case|case
name|SendBufferSizeSocketOption
case|:
name|ret
operator|=
name|d_func
argument_list|()
operator|->
name|socketEngine
operator|->
name|option
argument_list|(
name|QAbstractSocketEngine
operator|::
name|SendBufferSocketOption
argument_list|)
expr_stmt|;
break|break;
case|case
name|ReceiveBufferSizeSocketOption
case|:
name|ret
operator|=
name|d_func
argument_list|()
operator|->
name|socketEngine
operator|->
name|option
argument_list|(
name|QAbstractSocketEngine
operator|::
name|ReceiveBufferSocketOption
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
return|return
name|QVariant
argument_list|()
return|;
else|else
return|return
name|QVariant
argument_list|(
name|ret
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*    Returns the difference between msecs and elapsed. If msecs is -1,    however, -1 is returned. */
end_comment
begin_function
DECL|function|qt_timeout_value
specifier|static
name|int
name|qt_timeout_value
parameter_list|(
name|int
name|msecs
parameter_list|,
name|int
name|elapsed
parameter_list|)
block|{
if|if
condition|(
name|msecs
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|int
name|timeout
init|=
name|msecs
operator|-
name|elapsed
decl_stmt|;
return|return
name|timeout
operator|<
literal|0
condition|?
literal|0
else|:
name|timeout
return|;
block|}
end_function
begin_comment
comment|/*!     Waits until the socket is connected, up to \a msecs     milliseconds. If the connection has been established, this     function returns \c true; otherwise it returns \c false. In the case     where it returns \c false, you can call error() to determine     the cause of the error.      The following example waits up to one second for a connection     to be established:      \snippet code/src_network_socket_qabstractsocket.cpp 0      If msecs is -1, this function will not time out.      \note This function may wait slightly longer than \a msecs,     depending on the time it takes to complete the host lookup.      \note Multiple calls to this functions do not accumulate the time.     If the function times out, the connecting process will be aborted.      \note This function may fail randomly on Windows. Consider using the event     loop and the connected() signal if your software will run on Windows.      \sa connectToHost(), connected() */
end_comment
begin_function
DECL|function|waitForConnected
name|bool
name|QAbstractSocket
operator|::
name|waitForConnected
parameter_list|(
name|int
name|msecs
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractSocket
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QABSTRACTSOCKET_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QAbstractSocket::waitForConnected(%i)"
argument_list|,
name|msecs
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|state
argument_list|()
operator|==
name|ConnectedState
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|QABSTRACTSOCKET_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QAbstractSocket::waitForConnected(%i) already connected"
argument_list|,
name|msecs
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|true
return|;
block|}
name|bool
name|wasPendingClose
init|=
name|d
operator|->
name|pendingClose
decl_stmt|;
name|d
operator|->
name|pendingClose
operator|=
literal|false
expr_stmt|;
name|QElapsedTimer
name|stopWatch
decl_stmt|;
name|stopWatch
operator|.
name|start
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|state
operator|==
name|HostLookupState
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|QABSTRACTSOCKET_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QAbstractSocket::waitForConnected(%i) doing host name lookup"
argument_list|,
name|msecs
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|QHostInfo
operator|::
name|abortHostLookup
argument_list|(
name|d
operator|->
name|hostLookupId
argument_list|)
expr_stmt|;
name|d
operator|->
name|hostLookupId
operator|=
operator|-
literal|1
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_BEARERMANAGEMENT
name|QSharedPointer
argument_list|<
name|QNetworkSession
argument_list|>
name|networkSession
decl_stmt|;
name|QVariant
name|v
argument_list|(
name|property
argument_list|(
literal|"_q_networksession"
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|v
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|networkSession
operator|=
name|qvariant_cast
argument_list|<
name|QSharedPointer
argument_list|<
name|QNetworkSession
argument_list|>
argument_list|>
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|d
operator|->
name|_q_startConnecting
argument_list|(
name|QHostInfoPrivate
operator|::
name|fromName
argument_list|(
name|d
operator|->
name|hostName
argument_list|,
name|networkSession
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|QHostAddress
name|temp
decl_stmt|;
if|if
condition|(
name|temp
operator|.
name|setAddress
argument_list|(
name|d
operator|->
name|hostName
argument_list|)
condition|)
block|{
name|QHostInfo
name|info
decl_stmt|;
name|info
operator|.
name|setAddresses
argument_list|(
name|QList
argument_list|<
name|QHostAddress
argument_list|>
argument_list|()
operator|<<
name|temp
argument_list|)
expr_stmt|;
name|d
operator|->
name|_q_startConnecting
argument_list|(
name|info
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|_q_startConnecting
argument_list|(
name|QHostInfo
operator|::
name|fromName
argument_list|(
name|d
operator|->
name|hostName
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|state
argument_list|()
operator|==
name|UnconnectedState
condition|)
return|return
literal|false
return|;
comment|// connect not im progress anymore!
name|bool
name|timedOut
init|=
literal|true
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QABSTRACTSOCKET_DEBUG
argument_list|)
name|int
name|attempt
init|=
literal|1
decl_stmt|;
endif|#
directive|endif
while|while
condition|(
name|state
argument_list|()
operator|==
name|ConnectingState
operator|&&
operator|(
name|msecs
operator|==
operator|-
literal|1
operator|||
name|stopWatch
operator|.
name|elapsed
argument_list|()
operator|<
name|msecs
operator|)
condition|)
block|{
name|int
name|timeout
init|=
name|qt_timeout_value
argument_list|(
name|msecs
argument_list|,
name|stopWatch
operator|.
name|elapsed
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|msecs
operator|!=
operator|-
literal|1
operator|&&
name|timeout
operator|>
name|QT_CONNECT_TIMEOUT
condition|)
name|timeout
operator|=
name|QT_CONNECT_TIMEOUT
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QABSTRACTSOCKET_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QAbstractSocket::waitForConnected(%i) waiting %.2f secs for connection attempt #%i"
argument_list|,
name|msecs
argument_list|,
name|timeout
operator|/
literal|1000.0
argument_list|,
name|attempt
operator|++
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|timedOut
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|socketEngine
operator|&&
name|d
operator|->
name|socketEngine
operator|->
name|waitForWrite
argument_list|(
name|timeout
argument_list|,
operator|&
name|timedOut
argument_list|)
operator|&&
operator|!
name|timedOut
condition|)
block|{
name|d
operator|->
name|_q_testConnection
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|_q_connectToNextAddress
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|timedOut
operator|&&
name|state
argument_list|()
operator|!=
name|ConnectedState
operator|)
operator|||
name|state
argument_list|()
operator|==
name|ConnectingState
condition|)
block|{
name|d
operator|->
name|socketError
operator|=
name|SocketTimeoutError
expr_stmt|;
name|d
operator|->
name|state
operator|=
name|UnconnectedState
expr_stmt|;
emit|emit
name|stateChanged
argument_list|(
name|d
operator|->
name|state
argument_list|)
emit|;
name|d
operator|->
name|resetSocketLayer
argument_list|()
expr_stmt|;
name|setErrorString
argument_list|(
name|tr
argument_list|(
literal|"Socket operation timed out"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|QABSTRACTSOCKET_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QAbstractSocket::waitForConnected(%i) == %s"
argument_list|,
name|msecs
argument_list|,
name|state
argument_list|()
operator|==
name|ConnectedState
condition|?
literal|"true"
else|:
literal|"false"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|state
argument_list|()
operator|!=
name|ConnectedState
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|wasPendingClose
condition|)
name|disconnectFromHost
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     This function blocks until new data is available for reading and the     \l{QIODevice::}{readyRead()} signal has been emitted. The function     will timeout after \a msecs milliseconds; the default timeout is     30000 milliseconds.      The function returns \c true if the readyRead() signal is emitted and     there is new data available for reading; otherwise it returns \c false     (if an error occurred or the operation timed out).      \note This function may fail randomly on Windows. Consider using the event     loop and the readyRead() signal if your software will run on Windows.      \sa waitForBytesWritten() */
end_comment
begin_function
DECL|function|waitForReadyRead
name|bool
name|QAbstractSocket
operator|::
name|waitForReadyRead
parameter_list|(
name|int
name|msecs
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractSocket
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QABSTRACTSOCKET_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QAbstractSocket::waitForReadyRead(%i)"
argument_list|,
name|msecs
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// require calling connectToHost() before waitForReadyRead()
if|if
condition|(
name|state
argument_list|()
operator|==
name|UnconnectedState
condition|)
block|{
comment|/* If all you have is a QIODevice pointer to an abstractsocket, you cannot check            this, so you cannot avoid this warning. */
comment|//        qWarning("QAbstractSocket::waitForReadyRead() is not allowed in UnconnectedState");
return|return
literal|false
return|;
block|}
name|QElapsedTimer
name|stopWatch
decl_stmt|;
name|stopWatch
operator|.
name|start
argument_list|()
expr_stmt|;
comment|// handle a socket in connecting state
if|if
condition|(
name|state
argument_list|()
operator|==
name|HostLookupState
operator|||
name|state
argument_list|()
operator|==
name|ConnectingState
condition|)
block|{
if|if
condition|(
operator|!
name|waitForConnected
argument_list|(
name|msecs
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
name|Q_ASSERT
argument_list|(
name|d
operator|->
name|socketEngine
argument_list|)
expr_stmt|;
do|do
block|{
name|bool
name|readyToRead
init|=
literal|false
decl_stmt|;
name|bool
name|readyToWrite
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|socketEngine
operator|->
name|waitForReadOrWrite
argument_list|(
operator|&
name|readyToRead
argument_list|,
operator|&
name|readyToWrite
argument_list|,
literal|true
argument_list|,
operator|!
name|d
operator|->
name|writeBuffer
operator|.
name|isEmpty
argument_list|()
argument_list|,
name|qt_timeout_value
argument_list|(
name|msecs
argument_list|,
name|stopWatch
operator|.
name|elapsed
argument_list|()
argument_list|)
argument_list|)
condition|)
block|{
name|d
operator|->
name|socketError
operator|=
name|d
operator|->
name|socketEngine
operator|->
name|error
argument_list|()
expr_stmt|;
name|setErrorString
argument_list|(
name|d
operator|->
name|socketEngine
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QABSTRACTSOCKET_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QAbstractSocket::waitForReadyRead(%i) failed (%i, %s)"
argument_list|,
name|msecs
argument_list|,
name|d
operator|->
name|socketError
argument_list|,
name|errorString
argument_list|()
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
emit|emit
name|error
argument_list|(
name|d
operator|->
name|socketError
argument_list|)
emit|;
if|if
condition|(
name|d
operator|->
name|socketError
operator|!=
name|SocketTimeoutError
condition|)
name|close
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|readyToRead
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|canReadNotification
argument_list|()
condition|)
return|return
literal|true
return|;
block|}
if|if
condition|(
name|readyToWrite
condition|)
name|d
operator|->
name|canWriteNotification
argument_list|()
expr_stmt|;
if|if
condition|(
name|state
argument_list|()
operator|!=
name|ConnectedState
condition|)
return|return
literal|false
return|;
block|}
do|while
condition|(
name|msecs
operator|==
operator|-
literal|1
operator|||
name|qt_timeout_value
argument_list|(
name|msecs
argument_list|,
name|stopWatch
operator|.
name|elapsed
argument_list|()
argument_list|)
operator|>
literal|0
condition|)
do|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*! \reimp      This function blocks until at least one byte has been written on the socket     and the \l{QIODevice::}{bytesWritten()} signal has been emitted. The     function will timeout after \a msecs milliseconds; the default timeout is     30000 milliseconds.      The function returns \c true if the bytesWritten() signal is emitted;     otherwise it returns \c false (if an error occurred or the operation timed     out).      \note This function may fail randomly on Windows. Consider using the event     loop and the bytesWritten() signal if your software will run on Windows.      \sa waitForReadyRead()  */
end_comment
begin_function
DECL|function|waitForBytesWritten
name|bool
name|QAbstractSocket
operator|::
name|waitForBytesWritten
parameter_list|(
name|int
name|msecs
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractSocket
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QABSTRACTSOCKET_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QAbstractSocket::waitForBytesWritten(%i)"
argument_list|,
name|msecs
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// require calling connectToHost() before waitForBytesWritten()
if|if
condition|(
name|state
argument_list|()
operator|==
name|UnconnectedState
condition|)
block|{
name|qWarning
argument_list|(
literal|"QAbstractSocket::waitForBytesWritten() is not allowed in UnconnectedState"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|d
operator|->
name|writeBuffer
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
name|QElapsedTimer
name|stopWatch
decl_stmt|;
name|stopWatch
operator|.
name|start
argument_list|()
expr_stmt|;
comment|// handle a socket in connecting state
if|if
condition|(
name|state
argument_list|()
operator|==
name|HostLookupState
operator|||
name|state
argument_list|()
operator|==
name|ConnectingState
condition|)
block|{
if|if
condition|(
operator|!
name|waitForConnected
argument_list|(
name|msecs
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
forever|forever
block|{
name|bool
name|readyToRead
init|=
literal|false
decl_stmt|;
name|bool
name|readyToWrite
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|socketEngine
operator|->
name|waitForReadOrWrite
argument_list|(
operator|&
name|readyToRead
argument_list|,
operator|&
name|readyToWrite
argument_list|,
literal|true
argument_list|,
operator|!
name|d
operator|->
name|writeBuffer
operator|.
name|isEmpty
argument_list|()
argument_list|,
name|qt_timeout_value
argument_list|(
name|msecs
argument_list|,
name|stopWatch
operator|.
name|elapsed
argument_list|()
argument_list|)
argument_list|)
condition|)
block|{
name|d
operator|->
name|socketError
operator|=
name|d
operator|->
name|socketEngine
operator|->
name|error
argument_list|()
expr_stmt|;
name|setErrorString
argument_list|(
name|d
operator|->
name|socketEngine
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QABSTRACTSOCKET_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QAbstractSocket::waitForBytesWritten(%i) failed (%i, %s)"
argument_list|,
name|msecs
argument_list|,
name|d
operator|->
name|socketError
argument_list|,
name|errorString
argument_list|()
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
emit|emit
name|error
argument_list|(
name|d
operator|->
name|socketError
argument_list|)
emit|;
if|if
condition|(
name|d
operator|->
name|socketError
operator|!=
name|SocketTimeoutError
condition|)
name|close
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|readyToRead
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|QABSTRACTSOCKET_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QAbstractSocket::waitForBytesWritten calls canReadNotification"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|d
operator|->
name|canReadNotification
argument_list|()
condition|)
return|return
literal|false
return|;
block|}
if|if
condition|(
name|readyToWrite
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|canWriteNotification
argument_list|()
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|QABSTRACTSOCKET_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QAbstractSocket::waitForBytesWritten returns true"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|true
return|;
block|}
block|}
if|if
condition|(
name|state
argument_list|()
operator|!=
name|ConnectedState
condition|)
return|return
literal|false
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Waits until the socket has disconnected, up to \a msecs     milliseconds. If the connection has been disconnected, this     function returns \c true; otherwise it returns \c false. In the case     where it returns \c false, you can call error() to determine     the cause of the error.      The following example waits up to one second for a connection     to be closed:      \snippet code/src_network_socket_qabstractsocket.cpp 1      If msecs is -1, this function will not time out.      \note This function may fail randomly on Windows. Consider using the event     loop and the disconnected() signal if your software will run on Windows.      \sa disconnectFromHost(), close() */
end_comment
begin_function
DECL|function|waitForDisconnected
name|bool
name|QAbstractSocket
operator|::
name|waitForDisconnected
parameter_list|(
name|int
name|msecs
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractSocket
argument_list|)
expr_stmt|;
comment|// require calling connectToHost() before waitForDisconnected()
if|if
condition|(
name|state
argument_list|()
operator|==
name|UnconnectedState
condition|)
block|{
name|qWarning
argument_list|(
literal|"QAbstractSocket::waitForDisconnected() is not allowed in UnconnectedState"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
name|QElapsedTimer
name|stopWatch
decl_stmt|;
name|stopWatch
operator|.
name|start
argument_list|()
expr_stmt|;
comment|// handle a socket in connecting state
if|if
condition|(
name|state
argument_list|()
operator|==
name|HostLookupState
operator|||
name|state
argument_list|()
operator|==
name|ConnectingState
condition|)
block|{
if|if
condition|(
operator|!
name|waitForConnected
argument_list|(
name|msecs
argument_list|)
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|state
argument_list|()
operator|==
name|UnconnectedState
condition|)
return|return
literal|true
return|;
block|}
forever|forever
block|{
name|bool
name|readyToRead
init|=
literal|false
decl_stmt|;
name|bool
name|readyToWrite
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|socketEngine
operator|->
name|waitForReadOrWrite
argument_list|(
operator|&
name|readyToRead
argument_list|,
operator|&
name|readyToWrite
argument_list|,
name|state
argument_list|()
operator|==
name|ConnectedState
argument_list|,
operator|!
name|d
operator|->
name|writeBuffer
operator|.
name|isEmpty
argument_list|()
argument_list|,
name|qt_timeout_value
argument_list|(
name|msecs
argument_list|,
name|stopWatch
operator|.
name|elapsed
argument_list|()
argument_list|)
argument_list|)
condition|)
block|{
name|d
operator|->
name|socketError
operator|=
name|d
operator|->
name|socketEngine
operator|->
name|error
argument_list|()
expr_stmt|;
name|setErrorString
argument_list|(
name|d
operator|->
name|socketEngine
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QABSTRACTSOCKET_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QAbstractSocket::waitForReadyRead(%i) failed (%i, %s)"
argument_list|,
name|msecs
argument_list|,
name|d
operator|->
name|socketError
argument_list|,
name|errorString
argument_list|()
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
emit|emit
name|error
argument_list|(
name|d
operator|->
name|socketError
argument_list|)
emit|;
if|if
condition|(
name|d
operator|->
name|socketError
operator|!=
name|SocketTimeoutError
condition|)
name|close
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|readyToRead
condition|)
name|d
operator|->
name|canReadNotification
argument_list|()
expr_stmt|;
if|if
condition|(
name|readyToWrite
condition|)
name|d
operator|->
name|canWriteNotification
argument_list|()
expr_stmt|;
if|if
condition|(
name|state
argument_list|()
operator|==
name|UnconnectedState
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     Aborts the current connection and resets the socket. Unlike disconnectFromHost(),     this function immediately closes the socket, discarding any pending data in the     write buffer.      \sa disconnectFromHost(), close() */
end_comment
begin_function
DECL|function|abort
name|void
name|QAbstractSocket
operator|::
name|abort
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QAbstractSocket
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QABSTRACTSOCKET_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QAbstractSocket::abort()"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|writeBuffer
operator|.
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|state
operator|==
name|UnconnectedState
condition|)
return|return;
ifndef|#
directive|ifndef
name|QT_NO_SSL
if|if
condition|(
name|QSslSocket
modifier|*
name|socket
init|=
name|qobject_cast
argument_list|<
name|QSslSocket
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
condition|)
block|{
name|socket
operator|->
name|abort
argument_list|()
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
if|if
condition|(
name|d
operator|->
name|connectTimer
condition|)
block|{
name|d
operator|->
name|connectTimer
operator|->
name|stop
argument_list|()
expr_stmt|;
operator|delete
name|d
operator|->
name|connectTimer
expr_stmt|;
name|d
operator|->
name|connectTimer
operator|=
literal|0
expr_stmt|;
block|}
name|d
operator|->
name|abortCalled
operator|=
literal|true
expr_stmt|;
name|close
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|isSequential
name|bool
name|QAbstractSocket
operator|::
name|isSequential
parameter_list|()
specifier|const
block|{
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*! \reimp       Returns \c true if no more data is currently      available for reading; otherwise returns \c false.       This function is most commonly used when reading data from the      socket in a loop. For example:       \snippet code/src_network_socket_qabstractsocket.cpp 2       \sa bytesAvailable(), readyRead()  */
end_comment
begin_function
DECL|function|atEnd
name|bool
name|QAbstractSocket
operator|::
name|atEnd
parameter_list|()
specifier|const
block|{
return|return
name|QIODevice
operator|::
name|atEnd
argument_list|()
operator|&&
operator|(
operator|!
name|isOpen
argument_list|()
operator|||
name|d_func
argument_list|()
operator|->
name|buffer
operator|.
name|isEmpty
argument_list|()
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     This function writes as much as possible from the internal write buffer to     the underlying network socket, without blocking. If any data was written,     this function returns \c true; otherwise false is returned.      Call this function if you need QAbstractSocket to start sending buffered     data immediately. The number of bytes successfully written depends on the     operating system. In most cases, you do not need to call this function,     because QAbstractSocket will start sending data automatically once control     goes back to the event loop. In the absence of an event loop, call     waitForBytesWritten() instead.      \sa write(), waitForBytesWritten() */
end_comment
begin_comment
comment|// Note! docs copied to QSslSocket::flush()
end_comment
begin_function
DECL|function|flush
name|bool
name|QAbstractSocket
operator|::
name|flush
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QAbstractSocket
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_SSL
comment|// Manual polymorphism; flush() isn't virtual, but QSslSocket overloads
comment|// it.
if|if
condition|(
name|QSslSocket
modifier|*
name|socket
init|=
name|qobject_cast
argument_list|<
name|QSslSocket
operator|*
argument_list|>
argument_list|(
name|this
argument_list|)
condition|)
return|return
name|socket
operator|->
name|flush
argument_list|()
return|;
endif|#
directive|endif
name|Q_CHECK_SOCKETENGINE
argument_list|(
literal|false
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|flush
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|readData
name|qint64
name|QAbstractSocket
operator|::
name|readData
parameter_list|(
name|char
modifier|*
name|data
parameter_list|,
name|qint64
name|maxSize
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractSocket
argument_list|)
expr_stmt|;
comment|// Check if the read notifier can be enabled again.
if|if
condition|(
name|d
operator|->
name|socketEngine
operator|&&
operator|!
name|d
operator|->
name|socketEngine
operator|->
name|isReadNotificationEnabled
argument_list|()
operator|&&
name|d
operator|->
name|socketEngine
operator|->
name|isValid
argument_list|()
condition|)
name|d
operator|->
name|socketEngine
operator|->
name|setReadNotificationEnabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|maxSize
condition|)
return|return
literal|0
return|;
comment|// This is for a buffered QTcpSocket
if|if
condition|(
name|d
operator|->
name|isBuffered
condition|)
comment|// if we're still connected, return 0 indicating there may be more data in the future
comment|// if we're not connected, return -1 indicating EOF
return|return
name|d
operator|->
name|state
operator|==
name|QAbstractSocket
operator|::
name|ConnectedState
condition|?
name|qint64
argument_list|(
literal|0
argument_list|)
else|:
name|qint64
argument_list|(
operator|-
literal|1
argument_list|)
return|;
if|if
condition|(
operator|!
name|d
operator|->
name|socketEngine
condition|)
return|return
operator|-
literal|1
return|;
comment|// no socket engine is probably EOF
if|if
condition|(
operator|!
name|d
operator|->
name|socketEngine
operator|->
name|isValid
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
comment|// This is for unbuffered TCP when we already had been disconnected
if|if
condition|(
name|d
operator|->
name|state
operator|!=
name|QAbstractSocket
operator|::
name|ConnectedState
condition|)
return|return
operator|-
literal|1
return|;
comment|// This is for unbuffered TCP if we're not connected yet
name|qint64
name|readBytes
init|=
name|d
operator|->
name|socketEngine
operator|->
name|read
argument_list|(
name|data
argument_list|,
name|maxSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|readBytes
operator|==
operator|-
literal|2
condition|)
block|{
comment|// -2 from the engine means no bytes available (EAGAIN) so read more later
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|readBytes
operator|<
literal|0
condition|)
block|{
name|d
operator|->
name|socketError
operator|=
name|d
operator|->
name|socketEngine
operator|->
name|error
argument_list|()
expr_stmt|;
name|setErrorString
argument_list|(
name|d
operator|->
name|socketEngine
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
name|d
operator|->
name|resetSocketLayer
argument_list|()
expr_stmt|;
name|d
operator|->
name|state
operator|=
name|QAbstractSocket
operator|::
name|UnconnectedState
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|d
operator|->
name|socketEngine
operator|->
name|isReadNotificationEnabled
argument_list|()
condition|)
block|{
comment|// Only do this when there was no error
name|d
operator|->
name|socketEngine
operator|->
name|setReadNotificationEnabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|QABSTRACTSOCKET_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QAbstractSocket::readData(%p \"%s\", %lli) == %lld [engine]"
argument_list|,
name|data
argument_list|,
name|qt_prettyDebug
argument_list|(
name|data
argument_list|,
literal|32
argument_list|,
name|readBytes
argument_list|)
operator|.
name|data
argument_list|()
argument_list|,
name|maxSize
argument_list|,
name|readBytes
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|readBytes
return|;
block|}
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|readLineData
name|qint64
name|QAbstractSocket
operator|::
name|readLineData
parameter_list|(
name|char
modifier|*
name|data
parameter_list|,
name|qint64
name|maxlen
parameter_list|)
block|{
return|return
name|QIODevice
operator|::
name|readLineData
argument_list|(
name|data
argument_list|,
name|maxlen
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*! \reimp */
end_comment
begin_function
DECL|function|writeData
name|qint64
name|QAbstractSocket
operator|::
name|writeData
parameter_list|(
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|qint64
name|size
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractSocket
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|state
operator|==
name|QAbstractSocket
operator|::
name|UnconnectedState
condition|)
block|{
name|d
operator|->
name|socketError
operator|=
name|QAbstractSocket
operator|::
name|UnknownSocketError
expr_stmt|;
name|setErrorString
argument_list|(
name|tr
argument_list|(
literal|"Socket is not connected"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|d
operator|->
name|isBuffered
operator|&&
name|d
operator|->
name|socketType
operator|==
name|TcpSocket
operator|&&
name|d
operator|->
name|writeBuffer
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// This code is for the new Unbuffered QTcpSocket use case
name|qint64
name|written
init|=
name|d
operator|->
name|socketEngine
operator|->
name|write
argument_list|(
name|data
argument_list|,
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|written
operator|<
literal|0
condition|)
block|{
name|d
operator|->
name|socketError
operator|=
name|d
operator|->
name|socketEngine
operator|->
name|error
argument_list|()
expr_stmt|;
name|setErrorString
argument_list|(
name|d
operator|->
name|socketEngine
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|written
return|;
block|}
elseif|else
if|if
condition|(
name|written
operator|<
name|size
condition|)
block|{
comment|// Buffer what was not written yet
name|char
modifier|*
name|ptr
init|=
name|d
operator|->
name|writeBuffer
operator|.
name|reserve
argument_list|(
name|size
operator|-
name|written
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|ptr
argument_list|,
name|data
operator|+
name|written
argument_list|,
name|size
operator|-
name|written
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|socketEngine
condition|)
name|d
operator|->
name|socketEngine
operator|->
name|setWriteNotificationEnabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
return|return
name|size
return|;
comment|// size=actually written + what has been buffered
block|}
elseif|else
if|if
condition|(
operator|!
name|d
operator|->
name|isBuffered
operator|&&
name|d
operator|->
name|socketType
operator|!=
name|TcpSocket
condition|)
block|{
comment|// This is for a QUdpSocket that was connect()ed
name|qint64
name|written
init|=
name|d
operator|->
name|socketEngine
operator|->
name|write
argument_list|(
name|data
argument_list|,
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|written
operator|<
literal|0
condition|)
block|{
name|d
operator|->
name|socketError
operator|=
name|d
operator|->
name|socketEngine
operator|->
name|error
argument_list|()
expr_stmt|;
name|setErrorString
argument_list|(
name|d
operator|->
name|socketEngine
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|d
operator|->
name|writeBuffer
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|d
operator|->
name|socketEngine
operator|->
name|setWriteNotificationEnabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|QABSTRACTSOCKET_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QAbstractSocket::writeData(%p \"%s\", %lli) == %lli"
argument_list|,
name|data
argument_list|,
name|qt_prettyDebug
argument_list|(
name|data
argument_list|,
name|qMin
argument_list|(
operator|(
name|int
operator|)
name|size
argument_list|,
literal|32
argument_list|)
argument_list|,
name|size
argument_list|)
operator|.
name|data
argument_list|()
argument_list|,
name|size
argument_list|,
name|written
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|written
operator|>=
literal|0
condition|)
emit|emit
name|bytesWritten
argument_list|(
name|written
argument_list|)
emit|;
return|return
name|written
return|;
block|}
comment|// This is the code path for normal buffered QTcpSocket or
comment|// unbuffered QTcpSocket when there was already something in the
comment|// write buffer and therefore we could not do a direct engine write.
comment|// We just write to our write buffer and enable the write notifier
comment|// The write notifier then flush()es the buffer.
name|char
modifier|*
name|ptr
init|=
name|d
operator|->
name|writeBuffer
operator|.
name|reserve
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|1
condition|)
operator|*
name|ptr
operator|=
operator|*
name|data
expr_stmt|;
else|else
name|memcpy
argument_list|(
name|ptr
argument_list|,
name|data
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|qint64
name|written
init|=
name|size
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|socketEngine
operator|&&
operator|!
name|d
operator|->
name|writeBuffer
operator|.
name|isEmpty
argument_list|()
condition|)
name|d
operator|->
name|socketEngine
operator|->
name|setWriteNotificationEnabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QABSTRACTSOCKET_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QAbstractSocket::writeData(%p \"%s\", %lli) == %lli"
argument_list|,
name|data
argument_list|,
name|qt_prettyDebug
argument_list|(
name|data
argument_list|,
name|qMin
argument_list|(
operator|(
name|int
operator|)
name|size
argument_list|,
literal|32
argument_list|)
argument_list|,
name|size
argument_list|)
operator|.
name|data
argument_list|()
argument_list|,
name|size
argument_list|,
name|written
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|written
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.1      Sets the port on the local side of a connection to \a port.      You can call this function in a subclass of QAbstractSocket to     change the return value of the localPort() function after a     connection has been established. This feature is commonly used by     proxy connections for virtual connection settings.      Note that this function does not bind the local port of the socket     prior to a connection (e.g., QAbstractSocket::bind()).      \sa localAddress(), setLocalAddress(), setPeerPort() */
end_comment
begin_function
DECL|function|setLocalPort
name|void
name|QAbstractSocket
operator|::
name|setLocalPort
parameter_list|(
name|quint16
name|port
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractSocket
argument_list|)
expr_stmt|;
name|d
operator|->
name|localPort
operator|=
name|port
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.1      Sets the address on the local side of a connection to     \a address.      You can call this function in a subclass of QAbstractSocket to     change the return value of the localAddress() function after a     connection has been established. This feature is commonly used by     proxy connections for virtual connection settings.      Note that this function does not bind the local address of the socket     prior to a connection (e.g., QAbstractSocket::bind()).      \sa localAddress(), setLocalPort(), setPeerAddress() */
end_comment
begin_function
DECL|function|setLocalAddress
name|void
name|QAbstractSocket
operator|::
name|setLocalAddress
parameter_list|(
specifier|const
name|QHostAddress
modifier|&
name|address
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractSocket
argument_list|)
expr_stmt|;
name|d
operator|->
name|localAddress
operator|=
name|address
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.1      Sets the port of the remote side of the connection to     \a port.      You can call this function in a subclass of QAbstractSocket to     change the return value of the peerPort() function after a     connection has been established. This feature is commonly used by     proxy connections for virtual connection settings.      \sa peerPort(), setPeerAddress(), setLocalPort() */
end_comment
begin_function
DECL|function|setPeerPort
name|void
name|QAbstractSocket
operator|::
name|setPeerPort
parameter_list|(
name|quint16
name|port
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractSocket
argument_list|)
expr_stmt|;
name|d
operator|->
name|peerPort
operator|=
name|port
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.1      Sets the address of the remote side of the connection     to \a address.      You can call this function in a subclass of QAbstractSocket to     change the return value of the peerAddress() function after a     connection has been established. This feature is commonly used by     proxy connections for virtual connection settings.      \sa peerAddress(), setPeerPort(), setLocalAddress() */
end_comment
begin_function
DECL|function|setPeerAddress
name|void
name|QAbstractSocket
operator|::
name|setPeerAddress
parameter_list|(
specifier|const
name|QHostAddress
modifier|&
name|address
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractSocket
argument_list|)
expr_stmt|;
name|d
operator|->
name|peerAddress
operator|=
name|address
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.1      Sets the host name of the remote peer to \a name.      You can call this function in a subclass of QAbstractSocket to     change the return value of the peerName() function after a     connection has been established. This feature is commonly used by     proxy connections for virtual connection settings.      \sa peerName() */
end_comment
begin_function
DECL|function|setPeerName
name|void
name|QAbstractSocket
operator|::
name|setPeerName
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractSocket
argument_list|)
expr_stmt|;
name|d
operator|->
name|peerName
operator|=
name|name
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Closes the I/O device for the socket, disconnects the socket's connection with the     host, closes the socket, and resets the name, address, port number and underlying     socket descriptor.      See QIODevice::close() for a description of the actions that occur when an I/O     device is closed.      \sa abort() */
end_comment
begin_function
DECL|function|close
name|void
name|QAbstractSocket
operator|::
name|close
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QAbstractSocket
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QABSTRACTSOCKET_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QAbstractSocket::close()"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|QIODevice
operator|::
name|close
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|state
operator|!=
name|UnconnectedState
condition|)
block|{
name|d
operator|->
name|closeCalled
operator|=
literal|true
expr_stmt|;
name|disconnectFromHost
argument_list|()
expr_stmt|;
block|}
name|d
operator|->
name|localPort
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|peerPort
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|localAddress
operator|.
name|clear
argument_list|()
expr_stmt|;
name|d
operator|->
name|peerAddress
operator|.
name|clear
argument_list|()
expr_stmt|;
name|d
operator|->
name|peerName
operator|.
name|clear
argument_list|()
expr_stmt|;
name|d
operator|->
name|cachedSocketDescriptor
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Attempts to close the socket. If there is pending data waiting to     be written, QAbstractSocket will enter ClosingState and wait     until all data has been written. Eventually, it will enter     UnconnectedState and emit the disconnected() signal.      \sa connectToHost() */
end_comment
begin_function
DECL|function|disconnectFromHost
name|void
name|QAbstractSocket
operator|::
name|disconnectFromHost
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QAbstractSocket
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QABSTRACTSOCKET_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QAbstractSocket::disconnectFromHost()"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|d
operator|->
name|state
operator|==
name|UnconnectedState
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|QABSTRACTSOCKET_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QAbstractSocket::disconnectFromHost() was called on an unconnected socket"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
if|if
condition|(
operator|!
name|d
operator|->
name|abortCalled
operator|&&
operator|(
name|d
operator|->
name|state
operator|==
name|ConnectingState
operator|||
name|d
operator|->
name|state
operator|==
name|HostLookupState
operator|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|QABSTRACTSOCKET_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QAbstractSocket::disconnectFromHost() but we're still connecting"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|pendingClose
operator|=
literal|true
expr_stmt|;
return|return;
block|}
comment|// Disable and delete read notification
if|if
condition|(
name|d
operator|->
name|socketEngine
condition|)
name|d
operator|->
name|socketEngine
operator|->
name|setReadNotificationEnabled
argument_list|(
literal|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|abortCalled
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|QABSTRACTSOCKET_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QAbstractSocket::disconnectFromHost() aborting immediately"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|d
operator|->
name|state
operator|==
name|HostLookupState
condition|)
block|{
name|QHostInfo
operator|::
name|abortHostLookup
argument_list|(
name|d
operator|->
name|hostLookupId
argument_list|)
expr_stmt|;
name|d
operator|->
name|hostLookupId
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Perhaps emit closing()
if|if
condition|(
name|d
operator|->
name|state
operator|!=
name|ClosingState
condition|)
block|{
name|d
operator|->
name|state
operator|=
name|ClosingState
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QABSTRACTSOCKET_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QAbstractSocket::disconnectFromHost() emits stateChanged()(ClosingState)"
argument_list|)
expr_stmt|;
endif|#
directive|endif
emit|emit
name|stateChanged
argument_list|(
name|d
operator|->
name|state
argument_list|)
emit|;
block|}
else|else
block|{
if|#
directive|if
name|defined
argument_list|(
name|QABSTRACTSOCKET_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QAbstractSocket::disconnectFromHost() return from delayed close"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|// Wait for pending data to be written.
if|if
condition|(
name|d
operator|->
name|socketEngine
operator|&&
name|d
operator|->
name|socketEngine
operator|->
name|isValid
argument_list|()
operator|&&
operator|(
name|d
operator|->
name|writeBuffer
operator|.
name|size
argument_list|()
operator|>
literal|0
operator|||
name|d
operator|->
name|socketEngine
operator|->
name|bytesToWrite
argument_list|()
operator|>
literal|0
operator|)
condition|)
block|{
comment|// hack: when we are waiting for the socket engine to write bytes (only
comment|// possible when using Socks5 or HTTP socket engine), then close
comment|// anyway after 2 seconds. This is to prevent a timeout on Mac, where we
comment|// sometimes just did not get the write notifier from the underlying
comment|// CFSocket and no progress was made.
if|if
condition|(
name|d
operator|->
name|writeBuffer
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|&&
name|d
operator|->
name|socketEngine
operator|->
name|bytesToWrite
argument_list|()
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|disconnectTimer
condition|)
block|{
name|d
operator|->
name|disconnectTimer
operator|=
operator|new
name|QTimer
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|connect
argument_list|(
name|d
operator|->
name|disconnectTimer
argument_list|,
name|SIGNAL
argument_list|(
name|timeout
argument_list|()
argument_list|)
argument_list|,
name|this
argument_list|,
name|SLOT
argument_list|(
name|_q_forceDisconnect
argument_list|()
argument_list|)
argument_list|,
name|Qt
operator|::
name|DirectConnection
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|d
operator|->
name|disconnectTimer
operator|->
name|isActive
argument_list|()
condition|)
name|d
operator|->
name|disconnectTimer
operator|->
name|start
argument_list|(
literal|2000
argument_list|)
expr_stmt|;
block|}
name|d
operator|->
name|socketEngine
operator|->
name|setWriteNotificationEnabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QABSTRACTSOCKET_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QAbstractSocket::disconnectFromHost() delaying disconnect"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
else|else
block|{
if|#
directive|if
name|defined
argument_list|(
name|QABSTRACTSOCKET_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QAbstractSocket::disconnectFromHost() disconnecting immediately"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
name|SocketState
name|previousState
init|=
name|d
operator|->
name|state
decl_stmt|;
name|d
operator|->
name|resetSocketLayer
argument_list|()
expr_stmt|;
name|d
operator|->
name|state
operator|=
name|UnconnectedState
expr_stmt|;
emit|emit
name|stateChanged
argument_list|(
name|d
operator|->
name|state
argument_list|)
emit|;
emit|emit
name|readChannelFinished
argument_list|()
emit|;
comment|// we got an EOF
comment|// only emit disconnected if we were connected before
if|if
condition|(
name|previousState
operator|==
name|ConnectedState
operator|||
name|previousState
operator|==
name|ClosingState
condition|)
emit|emit
name|disconnected
argument_list|()
emit|;
name|d
operator|->
name|localPort
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|peerPort
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|localAddress
operator|.
name|clear
argument_list|()
expr_stmt|;
name|d
operator|->
name|peerAddress
operator|.
name|clear
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QABSTRACTSOCKET_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QAbstractSocket::disconnectFromHost() disconnected!"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|d
operator|->
name|closeCalled
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|QABSTRACTSOCKET_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QAbstractSocket::disconnectFromHost() closed!"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|buffer
operator|.
name|clear
argument_list|()
expr_stmt|;
name|d
operator|->
name|writeBuffer
operator|.
name|clear
argument_list|()
expr_stmt|;
name|QIODevice
operator|::
name|close
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Returns the size of the internal read buffer. This limits the     amount of data that the client can receive before you call read()     or readAll().      A read buffer size of 0 (the default) means that the buffer has     no size limit, ensuring that no data is lost.      \sa setReadBufferSize(), read() */
end_comment
begin_function
DECL|function|readBufferSize
name|qint64
name|QAbstractSocket
operator|::
name|readBufferSize
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|readBufferMaxSize
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the size of QAbstractSocket's internal read buffer to be \a     size bytes.      If the buffer size is limited to a certain size, QAbstractSocket     won't buffer more than this size of data. Exceptionally, a buffer     size of 0 means that the read buffer is unlimited and all     incoming data is buffered. This is the default.      This option is useful if you only read the data at certain points     in time (e.g., in a real-time streaming application) or if you     want to protect your socket against receiving too much data,     which may eventually cause your application to run out of memory.      Only QTcpSocket uses QAbstractSocket's internal buffer; QUdpSocket     does not use any buffering at all, but rather relies on the     implicit buffering provided by the operating system.     Because of this, calling this function on QUdpSocket has no     effect.      \sa readBufferSize(), read() */
end_comment
begin_function
DECL|function|setReadBufferSize
name|void
name|QAbstractSocket
operator|::
name|setReadBufferSize
parameter_list|(
name|qint64
name|size
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractSocket
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|readBufferMaxSize
operator|==
name|size
condition|)
return|return;
name|d
operator|->
name|readBufferMaxSize
operator|=
name|size
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|readSocketNotifierCalled
operator|&&
name|d
operator|->
name|socketEngine
condition|)
block|{
comment|// ensure that the read notification is enabled if we've now got
comment|// room in the read buffer
comment|// but only if we're not inside canReadNotification -- that will take care on its own
if|if
condition|(
operator|(
name|size
operator|==
literal|0
operator|||
name|d
operator|->
name|buffer
operator|.
name|size
argument_list|()
operator|<
name|size
operator|)
operator|&&
name|d
operator|->
name|state
operator|==
name|QAbstractSocket
operator|::
name|ConnectedState
condition|)
comment|// Do not change the notifier unless we are connected.
name|d
operator|->
name|socketEngine
operator|->
name|setReadNotificationEnabled
argument_list|(
literal|true
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Returns the state of the socket.      \sa error() */
end_comment
begin_function
DECL|function|state
name|QAbstractSocket
operator|::
name|SocketState
name|QAbstractSocket
operator|::
name|state
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|state
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the state of the socket to \a state.      \sa state() */
end_comment
begin_function
DECL|function|setSocketState
name|void
name|QAbstractSocket
operator|::
name|setSocketState
parameter_list|(
name|SocketState
name|state
parameter_list|)
block|{
name|d_func
argument_list|()
operator|->
name|state
operator|=
name|state
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the socket type (TCP, UDP, or other).      \sa QTcpSocket, QUdpSocket */
end_comment
begin_function
DECL|function|socketType
name|QAbstractSocket
operator|::
name|SocketType
name|QAbstractSocket
operator|::
name|socketType
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|socketType
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the type of error that last occurred.      \sa state(), errorString() */
end_comment
begin_function
DECL|function|error
name|QAbstractSocket
operator|::
name|SocketError
name|QAbstractSocket
operator|::
name|error
parameter_list|()
specifier|const
block|{
return|return
name|d_func
argument_list|()
operator|->
name|socketError
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the type of error that last occurred to \a socketError.      \sa setSocketState(), setErrorString() */
end_comment
begin_function
DECL|function|setSocketError
name|void
name|QAbstractSocket
operator|::
name|setSocketError
parameter_list|(
name|SocketError
name|socketError
parameter_list|)
block|{
name|d_func
argument_list|()
operator|->
name|socketError
operator|=
name|socketError
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
end_ifndef
begin_comment
comment|/*!     \since 4.1      Sets the explicit network proxy for this socket to \a networkProxy.      To disable the use of a proxy for this socket, use the     QNetworkProxy::NoProxy proxy type:      \snippet code/src_network_socket_qabstractsocket.cpp 3      The default value for the proxy is QNetworkProxy::DefaultProxy,     which means the socket will use the application settings: if a     proxy is set with QNetworkProxy::setApplicationProxy, it will use     that; otherwise, if a factory is set with     QNetworkProxyFactory::setApplicationProxyFactory, it will query     that factory with type QNetworkProxyQuery::TcpSocket.      \sa proxy(), QNetworkProxy, QNetworkProxyFactory::queryProxy() */
end_comment
begin_function
DECL|function|setProxy
name|void
name|QAbstractSocket
operator|::
name|setProxy
parameter_list|(
specifier|const
name|QNetworkProxy
modifier|&
name|networkProxy
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QAbstractSocket
argument_list|)
expr_stmt|;
name|d
operator|->
name|proxy
operator|=
name|networkProxy
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.1      Returns the network proxy for this socket.     By default QNetworkProxy::DefaultProxy is used, which means this     socket will query the default proxy settings for the application.      \sa setProxy(), QNetworkProxy, QNetworkProxyFactory */
end_comment
begin_function
DECL|function|proxy
name|QNetworkProxy
name|QAbstractSocket
operator|::
name|proxy
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QAbstractSocket
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|proxy
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_NETWORKPROXY
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DEBUG_STREAM
end_ifndef
begin_function
DECL|function|operator <<
name|Q_NETWORK_EXPORT
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|debug
parameter_list|,
name|QAbstractSocket
operator|::
name|SocketError
name|error
parameter_list|)
block|{
switch|switch
condition|(
name|error
condition|)
block|{
case|case
name|QAbstractSocket
operator|::
name|ConnectionRefusedError
case|:
name|debug
operator|<<
literal|"QAbstractSocket::ConnectionRefusedError"
expr_stmt|;
break|break;
case|case
name|QAbstractSocket
operator|::
name|RemoteHostClosedError
case|:
name|debug
operator|<<
literal|"QAbstractSocket::RemoteHostClosedError"
expr_stmt|;
break|break;
case|case
name|QAbstractSocket
operator|::
name|HostNotFoundError
case|:
name|debug
operator|<<
literal|"QAbstractSocket::HostNotFoundError"
expr_stmt|;
break|break;
case|case
name|QAbstractSocket
operator|::
name|SocketAccessError
case|:
name|debug
operator|<<
literal|"QAbstractSocket::SocketAccessError"
expr_stmt|;
break|break;
case|case
name|QAbstractSocket
operator|::
name|SocketResourceError
case|:
name|debug
operator|<<
literal|"QAbstractSocket::SocketResourceError"
expr_stmt|;
break|break;
case|case
name|QAbstractSocket
operator|::
name|SocketTimeoutError
case|:
name|debug
operator|<<
literal|"QAbstractSocket::SocketTimeoutError"
expr_stmt|;
break|break;
case|case
name|QAbstractSocket
operator|::
name|DatagramTooLargeError
case|:
name|debug
operator|<<
literal|"QAbstractSocket::DatagramTooLargeError"
expr_stmt|;
break|break;
case|case
name|QAbstractSocket
operator|::
name|NetworkError
case|:
name|debug
operator|<<
literal|"QAbstractSocket::NetworkError"
expr_stmt|;
break|break;
case|case
name|QAbstractSocket
operator|::
name|AddressInUseError
case|:
name|debug
operator|<<
literal|"QAbstractSocket::AddressInUseError"
expr_stmt|;
break|break;
case|case
name|QAbstractSocket
operator|::
name|SocketAddressNotAvailableError
case|:
name|debug
operator|<<
literal|"QAbstractSocket::SocketAddressNotAvailableError"
expr_stmt|;
break|break;
case|case
name|QAbstractSocket
operator|::
name|UnsupportedSocketOperationError
case|:
name|debug
operator|<<
literal|"QAbstractSocket::UnsupportedSocketOperationError"
expr_stmt|;
break|break;
case|case
name|QAbstractSocket
operator|::
name|UnfinishedSocketOperationError
case|:
name|debug
operator|<<
literal|"QAbstractSocket::UnfinishedSocketOperationError"
expr_stmt|;
break|break;
case|case
name|QAbstractSocket
operator|::
name|ProxyAuthenticationRequiredError
case|:
name|debug
operator|<<
literal|"QAbstractSocket::ProxyAuthenticationRequiredError"
expr_stmt|;
break|break;
case|case
name|QAbstractSocket
operator|::
name|UnknownSocketError
case|:
name|debug
operator|<<
literal|"QAbstractSocket::UnknownSocketError"
expr_stmt|;
break|break;
case|case
name|QAbstractSocket
operator|::
name|ProxyConnectionRefusedError
case|:
name|debug
operator|<<
literal|"QAbstractSocket::ProxyConnectionRefusedError"
expr_stmt|;
break|break;
case|case
name|QAbstractSocket
operator|::
name|ProxyConnectionClosedError
case|:
name|debug
operator|<<
literal|"QAbstractSocket::ProxyConnectionClosedError"
expr_stmt|;
break|break;
case|case
name|QAbstractSocket
operator|::
name|ProxyConnectionTimeoutError
case|:
name|debug
operator|<<
literal|"QAbstractSocket::ProxyConnectionTimeoutError"
expr_stmt|;
break|break;
case|case
name|QAbstractSocket
operator|::
name|ProxyNotFoundError
case|:
name|debug
operator|<<
literal|"QAbstractSocket::ProxyNotFoundError"
expr_stmt|;
break|break;
case|case
name|QAbstractSocket
operator|::
name|ProxyProtocolError
case|:
name|debug
operator|<<
literal|"QAbstractSocket::ProxyProtocolError"
expr_stmt|;
break|break;
default|default:
name|debug
operator|<<
literal|"QAbstractSocket::SocketError("
operator|<<
name|int
argument_list|(
name|error
argument_list|)
operator|<<
literal|')'
expr_stmt|;
break|break;
block|}
return|return
name|debug
return|;
block|}
end_function
begin_function
DECL|function|operator <<
name|Q_NETWORK_EXPORT
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|debug
parameter_list|,
name|QAbstractSocket
operator|::
name|SocketState
name|state
parameter_list|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|QAbstractSocket
operator|::
name|UnconnectedState
case|:
name|debug
operator|<<
literal|"QAbstractSocket::UnconnectedState"
expr_stmt|;
break|break;
case|case
name|QAbstractSocket
operator|::
name|HostLookupState
case|:
name|debug
operator|<<
literal|"QAbstractSocket::HostLookupState"
expr_stmt|;
break|break;
case|case
name|QAbstractSocket
operator|::
name|ConnectingState
case|:
name|debug
operator|<<
literal|"QAbstractSocket::ConnectingState"
expr_stmt|;
break|break;
case|case
name|QAbstractSocket
operator|::
name|ConnectedState
case|:
name|debug
operator|<<
literal|"QAbstractSocket::ConnectedState"
expr_stmt|;
break|break;
case|case
name|QAbstractSocket
operator|::
name|BoundState
case|:
name|debug
operator|<<
literal|"QAbstractSocket::BoundState"
expr_stmt|;
break|break;
case|case
name|QAbstractSocket
operator|::
name|ListeningState
case|:
name|debug
operator|<<
literal|"QAbstractSocket::ListeningState"
expr_stmt|;
break|break;
case|case
name|QAbstractSocket
operator|::
name|ClosingState
case|:
name|debug
operator|<<
literal|"QAbstractSocket::ClosingState"
expr_stmt|;
break|break;
default|default:
name|debug
operator|<<
literal|"QAbstractSocket::SocketState("
operator|<<
name|int
argument_list|(
name|state
argument_list|)
operator|<<
literal|')'
expr_stmt|;
break|break;
block|}
return|return
name|debug
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_include
include|#
directive|include
file|"moc_qabstractsocket.cpp"
end_include
end_unit
