begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtNetwork module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_comment
comment|//#define QSSLSOCKET_DEBUG
end_comment
begin_comment
comment|/*!     \class QSslSocket     \brief The QSslSocket class provides an SSL encrypted socket for both     clients and servers.     \since 4.3      \reentrant     \ingroup network     \ingroup ssl     \inmodule QtNetwork      QSslSocket establishes a secure, encrypted TCP connection you can     use for transmitting encrypted data. It can operate in both client     and server mode, and it supports modern SSL protocols, including     SSLv3 and TLSv1_0. By default, QSslSocket uses TLSv1_0, but you can     change the SSL protocol by calling setProtocol() as long as you do     it before the handshake has started.      SSL encryption operates on top of the existing TCP stream after     the socket enters the ConnectedState. There are two simple ways to     establish a secure connection using QSslSocket: With an immediate     SSL handshake, or with a delayed SSL handshake occurring after the     connection has been established in unencrypted mode.      The most common way to use QSslSocket is to construct an object     and start a secure connection by calling connectToHostEncrypted().     This method starts an immediate SSL handshake once the connection     has been established.      \snippet code/src_network_ssl_qsslsocket.cpp 0      As with a plain QTcpSocket, QSslSocket enters the HostLookupState,     ConnectingState, and finally the ConnectedState, if the connection     is successful. The handshake then starts automatically, and if it     succeeds, the encrypted() signal is emitted to indicate the socket     has entered the encrypted state and is ready for use.      Note that data can be written to the socket immediately after the     return from connectToHostEncrypted() (i.e., before the encrypted()     signal is emitted). The data is queued in QSslSocket until after     the encrypted() signal is emitted.      An example of using the delayed SSL handshake to secure an     existing connection is the case where an SSL server secures an     incoming connection. Suppose you create an SSL server class as a     subclass of QTcpServer. You would override     QTcpServer::incomingConnection() with something like the example     below, which first constructs an instance of QSslSocket and then     calls setSocketDescriptor() to set the new socket's descriptor to     the existing one passed in. It then initiates the SSL handshake     by calling startServerEncryption().      \snippet code/src_network_ssl_qsslsocket.cpp 1      If an error occurs, QSslSocket emits the sslErrors() signal. In this     case, if no action is taken to ignore the error(s), the connection     is dropped. To continue, despite the occurrence of an error, you     can call ignoreSslErrors(), either from within this slot after the     error occurs, or any time after construction of the QSslSocket and     before the connection is attempted. This will allow QSslSocket to     ignore the errors it encounters when establishing the identity of     the peer. Ignoring errors during an SSL handshake should be used     with caution, since a fundamental characteristic of secure     connections is that they should be established with a successful     handshake.      Once encrypted, you use QSslSocket as a regular QTcpSocket. When     readyRead() is emitted, you can call read(), canReadLine() and     readLine(), or getChar() to read decrypted data from QSslSocket's     internal buffer, and you can call write() or putChar() to write     data back to the peer. QSslSocket will automatically encrypt the     written data for you, and emit encryptedBytesWritten() once     the data has been written to the peer.      As a convenience, QSslSocket supports QTcpSocket's blocking     functions waitForConnected(), waitForReadyRead(),     waitForBytesWritten(), and waitForDisconnected(). It also provides     waitForEncrypted(), which will block the calling thread until an     encrypted connection has been established.      \snippet code/src_network_ssl_qsslsocket.cpp 2      QSslSocket provides an extensive, easy-to-use API for handling     cryptographic ciphers, private keys, and local, peer, and     Certification Authority (CA) certificates. It also provides an API     for handling errors that occur during the handshake phase.      The following features can also be customized:      \list     \li The socket's cryptographic cipher suite can be customized before     the handshake phase with setCiphers() and setDefaultCiphers().     \li The socket's local certificate and private key can be customized     before the handshake phase with setLocalCertificate() and     setPrivateKey().     \li The CA certificate database can be extended and customized with     addCaCertificate(), addCaCertificates(), setCaCertificates(),     addDefaultCaCertificate(), addDefaultCaCertificates(), and     setDefaultCaCertificates().     \endlist      \note If available, root certificates on Unix (excluding Mac OS X) will be     loaded on demand from the standard certificate directories. If     you do not want to load root certificates on demand, you need to call either     the static function setDefaultCaCertificates() before the first SSL handshake     is made in your application, (e.g. via     "QSslSocket::setDefaultCaCertificates(QSslSocket::systemCaCertificates());"),     or call setCaCertificates() on your QSslSocket instance prior to the SSL     handshake.      For more information about ciphers and certificates, refer to QSslCipher and     QSslCertificate.      This product includes software developed by the OpenSSL Project     for use in the OpenSSL Toolkit (\l{http://www.openssl.org/}).      \note Be aware of the difference between the bytesWritten() signal and     the encryptedBytesWritten() signal. For a QTcpSocket, bytesWritten()     will get emitted as soon as data has been written to the TCP socket.     For a QSslSocket, bytesWritten() will get emitted when the data     is being encrypted and encryptedBytesWritten()     will get emitted as soon as data has been written to the TCP socket.      \sa QSslCertificate, QSslCipher, QSslError */
end_comment
begin_comment
comment|/*!     \enum QSslSocket::SslMode      Describes the connection modes available for QSslSocket.      \value UnencryptedMode The socket is unencrypted. Its     behavior is identical to QTcpSocket.      \value SslClientMode The socket is a client-side SSL socket.     It is either alreayd encrypted, or it is in the SSL handshake     phase (see QSslSocket::isEncrypted()).      \value SslServerMode The socket is a server-side SSL socket.     It is either already encrypted, or it is in the SSL handshake     phase (see QSslSocket::isEncrypted()). */
end_comment
begin_comment
comment|/*!     \enum QSslSocket::PeerVerifyMode     \since 4.4      Describes the peer verification modes for QSslSocket. The default mode is     AutoVerifyPeer, which selects an appropriate mode depending on the     socket's QSocket::SslMode.      \value VerifyNone QSslSocket will not request a certificate from the     peer. You can set this mode if you are not interested in the identity of     the other side of the connection. The connection will still be encrypted,     and your socket will still send its local certificate to the peer if it's     requested.      \value QueryPeer QSslSocket will request a certificate from the peer, but     does not require this certificate to be valid. This is useful when you     want to display peer certificate details to the user without affecting the     actual SSL handshake. This mode is the default for servers.      \value VerifyPeer QSslSocket will request a certificate from the peer     during the SSL handshake phase, and requires that this certificate is     valid. On failure, QSslSocket will emit the QSslSocket::sslErrors()     signal. This mode is the default for clients.      \value AutoVerifyPeer QSslSocket will automatically use QueryPeer for     server sockets and VerifyPeer for client sockets.      \sa QSslSocket::peerVerifyMode() */
end_comment
begin_comment
comment|/*!     \fn QSslSocket::encrypted()      This signal is emitted when QSslSocket enters encrypted mode. After this     signal has been emitted, QSslSocket::isEncrypted() will return true, and     all further transmissions on the socket will be encrypted.      \sa QSslSocket::connectToHostEncrypted(), QSslSocket::isEncrypted() */
end_comment
begin_comment
comment|/*!     \fn QSslSocket::modeChanged(QSslSocket::SslMode mode)      This signal is emitted when QSslSocket changes from \l     QSslSocket::UnencryptedMode to either \l QSslSocket::SslClientMode or \l     QSslSocket::SslServerMode. \a mode is the new mode.      \sa QSslSocket::mode() */
end_comment
begin_comment
comment|/*!     \fn QSslSocket::encryptedBytesWritten(qint64 written)     \since 4.4      This signal is emitted when QSslSocket writes its encrypted data to the     network. The \a written parameter contains the number of bytes that were     successfully written.      \sa QIODevice::bytesWritten() */
end_comment
begin_comment
comment|/*!     \fn void QSslSocket::peerVerifyError(const QSslError&error)     \since 4.4      QSslSocket can emit this signal several times during the SSL handshake,     before encryption has been established, to indicate that an error has     occurred while establishing the identity of the peer. The \a error is     usually an indication that QSslSocket is unable to securely identify the     peer.      This signal provides you with an early indication when something's wrong.     By connecting to this signal, you can manually choose to tear down the     connection from inside the connected slot before the handshake has     completed. If no action is taken, QSslSocket will proceed to emitting     QSslSocket::sslErrors().      \sa sslErrors() */
end_comment
begin_comment
comment|/*!     \fn void QSslSocket::sslErrors(const QList<QSslError>&errors);          QSslSocket emits this signal after the SSL handshake to indicate that one     or more errors have occurred while establishing the identity of the     peer. The errors are usually an indication that QSslSocket is unable to     securely identify the peer. Unless any action is taken, the connection     will be dropped after this signal has been emitted.      If you want to continue connecting despite the errors that have occurred,     you must call QSslSocket::ignoreSslErrors() from inside a slot connected to     this signal. If you need to access the error list at a later point, you     can call sslErrors() (without arguments).      \a errors contains one or more errors that prevent QSslSocket from     verifying the identity of the peer.          Note: You cannot use Qt::QueuedConnection when connecting to this signal,     or calling QSslSocket::ignoreSslErrors() will have no effect.      \sa peerVerifyError() */
end_comment
begin_include
include|#
directive|include
file|"qsslsocket.h"
end_include
begin_include
include|#
directive|include
file|"qsslcipher.h"
end_include
begin_include
include|#
directive|include
file|"qsslsocket_openssl_p.h"
end_include
begin_include
include|#
directive|include
file|"qsslconfiguration_p.h"
end_include
begin_include
include|#
directive|include
file|<QtCore/qdebug.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qdir.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qmutex.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qelapsedtimer.h>
end_include
begin_include
include|#
directive|include
file|<QtNetwork/qhostaddress.h>
end_include
begin_include
include|#
directive|include
file|<QtNetwork/qhostinfo.h>
end_include
begin_function
name|QT_BEGIN_NAMESPACE
comment|/*    Returns the difference between msecs and elapsed. If msecs is -1,    however, -1 is returned. */
DECL|function|qt_timeout_value
specifier|static
name|int
name|qt_timeout_value
parameter_list|(
name|int
name|msecs
parameter_list|,
name|int
name|elapsed
parameter_list|)
block|{
if|if
condition|(
name|msecs
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|int
name|timeout
init|=
name|msecs
operator|-
name|elapsed
decl_stmt|;
return|return
name|timeout
operator|<
literal|0
condition|?
literal|0
else|:
name|timeout
return|;
block|}
end_function
begin_class
DECL|class|QSslSocketGlobalData
class|class
name|QSslSocketGlobalData
block|{
public|public:
DECL|function|QSslSocketGlobalData
name|QSslSocketGlobalData
parameter_list|()
member_init_list|:
name|config
argument_list|(
operator|new
name|QSslConfigurationPrivate
argument_list|)
block|{}
DECL|member|mutex
name|QMutex
name|mutex
decl_stmt|;
DECL|member|supportedCiphers
name|QList
argument_list|<
name|QSslCipher
argument_list|>
name|supportedCiphers
decl_stmt|;
DECL|member|config
name|QExplicitlySharedDataPointer
argument_list|<
name|QSslConfigurationPrivate
argument_list|>
name|config
decl_stmt|;
block|}
class|;
end_class
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|QSslSocketGlobalData
argument_list|,
argument|globalData
argument_list|)
end_macro
begin_comment
comment|/*!     Constructs a QSslSocket object. \a parent is passed to QObject's     constructor. The new socket's \l {QSslCipher} {cipher} suite is     set to the one returned by the static method defaultCiphers(). */
end_comment
begin_constructor
DECL|function|QSslSocket
name|QSslSocket
operator|::
name|QSslSocket
parameter_list|(
name|QObject
modifier|*
name|parent
parameter_list|)
member_init_list|:
name|QTcpSocket
argument_list|(
operator|*
operator|new
name|QSslSocketBackendPrivate
argument_list|,
name|parent
argument_list|)
block|{
name|Q_D
argument_list|(
name|QSslSocket
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QSSLSOCKET_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QSslSocket::QSslSocket("
operator|<<
name|parent
operator|<<
literal|"), this ="
operator|<<
operator|(
name|void
operator|*
operator|)
name|this
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|q_ptr
operator|=
name|this
expr_stmt|;
name|d
operator|->
name|init
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Destroys the QSslSocket. */
end_comment
begin_destructor
DECL|function|~QSslSocket
name|QSslSocket
operator|::
name|~
name|QSslSocket
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QSslSocket
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QSSLSOCKET_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QSslSocket::~QSslSocket(), this ="
operator|<<
operator|(
name|void
operator|*
operator|)
name|this
expr_stmt|;
endif|#
directive|endif
operator|delete
name|d
operator|->
name|plainSocket
expr_stmt|;
name|d
operator|->
name|plainSocket
operator|=
literal|0
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     \reimp      \since 5.0      Continues data transfer on the socket after it has been paused. If     "setPauseMode(QAbstractSocket::PauseOnSslErrors);" has been called on     this socket and a sslErrors() signal is received, calling this method     is necessary for the socket to continue.      \sa QAbstractSocket::pauseMode(), QAbstractSocket::setPauseMode() */
end_comment
begin_function
DECL|function|resume
name|void
name|QSslSocket
operator|::
name|resume
parameter_list|()
block|{
comment|// continuing might emit signals, rather do this through the event loop
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|this
argument_list|,
literal|"_q_resumeImplementation"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Starts an encrypted connection to the device \a hostName on \a     port, using \a mode as the \l OpenMode. This is equivalent to     calling connectToHost() to establish the connection, followed by a     call to startClientEncryption(). The \a protocol parameter can be     used to specify which network protocol to use (eg. IPv4 or IPv6).      QSslSocket first enters the HostLookupState. Then, after entering     either the event loop or one of the waitFor...() functions, it     enters the ConnectingState, emits connected(), and then initiates     the SSL client handshake. At each state change, QSslSocket emits     signal stateChanged().      After initiating the SSL client handshake, if the identity of the     peer can't be established, signal sslErrors() is emitted. If you     want to ignore the errors and continue connecting, you must call     ignoreSslErrors(), either from inside a slot function connected to     the sslErrors() signal, or prior to entering encrypted mode. If     ignoreSslErrors() is not called, the connection is dropped, signal     disconnected() is emitted, and QSslSocket returns to the     UnconnectedState.      If the SSL handshake is successful, QSslSocket emits encrypted().      \snippet code/src_network_ssl_qsslsocket.cpp 3      \b{Note:} The example above shows that text can be written to     the socket immediately after requesting the encrypted connection,     before the encrypted() signal has been emitted. In such cases, the     text is queued in the object and written to the socket \e after     the connection is established and the encrypted() signal has been     emitted.      The default for \a mode is \l ReadWrite.      If you want to create a QSslSocket on the server side of a connection, you     should instead call startServerEncryption() upon receiving the incoming     connection through QTcpServer.      \sa connectToHost(), startClientEncryption(), waitForConnected(), waitForEncrypted() */
end_comment
begin_function
DECL|function|connectToHostEncrypted
name|void
name|QSslSocket
operator|::
name|connectToHostEncrypted
parameter_list|(
specifier|const
name|QString
modifier|&
name|hostName
parameter_list|,
name|quint16
name|port
parameter_list|,
name|OpenMode
name|mode
parameter_list|,
name|NetworkLayerProtocol
name|protocol
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSslSocket
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|state
operator|==
name|ConnectedState
operator|||
name|d
operator|->
name|state
operator|==
name|ConnectingState
condition|)
block|{
name|qWarning
argument_list|(
literal|"QSslSocket::connectToHostEncrypted() called when already connecting/connected"
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|init
argument_list|()
expr_stmt|;
name|d
operator|->
name|autoStartHandshake
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|initialized
operator|=
literal|true
expr_stmt|;
comment|// Note: When connecting to localhost, some platforms (e.g., HP-UX and some BSDs)
comment|// establish the connection immediately (i.e., first attempt).
name|connectToHost
argument_list|(
name|hostName
argument_list|,
name|port
argument_list|,
name|mode
argument_list|,
name|protocol
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.6     \overload      In addition to the original behaviour of connectToHostEncrypted,     this overloaded method enables the usage of a different hostname      (\a sslPeerName) for the certificate validation instead of     the one used for the TCP connection (\a hostName).      \sa connectToHostEncrypted() */
end_comment
begin_function
DECL|function|connectToHostEncrypted
name|void
name|QSslSocket
operator|::
name|connectToHostEncrypted
parameter_list|(
specifier|const
name|QString
modifier|&
name|hostName
parameter_list|,
name|quint16
name|port
parameter_list|,
specifier|const
name|QString
modifier|&
name|sslPeerName
parameter_list|,
name|OpenMode
name|mode
parameter_list|,
name|NetworkLayerProtocol
name|protocol
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSslSocket
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|state
operator|==
name|ConnectedState
operator|||
name|d
operator|->
name|state
operator|==
name|ConnectingState
condition|)
block|{
name|qWarning
argument_list|(
literal|"QSslSocket::connectToHostEncrypted() called when already connecting/connected"
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|init
argument_list|()
expr_stmt|;
name|d
operator|->
name|autoStartHandshake
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|initialized
operator|=
literal|true
expr_stmt|;
name|d
operator|->
name|verificationPeerName
operator|=
name|sslPeerName
expr_stmt|;
comment|// Note: When connecting to localhost, some platforms (e.g., HP-UX and some BSDs)
comment|// establish the connection immediately (i.e., first attempt).
name|connectToHost
argument_list|(
name|hostName
argument_list|,
name|port
argument_list|,
name|mode
argument_list|,
name|protocol
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Initializes QSslSocket with the native socket descriptor \a     socketDescriptor. Returns true if \a socketDescriptor is accepted     as a valid socket descriptor; otherwise returns false.     The socket is opened in the mode specified by \a openMode, and     enters the socket state specified by \a state.      \b{Note:} It is not possible to initialize two sockets with the same     native socket descriptor.      \sa socketDescriptor() */
end_comment
begin_function
DECL|function|setSocketDescriptor
name|bool
name|QSslSocket
operator|::
name|setSocketDescriptor
parameter_list|(
name|qintptr
name|socketDescriptor
parameter_list|,
name|SocketState
name|state
parameter_list|,
name|OpenMode
name|openMode
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSslSocket
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QSSLSOCKET_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QSslSocket::setSocketDescriptor("
operator|<<
name|socketDescriptor
operator|<<
literal|','
operator|<<
name|state
operator|<<
literal|','
operator|<<
name|openMode
operator|<<
literal|')'
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|d
operator|->
name|plainSocket
condition|)
name|d
operator|->
name|createPlainSocket
argument_list|(
name|openMode
argument_list|)
expr_stmt|;
name|bool
name|retVal
init|=
name|d
operator|->
name|plainSocket
operator|->
name|setSocketDescriptor
argument_list|(
name|socketDescriptor
argument_list|,
name|state
argument_list|,
name|openMode
argument_list|)
decl_stmt|;
name|d
operator|->
name|cachedSocketDescriptor
operator|=
name|d
operator|->
name|plainSocket
operator|->
name|socketDescriptor
argument_list|()
expr_stmt|;
name|setSocketError
argument_list|(
name|d
operator|->
name|plainSocket
operator|->
name|error
argument_list|()
argument_list|)
expr_stmt|;
name|setSocketState
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|setOpenMode
argument_list|(
name|openMode
argument_list|)
expr_stmt|;
name|setLocalPort
argument_list|(
name|d
operator|->
name|plainSocket
operator|->
name|localPort
argument_list|()
argument_list|)
expr_stmt|;
name|setLocalAddress
argument_list|(
name|d
operator|->
name|plainSocket
operator|->
name|localAddress
argument_list|()
argument_list|)
expr_stmt|;
name|setPeerPort
argument_list|(
name|d
operator|->
name|plainSocket
operator|->
name|peerPort
argument_list|()
argument_list|)
expr_stmt|;
name|setPeerAddress
argument_list|(
name|d
operator|->
name|plainSocket
operator|->
name|peerAddress
argument_list|()
argument_list|)
expr_stmt|;
name|setPeerName
argument_list|(
name|d
operator|->
name|plainSocket
operator|->
name|peerName
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|retVal
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.6     Sets the given \a option to the value described by \a value.      \sa socketOption() */
end_comment
begin_function
DECL|function|setSocketOption
name|void
name|QSslSocket
operator|::
name|setSocketOption
parameter_list|(
name|QAbstractSocket
operator|::
name|SocketOption
name|option
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|value
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSslSocket
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|plainSocket
condition|)
name|d
operator|->
name|plainSocket
operator|->
name|setSocketOption
argument_list|(
name|option
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.6     Returns the value of the \a option option.      \sa setSocketOption() */
end_comment
begin_function
DECL|function|socketOption
name|QVariant
name|QSslSocket
operator|::
name|socketOption
parameter_list|(
name|QAbstractSocket
operator|::
name|SocketOption
name|option
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSslSocket
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|plainSocket
condition|)
return|return
name|d
operator|->
name|plainSocket
operator|->
name|socketOption
argument_list|(
name|option
argument_list|)
return|;
else|else
return|return
name|QVariant
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the current mode for the socket; either UnencryptedMode, where     QSslSocket behaves identially to QTcpSocket, or one of SslClientMode or     SslServerMode, where the client is either negotiating or in encrypted     mode.      When the mode changes, QSslSocket emits modeChanged()      \sa SslMode */
end_comment
begin_function
DECL|function|mode
name|QSslSocket
operator|::
name|SslMode
name|QSslSocket
operator|::
name|mode
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSslSocket
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|mode
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the socket is encrypted; otherwise, false is returned.      An encrypted socket encrypts all data that is written by calling write()     or putChar() before the data is written to the network, and decrypts all     incoming data as the data is received from the network, before you call     read(), readLine() or getChar().      QSslSocket emits encrypted() when it enters encrypted mode.      You can call sessionCipher() to find which cryptographic cipher is used to     encrypt and decrypt your data.      \sa mode() */
end_comment
begin_function
DECL|function|isEncrypted
name|bool
name|QSslSocket
operator|::
name|isEncrypted
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSslSocket
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|connectionEncrypted
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the socket's SSL protocol. By default, \l QSsl::SecureProtocols is used.      \sa setProtocol() */
end_comment
begin_function
DECL|function|protocol
name|QSsl
operator|::
name|SslProtocol
name|QSslSocket
operator|::
name|protocol
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSslSocket
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|configuration
operator|.
name|protocol
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the socket's SSL protocol to \a protocol. This will affect the next     initiated handshake; calling this function on an already-encrypted socket     will not affect the socket's protocol. */
end_comment
begin_function
DECL|function|setProtocol
name|void
name|QSslSocket
operator|::
name|setProtocol
parameter_list|(
name|QSsl
operator|::
name|SslProtocol
name|protocol
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSslSocket
argument_list|)
expr_stmt|;
name|d
operator|->
name|configuration
operator|.
name|protocol
operator|=
name|protocol
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Returns the socket's verify mode. This mode decides whether     QSslSocket should request a certificate from the peer (i.e., the client     requests a certificate from the server, or a server requesting a     certificate from the client), and whether it should require that this     certificate is valid.      The default mode is AutoVerifyPeer, which tells QSslSocket to use     VerifyPeer for clients and QueryPeer for servers.      \sa setPeerVerifyMode(), peerVerifyDepth(), mode() */
end_comment
begin_function
DECL|function|peerVerifyMode
name|QSslSocket
operator|::
name|PeerVerifyMode
name|QSslSocket
operator|::
name|peerVerifyMode
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSslSocket
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|configuration
operator|.
name|peerVerifyMode
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Sets the socket's verify mode to \a mode. This mode decides whether     QSslSocket should request a certificate from the peer (i.e., the client     requests a certificate from the server, or a server requesting a     certificate from the client), and whether it should require that this     certificate is valid.      The default mode is AutoVerifyPeer, which tells QSslSocket to use     VerifyPeer for clients and QueryPeer for servers.      Setting this mode after encryption has started has no effect on the     current connection.      \sa peerVerifyMode(), setPeerVerifyDepth(), mode() */
end_comment
begin_function
DECL|function|setPeerVerifyMode
name|void
name|QSslSocket
operator|::
name|setPeerVerifyMode
parameter_list|(
name|QSslSocket
operator|::
name|PeerVerifyMode
name|mode
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSslSocket
argument_list|)
expr_stmt|;
name|d
operator|->
name|configuration
operator|.
name|peerVerifyMode
operator|=
name|mode
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Returns the maximum number of certificates in the peer's certificate chain     to be checked during the SSL handshake phase, or 0 (the default) if no     maximum depth has been set, indicating that the whole certificate chain     should be checked.      The certificates are checked in issuing order, starting with the peer's     own certificate, then its issuer's certificate, and so on.      \sa setPeerVerifyDepth(), peerVerifyMode() */
end_comment
begin_function
DECL|function|peerVerifyDepth
name|int
name|QSslSocket
operator|::
name|peerVerifyDepth
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSslSocket
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|configuration
operator|.
name|peerVerifyDepth
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Sets the maximum number of certificates in the peer's certificate chain to     be checked during the SSL handshake phase, to \a depth. Setting a depth of     0 means that no maximum depth is set, indicating that the whole     certificate chain should be checked.      The certificates are checked in issuing order, starting with the peer's     own certificate, then its issuer's certificate, and so on.      \sa peerVerifyDepth(), setPeerVerifyMode() */
end_comment
begin_function
DECL|function|setPeerVerifyDepth
name|void
name|QSslSocket
operator|::
name|setPeerVerifyDepth
parameter_list|(
name|int
name|depth
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSslSocket
argument_list|)
expr_stmt|;
if|if
condition|(
name|depth
operator|<
literal|0
condition|)
block|{
name|qWarning
argument_list|(
literal|"QSslSocket::setPeerVerifyDepth: cannot set negative depth of %d"
argument_list|,
name|depth
argument_list|)
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|configuration
operator|.
name|peerVerifyDepth
operator|=
name|depth
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.8      Returns the different hostname for the certificate validation, as set by     setPeerVerifyName or by connectToHostEncrypted.      \sa setPeerVerifyName(), connectToHostEncrypted() */
end_comment
begin_function
DECL|function|peerVerifyName
name|QString
name|QSslSocket
operator|::
name|peerVerifyName
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSslSocket
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|verificationPeerName
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.8      Sets a different host name, given by \a hostName, for the certificate     validation instead of the one used for the TCP connection.      \sa connectToHostEncrypted() */
end_comment
begin_function
DECL|function|setPeerVerifyName
name|void
name|QSslSocket
operator|::
name|setPeerVerifyName
parameter_list|(
specifier|const
name|QString
modifier|&
name|hostName
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSslSocket
argument_list|)
expr_stmt|;
name|d
operator|->
name|verificationPeerName
operator|=
name|hostName
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp      Returns the number of decrypted bytes that are immediately available for     reading. */
end_comment
begin_function
DECL|function|bytesAvailable
name|qint64
name|QSslSocket
operator|::
name|bytesAvailable
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSslSocket
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|mode
operator|==
name|UnencryptedMode
condition|)
return|return
name|QIODevice
operator|::
name|bytesAvailable
argument_list|()
operator|+
operator|(
name|d
operator|->
name|plainSocket
condition|?
name|d
operator|->
name|plainSocket
operator|->
name|bytesAvailable
argument_list|()
else|:
literal|0
operator|)
return|;
return|return
name|QIODevice
operator|::
name|bytesAvailable
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp      Returns the number of unencrypted bytes that are waiting to be encrypted     and written to the network. */
end_comment
begin_function
DECL|function|bytesToWrite
name|qint64
name|QSslSocket
operator|::
name|bytesToWrite
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSslSocket
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|mode
operator|==
name|UnencryptedMode
condition|)
return|return
name|d
operator|->
name|plainSocket
condition|?
name|d
operator|->
name|plainSocket
operator|->
name|bytesToWrite
argument_list|()
else|:
literal|0
return|;
return|return
name|d
operator|->
name|writeBuffer
operator|.
name|size
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Returns the number of encrypted bytes that are awaiting decryption.     Normally, this function will return 0 because QSslSocket decrypts its     incoming data as soon as it can. */
end_comment
begin_function
DECL|function|encryptedBytesAvailable
name|qint64
name|QSslSocket
operator|::
name|encryptedBytesAvailable
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSslSocket
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|mode
operator|==
name|UnencryptedMode
condition|)
return|return
literal|0
return|;
return|return
name|d
operator|->
name|plainSocket
operator|->
name|bytesAvailable
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Returns the number of encrypted bytes that are waiting to be written to     the network. */
end_comment
begin_function
DECL|function|encryptedBytesToWrite
name|qint64
name|QSslSocket
operator|::
name|encryptedBytesToWrite
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSslSocket
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|mode
operator|==
name|UnencryptedMode
condition|)
return|return
literal|0
return|;
return|return
name|d
operator|->
name|plainSocket
operator|->
name|bytesToWrite
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp      Returns true if you can read one while line (terminated by a single ASCII     '\\n' character) of decrypted characters; otherwise, false is returned. */
end_comment
begin_function
DECL|function|canReadLine
name|bool
name|QSslSocket
operator|::
name|canReadLine
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSslSocket
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|mode
operator|==
name|UnencryptedMode
condition|)
return|return
name|QIODevice
operator|::
name|canReadLine
argument_list|()
operator|||
operator|(
name|d
operator|->
name|plainSocket
operator|&&
name|d
operator|->
name|plainSocket
operator|->
name|canReadLine
argument_list|()
operator|)
return|;
return|return
name|QIODevice
operator|::
name|canReadLine
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|close
name|void
name|QSslSocket
operator|::
name|close
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|QSSLSOCKET_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QSslSocket::close()"
expr_stmt|;
endif|#
directive|endif
name|Q_D
argument_list|(
name|QSslSocket
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|plainSocket
condition|)
name|d
operator|->
name|plainSocket
operator|->
name|close
argument_list|()
expr_stmt|;
name|QTcpSocket
operator|::
name|close
argument_list|()
expr_stmt|;
comment|// must be cleared, reading/writing not possible on closed socket:
name|d
operator|->
name|buffer
operator|.
name|clear
argument_list|()
expr_stmt|;
name|d
operator|->
name|writeBuffer
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|atEnd
name|bool
name|QSslSocket
operator|::
name|atEnd
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSslSocket
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|mode
operator|==
name|UnencryptedMode
condition|)
return|return
name|QIODevice
operator|::
name|atEnd
argument_list|()
operator|&&
operator|(
operator|!
name|d
operator|->
name|plainSocket
operator|||
name|d
operator|->
name|plainSocket
operator|->
name|atEnd
argument_list|()
operator|)
return|;
return|return
name|QIODevice
operator|::
name|atEnd
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     This function writes as much as possible from the internal write buffer to     the underlying network socket, without blocking. If any data was written,     this function returns true; otherwise false is returned.      Call this function if you need QSslSocket to start sending buffered data     immediately. The number of bytes successfully written depends on the     operating system. In most cases, you do not need to call this function,     because QAbstractSocket will start sending data automatically once control     goes back to the event loop. In the absence of an event loop, call     waitForBytesWritten() instead.      \sa write(), waitForBytesWritten() */
end_comment
begin_comment
comment|// Note! docs copied from QAbstractSocket::flush()
end_comment
begin_function
DECL|function|flush
name|bool
name|QSslSocket
operator|::
name|flush
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QSslSocket
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QSSLSOCKET_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QSslSocket::flush()"
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|d
operator|->
name|mode
operator|!=
name|UnencryptedMode
condition|)
comment|// encrypt any unencrypted bytes in our buffer
name|d
operator|->
name|transmit
argument_list|()
expr_stmt|;
return|return
name|d
operator|->
name|plainSocket
condition|?
name|d
operator|->
name|plainSocket
operator|->
name|flush
argument_list|()
else|:
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Sets the size of QSslSocket's internal read buffer to be \a size bytes.  */
end_comment
begin_function
DECL|function|setReadBufferSize
name|void
name|QSslSocket
operator|::
name|setReadBufferSize
parameter_list|(
name|qint64
name|size
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSslSocket
argument_list|)
expr_stmt|;
name|d
operator|->
name|readBufferMaxSize
operator|=
name|size
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|plainSocket
condition|)
name|d
operator|->
name|plainSocket
operator|->
name|setReadBufferSize
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Aborts the current connection and resets the socket. Unlike     disconnectFromHost(), this function immediately closes the socket,     clearing any pending data in the write buffer.      \sa disconnectFromHost(), close() */
end_comment
begin_function
DECL|function|abort
name|void
name|QSslSocket
operator|::
name|abort
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QSslSocket
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QSSLSOCKET_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QSslSocket::abort()"
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|d
operator|->
name|plainSocket
condition|)
name|d
operator|->
name|plainSocket
operator|->
name|abort
argument_list|()
expr_stmt|;
name|close
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Returns the socket's SSL configuration state. The default SSL     configuration of a socket is to use the default ciphers,     default CA certificates, no local private key or certificate.      The SSL configuration also contains fields that can change with     time without notice.      \sa localCertificate(), peerCertificate(), peerCertificateChain(),         sessionCipher(), privateKey(), ciphers(), caCertificates() */
end_comment
begin_function
DECL|function|sslConfiguration
name|QSslConfiguration
name|QSslSocket
operator|::
name|sslConfiguration
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSslSocket
argument_list|)
expr_stmt|;
comment|// create a deep copy of our configuration
name|QSslConfigurationPrivate
modifier|*
name|copy
init|=
operator|new
name|QSslConfigurationPrivate
argument_list|(
name|d
operator|->
name|configuration
argument_list|)
decl_stmt|;
name|copy
operator|->
name|ref
operator|.
name|store
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|// the QSslConfiguration constructor refs up
name|copy
operator|->
name|sessionCipher
operator|=
name|d
operator|->
name|sessionCipher
argument_list|()
expr_stmt|;
return|return
name|QSslConfiguration
argument_list|(
name|copy
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Sets the socket's SSL configuration to be the contents of \a configuration.     This function sets the local certificate, the ciphers, the private key and the CA     certificates to those stored in \a configuration.      It is not possible to set the SSL-state related fields.      \sa setLocalCertificate(), setPrivateKey(), setCaCertificates(), setCiphers() */
end_comment
begin_function
DECL|function|setSslConfiguration
name|void
name|QSslSocket
operator|::
name|setSslConfiguration
parameter_list|(
specifier|const
name|QSslConfiguration
modifier|&
name|configuration
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSslSocket
argument_list|)
expr_stmt|;
name|d
operator|->
name|configuration
operator|.
name|localCertificateChain
operator|=
name|configuration
operator|.
name|localCertificateChain
argument_list|()
expr_stmt|;
name|d
operator|->
name|configuration
operator|.
name|privateKey
operator|=
name|configuration
operator|.
name|privateKey
argument_list|()
expr_stmt|;
name|d
operator|->
name|configuration
operator|.
name|ciphers
operator|=
name|configuration
operator|.
name|ciphers
argument_list|()
expr_stmt|;
name|d
operator|->
name|configuration
operator|.
name|caCertificates
operator|=
name|configuration
operator|.
name|caCertificates
argument_list|()
expr_stmt|;
name|d
operator|->
name|configuration
operator|.
name|peerVerifyDepth
operator|=
name|configuration
operator|.
name|peerVerifyDepth
argument_list|()
expr_stmt|;
name|d
operator|->
name|configuration
operator|.
name|peerVerifyMode
operator|=
name|configuration
operator|.
name|peerVerifyMode
argument_list|()
expr_stmt|;
name|d
operator|->
name|configuration
operator|.
name|protocol
operator|=
name|configuration
operator|.
name|protocol
argument_list|()
expr_stmt|;
name|d
operator|->
name|configuration
operator|.
name|sslOptions
operator|=
name|configuration
operator|.
name|d
operator|->
name|sslOptions
expr_stmt|;
comment|// if the CA certificates were set explicitly (either via
comment|// QSslConfiguration::setCaCertificates() or QSslSocket::setCaCertificates(),
comment|// we cannot load the certificates on demand
if|if
condition|(
operator|!
name|configuration
operator|.
name|d
operator|->
name|allowRootCertOnDemandLoading
condition|)
name|d
operator|->
name|allowRootCertOnDemandLoading
operator|=
literal|false
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the socket's local certificate to \a certificate. The local     certificate is necessary if you need to confirm your identity to the     peer. It is used together with the private key; if you set the local     certificate, you must also set the private key.      The local certificate and private key are always necessary for server     sockets, but are also rarely used by client sockets if the server requires     the client to authenticate.      \sa localCertificate(), setPrivateKey() */
end_comment
begin_function
DECL|function|setLocalCertificate
name|void
name|QSslSocket
operator|::
name|setLocalCertificate
parameter_list|(
specifier|const
name|QSslCertificate
modifier|&
name|certificate
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSslSocket
argument_list|)
expr_stmt|;
name|d
operator|->
name|configuration
operator|.
name|localCertificateChain
operator|=
name|QList
argument_list|<
name|QSslCertificate
argument_list|>
argument_list|()
expr_stmt|;
name|d
operator|->
name|configuration
operator|.
name|localCertificateChain
operator|+=
name|certificate
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Sets the socket's local \l {QSslCertificate} {certificate} to the     first one found in file \a path, which is parsed according to the      specified \a format. */
end_comment
begin_function
DECL|function|setLocalCertificate
name|void
name|QSslSocket
operator|::
name|setLocalCertificate
parameter_list|(
specifier|const
name|QString
modifier|&
name|path
parameter_list|,
name|QSsl
operator|::
name|EncodingFormat
name|format
parameter_list|)
block|{
name|QFile
name|file
argument_list|(
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
name|file
operator|.
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
operator||
name|QIODevice
operator|::
name|Text
argument_list|)
condition|)
name|setLocalCertificate
argument_list|(
name|QSslCertificate
argument_list|(
name|file
operator|.
name|readAll
argument_list|()
argument_list|,
name|format
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the socket's local \l {QSslCertificate} {certificate}, or     an empty certificate if no local certificate has been assigned.      \sa setLocalCertificate(), privateKey() */
end_comment
begin_function
DECL|function|localCertificate
name|QSslCertificate
name|QSslSocket
operator|::
name|localCertificate
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSslSocket
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|configuration
operator|.
name|localCertificateChain
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|QSslCertificate
argument_list|()
return|;
return|return
name|d
operator|->
name|configuration
operator|.
name|localCertificateChain
index|[
literal|0
index|]
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the peer's digital certificate (i.e., the immediate     certificate of the host you are connected to), or a null     certificate, if the peer has not assigned a certificate.          The peer certificate is checked automatically during the     handshake phase, so this function is normally used to fetch     the certificate for display or for connection diagnostic     purposes. It contains information about the peer, including     its host name, the certificate issuer, and the peer's public     key.      Because the peer certificate is set during the handshake phase, it     is safe to access the peer certificate from a slot connected to     the sslErrors() signal or the encrypted() signal.      If a null certificate is returned, it can mean the SSL handshake     failed, or it can mean the host you are connected to doesn't have     a certificate, or it can mean there is no connection.      If you want to check the peer's complete chain of certificates,     use peerCertificateChain() to get them all at once.      \sa peerCertificateChain() */
end_comment
begin_function
DECL|function|peerCertificate
name|QSslCertificate
name|QSslSocket
operator|::
name|peerCertificate
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSslSocket
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|configuration
operator|.
name|peerCertificate
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the peer's chain of digital certificates, or an empty list     of certificates.      Peer certificates are checked automatically during the handshake     phase. This function is normally used to fetch certificates for     display, or for performing connection diagnostics. Certificates     contain information about the peer and the certificate issuers,     including host name, issuer names, and issuer public keys.      The peer certificates are set in QSslSocket during the handshake     phase, so it is safe to call this function from a slot connected     to the sslErrors() signal or the encrypted() signal.      If an empty list is returned, it can mean the SSL handshake     failed, or it can mean the host you are connected to doesn't have     a certificate, or it can mean there is no connection.      If you want to get only the peer's immediate certificate, use     peerCertificate().      \sa peerCertificate() */
end_comment
begin_function
DECL|function|peerCertificateChain
name|QList
argument_list|<
name|QSslCertificate
argument_list|>
name|QSslSocket
operator|::
name|peerCertificateChain
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSslSocket
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|configuration
operator|.
name|peerCertificateChain
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the socket's cryptographic \l {QSslCipher} {cipher}, or a     null cipher if the connection isn't encrypted. The socket's cipher     for the session is set during the handshake phase. The cipher is     used to encrypt and decrypt data transmitted through the socket.      QSslSocket also provides functions for setting the ordered list of     ciphers from which the handshake phase will eventually select the     session cipher. This ordered list must be in place before the     handshake phase begins.      \sa ciphers(), setCiphers(), setDefaultCiphers(), defaultCiphers(),     supportedCiphers() */
end_comment
begin_function
DECL|function|sessionCipher
name|QSslCipher
name|QSslSocket
operator|::
name|sessionCipher
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSslSocket
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|sessionCipher
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the socket's private \l {QSslKey} {key} to \a key. The     private key and the local \l {QSslCertificate} {certificate} are     used by clients and servers that must prove their identity to     SSL peers.      Both the key and the local certificate are required if you are     creating an SSL server socket. If you are creating an SSL client     socket, the key and local certificate are required if your client     must identify itself to an SSL server.      \sa privateKey(), setLocalCertificate() */
end_comment
begin_function
DECL|function|setPrivateKey
name|void
name|QSslSocket
operator|::
name|setPrivateKey
parameter_list|(
specifier|const
name|QSslKey
modifier|&
name|key
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSslSocket
argument_list|)
expr_stmt|;
name|d
operator|->
name|configuration
operator|.
name|privateKey
operator|=
name|key
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Reads the string in file \a fileName and decodes it using     a specified \a algorithm and encoding \a format to construct     an \l {QSslKey} {SSL key}. If the encoded key is encrypted,     \a passPhrase is used to decrypt it.      The socket's private key is set to the constructed key. The     private key and the local \l {QSslCertificate} {certificate} are     used by clients and servers that must prove their identity to SSL     peers.      Both the key and the local certificate are required if you are     creating an SSL server socket. If you are creating an SSL client     socket, the key and local certificate are required if your client     must identify itself to an SSL server.          \sa privateKey(), setLocalCertificate() */
end_comment
begin_function
DECL|function|setPrivateKey
name|void
name|QSslSocket
operator|::
name|setPrivateKey
parameter_list|(
specifier|const
name|QString
modifier|&
name|fileName
parameter_list|,
name|QSsl
operator|::
name|KeyAlgorithm
name|algorithm
parameter_list|,
name|QSsl
operator|::
name|EncodingFormat
name|format
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|passPhrase
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSslSocket
argument_list|)
expr_stmt|;
name|QFile
name|file
argument_list|(
name|fileName
argument_list|)
decl_stmt|;
if|if
condition|(
name|file
operator|.
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
argument_list|)
condition|)
block|{
name|d
operator|->
name|configuration
operator|.
name|privateKey
operator|=
name|QSslKey
argument_list|(
name|file
operator|.
name|readAll
argument_list|()
argument_list|,
name|algorithm
argument_list|,
name|format
argument_list|,
name|QSsl
operator|::
name|PrivateKey
argument_list|,
name|passPhrase
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Returns this socket's private key.      \sa setPrivateKey(), localCertificate() */
end_comment
begin_function
DECL|function|privateKey
name|QSslKey
name|QSslSocket
operator|::
name|privateKey
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSslSocket
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|configuration
operator|.
name|privateKey
return|;
block|}
end_function
begin_comment
comment|/*!     Returns this socket's current cryptographic cipher suite. This     list is used during the socket's handshake phase for choosing a     session cipher. The returned list of ciphers is ordered by     descending preference. (i.e., the first cipher in the list is the     most preferred cipher). The session cipher will be the first one     in the list that is also supported by the peer.      By default, the handshake phase can choose any of the ciphers     supported by this system's SSL libraries, which may vary from     system to system. The list of ciphers supported by this system's     SSL libraries is returned by supportedCiphers(). You can restrict     the list of ciphers used for choosing the session cipher for this     socket by calling setCiphers() with a subset of the supported     ciphers. You can revert to using the entire set by calling     setCiphers() with the list returned by supportedCiphers().      You can restrict the list of ciphers used for choosing the session     cipher for \e all sockets by calling setDefaultCiphers() with a     subset of the supported ciphers. You can revert to using the     entire set by calling setCiphers() with the list returned by     supportedCiphers().      \sa setCiphers(), defaultCiphers(), setDefaultCiphers(), supportedCiphers() */
end_comment
begin_function
DECL|function|ciphers
name|QList
argument_list|<
name|QSslCipher
argument_list|>
name|QSslSocket
operator|::
name|ciphers
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSslSocket
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|configuration
operator|.
name|ciphers
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the cryptographic cipher suite for this socket to \a ciphers,     which must contain a subset of the ciphers in the list returned by     supportedCiphers().      Restricting the cipher suite must be done before the handshake     phase, where the session cipher is chosen.      \sa ciphers(), setDefaultCiphers(), supportedCiphers() */
end_comment
begin_function
DECL|function|setCiphers
name|void
name|QSslSocket
operator|::
name|setCiphers
parameter_list|(
specifier|const
name|QList
argument_list|<
name|QSslCipher
argument_list|>
modifier|&
name|ciphers
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSslSocket
argument_list|)
expr_stmt|;
name|d
operator|->
name|configuration
operator|.
name|ciphers
operator|=
name|ciphers
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the cryptographic cipher suite for this socket to \a ciphers, which     is a colon-separated list of cipher suite names. The ciphers are listed in     order of preference, starting with the most preferred cipher. For example:      \snippet code/src_network_ssl_qsslsocket.cpp 4      Each cipher name in \a ciphers must be the name of a cipher in the     list returned by supportedCiphers().  Restricting the cipher suite     must be done before the handshake phase, where the session cipher     is chosen.      \sa ciphers(), setDefaultCiphers(), supportedCiphers() */
end_comment
begin_function
DECL|function|setCiphers
name|void
name|QSslSocket
operator|::
name|setCiphers
parameter_list|(
specifier|const
name|QString
modifier|&
name|ciphers
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSslSocket
argument_list|)
expr_stmt|;
name|d
operator|->
name|configuration
operator|.
name|ciphers
operator|.
name|clear
argument_list|()
expr_stmt|;
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|cipherName
decl|,
name|ciphers
operator|.
name|split
argument_list|(
name|QLatin1String
argument_list|(
literal|":"
argument_list|)
argument_list|,
name|QString
operator|::
name|SkipEmptyParts
argument_list|)
control|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
operator|++
name|i
control|)
block|{
comment|// ### Crude
name|QSslCipher
name|cipher
argument_list|(
name|cipherName
argument_list|,
name|QSsl
operator|::
name|SslProtocol
argument_list|(
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|cipher
operator|.
name|isNull
argument_list|()
condition|)
name|d
operator|->
name|configuration
operator|.
name|ciphers
operator|<<
name|cipher
expr_stmt|;
block|}
block|}
block|}
end_function
begin_comment
comment|/*!     Sets the default cryptographic cipher suite for all sockets in     this application to \a ciphers, which must contain a subset of the     ciphers in the list returned by supportedCiphers().      Restricting the default cipher suite only affects SSL sockets     that perform their handshake phase after the default cipher     suite has been changed.      \sa setCiphers(), defaultCiphers(), supportedCiphers() */
end_comment
begin_function
DECL|function|setDefaultCiphers
name|void
name|QSslSocket
operator|::
name|setDefaultCiphers
parameter_list|(
specifier|const
name|QList
argument_list|<
name|QSslCipher
argument_list|>
modifier|&
name|ciphers
parameter_list|)
block|{
name|QSslSocketPrivate
operator|::
name|setDefaultCiphers
argument_list|(
name|ciphers
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the default cryptographic cipher suite for all sockets in     this application. This list is used during the socket's handshake     phase when negotiating with the peer to choose a session cipher.     The list is ordered by preference (i.e., the first cipher in the     list is the most preferred cipher).      By default, the handshake phase can choose any of the ciphers     supported by this system's SSL libraries, which may vary from     system to system. The list of ciphers supported by this system's     SSL libraries is returned by supportedCiphers().      \sa supportedCiphers() */
end_comment
begin_function
DECL|function|defaultCiphers
name|QList
argument_list|<
name|QSslCipher
argument_list|>
name|QSslSocket
operator|::
name|defaultCiphers
parameter_list|()
block|{
return|return
name|QSslSocketPrivate
operator|::
name|defaultCiphers
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the list of cryptographic ciphers supported by this     system. This list is set by the system's SSL libraries and may     vary from system to system.      \sa defaultCiphers(), ciphers(), setCiphers() */
end_comment
begin_function
DECL|function|supportedCiphers
name|QList
argument_list|<
name|QSslCipher
argument_list|>
name|QSslSocket
operator|::
name|supportedCiphers
parameter_list|()
block|{
return|return
name|QSslSocketPrivate
operator|::
name|supportedCiphers
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!   Searches all files in the \a path for certificates encoded in the   specified \a format and adds them to this socket's CA certificate   database. \a path can be explicit, or it can contain wildcards in   the format specified by \a syntax. Returns true if one or more   certificates are added to the socket's CA certificate database;   otherwise returns false.    The CA certificate database is used by the socket during the   handshake phase to validate the peer's certificate.    For more precise control, use addCaCertificate().    \sa addCaCertificate(), QSslCertificate::fromPath() */
end_comment
begin_function
DECL|function|addCaCertificates
name|bool
name|QSslSocket
operator|::
name|addCaCertificates
parameter_list|(
specifier|const
name|QString
modifier|&
name|path
parameter_list|,
name|QSsl
operator|::
name|EncodingFormat
name|format
parameter_list|,
name|QRegExp
operator|::
name|PatternSyntax
name|syntax
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSslSocket
argument_list|)
expr_stmt|;
name|QList
argument_list|<
name|QSslCertificate
argument_list|>
name|certs
init|=
name|QSslCertificate
operator|::
name|fromPath
argument_list|(
name|path
argument_list|,
name|format
argument_list|,
name|syntax
argument_list|)
decl_stmt|;
if|if
condition|(
name|certs
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
name|d
operator|->
name|configuration
operator|.
name|caCertificates
operator|+=
name|certs
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!   Adds the \a certificate to this socket's CA certificate database.   The CA certificate database is used by the socket during the   handshake phase to validate the peer's certificate.    To add multiple certificates, use addCaCertificates().    \sa caCertificates(), setCaCertificates() */
end_comment
begin_function
DECL|function|addCaCertificate
name|void
name|QSslSocket
operator|::
name|addCaCertificate
parameter_list|(
specifier|const
name|QSslCertificate
modifier|&
name|certificate
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSslSocket
argument_list|)
expr_stmt|;
name|d
operator|->
name|configuration
operator|.
name|caCertificates
operator|+=
name|certificate
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Adds the \a certificates to this socket's CA certificate database.   The CA certificate database is used by the socket during the   handshake phase to validate the peer's certificate.    For more precise control, use addCaCertificate().    \sa caCertificates(), addDefaultCaCertificate() */
end_comment
begin_function
DECL|function|addCaCertificates
name|void
name|QSslSocket
operator|::
name|addCaCertificates
parameter_list|(
specifier|const
name|QList
argument_list|<
name|QSslCertificate
argument_list|>
modifier|&
name|certificates
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSslSocket
argument_list|)
expr_stmt|;
name|d
operator|->
name|configuration
operator|.
name|caCertificates
operator|+=
name|certificates
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Sets this socket's CA certificate database to be \a certificates.   The certificate database must be set prior to the SSL handshake.   The CA certificate database is used by the socket during the   handshake phase to validate the peer's certificate.    The CA certificate database can be reset to the current default CA   certificate database by calling this function with the list of CA   certificates returned by defaultCaCertificates().    \sa defaultCaCertificates() */
end_comment
begin_function
DECL|function|setCaCertificates
name|void
name|QSslSocket
operator|::
name|setCaCertificates
parameter_list|(
specifier|const
name|QList
argument_list|<
name|QSslCertificate
argument_list|>
modifier|&
name|certificates
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSslSocket
argument_list|)
expr_stmt|;
name|d
operator|->
name|configuration
operator|.
name|caCertificates
operator|=
name|certificates
expr_stmt|;
name|d
operator|->
name|allowRootCertOnDemandLoading
operator|=
literal|false
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   Returns this socket's CA certificate database. The CA certificate   database is used by the socket during the handshake phase to   validate the peer's certificate. It can be moodified prior to the   handshake with addCaCertificate(), addCaCertificates(), and   setCaCertificates().    \note On Unix, this method may return an empty list if the root   certificates are loaded on demand.    \sa addCaCertificate(), addCaCertificates(), setCaCertificates() */
end_comment
begin_function
DECL|function|caCertificates
name|QList
argument_list|<
name|QSslCertificate
argument_list|>
name|QSslSocket
operator|::
name|caCertificates
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSslSocket
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|configuration
operator|.
name|caCertificates
return|;
block|}
end_function
begin_comment
comment|/*!     Searches all files in the \a path for certificates with the     specified \a encoding and adds them to the default CA certificate     database. \a path can be an explicit file, or it can contain     wildcards in the format specified by \a syntax. Returns true if     any CA certificates are added to the default database.      Each SSL socket's CA certificate database is initialized to the     default CA certificate database.      \sa defaultCaCertificates(), addCaCertificates(), addDefaultCaCertificate() */
end_comment
begin_function
DECL|function|addDefaultCaCertificates
name|bool
name|QSslSocket
operator|::
name|addDefaultCaCertificates
parameter_list|(
specifier|const
name|QString
modifier|&
name|path
parameter_list|,
name|QSsl
operator|::
name|EncodingFormat
name|encoding
parameter_list|,
name|QRegExp
operator|::
name|PatternSyntax
name|syntax
parameter_list|)
block|{
return|return
name|QSslSocketPrivate
operator|::
name|addDefaultCaCertificates
argument_list|(
name|path
argument_list|,
name|encoding
argument_list|,
name|syntax
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Adds \a certificate to the default CA certificate database.  Each     SSL socket's CA certificate database is initialized to the default     CA certificate database.      \sa defaultCaCertificates(), addCaCertificates() */
end_comment
begin_function
DECL|function|addDefaultCaCertificate
name|void
name|QSslSocket
operator|::
name|addDefaultCaCertificate
parameter_list|(
specifier|const
name|QSslCertificate
modifier|&
name|certificate
parameter_list|)
block|{
name|QSslSocketPrivate
operator|::
name|addDefaultCaCertificate
argument_list|(
name|certificate
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Adds \a certificates to the default CA certificate database.  Each     SSL socket's CA certificate database is initialized to the default     CA certificate database.      \sa defaultCaCertificates(), addCaCertificates() */
end_comment
begin_function
DECL|function|addDefaultCaCertificates
name|void
name|QSslSocket
operator|::
name|addDefaultCaCertificates
parameter_list|(
specifier|const
name|QList
argument_list|<
name|QSslCertificate
argument_list|>
modifier|&
name|certificates
parameter_list|)
block|{
name|QSslSocketPrivate
operator|::
name|addDefaultCaCertificates
argument_list|(
name|certificates
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Sets the default CA certificate database to \a certificates. The     default CA certificate database is originally set to your system's     default CA certificate database. You can override the default CA     certificate database with your own CA certificate database using     this function.      Each SSL socket's CA certificate database is initialized to the     default CA certificate database.      \sa addDefaultCaCertificate() */
end_comment
begin_function
DECL|function|setDefaultCaCertificates
name|void
name|QSslSocket
operator|::
name|setDefaultCaCertificates
parameter_list|(
specifier|const
name|QList
argument_list|<
name|QSslCertificate
argument_list|>
modifier|&
name|certificates
parameter_list|)
block|{
name|QSslSocketPrivate
operator|::
name|setDefaultCaCertificates
argument_list|(
name|certificates
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the current default CA certificate database. This database     is originally set to your system's default CA certificate database.     If no system default database is found, an empty database will be     returned. You can override the default CA certificate database     with your own CA certificate database using setDefaultCaCertificates().      Each SSL socket's CA certificate database is initialized to the     default CA certificate database.      \note On Unix, this method may return an empty list if the root     certificates are loaded on demand.      \sa caCertificates() */
end_comment
begin_function
DECL|function|defaultCaCertificates
name|QList
argument_list|<
name|QSslCertificate
argument_list|>
name|QSslSocket
operator|::
name|defaultCaCertificates
parameter_list|()
block|{
return|return
name|QSslSocketPrivate
operator|::
name|defaultCaCertificates
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     This function provides the CA certificate database     provided by the operating system. The CA certificate database     returned by this function is used to initialize the database     returned by defaultCaCertificates(). You can replace that database     with your own with setDefaultCaCertificates().      \sa caCertificates(), defaultCaCertificates(), setDefaultCaCertificates() */
end_comment
begin_function
DECL|function|systemCaCertificates
name|QList
argument_list|<
name|QSslCertificate
argument_list|>
name|QSslSocket
operator|::
name|systemCaCertificates
parameter_list|()
block|{
comment|// we are calling ensureInitialized() in the method below
return|return
name|QSslSocketPrivate
operator|::
name|systemCaCertificates
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Waits until the socket is connected, or \a msecs milliseconds,     whichever happens first. If the connection has been established,     this function returns true; otherwise it returns false.      \sa QAbstractSocket::waitForConnected() */
end_comment
begin_function
DECL|function|waitForConnected
name|bool
name|QSslSocket
operator|::
name|waitForConnected
parameter_list|(
name|int
name|msecs
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSslSocket
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|plainSocket
condition|)
return|return
literal|false
return|;
name|bool
name|retVal
init|=
name|d
operator|->
name|plainSocket
operator|->
name|waitForConnected
argument_list|(
name|msecs
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|retVal
condition|)
block|{
name|setSocketState
argument_list|(
name|d
operator|->
name|plainSocket
operator|->
name|state
argument_list|()
argument_list|)
expr_stmt|;
name|setSocketError
argument_list|(
name|d
operator|->
name|plainSocket
operator|->
name|error
argument_list|()
argument_list|)
expr_stmt|;
name|setErrorString
argument_list|(
name|d
operator|->
name|plainSocket
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|retVal
return|;
block|}
end_function
begin_comment
comment|/*!     Waits until the socket has completed the SSL handshake and has     emitted encrypted(), or \a msecs milliseconds, whichever comes     first. If encrypted() has been emitted, this function returns     true; otherwise (e.g., the socket is disconnected, or the SSL     handshake fails), false is returned.      The following example waits up to one second for the socket to be     encrypted:      \snippet code/src_network_ssl_qsslsocket.cpp 5      If msecs is -1, this function will not time out.      \sa startClientEncryption(), startServerEncryption(), encrypted(), isEncrypted() */
end_comment
begin_function
DECL|function|waitForEncrypted
name|bool
name|QSslSocket
operator|::
name|waitForEncrypted
parameter_list|(
name|int
name|msecs
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSslSocket
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|plainSocket
operator|||
name|d
operator|->
name|connectionEncrypted
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|d
operator|->
name|mode
operator|==
name|UnencryptedMode
operator|&&
operator|!
name|d
operator|->
name|autoStartHandshake
condition|)
return|return
literal|false
return|;
name|QElapsedTimer
name|stopWatch
decl_stmt|;
name|stopWatch
operator|.
name|start
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|plainSocket
operator|->
name|state
argument_list|()
operator|!=
name|QAbstractSocket
operator|::
name|ConnectedState
condition|)
block|{
comment|// Wait until we've entered connected state.
if|if
condition|(
operator|!
name|d
operator|->
name|plainSocket
operator|->
name|waitForConnected
argument_list|(
name|msecs
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
while|while
condition|(
operator|!
name|d
operator|->
name|connectionEncrypted
condition|)
block|{
comment|// Start the handshake, if this hasn't been started yet.
if|if
condition|(
name|d
operator|->
name|mode
operator|==
name|UnencryptedMode
condition|)
name|startClientEncryption
argument_list|()
expr_stmt|;
comment|// Loop, waiting until the connection has been encrypted or an error
comment|// occurs.
if|if
condition|(
operator|!
name|d
operator|->
name|plainSocket
operator|->
name|waitForReadyRead
argument_list|(
name|qt_timeout_value
argument_list|(
name|msecs
argument_list|,
name|stopWatch
operator|.
name|elapsed
argument_list|()
argument_list|)
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
return|return
name|d
operator|->
name|connectionEncrypted
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|waitForReadyRead
name|bool
name|QSslSocket
operator|::
name|waitForReadyRead
parameter_list|(
name|int
name|msecs
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSslSocket
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|plainSocket
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|d
operator|->
name|mode
operator|==
name|UnencryptedMode
operator|&&
operator|!
name|d
operator|->
name|autoStartHandshake
condition|)
return|return
name|d
operator|->
name|plainSocket
operator|->
name|waitForReadyRead
argument_list|(
name|msecs
argument_list|)
return|;
comment|// This function must return true if and only if readyRead() *was* emitted.
comment|// So we initialize "readyReadEmitted" to false and check if it was set to true.
comment|// waitForReadyRead() could be called recursively, so we can't use the same variable
comment|// (the inner waitForReadyRead() may fail, but the outer one still succeeded)
name|bool
name|readyReadEmitted
init|=
literal|false
decl_stmt|;
name|bool
modifier|*
name|previousReadyReadEmittedPointer
init|=
name|d
operator|->
name|readyReadEmittedPointer
decl_stmt|;
name|d
operator|->
name|readyReadEmittedPointer
operator|=
operator|&
name|readyReadEmitted
expr_stmt|;
name|QElapsedTimer
name|stopWatch
decl_stmt|;
name|stopWatch
operator|.
name|start
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|connectionEncrypted
condition|)
block|{
comment|// Wait until we've entered encrypted mode, or until a failure occurs.
if|if
condition|(
operator|!
name|waitForEncrypted
argument_list|(
name|msecs
argument_list|)
condition|)
block|{
name|d
operator|->
name|readyReadEmittedPointer
operator|=
name|previousReadyReadEmittedPointer
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
if|if
condition|(
operator|!
name|d
operator|->
name|writeBuffer
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// empty our cleartext write buffer first
name|d
operator|->
name|transmit
argument_list|()
expr_stmt|;
block|}
comment|// test readyReadEmitted first because either operation above
comment|// (waitForEncrypted or transmit) may have set it
while|while
condition|(
operator|!
name|readyReadEmitted
operator|&&
name|d
operator|->
name|plainSocket
operator|->
name|waitForReadyRead
argument_list|(
name|qt_timeout_value
argument_list|(
name|msecs
argument_list|,
name|stopWatch
operator|.
name|elapsed
argument_list|()
argument_list|)
argument_list|)
condition|)
block|{     }
name|d
operator|->
name|readyReadEmittedPointer
operator|=
name|previousReadyReadEmittedPointer
expr_stmt|;
return|return
name|readyReadEmitted
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|waitForBytesWritten
name|bool
name|QSslSocket
operator|::
name|waitForBytesWritten
parameter_list|(
name|int
name|msecs
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSslSocket
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|plainSocket
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|d
operator|->
name|mode
operator|==
name|UnencryptedMode
condition|)
return|return
name|d
operator|->
name|plainSocket
operator|->
name|waitForBytesWritten
argument_list|(
name|msecs
argument_list|)
return|;
name|QElapsedTimer
name|stopWatch
decl_stmt|;
name|stopWatch
operator|.
name|start
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|connectionEncrypted
condition|)
block|{
comment|// Wait until we've entered encrypted mode, or until a failure occurs.
if|if
condition|(
operator|!
name|waitForEncrypted
argument_list|(
name|msecs
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|d
operator|->
name|writeBuffer
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// empty our cleartext write buffer first
name|d
operator|->
name|transmit
argument_list|()
expr_stmt|;
block|}
return|return
name|d
operator|->
name|plainSocket
operator|->
name|waitForBytesWritten
argument_list|(
name|qt_timeout_value
argument_list|(
name|msecs
argument_list|,
name|stopWatch
operator|.
name|elapsed
argument_list|()
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Waits until the socket has disconnected or \a msecs milliseconds,     whichever comes first. If the connection has been disconnected,     this function returns true; otherwise it returns false.      \sa QAbstractSocket::waitForDisconnected() */
end_comment
begin_function
DECL|function|waitForDisconnected
name|bool
name|QSslSocket
operator|::
name|waitForDisconnected
parameter_list|(
name|int
name|msecs
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSslSocket
argument_list|)
expr_stmt|;
comment|// require calling connectToHost() before waitForDisconnected()
if|if
condition|(
name|state
argument_list|()
operator|==
name|UnconnectedState
condition|)
block|{
name|qWarning
argument_list|(
literal|"QSslSocket::waitForDisconnected() is not allowed in UnconnectedState"
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
if|if
condition|(
operator|!
name|d
operator|->
name|plainSocket
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|d
operator|->
name|mode
operator|==
name|UnencryptedMode
condition|)
return|return
name|d
operator|->
name|plainSocket
operator|->
name|waitForDisconnected
argument_list|(
name|msecs
argument_list|)
return|;
name|QElapsedTimer
name|stopWatch
decl_stmt|;
name|stopWatch
operator|.
name|start
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|connectionEncrypted
condition|)
block|{
comment|// Wait until we've entered encrypted mode, or until a failure occurs.
if|if
condition|(
operator|!
name|waitForEncrypted
argument_list|(
name|msecs
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
name|bool
name|retVal
init|=
name|d
operator|->
name|plainSocket
operator|->
name|waitForDisconnected
argument_list|(
name|qt_timeout_value
argument_list|(
name|msecs
argument_list|,
name|stopWatch
operator|.
name|elapsed
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|retVal
condition|)
block|{
name|setSocketState
argument_list|(
name|d
operator|->
name|plainSocket
operator|->
name|state
argument_list|()
argument_list|)
expr_stmt|;
name|setSocketError
argument_list|(
name|d
operator|->
name|plainSocket
operator|->
name|error
argument_list|()
argument_list|)
expr_stmt|;
name|setErrorString
argument_list|(
name|d
operator|->
name|plainSocket
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|retVal
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a list of the last SSL errors that occurred. This is the     same list as QSslSocket passes via the sslErrors() signal. If the     connection has been encrypted with no errors, this function will     return an empty list.      \sa connectToHostEncrypted() */
end_comment
begin_function
DECL|function|sslErrors
name|QList
argument_list|<
name|QSslError
argument_list|>
name|QSslSocket
operator|::
name|sslErrors
parameter_list|()
specifier|const
block|{
name|Q_D
argument_list|(
specifier|const
name|QSslSocket
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|sslErrors
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if this platform supports SSL; otherwise, returns     false. If the platform doesn't support SSL, the socket will fail     in the connection phase. */
end_comment
begin_function
DECL|function|supportsSsl
name|bool
name|QSslSocket
operator|::
name|supportsSsl
parameter_list|()
block|{
return|return
name|QSslSocketPrivate
operator|::
name|supportsSsl
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 5.0     Returns the version number of the SSL library in use. Note that     this is the version of the library in use at run-time not compile     time. If no SSL support is available then this will return an     undefined value. */
end_comment
begin_function
DECL|function|sslLibraryVersionNumber
name|long
name|QSslSocket
operator|::
name|sslLibraryVersionNumber
parameter_list|()
block|{
return|return
name|QSslSocketPrivate
operator|::
name|sslLibraryVersionNumber
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 5.0     Returns the version string of the SSL library in use. Note that     this is the version of the library in use at run-time not compile     time. If no SSL support is available then this will return an empty value. */
end_comment
begin_function
DECL|function|sslLibraryVersionString
name|QString
name|QSslSocket
operator|::
name|sslLibraryVersionString
parameter_list|()
block|{
return|return
name|QSslSocketPrivate
operator|::
name|sslLibraryVersionString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Starts a delayed SSL handshake for a client connection. This     function can be called when the socket is in the \l ConnectedState     but still in the \l UnencryptedMode. If it is not yet connected,     or if it is already encrypted, this function has no effect.      Clients that implement STARTTLS functionality often make use of     delayed SSL handshakes. Most other clients can avoid calling this     function directly by using connectToHostEncrypted() instead, which     automatically performs the handshake.      \sa connectToHostEncrypted(), startServerEncryption() */
end_comment
begin_function
DECL|function|startClientEncryption
name|void
name|QSslSocket
operator|::
name|startClientEncryption
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QSslSocket
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|mode
operator|!=
name|UnencryptedMode
condition|)
block|{
name|qWarning
argument_list|(
literal|"QSslSocket::startClientEncryption: cannot start handshake on non-plain connection"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|state
argument_list|()
operator|!=
name|ConnectedState
condition|)
block|{
name|qWarning
argument_list|(
literal|"QSslSocket::startClientEncryption: cannot start handshake when not connected"
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|QSSLSOCKET_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QSslSocket::startClientEncryption()"
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|mode
operator|=
name|SslClientMode
expr_stmt|;
emit|emit
name|modeChanged
argument_list|(
name|d
operator|->
name|mode
argument_list|)
emit|;
name|d
operator|->
name|startClientEncryption
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Starts a delayed SSL handshake for a server connection. This     function can be called when the socket is in the \l ConnectedState     but still in \l UnencryptedMode. If it is not connected or it is     already encrypted, the function has no effect.      For server sockets, calling this function is the only way to     initiate the SSL handshake. Most servers will call this function     immediately upon receiving a connection, or as a result of having     received a protocol-specific command to enter SSL mode (e.g, the     server may respond to receiving the string "STARTTLS\\r\\n" by     calling this function).      The most common way to implement an SSL server is to create a     subclass of QTcpServer and reimplement     QTcpServer::incomingConnection(). The returned socket descriptor     is then passed to QSslSocket::setSocketDescriptor().          \sa connectToHostEncrypted(), startClientEncryption() */
end_comment
begin_function
DECL|function|startServerEncryption
name|void
name|QSslSocket
operator|::
name|startServerEncryption
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QSslSocket
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|mode
operator|!=
name|UnencryptedMode
condition|)
block|{
name|qWarning
argument_list|(
literal|"QSslSocket::startServerEncryption: cannot start handshake on non-plain connection"
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|QSSLSOCKET_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QSslSocket::startServerEncryption()"
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|mode
operator|=
name|SslServerMode
expr_stmt|;
emit|emit
name|modeChanged
argument_list|(
name|d
operator|->
name|mode
argument_list|)
emit|;
name|d
operator|->
name|startServerEncryption
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     This slot tells QSslSocket to ignore errors during QSslSocket's     handshake phase and continue connecting. If you want to continue     with the connection even if errors occur during the handshake     phase, then you must call this slot, either from a slot connected     to sslErrors(), or before the handshake phase. If you don't call     this slot, either in response to errors or before the handshake,     the connection will be dropped after the sslErrors() signal has     been emitted.      If there are no errors during the SSL handshake phase (i.e., the     identity of the peer is established with no problems), QSslSocket     will not emit the sslErrors() signal, and it is unnecessary to     call this function.      \warning Be sure to always let the user inspect the errors     reported by the sslErrors() signal, and only call this method     upon confirmation from the user that proceeding is ok.     If there are unexpected errors, the connection should be aborted.     Calling this method without inspecting the actual errors will     most likely pose a security risk for your application. Use it     with great care!      \sa sslErrors() */
end_comment
begin_function
DECL|function|ignoreSslErrors
name|void
name|QSslSocket
operator|::
name|ignoreSslErrors
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QSslSocket
argument_list|)
expr_stmt|;
name|d
operator|->
name|ignoreAllSslErrors
operator|=
literal|true
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload     \since 4.6      This method tells QSslSocket to ignore only the errors given in \a     errors.      Note that you can set the expected certificate in the SSL error:     If, for instance, you want to connect to a server that uses     a self-signed certificate, consider the following snippet:      \snippet code/src_network_ssl_qsslsocket.cpp 6      Multiple calls to this function will replace the list of errors that     were passed in previous calls.     You can clear the list of errors you want to ignore by calling this     function with an empty list.      \sa sslErrors() */
end_comment
begin_function
DECL|function|ignoreSslErrors
name|void
name|QSslSocket
operator|::
name|ignoreSslErrors
parameter_list|(
specifier|const
name|QList
argument_list|<
name|QSslError
argument_list|>
modifier|&
name|errors
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSslSocket
argument_list|)
expr_stmt|;
name|d
operator|->
name|ignoreErrorsList
operator|=
name|errors
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|connectToHost
name|void
name|QSslSocket
operator|::
name|connectToHost
parameter_list|(
specifier|const
name|QString
modifier|&
name|hostName
parameter_list|,
name|quint16
name|port
parameter_list|,
name|OpenMode
name|openMode
parameter_list|,
name|NetworkLayerProtocol
name|protocol
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSslSocket
argument_list|)
expr_stmt|;
name|d
operator|->
name|preferredNetworkLayerProtocol
operator|=
name|protocol
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|initialized
condition|)
name|d
operator|->
name|init
argument_list|()
expr_stmt|;
name|d
operator|->
name|initialized
operator|=
literal|false
expr_stmt|;
ifdef|#
directive|ifdef
name|QSSLSOCKET_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QSslSocket::connectToHost("
operator|<<
name|hostName
operator|<<
literal|','
operator|<<
name|port
operator|<<
literal|','
operator|<<
name|openMode
operator|<<
literal|')'
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|d
operator|->
name|plainSocket
condition|)
block|{
ifdef|#
directive|ifdef
name|QSSLSOCKET_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"\tcreating internal plain socket"
expr_stmt|;
endif|#
directive|endif
name|d
operator|->
name|createPlainSocket
argument_list|(
name|openMode
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
name|d
operator|->
name|plainSocket
operator|->
name|setProxy
argument_list|(
name|proxy
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|QIODevice
operator|::
name|open
argument_list|(
name|openMode
argument_list|)
expr_stmt|;
name|d
operator|->
name|plainSocket
operator|->
name|connectToHost
argument_list|(
name|hostName
argument_list|,
name|port
argument_list|,
name|openMode
argument_list|,
name|d
operator|->
name|preferredNetworkLayerProtocol
argument_list|)
expr_stmt|;
name|d
operator|->
name|cachedSocketDescriptor
operator|=
name|d
operator|->
name|plainSocket
operator|->
name|socketDescriptor
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|disconnectFromHost
name|void
name|QSslSocket
operator|::
name|disconnectFromHost
parameter_list|()
block|{
name|Q_D
argument_list|(
name|QSslSocket
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QSSLSOCKET_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QSslSocket::disconnectFromHost()"
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|d
operator|->
name|plainSocket
condition|)
return|return;
if|if
condition|(
name|d
operator|->
name|state
operator|==
name|UnconnectedState
condition|)
return|return;
if|if
condition|(
name|d
operator|->
name|mode
operator|==
name|UnencryptedMode
operator|&&
operator|!
name|d
operator|->
name|autoStartHandshake
condition|)
block|{
name|d
operator|->
name|plainSocket
operator|->
name|disconnectFromHost
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|d
operator|->
name|state
operator|<=
name|ConnectingState
condition|)
block|{
name|d
operator|->
name|pendingClose
operator|=
literal|true
expr_stmt|;
return|return;
block|}
comment|// Perhaps emit closing()
if|if
condition|(
name|d
operator|->
name|state
operator|!=
name|ClosingState
condition|)
block|{
name|d
operator|->
name|state
operator|=
name|ClosingState
expr_stmt|;
emit|emit
name|stateChanged
argument_list|(
name|d
operator|->
name|state
argument_list|)
emit|;
block|}
if|if
condition|(
operator|!
name|d
operator|->
name|writeBuffer
operator|.
name|isEmpty
argument_list|()
condition|)
return|return;
if|if
condition|(
name|d
operator|->
name|mode
operator|==
name|UnencryptedMode
condition|)
block|{
name|d
operator|->
name|plainSocket
operator|->
name|disconnectFromHost
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|disconnectFromHost
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|readData
name|qint64
name|QSslSocket
operator|::
name|readData
parameter_list|(
name|char
modifier|*
name|data
parameter_list|,
name|qint64
name|maxlen
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSslSocket
argument_list|)
expr_stmt|;
name|qint64
name|readBytes
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|mode
operator|==
name|UnencryptedMode
operator|&&
operator|!
name|d
operator|->
name|autoStartHandshake
condition|)
block|{
name|readBytes
operator|=
name|d
operator|->
name|plainSocket
operator|->
name|read
argument_list|(
name|data
argument_list|,
name|maxlen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|bytesToRead
init|=
name|qMin
argument_list|<
name|int
argument_list|>
argument_list|(
name|maxlen
argument_list|,
name|d
operator|->
name|buffer
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|readBytes
operator|=
name|d
operator|->
name|buffer
operator|.
name|read
argument_list|(
name|data
argument_list|,
name|bytesToRead
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|QSSLSOCKET_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QSslSocket::readData("
operator|<<
operator|(
name|void
operator|*
operator|)
name|data
operator|<<
literal|','
operator|<<
name|maxlen
operator|<<
literal|") =="
operator|<<
name|readBytes
expr_stmt|;
endif|#
directive|endif
comment|// possibly trigger another transmit() to decrypt more data from the socket
if|if
condition|(
name|d
operator|->
name|buffer
operator|.
name|isEmpty
argument_list|()
operator|&&
name|d
operator|->
name|plainSocket
operator|->
name|bytesAvailable
argument_list|()
condition|)
block|{
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|this
argument_list|,
literal|"_q_flushReadBuffer"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
block|}
return|return
name|readBytes
return|;
block|}
end_function
begin_comment
comment|/*!     \reimp */
end_comment
begin_function
DECL|function|writeData
name|qint64
name|QSslSocket
operator|::
name|writeData
parameter_list|(
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|qint64
name|len
parameter_list|)
block|{
name|Q_D
argument_list|(
name|QSslSocket
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QSSLSOCKET_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QSslSocket::writeData("
operator|<<
operator|(
name|void
operator|*
operator|)
name|data
operator|<<
literal|','
operator|<<
name|len
operator|<<
literal|')'
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|d
operator|->
name|mode
operator|==
name|UnencryptedMode
operator|&&
operator|!
name|d
operator|->
name|autoStartHandshake
condition|)
return|return
name|d
operator|->
name|plainSocket
operator|->
name|write
argument_list|(
name|data
argument_list|,
name|len
argument_list|)
return|;
name|char
modifier|*
name|writePtr
init|=
name|d
operator|->
name|writeBuffer
operator|.
name|reserve
argument_list|(
name|len
argument_list|)
decl_stmt|;
operator|::
name|memcpy
argument_list|(
name|writePtr
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|// make sure we flush to the plain socket's buffer
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|this
argument_list|,
literal|"_q_flushWriteBuffer"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
return|return
name|len
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_constructor
DECL|function|QSslSocketPrivate
name|QSslSocketPrivate
operator|::
name|QSslSocketPrivate
parameter_list|()
member_init_list|:
name|initialized
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|mode
argument_list|(
name|QSslSocket
operator|::
name|UnencryptedMode
argument_list|)
member_init_list|,
name|autoStartHandshake
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|connectionEncrypted
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|ignoreAllSslErrors
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|readyReadEmittedPointer
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|allowRootCertOnDemandLoading
argument_list|(
literal|true
argument_list|)
member_init_list|,
name|plainSocket
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|paused
argument_list|(
literal|false
argument_list|)
block|{
name|QSslConfigurationPrivate
operator|::
name|deepCopyDefaultConfiguration
argument_list|(
operator|&
name|configuration
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     \internal */
end_comment
begin_destructor
DECL|function|~QSslSocketPrivate
name|QSslSocketPrivate
operator|::
name|~
name|QSslSocketPrivate
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|init
name|void
name|QSslSocketPrivate
operator|::
name|init
parameter_list|()
block|{
name|mode
operator|=
name|QSslSocket
operator|::
name|UnencryptedMode
expr_stmt|;
name|autoStartHandshake
operator|=
literal|false
expr_stmt|;
name|connectionEncrypted
operator|=
literal|false
expr_stmt|;
name|ignoreAllSslErrors
operator|=
literal|false
expr_stmt|;
comment|// we don't want to clear the ignoreErrorsList, so
comment|// that it is possible setting it before connecting
comment|//    ignoreErrorsList.clear();
name|buffer
operator|.
name|clear
argument_list|()
expr_stmt|;
name|writeBuffer
operator|.
name|clear
argument_list|()
expr_stmt|;
name|configuration
operator|.
name|peerCertificate
operator|.
name|clear
argument_list|()
expr_stmt|;
name|configuration
operator|.
name|peerCertificateChain
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|defaultCiphers
name|QList
argument_list|<
name|QSslCipher
argument_list|>
name|QSslSocketPrivate
operator|::
name|defaultCiphers
parameter_list|()
block|{
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|globalData
argument_list|()
operator|->
name|mutex
argument_list|)
decl_stmt|;
return|return
name|globalData
argument_list|()
operator|->
name|config
operator|->
name|ciphers
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|supportedCiphers
name|QList
argument_list|<
name|QSslCipher
argument_list|>
name|QSslSocketPrivate
operator|::
name|supportedCiphers
parameter_list|()
block|{
name|QSslSocketPrivate
operator|::
name|ensureInitialized
argument_list|()
expr_stmt|;
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|globalData
argument_list|()
operator|->
name|mutex
argument_list|)
decl_stmt|;
return|return
name|globalData
argument_list|()
operator|->
name|supportedCiphers
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|setDefaultCiphers
name|void
name|QSslSocketPrivate
operator|::
name|setDefaultCiphers
parameter_list|(
specifier|const
name|QList
argument_list|<
name|QSslCipher
argument_list|>
modifier|&
name|ciphers
parameter_list|)
block|{
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|globalData
argument_list|()
operator|->
name|mutex
argument_list|)
decl_stmt|;
name|globalData
argument_list|()
operator|->
name|config
operator|.
name|detach
argument_list|()
expr_stmt|;
name|globalData
argument_list|()
operator|->
name|config
operator|->
name|ciphers
operator|=
name|ciphers
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|setDefaultSupportedCiphers
name|void
name|QSslSocketPrivate
operator|::
name|setDefaultSupportedCiphers
parameter_list|(
specifier|const
name|QList
argument_list|<
name|QSslCipher
argument_list|>
modifier|&
name|ciphers
parameter_list|)
block|{
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|globalData
argument_list|()
operator|->
name|mutex
argument_list|)
decl_stmt|;
name|globalData
argument_list|()
operator|->
name|config
operator|.
name|detach
argument_list|()
expr_stmt|;
name|globalData
argument_list|()
operator|->
name|supportedCiphers
operator|=
name|ciphers
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|defaultCaCertificates
name|QList
argument_list|<
name|QSslCertificate
argument_list|>
name|QSslSocketPrivate
operator|::
name|defaultCaCertificates
parameter_list|()
block|{
name|QSslSocketPrivate
operator|::
name|ensureInitialized
argument_list|()
expr_stmt|;
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|globalData
argument_list|()
operator|->
name|mutex
argument_list|)
decl_stmt|;
return|return
name|globalData
argument_list|()
operator|->
name|config
operator|->
name|caCertificates
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|setDefaultCaCertificates
name|void
name|QSslSocketPrivate
operator|::
name|setDefaultCaCertificates
parameter_list|(
specifier|const
name|QList
argument_list|<
name|QSslCertificate
argument_list|>
modifier|&
name|certs
parameter_list|)
block|{
name|QSslSocketPrivate
operator|::
name|ensureInitialized
argument_list|()
expr_stmt|;
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|globalData
argument_list|()
operator|->
name|mutex
argument_list|)
decl_stmt|;
name|globalData
argument_list|()
operator|->
name|config
operator|.
name|detach
argument_list|()
expr_stmt|;
name|globalData
argument_list|()
operator|->
name|config
operator|->
name|caCertificates
operator|=
name|certs
expr_stmt|;
comment|// when the certificates are set explicitly, we do not want to
comment|// load the system certificates on demand
name|s_loadRootCertsOnDemand
operator|=
literal|false
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|addDefaultCaCertificates
name|bool
name|QSslSocketPrivate
operator|::
name|addDefaultCaCertificates
parameter_list|(
specifier|const
name|QString
modifier|&
name|path
parameter_list|,
name|QSsl
operator|::
name|EncodingFormat
name|format
parameter_list|,
name|QRegExp
operator|::
name|PatternSyntax
name|syntax
parameter_list|)
block|{
name|QSslSocketPrivate
operator|::
name|ensureInitialized
argument_list|()
expr_stmt|;
name|QList
argument_list|<
name|QSslCertificate
argument_list|>
name|certs
init|=
name|QSslCertificate
operator|::
name|fromPath
argument_list|(
name|path
argument_list|,
name|format
argument_list|,
name|syntax
argument_list|)
decl_stmt|;
if|if
condition|(
name|certs
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|globalData
argument_list|()
operator|->
name|mutex
argument_list|)
decl_stmt|;
name|globalData
argument_list|()
operator|->
name|config
operator|.
name|detach
argument_list|()
expr_stmt|;
name|globalData
argument_list|()
operator|->
name|config
operator|->
name|caCertificates
operator|+=
name|certs
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|addDefaultCaCertificate
name|void
name|QSslSocketPrivate
operator|::
name|addDefaultCaCertificate
parameter_list|(
specifier|const
name|QSslCertificate
modifier|&
name|cert
parameter_list|)
block|{
name|QSslSocketPrivate
operator|::
name|ensureInitialized
argument_list|()
expr_stmt|;
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|globalData
argument_list|()
operator|->
name|mutex
argument_list|)
decl_stmt|;
name|globalData
argument_list|()
operator|->
name|config
operator|.
name|detach
argument_list|()
expr_stmt|;
name|globalData
argument_list|()
operator|->
name|config
operator|->
name|caCertificates
operator|+=
name|cert
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|addDefaultCaCertificates
name|void
name|QSslSocketPrivate
operator|::
name|addDefaultCaCertificates
parameter_list|(
specifier|const
name|QList
argument_list|<
name|QSslCertificate
argument_list|>
modifier|&
name|certs
parameter_list|)
block|{
name|QSslSocketPrivate
operator|::
name|ensureInitialized
argument_list|()
expr_stmt|;
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|globalData
argument_list|()
operator|->
name|mutex
argument_list|)
decl_stmt|;
name|globalData
argument_list|()
operator|->
name|config
operator|.
name|detach
argument_list|()
expr_stmt|;
name|globalData
argument_list|()
operator|->
name|config
operator|->
name|caCertificates
operator|+=
name|certs
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|defaultConfiguration
name|QSslConfiguration
name|QSslConfigurationPrivate
operator|::
name|defaultConfiguration
parameter_list|()
block|{
name|QSslSocketPrivate
operator|::
name|ensureInitialized
argument_list|()
expr_stmt|;
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|globalData
argument_list|()
operator|->
name|mutex
argument_list|)
decl_stmt|;
return|return
name|QSslConfiguration
argument_list|(
name|globalData
argument_list|()
operator|->
name|config
operator|.
name|data
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|setDefaultConfiguration
name|void
name|QSslConfigurationPrivate
operator|::
name|setDefaultConfiguration
parameter_list|(
specifier|const
name|QSslConfiguration
modifier|&
name|configuration
parameter_list|)
block|{
name|QSslSocketPrivate
operator|::
name|ensureInitialized
argument_list|()
expr_stmt|;
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|globalData
argument_list|()
operator|->
name|mutex
argument_list|)
decl_stmt|;
if|if
condition|(
name|globalData
argument_list|()
operator|->
name|config
operator|==
name|configuration
operator|.
name|d
condition|)
return|return;
comment|// nothing to do
name|globalData
argument_list|()
operator|->
name|config
operator|=
cast|const_cast
argument_list|<
name|QSslConfigurationPrivate
operator|*
argument_list|>
argument_list|(
name|configuration
operator|.
name|d
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|deepCopyDefaultConfiguration
name|void
name|QSslConfigurationPrivate
operator|::
name|deepCopyDefaultConfiguration
parameter_list|(
name|QSslConfigurationPrivate
modifier|*
name|ptr
parameter_list|)
block|{
name|QSslSocketPrivate
operator|::
name|ensureInitialized
argument_list|()
expr_stmt|;
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|globalData
argument_list|()
operator|->
name|mutex
argument_list|)
decl_stmt|;
specifier|const
name|QSslConfigurationPrivate
modifier|*
name|global
init|=
name|globalData
argument_list|()
operator|->
name|config
operator|.
name|constData
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|global
condition|)
block|{
name|ptr
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|ptr
operator|->
name|ref
operator|.
name|store
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|peerCertificate
operator|=
name|global
operator|->
name|peerCertificate
expr_stmt|;
name|ptr
operator|->
name|peerCertificateChain
operator|=
name|global
operator|->
name|peerCertificateChain
expr_stmt|;
name|ptr
operator|->
name|localCertificateChain
operator|=
name|global
operator|->
name|localCertificateChain
expr_stmt|;
name|ptr
operator|->
name|privateKey
operator|=
name|global
operator|->
name|privateKey
expr_stmt|;
name|ptr
operator|->
name|sessionCipher
operator|=
name|global
operator|->
name|sessionCipher
expr_stmt|;
name|ptr
operator|->
name|ciphers
operator|=
name|global
operator|->
name|ciphers
expr_stmt|;
name|ptr
operator|->
name|caCertificates
operator|=
name|global
operator|->
name|caCertificates
expr_stmt|;
name|ptr
operator|->
name|protocol
operator|=
name|global
operator|->
name|protocol
expr_stmt|;
name|ptr
operator|->
name|peerVerifyMode
operator|=
name|global
operator|->
name|peerVerifyMode
expr_stmt|;
name|ptr
operator|->
name|peerVerifyDepth
operator|=
name|global
operator|->
name|peerVerifyDepth
expr_stmt|;
name|ptr
operator|->
name|sslOptions
operator|=
name|global
operator|->
name|sslOptions
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|createPlainSocket
name|void
name|QSslSocketPrivate
operator|::
name|createPlainSocket
parameter_list|(
name|QIODevice
operator|::
name|OpenMode
name|openMode
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QSslSocket
argument_list|)
expr_stmt|;
name|q
operator|->
name|setOpenMode
argument_list|(
name|openMode
argument_list|)
expr_stmt|;
comment|//<- from QIODevice
name|q
operator|->
name|setSocketState
argument_list|(
name|QAbstractSocket
operator|::
name|UnconnectedState
argument_list|)
expr_stmt|;
name|q
operator|->
name|setSocketError
argument_list|(
name|QAbstractSocket
operator|::
name|UnknownSocketError
argument_list|)
expr_stmt|;
name|q
operator|->
name|setLocalPort
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|q
operator|->
name|setLocalAddress
argument_list|(
name|QHostAddress
argument_list|()
argument_list|)
expr_stmt|;
name|q
operator|->
name|setPeerPort
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|q
operator|->
name|setPeerAddress
argument_list|(
name|QHostAddress
argument_list|()
argument_list|)
expr_stmt|;
name|q
operator|->
name|setPeerName
argument_list|(
name|QString
argument_list|()
argument_list|)
expr_stmt|;
name|plainSocket
operator|=
operator|new
name|QTcpSocket
argument_list|(
name|q
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_BEARERMANAGEMENT
comment|//copy network session down to the plain socket (if it has been set)
name|plainSocket
operator|->
name|setProperty
argument_list|(
literal|"_q_networksession"
argument_list|,
name|q
operator|->
name|property
argument_list|(
literal|"_q_networksession"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|q
operator|->
name|connect
argument_list|(
name|plainSocket
argument_list|,
name|SIGNAL
argument_list|(
name|connected
argument_list|()
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_connectedSlot
argument_list|()
argument_list|)
argument_list|,
name|Qt
operator|::
name|DirectConnection
argument_list|)
expr_stmt|;
name|q
operator|->
name|connect
argument_list|(
name|plainSocket
argument_list|,
name|SIGNAL
argument_list|(
name|hostFound
argument_list|()
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_hostFoundSlot
argument_list|()
argument_list|)
argument_list|,
name|Qt
operator|::
name|DirectConnection
argument_list|)
expr_stmt|;
name|q
operator|->
name|connect
argument_list|(
name|plainSocket
argument_list|,
name|SIGNAL
argument_list|(
name|disconnected
argument_list|()
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_disconnectedSlot
argument_list|()
argument_list|)
argument_list|,
name|Qt
operator|::
name|DirectConnection
argument_list|)
expr_stmt|;
name|q
operator|->
name|connect
argument_list|(
name|plainSocket
argument_list|,
name|SIGNAL
argument_list|(
name|stateChanged
argument_list|(
name|QAbstractSocket
operator|::
name|SocketState
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_stateChangedSlot
argument_list|(
name|QAbstractSocket
operator|::
name|SocketState
argument_list|)
argument_list|)
argument_list|,
name|Qt
operator|::
name|DirectConnection
argument_list|)
expr_stmt|;
name|q
operator|->
name|connect
argument_list|(
name|plainSocket
argument_list|,
name|SIGNAL
argument_list|(
name|error
argument_list|(
name|QAbstractSocket
operator|::
name|SocketError
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_errorSlot
argument_list|(
name|QAbstractSocket
operator|::
name|SocketError
argument_list|)
argument_list|)
argument_list|,
name|Qt
operator|::
name|DirectConnection
argument_list|)
expr_stmt|;
name|q
operator|->
name|connect
argument_list|(
name|plainSocket
argument_list|,
name|SIGNAL
argument_list|(
name|readyRead
argument_list|()
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_readyReadSlot
argument_list|()
argument_list|)
argument_list|,
name|Qt
operator|::
name|DirectConnection
argument_list|)
expr_stmt|;
name|q
operator|->
name|connect
argument_list|(
name|plainSocket
argument_list|,
name|SIGNAL
argument_list|(
name|bytesWritten
argument_list|(
name|qint64
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_bytesWrittenSlot
argument_list|(
name|qint64
argument_list|)
argument_list|)
argument_list|,
name|Qt
operator|::
name|DirectConnection
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
name|q
operator|->
name|connect
argument_list|(
name|plainSocket
argument_list|,
name|SIGNAL
argument_list|(
name|proxyAuthenticationRequired
argument_list|(
name|QNetworkProxy
argument_list|,
name|QAuthenticator
operator|*
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|SIGNAL
argument_list|(
name|proxyAuthenticationRequired
argument_list|(
name|QNetworkProxy
argument_list|,
name|QAuthenticator
operator|*
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|buffer
operator|.
name|clear
argument_list|()
expr_stmt|;
name|writeBuffer
operator|.
name|clear
argument_list|()
expr_stmt|;
name|connectionEncrypted
operator|=
literal|false
expr_stmt|;
name|configuration
operator|.
name|peerCertificate
operator|.
name|clear
argument_list|()
expr_stmt|;
name|configuration
operator|.
name|peerCertificateChain
operator|.
name|clear
argument_list|()
expr_stmt|;
name|mode
operator|=
name|QSslSocket
operator|::
name|UnencryptedMode
expr_stmt|;
name|q
operator|->
name|setReadBufferSize
argument_list|(
name|readBufferMaxSize
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|pauseSocketNotifiers
name|void
name|QSslSocketPrivate
operator|::
name|pauseSocketNotifiers
parameter_list|(
name|QSslSocket
modifier|*
name|socket
parameter_list|)
block|{
if|if
condition|(
operator|!
name|socket
operator|->
name|d_func
argument_list|()
operator|->
name|plainSocket
condition|)
return|return;
name|QAbstractSocketPrivate
operator|::
name|pauseSocketNotifiers
argument_list|(
name|socket
operator|->
name|d_func
argument_list|()
operator|->
name|plainSocket
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|resumeSocketNotifiers
name|void
name|QSslSocketPrivate
operator|::
name|resumeSocketNotifiers
parameter_list|(
name|QSslSocket
modifier|*
name|socket
parameter_list|)
block|{
if|if
condition|(
operator|!
name|socket
operator|->
name|d_func
argument_list|()
operator|->
name|plainSocket
condition|)
return|return;
name|QAbstractSocketPrivate
operator|::
name|resumeSocketNotifiers
argument_list|(
name|socket
operator|->
name|d_func
argument_list|()
operator|->
name|plainSocket
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|isPaused
name|bool
name|QSslSocketPrivate
operator|::
name|isPaused
parameter_list|()
specifier|const
block|{
return|return
name|paused
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|_q_connectedSlot
name|void
name|QSslSocketPrivate
operator|::
name|_q_connectedSlot
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QSslSocket
argument_list|)
expr_stmt|;
name|q
operator|->
name|setLocalPort
argument_list|(
name|plainSocket
operator|->
name|localPort
argument_list|()
argument_list|)
expr_stmt|;
name|q
operator|->
name|setLocalAddress
argument_list|(
name|plainSocket
operator|->
name|localAddress
argument_list|()
argument_list|)
expr_stmt|;
name|q
operator|->
name|setPeerPort
argument_list|(
name|plainSocket
operator|->
name|peerPort
argument_list|()
argument_list|)
expr_stmt|;
name|q
operator|->
name|setPeerAddress
argument_list|(
name|plainSocket
operator|->
name|peerAddress
argument_list|()
argument_list|)
expr_stmt|;
name|q
operator|->
name|setPeerName
argument_list|(
name|plainSocket
operator|->
name|peerName
argument_list|()
argument_list|)
expr_stmt|;
name|cachedSocketDescriptor
operator|=
name|plainSocket
operator|->
name|socketDescriptor
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|QSSLSOCKET_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QSslSocket::_q_connectedSlot()"
expr_stmt|;
name|qDebug
argument_list|()
operator|<<
literal|"\tstate ="
operator|<<
name|q
operator|->
name|state
argument_list|()
expr_stmt|;
name|qDebug
argument_list|()
operator|<<
literal|"\tpeer ="
operator|<<
name|q
operator|->
name|peerName
argument_list|()
operator|<<
name|q
operator|->
name|peerAddress
argument_list|()
operator|<<
name|q
operator|->
name|peerPort
argument_list|()
expr_stmt|;
name|qDebug
argument_list|()
operator|<<
literal|"\tlocal ="
operator|<<
name|QHostInfo
operator|::
name|fromName
argument_list|(
name|q
operator|->
name|localAddress
argument_list|()
operator|.
name|toString
argument_list|()
argument_list|)
operator|.
name|hostName
argument_list|()
operator|<<
name|q
operator|->
name|localAddress
argument_list|()
operator|<<
name|q
operator|->
name|localPort
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|autoStartHandshake
condition|)
name|q
operator|->
name|startClientEncryption
argument_list|()
expr_stmt|;
emit|emit
name|q
operator|->
name|connected
argument_list|()
emit|;
if|if
condition|(
name|pendingClose
operator|&&
operator|!
name|autoStartHandshake
condition|)
block|{
name|pendingClose
operator|=
literal|false
expr_stmt|;
name|q
operator|->
name|disconnectFromHost
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|_q_hostFoundSlot
name|void
name|QSslSocketPrivate
operator|::
name|_q_hostFoundSlot
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QSslSocket
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QSSLSOCKET_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QSslSocket::_q_hostFoundSlot()"
expr_stmt|;
name|qDebug
argument_list|()
operator|<<
literal|"\tstate ="
operator|<<
name|q
operator|->
name|state
argument_list|()
expr_stmt|;
endif|#
directive|endif
emit|emit
name|q
operator|->
name|hostFound
argument_list|()
emit|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|_q_disconnectedSlot
name|void
name|QSslSocketPrivate
operator|::
name|_q_disconnectedSlot
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QSslSocket
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QSSLSOCKET_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QSslSocket::_q_disconnectedSlot()"
expr_stmt|;
name|qDebug
argument_list|()
operator|<<
literal|"\tstate ="
operator|<<
name|q
operator|->
name|state
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|disconnected
argument_list|()
expr_stmt|;
emit|emit
name|q
operator|->
name|disconnected
argument_list|()
emit|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|_q_stateChangedSlot
name|void
name|QSslSocketPrivate
operator|::
name|_q_stateChangedSlot
parameter_list|(
name|QAbstractSocket
operator|::
name|SocketState
name|state
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QSslSocket
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QSSLSOCKET_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QSslSocket::_q_stateChangedSlot("
operator|<<
name|state
operator|<<
literal|')'
expr_stmt|;
endif|#
directive|endif
name|q
operator|->
name|setSocketState
argument_list|(
name|state
argument_list|)
expr_stmt|;
emit|emit
name|q
operator|->
name|stateChanged
argument_list|(
name|state
argument_list|)
emit|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|_q_errorSlot
name|void
name|QSslSocketPrivate
operator|::
name|_q_errorSlot
parameter_list|(
name|QAbstractSocket
operator|::
name|SocketError
name|error
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QSslSocket
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QSSLSOCKET_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QSslSocket::_q_errorSlot("
operator|<<
name|error
operator|<<
literal|')'
expr_stmt|;
name|qDebug
argument_list|()
operator|<<
literal|"\tstate ="
operator|<<
name|q
operator|->
name|state
argument_list|()
expr_stmt|;
name|qDebug
argument_list|()
operator|<<
literal|"\terrorString ="
operator|<<
name|q
operator|->
name|errorString
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|q
operator|->
name|setSocketError
argument_list|(
name|plainSocket
operator|->
name|error
argument_list|()
argument_list|)
expr_stmt|;
name|q
operator|->
name|setErrorString
argument_list|(
name|plainSocket
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
emit|emit
name|q
operator|->
name|error
argument_list|(
name|error
argument_list|)
emit|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|_q_readyReadSlot
name|void
name|QSslSocketPrivate
operator|::
name|_q_readyReadSlot
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QSslSocket
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QSSLSOCKET_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QSslSocket::_q_readyReadSlot() -"
operator|<<
name|plainSocket
operator|->
name|bytesAvailable
argument_list|()
operator|<<
literal|"bytes available"
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|mode
operator|==
name|QSslSocket
operator|::
name|UnencryptedMode
condition|)
block|{
if|if
condition|(
name|readyReadEmittedPointer
condition|)
operator|*
name|readyReadEmittedPointer
operator|=
literal|true
expr_stmt|;
emit|emit
name|q
operator|->
name|readyRead
argument_list|()
emit|;
return|return;
block|}
name|transmit
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|_q_bytesWrittenSlot
name|void
name|QSslSocketPrivate
operator|::
name|_q_bytesWrittenSlot
parameter_list|(
name|qint64
name|written
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QSslSocket
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QSSLSOCKET_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QSslSocket::_q_bytesWrittenSlot("
operator|<<
name|written
operator|<<
literal|')'
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|mode
operator|==
name|QSslSocket
operator|::
name|UnencryptedMode
condition|)
emit|emit
name|q
operator|->
name|bytesWritten
argument_list|(
name|written
argument_list|)
emit|;
else|else
emit|emit
name|q
operator|->
name|encryptedBytesWritten
argument_list|(
name|written
argument_list|)
emit|;
if|if
condition|(
name|state
operator|==
name|QAbstractSocket
operator|::
name|ClosingState
operator|&&
name|writeBuffer
operator|.
name|isEmpty
argument_list|()
condition|)
name|q
operator|->
name|disconnectFromHost
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|_q_flushWriteBuffer
name|void
name|QSslSocketPrivate
operator|::
name|_q_flushWriteBuffer
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QSslSocket
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|writeBuffer
operator|.
name|isEmpty
argument_list|()
condition|)
name|q
operator|->
name|flush
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|_q_flushReadBuffer
name|void
name|QSslSocketPrivate
operator|::
name|_q_flushReadBuffer
parameter_list|()
block|{
comment|// trigger a read from the plainSocket into SSL
if|if
condition|(
name|mode
operator|!=
name|QSslSocket
operator|::
name|UnencryptedMode
condition|)
name|transmit
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|_q_resumeImplementation
name|void
name|QSslSocketPrivate
operator|::
name|_q_resumeImplementation
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QSslSocket
argument_list|)
expr_stmt|;
if|if
condition|(
name|plainSocket
condition|)
name|plainSocket
operator|->
name|resume
argument_list|()
expr_stmt|;
name|paused
operator|=
literal|false
expr_stmt|;
if|if
condition|(
operator|!
name|connectionEncrypted
condition|)
block|{
if|if
condition|(
name|verifyErrorsHaveBeenIgnored
argument_list|()
condition|)
block|{
name|continueHandshake
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|q
operator|->
name|setErrorString
argument_list|(
name|sslErrors
operator|.
name|first
argument_list|()
operator|.
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
name|q
operator|->
name|setSocketError
argument_list|(
name|QAbstractSocket
operator|::
name|SslHandshakeFailedError
argument_list|)
expr_stmt|;
emit|emit
name|q
operator|->
name|error
argument_list|(
name|QAbstractSocket
operator|::
name|SslHandshakeFailedError
argument_list|)
emit|;
name|plainSocket
operator|->
name|disconnectFromHost
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
name|transmit
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|verifyErrorsHaveBeenIgnored
name|bool
name|QSslSocketPrivate
operator|::
name|verifyErrorsHaveBeenIgnored
parameter_list|()
block|{
name|bool
name|doEmitSslError
decl_stmt|;
if|if
condition|(
operator|!
name|ignoreErrorsList
operator|.
name|empty
argument_list|()
condition|)
block|{
comment|// check whether the errors we got are all in the list of expected errors
comment|// (applies only if the method QSslSocket::ignoreSslErrors(const QList<QSslError>&errors)
comment|// was called)
name|doEmitSslError
operator|=
literal|false
expr_stmt|;
for|for
control|(
name|int
name|a
init|=
literal|0
init|;
name|a
operator|<
name|sslErrors
operator|.
name|count
argument_list|()
condition|;
name|a
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|ignoreErrorsList
operator|.
name|contains
argument_list|(
name|sslErrors
operator|.
name|at
argument_list|(
name|a
argument_list|)
argument_list|)
condition|)
block|{
name|doEmitSslError
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
comment|// if QSslSocket::ignoreSslErrors(const QList<QSslError>&errors) was not called and
comment|// we get an SSL error, emit a signal unless we ignored all errors (by calling
comment|// QSslSocket::ignoreSslErrors() )
name|doEmitSslError
operator|=
operator|!
name|ignoreAllSslErrors
expr_stmt|;
block|}
return|return
operator|!
name|doEmitSslError
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|peek
name|qint64
name|QSslSocketPrivate
operator|::
name|peek
parameter_list|(
name|char
modifier|*
name|data
parameter_list|,
name|qint64
name|maxSize
parameter_list|)
block|{
if|if
condition|(
name|mode
operator|==
name|QSslSocket
operator|::
name|UnencryptedMode
operator|&&
operator|!
name|autoStartHandshake
condition|)
block|{
comment|//unencrypted mode - do not use QIODevice::peek, as it reads ahead data from the plain socket
comment|//peek at data already in the QIODevice buffer (from a previous read)
name|qint64
name|r
init|=
name|buffer
operator|.
name|peek
argument_list|(
name|data
argument_list|,
name|maxSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|==
name|maxSize
condition|)
return|return
name|r
return|;
name|data
operator|+=
name|r
expr_stmt|;
comment|//peek at data in the plain socket
if|if
condition|(
name|plainSocket
condition|)
block|{
name|qint64
name|r2
init|=
name|plainSocket
operator|->
name|peek
argument_list|(
name|data
argument_list|,
name|maxSize
operator|-
name|r
argument_list|)
decl_stmt|;
if|if
condition|(
name|r2
operator|<
literal|0
condition|)
return|return
operator|(
name|r
operator|>
literal|0
condition|?
name|r
else|:
name|r2
operator|)
return|;
return|return
name|r
operator|+
name|r2
return|;
block|}
else|else
block|{
return|return
operator|-
literal|1
return|;
block|}
block|}
else|else
block|{
comment|//encrypted mode - the socket engine will read and decrypt data into the QIODevice buffer
return|return
name|QTcpSocketPrivate
operator|::
name|peek
argument_list|(
name|data
argument_list|,
name|maxSize
argument_list|)
return|;
block|}
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|peek
name|QByteArray
name|QSslSocketPrivate
operator|::
name|peek
parameter_list|(
name|qint64
name|maxSize
parameter_list|)
block|{
if|if
condition|(
name|mode
operator|==
name|QSslSocket
operator|::
name|UnencryptedMode
operator|&&
operator|!
name|autoStartHandshake
condition|)
block|{
comment|//unencrypted mode - do not use QIODevice::peek, as it reads ahead data from the plain socket
comment|//peek at data already in the QIODevice buffer (from a previous read)
name|QByteArray
name|ret
decl_stmt|;
name|ret
operator|.
name|reserve
argument_list|(
name|maxSize
argument_list|)
expr_stmt|;
name|ret
operator|.
name|resize
argument_list|(
name|buffer
operator|.
name|peek
argument_list|(
name|ret
operator|.
name|data
argument_list|()
argument_list|,
name|maxSize
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|.
name|length
argument_list|()
operator|==
name|maxSize
condition|)
return|return
name|ret
return|;
comment|//peek at data in the plain socket
if|if
condition|(
name|plainSocket
condition|)
return|return
name|ret
operator|+
name|plainSocket
operator|->
name|peek
argument_list|(
name|maxSize
operator|-
name|ret
operator|.
name|length
argument_list|()
argument_list|)
return|;
else|else
return|return
name|QByteArray
argument_list|()
return|;
block|}
else|else
block|{
comment|//encrypted mode - the socket engine will read and decrypt data into the QIODevice buffer
return|return
name|QTcpSocketPrivate
operator|::
name|peek
argument_list|(
name|maxSize
argument_list|)
return|;
block|}
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|rootCertOnDemandLoadingSupported
name|bool
name|QSslSocketPrivate
operator|::
name|rootCertOnDemandLoadingSupported
parameter_list|()
block|{
return|return
name|s_loadRootCertsOnDemand
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|unixRootCertDirectories
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|QSslSocketPrivate
operator|::
name|unixRootCertDirectories
parameter_list|()
block|{
return|return
name|QList
argument_list|<
name|QByteArray
argument_list|>
argument_list|()
operator|<<
literal|"/etc/ssl/certs/"
comment|// (K)ubuntu, OpenSUSE, Mandriva, MeeGo ...
operator|<<
literal|"/usr/lib/ssl/certs/"
comment|// Gentoo, Mandrake
operator|<<
literal|"/usr/share/ssl/"
comment|// Centos, Redhat, SuSE
operator|<<
literal|"/usr/local/ssl/"
comment|// Normal OpenSSL Tarball
operator|<<
literal|"/var/ssl/certs/"
comment|// AIX
operator|<<
literal|"/usr/local/ssl/certs/"
comment|// Solaris
operator|<<
literal|"/etc/openssl/certs/"
comment|// BlackBerry
operator|<<
literal|"/opt/openssl/certs/"
return|;
comment|// HP-UX
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|checkSettingSslContext
name|void
name|QSslSocketPrivate
operator|::
name|checkSettingSslContext
parameter_list|(
name|QSslSocket
modifier|*
name|socket
parameter_list|,
name|QSharedPointer
argument_list|<
name|QSslContext
argument_list|>
name|sslContext
parameter_list|)
block|{
if|if
condition|(
name|socket
operator|->
name|d_func
argument_list|()
operator|->
name|sslContextPointer
operator|.
name|isNull
argument_list|()
condition|)
name|socket
operator|->
name|d_func
argument_list|()
operator|->
name|sslContextPointer
operator|=
name|sslContext
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|sslContext
name|QSharedPointer
argument_list|<
name|QSslContext
argument_list|>
name|QSslSocketPrivate
operator|::
name|sslContext
parameter_list|(
name|QSslSocket
modifier|*
name|socket
parameter_list|)
block|{
return|return
operator|(
name|socket
operator|)
condition|?
name|socket
operator|->
name|d_func
argument_list|()
operator|->
name|sslContextPointer
else|:
name|QSharedPointer
argument_list|<
name|QSslContext
argument_list|>
argument_list|()
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_include
include|#
directive|include
file|"moc_qsslsocket.cpp"
end_include
end_unit
