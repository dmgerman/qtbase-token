begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtNetwork module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_comment
comment|/*!     \class QSslCertificate     \brief The QSslCertificate class provides a convenient API for an X509 certificate.     \since 4.3      \reentrant     \ingroup network     \ingroup ssl     \inmodule QtNetwork      QSslCertificate stores an X509 certificate, and is commonly used     to verify the identity and store information about the local host,     a remotely connected peer, or a trusted third party Certificate     Authority.      There are many ways to construct a QSslCertificate. The most     common way is to call QSslSocket::peerCertificate(), which returns     a QSslCertificate object, or QSslSocket::peerCertificateChain(),     which returns a list of them. You can also load certificates from     a DER (binary) or PEM (Base64) encoded bundle, typically stored as     one or more local files, or in a Qt Resource.      You can call isNull() to check if your certificate is null. By default,     QSslCertificate constructs a null certificate. A null certificate is     invalid, but an invalid certificate is not necessarily null. If you want     to reset all contents in a certificate, call clear().      After loading a certificate, you can find information about the     certificate, its subject, and its issuer, by calling one of the     many accessor functions, including version(), serialNumber(),     issuerInfo() and subjectInfo(). You can call effectiveDate() and     expiryDate() to check when the certificate starts being     effective and when it expires.     The publicKey() function returns the certificate     subject's public key as a QSslKey. You can call issuerInfo() or     subjectInfo() to get detailed information about the certificate     issuer and its subject.      Internally, QSslCertificate is stored as an X509 structure. You     can access this handle by calling handle(), but the results are     likely to not be portable.      \sa QSslSocket, QSslKey, QSslCipher, QSslError */
end_comment
begin_comment
comment|/*!     \enum QSslCertificate::SubjectInfo      Describes keys that you can pass to QSslCertificate::issuerInfo() or     QSslCertificate::subjectInfo() to get information about the certificate     issuer or subject.      \value Organization "O" The name of the organization.      \value CommonName "CN" The common name; most often this is used to store     the host name.      \value LocalityName "L" The locality.      \value OrganizationalUnitName "OU" The organizational unit name.      \value CountryName "C" The country.      \value StateOrProvinceName "ST" The state or province.      \value DistinguishedNameQualifier The distinguished name qualifier      \value SerialNumber The certificate's serial number      \value EmailAddress The email address associated with the certificate */
end_comment
begin_include
include|#
directive|include
file|"qsslsocket_openssl_symbols_p.h"
end_include
begin_include
include|#
directive|include
file|"qsslcertificate.h"
end_include
begin_include
include|#
directive|include
file|"qsslcertificate_p.h"
end_include
begin_include
include|#
directive|include
file|"qsslkey.h"
end_include
begin_include
include|#
directive|include
file|"qsslkey_p.h"
end_include
begin_include
include|#
directive|include
file|"qsslcertificateextension.h"
end_include
begin_include
include|#
directive|include
file|"qsslcertificateextension_p.h"
end_include
begin_include
include|#
directive|include
file|<QtCore/qatomic.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qdatetime.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qdebug.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qdir.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qdiriterator.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qfile.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qfileinfo.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qmap.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qmutex.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/private/qmutexpool_p.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qstring.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qstringlist.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qvarlengtharray.h>
end_include
begin_function_decl
name|QT_BEGIN_NAMESPACE
comment|// forward declaration
specifier|static
name|QMap
argument_list|<
name|QByteArray
argument_list|,
name|QString
argument_list|>
name|_q_mapFromX509Name
parameter_list|(
name|X509_NAME
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/*!     Constructs a QSslCertificate by reading \a format encoded data     from \a device and using the first certificate found. You can     later call isNull() to see if \a device contained a certificate,     and if this certificate was loaded successfully. */
end_comment
begin_constructor
DECL|function|QSslCertificate
name|QSslCertificate
operator|::
name|QSslCertificate
parameter_list|(
name|QIODevice
modifier|*
name|device
parameter_list|,
name|QSsl
operator|::
name|EncodingFormat
name|format
parameter_list|)
member_init_list|:
name|d
argument_list|(
operator|new
name|QSslCertificatePrivate
argument_list|)
block|{
name|QSslSocketPrivate
operator|::
name|ensureInitialized
argument_list|()
expr_stmt|;
if|if
condition|(
name|device
condition|)
name|d
operator|->
name|init
argument_list|(
name|device
operator|->
name|readAll
argument_list|()
argument_list|,
name|format
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a QSslCertificate by parsing the \a format encoded     \a data and using the first available certificate found. You can     later call isNull() to see if \a data contained a certificate,     and if this certificate was loaded successfully. */
end_comment
begin_constructor
DECL|function|QSslCertificate
name|QSslCertificate
operator|::
name|QSslCertificate
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|data
parameter_list|,
name|QSsl
operator|::
name|EncodingFormat
name|format
parameter_list|)
member_init_list|:
name|d
argument_list|(
operator|new
name|QSslCertificatePrivate
argument_list|)
block|{
name|QSslSocketPrivate
operator|::
name|ensureInitialized
argument_list|()
expr_stmt|;
name|d
operator|->
name|init
argument_list|(
name|data
argument_list|,
name|format
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs an identical copy of \a other. */
end_comment
begin_constructor
DECL|function|QSslCertificate
name|QSslCertificate
operator|::
name|QSslCertificate
parameter_list|(
specifier|const
name|QSslCertificate
modifier|&
name|other
parameter_list|)
member_init_list|:
name|d
argument_list|(
name|other
operator|.
name|d
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Destroys the QSslCertificate. */
end_comment
begin_destructor
DECL|function|~QSslCertificate
name|QSslCertificate
operator|::
name|~
name|QSslCertificate
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     Copies the contents of \a other into this certificate, making the two     certificates identical. */
end_comment
begin_function
DECL|function|operator =
name|QSslCertificate
modifier|&
name|QSslCertificate
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QSslCertificate
modifier|&
name|other
parameter_list|)
block|{
name|d
operator|=
name|other
operator|.
name|d
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QSslCertificate::swap(QSslCertificate&other)     \since 5.0      Swaps this certificate instance with \a other. This function is     very fast and never fails. */
end_comment
begin_comment
comment|/*!     Returns true if this certificate is the same as \a other; otherwise     returns false. */
end_comment
begin_function
DECL|function|operator ==
name|bool
name|QSslCertificate
operator|::
name|operator
name|==
parameter_list|(
specifier|const
name|QSslCertificate
modifier|&
name|other
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|d
operator|==
name|other
operator|.
name|d
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|d
operator|->
name|null
operator|&&
name|other
operator|.
name|d
operator|->
name|null
condition|)
return|return
literal|true
return|;
if|if
condition|(
name|d
operator|->
name|x509
operator|&&
name|other
operator|.
name|d
operator|->
name|x509
condition|)
return|return
name|q_X509_cmp
argument_list|(
name|d
operator|->
name|x509
argument_list|,
name|other
operator|.
name|d
operator|->
name|x509
argument_list|)
operator|==
literal|0
return|;
return|return
literal|false
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QSslCertificate::operator!=(const QSslCertificate&other) const      Returns true if this certificate is not the same as \a other; otherwise     returns false. */
end_comment
begin_comment
comment|/*!     Returns true if this is a null certificate (i.e., a certificate     with no contents); otherwise returns false.      By default, QSslCertificate constructs a null certificate.      \sa clear() */
end_comment
begin_function
DECL|function|isNull
name|bool
name|QSslCertificate
operator|::
name|isNull
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|null
return|;
block|}
end_function
begin_if
if|#
directive|if
name|QT_DEPRECATED_SINCE
argument_list|(
literal|5
operator|,
literal|0
argument_list|)
end_if
begin_comment
comment|/*!     \fn bool QSslCertificate::isValid() const     \obsolete      To verify a certificate, use verify().     To check if a certificate is blacklisted, use isBlacklisted().     To check if a certificate has expired or is not yet valid, compare     expiryDate() and effectiveDate() with QDateTime::currentDateTime()      This function checks that the current     data-time is within the date-time range during which the     certificate is considered valid, and checks that the     certificate is not in a blacklist of fraudulent certificates.      \sa isNull(), verify(), isBlacklisted(), expiryDate(), effectiveDate() */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     Returns true if this certificate is blacklisted; otherwise     returns false.      \sa isNull() */
end_comment
begin_function
DECL|function|isBlacklisted
name|bool
name|QSslCertificate
operator|::
name|isBlacklisted
parameter_list|()
specifier|const
block|{
return|return
name|QSslCertificatePrivate
operator|::
name|isBlacklisted
argument_list|(
operator|*
name|this
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Clears the contents of this certificate, making it a null     certificate.      \sa isNull() */
end_comment
begin_function
DECL|function|clear
name|void
name|QSslCertificate
operator|::
name|clear
parameter_list|()
block|{
if|if
condition|(
name|isNull
argument_list|()
condition|)
return|return;
name|d
operator|=
operator|new
name|QSslCertificatePrivate
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the certificate's version string. */
end_comment
begin_function
DECL|function|version
name|QByteArray
name|QSslCertificate
operator|::
name|version
parameter_list|()
specifier|const
block|{
name|QMutexLocker
name|lock
argument_list|(
name|QMutexPool
operator|::
name|globalInstanceGet
argument_list|(
name|d
operator|.
name|data
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|versionString
operator|.
name|isEmpty
argument_list|()
operator|&&
name|d
operator|->
name|x509
condition|)
name|d
operator|->
name|versionString
operator|=
name|QByteArray
operator|::
name|number
argument_list|(
name|qlonglong
argument_list|(
name|q_ASN1_INTEGER_get
argument_list|(
name|d
operator|->
name|x509
operator|->
name|cert_info
operator|->
name|version
argument_list|)
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|versionString
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the certificate's serial number string in hexadecimal format. */
end_comment
begin_function
DECL|function|serialNumber
name|QByteArray
name|QSslCertificate
operator|::
name|serialNumber
parameter_list|()
specifier|const
block|{
name|QMutexLocker
name|lock
argument_list|(
name|QMutexPool
operator|::
name|globalInstanceGet
argument_list|(
name|d
operator|.
name|data
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|serialNumberString
operator|.
name|isEmpty
argument_list|()
operator|&&
name|d
operator|->
name|x509
condition|)
block|{
name|ASN1_INTEGER
modifier|*
name|serialNumber
init|=
name|d
operator|->
name|x509
operator|->
name|cert_info
operator|->
name|serialNumber
decl_stmt|;
name|QByteArray
name|hexString
decl_stmt|;
name|hexString
operator|.
name|reserve
argument_list|(
name|serialNumber
operator|->
name|length
operator|*
literal|3
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|a
init|=
literal|0
init|;
name|a
operator|<
name|serialNumber
operator|->
name|length
condition|;
operator|++
name|a
control|)
block|{
name|hexString
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|serialNumber
operator|->
name|data
index|[
name|a
index|]
argument_list|,
literal|16
argument_list|)
operator|.
name|rightJustified
argument_list|(
literal|2
argument_list|,
literal|'0'
argument_list|)
expr_stmt|;
name|hexString
operator|+=
literal|':'
expr_stmt|;
block|}
name|hexString
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|d
operator|->
name|serialNumberString
operator|=
name|hexString
expr_stmt|;
block|}
return|return
name|d
operator|->
name|serialNumberString
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a cryptographic digest of this certificate. By default,     an MD5 digest will be generated, but you can also specify a     custom \a algorithm. */
end_comment
begin_function
DECL|function|digest
name|QByteArray
name|QSslCertificate
operator|::
name|digest
parameter_list|(
name|QCryptographicHash
operator|::
name|Algorithm
name|algorithm
parameter_list|)
specifier|const
block|{
return|return
name|QCryptographicHash
operator|::
name|hash
argument_list|(
name|toDer
argument_list|()
argument_list|,
name|algorithm
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|_q_SubjectInfoToString
specifier|static
name|QByteArray
name|_q_SubjectInfoToString
parameter_list|(
name|QSslCertificate
operator|::
name|SubjectInfo
name|info
parameter_list|)
block|{
name|QByteArray
name|str
decl_stmt|;
switch|switch
condition|(
name|info
condition|)
block|{
case|case
name|QSslCertificate
operator|::
name|Organization
case|:
name|str
operator|=
name|QByteArray
argument_list|(
literal|"O"
argument_list|)
expr_stmt|;
break|break;
case|case
name|QSslCertificate
operator|::
name|CommonName
case|:
name|str
operator|=
name|QByteArray
argument_list|(
literal|"CN"
argument_list|)
expr_stmt|;
break|break;
case|case
name|QSslCertificate
operator|::
name|LocalityName
case|:
name|str
operator|=
name|QByteArray
argument_list|(
literal|"L"
argument_list|)
expr_stmt|;
break|break;
case|case
name|QSslCertificate
operator|::
name|OrganizationalUnitName
case|:
name|str
operator|=
name|QByteArray
argument_list|(
literal|"OU"
argument_list|)
expr_stmt|;
break|break;
case|case
name|QSslCertificate
operator|::
name|CountryName
case|:
name|str
operator|=
name|QByteArray
argument_list|(
literal|"C"
argument_list|)
expr_stmt|;
break|break;
case|case
name|QSslCertificate
operator|::
name|StateOrProvinceName
case|:
name|str
operator|=
name|QByteArray
argument_list|(
literal|"ST"
argument_list|)
expr_stmt|;
break|break;
case|case
name|QSslCertificate
operator|::
name|DistinguishedNameQualifier
case|:
name|str
operator|=
name|QByteArray
argument_list|(
literal|"dnQualifier"
argument_list|)
expr_stmt|;
break|break;
case|case
name|QSslCertificate
operator|::
name|SerialNumber
case|:
name|str
operator|=
name|QByteArray
argument_list|(
literal|"serialNumber"
argument_list|)
expr_stmt|;
break|break;
case|case
name|QSslCertificate
operator|::
name|EmailAddress
case|:
name|str
operator|=
name|QByteArray
argument_list|(
literal|"emailAddress"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|str
return|;
block|}
end_function
begin_comment
comment|/*!   \fn QString QSslCertificate::issuerInfo(SubjectInfo subject) const    Returns the issuer information for the \a subject from the   certificate, or an empty string if there is no information for   \a subject in the certificate.    \sa subjectInfo() */
end_comment
begin_function
DECL|function|issuerInfo
name|QStringList
name|QSslCertificate
operator|::
name|issuerInfo
parameter_list|(
name|SubjectInfo
name|info
parameter_list|)
specifier|const
block|{
name|QMutexLocker
name|lock
argument_list|(
name|QMutexPool
operator|::
name|globalInstanceGet
argument_list|(
name|d
operator|.
name|data
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
comment|// lazy init
if|if
condition|(
name|d
operator|->
name|issuerInfo
operator|.
name|isEmpty
argument_list|()
operator|&&
name|d
operator|->
name|x509
condition|)
name|d
operator|->
name|issuerInfo
operator|=
name|_q_mapFromX509Name
argument_list|(
name|q_X509_get_issuer_name
argument_list|(
name|d
operator|->
name|x509
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|issuerInfo
operator|.
name|values
argument_list|(
name|_q_SubjectInfoToString
argument_list|(
name|info
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the issuer information for \a attribute from the certificate,   or an empty string if there is no information for \a attribute in the   certificate.    \sa subjectInfo() */
end_comment
begin_function
DECL|function|issuerInfo
name|QStringList
name|QSslCertificate
operator|::
name|issuerInfo
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|attribute
parameter_list|)
specifier|const
block|{
name|QMutexLocker
name|lock
argument_list|(
name|QMutexPool
operator|::
name|globalInstanceGet
argument_list|(
name|d
operator|.
name|data
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
comment|// lazy init
if|if
condition|(
name|d
operator|->
name|issuerInfo
operator|.
name|isEmpty
argument_list|()
operator|&&
name|d
operator|->
name|x509
condition|)
name|d
operator|->
name|issuerInfo
operator|=
name|_q_mapFromX509Name
argument_list|(
name|q_X509_get_issuer_name
argument_list|(
name|d
operator|->
name|x509
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|issuerInfo
operator|.
name|values
argument_list|(
name|attribute
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!    \fn QString QSslCertificate::subjectInfo(SubjectInfo subject) const    Returns the information for the \a subject, or an empty string if   there is no information for \a subject in the certificate.      \sa issuerInfo() */
end_comment
begin_function
DECL|function|subjectInfo
name|QStringList
name|QSslCertificate
operator|::
name|subjectInfo
parameter_list|(
name|SubjectInfo
name|info
parameter_list|)
specifier|const
block|{
name|QMutexLocker
name|lock
argument_list|(
name|QMutexPool
operator|::
name|globalInstanceGet
argument_list|(
name|d
operator|.
name|data
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
comment|// lazy init
if|if
condition|(
name|d
operator|->
name|subjectInfo
operator|.
name|isEmpty
argument_list|()
operator|&&
name|d
operator|->
name|x509
condition|)
name|d
operator|->
name|subjectInfo
operator|=
name|_q_mapFromX509Name
argument_list|(
name|q_X509_get_subject_name
argument_list|(
name|d
operator|->
name|x509
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|subjectInfo
operator|.
name|values
argument_list|(
name|_q_SubjectInfoToString
argument_list|(
name|info
argument_list|)
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the subject information for \a attribute, or an empty string if     there is no information for \a attribute in the certificate.      \sa issuerInfo() */
end_comment
begin_function
DECL|function|subjectInfo
name|QStringList
name|QSslCertificate
operator|::
name|subjectInfo
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|attribute
parameter_list|)
specifier|const
block|{
name|QMutexLocker
name|lock
argument_list|(
name|QMutexPool
operator|::
name|globalInstanceGet
argument_list|(
name|d
operator|.
name|data
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
comment|// lazy init
if|if
condition|(
name|d
operator|->
name|subjectInfo
operator|.
name|isEmpty
argument_list|()
operator|&&
name|d
operator|->
name|x509
condition|)
name|d
operator|->
name|subjectInfo
operator|=
name|_q_mapFromX509Name
argument_list|(
name|q_X509_get_subject_name
argument_list|(
name|d
operator|->
name|x509
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|subjectInfo
operator|.
name|values
argument_list|(
name|attribute
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 5.0     Returns a list of the attributes that have values in the subject     information of this certificate. The information associated     with a given attribute can be accessed using the subjectInfo()     method. Note that this list may include the OIDs for any     elements that are not known by the SSL backend.      \sa subjectInfo() */
end_comment
begin_function
DECL|function|subjectInfoAttributes
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|QSslCertificate
operator|::
name|subjectInfoAttributes
parameter_list|()
specifier|const
block|{
name|QMutexLocker
name|lock
argument_list|(
name|QMutexPool
operator|::
name|globalInstanceGet
argument_list|(
name|d
operator|.
name|data
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
comment|// lazy init
if|if
condition|(
name|d
operator|->
name|subjectInfo
operator|.
name|isEmpty
argument_list|()
operator|&&
name|d
operator|->
name|x509
condition|)
name|d
operator|->
name|subjectInfo
operator|=
name|_q_mapFromX509Name
argument_list|(
name|q_X509_get_subject_name
argument_list|(
name|d
operator|->
name|x509
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|subjectInfo
operator|.
name|uniqueKeys
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 5.0     Returns a list of the attributes that have values in the issuer     information of this certificate. The information associated     with a given attribute can be accessed using the issuerInfo()     method. Note that this list may include the OIDs for any     elements that are not known by the SSL backend.      \sa subjectInfo() */
end_comment
begin_function
DECL|function|issuerInfoAttributes
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|QSslCertificate
operator|::
name|issuerInfoAttributes
parameter_list|()
specifier|const
block|{
name|QMutexLocker
name|lock
argument_list|(
name|QMutexPool
operator|::
name|globalInstanceGet
argument_list|(
name|d
operator|.
name|data
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
comment|// lazy init
if|if
condition|(
name|d
operator|->
name|issuerInfo
operator|.
name|isEmpty
argument_list|()
operator|&&
name|d
operator|->
name|x509
condition|)
name|d
operator|->
name|issuerInfo
operator|=
name|_q_mapFromX509Name
argument_list|(
name|q_X509_get_issuer_name
argument_list|(
name|d
operator|->
name|x509
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|issuerInfo
operator|.
name|uniqueKeys
argument_list|()
return|;
block|}
end_function
begin_if
if|#
directive|if
name|QT_DEPRECATED_SINCE
argument_list|(
literal|5
operator|,
literal|0
argument_list|)
end_if
begin_comment
comment|/*!   \fn QMultiMap<QSsl::AlternateNameEntryType, QString> QSslCertificate::alternateSubjectNames() const   \obsolete    Use QSslCertificate::subjectAlternativeNames(); */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!   Returns the list of alternative subject names for this   certificate. The alternative names typically contain host   names, optionally with wildcards, that are valid for this   certificate.    These names are tested against the connected peer's host name, if   either the subject information for \l CommonName doesn't define a   valid host name, or the subject info name doesn't match the peer's   host name.    \sa subjectInfo() */
end_comment
begin_function
DECL|function|subjectAlternativeNames
name|QMultiMap
argument_list|<
name|QSsl
operator|::
name|AlternativeNameEntryType
argument_list|,
name|QString
argument_list|>
name|QSslCertificate
operator|::
name|subjectAlternativeNames
parameter_list|()
specifier|const
block|{
name|QMultiMap
argument_list|<
name|QSsl
operator|::
name|AlternativeNameEntryType
argument_list|,
name|QString
argument_list|>
name|result
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|x509
condition|)
return|return
name|result
return|;
name|STACK_OF
argument_list|(
name|GENERAL_NAME
argument_list|)
operator|*
name|altNames
operator|=
operator|(
name|STACK_OF
argument_list|(
name|GENERAL_NAME
argument_list|)
operator|*
operator|)
name|q_X509_get_ext_d2i
argument_list|(
name|d
operator|->
name|x509
argument_list|,
name|NID_subject_alt_name
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|altNames
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|q_sk_GENERAL_NAME_num
argument_list|(
name|altNames
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|GENERAL_NAME
modifier|*
name|genName
init|=
name|q_sk_GENERAL_NAME_value
argument_list|(
name|altNames
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|genName
operator|->
name|type
operator|!=
name|GEN_DNS
operator|&&
name|genName
operator|->
name|type
operator|!=
name|GEN_EMAIL
condition|)
continue|continue;
name|int
name|len
init|=
name|q_ASN1_STRING_length
argument_list|(
name|genName
operator|->
name|d
operator|.
name|ia5
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
operator|||
name|len
operator|>=
literal|8192
condition|)
block|{
comment|// broken name
continue|continue;
block|}
specifier|const
name|char
modifier|*
name|altNameStr
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|char
operator|*
argument_list|>
argument_list|(
name|q_ASN1_STRING_data
argument_list|(
name|genName
operator|->
name|d
operator|.
name|ia5
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|QString
name|altName
init|=
name|QString
operator|::
name|fromLatin1
argument_list|(
name|altNameStr
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|genName
operator|->
name|type
operator|==
name|GEN_DNS
condition|)
name|result
operator|.
name|insert
argument_list|(
name|QSsl
operator|::
name|DnsEntry
argument_list|,
name|altName
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|genName
operator|->
name|type
operator|==
name|GEN_EMAIL
condition|)
name|result
operator|.
name|insert
argument_list|(
name|QSsl
operator|::
name|EmailEntry
argument_list|,
name|altName
argument_list|)
expr_stmt|;
block|}
name|q_sk_pop_free
argument_list|(
operator|(
name|STACK
operator|*
operator|)
name|altNames
argument_list|,
cast|reinterpret_cast
argument_list|<
name|void
operator|(
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
argument_list|>
argument_list|(
name|q_sk_free
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the date-time that the certificate becomes valid, or an   empty QDateTime if this is a null certificate.    \sa expiryDate() */
end_comment
begin_function
DECL|function|effectiveDate
name|QDateTime
name|QSslCertificate
operator|::
name|effectiveDate
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|notValidBefore
return|;
block|}
end_function
begin_comment
comment|/*!   Returns the date-time that the certificate expires, or an empty   QDateTime if this is a null certificate.      \sa effectiveDate() */
end_comment
begin_function
DECL|function|expiryDate
name|QDateTime
name|QSslCertificate
operator|::
name|expiryDate
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|notValidAfter
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a pointer to the native certificate handle, if there is     one, or a null pointer otherwise.      You can use this handle, together with the native API, to access     extended information about the certificate.      \warning Use of this function has a high probability of being     non-portable, and its return value may vary from platform to     platform or change from minor release to minor release. */
end_comment
begin_function
DECL|function|handle
name|Qt
operator|::
name|HANDLE
name|QSslCertificate
operator|::
name|handle
parameter_list|()
specifier|const
block|{
return|return
name|Qt
operator|::
name|HANDLE
argument_list|(
name|d
operator|->
name|x509
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the certificate subject's public key. */
end_comment
begin_function
DECL|function|publicKey
name|QSslKey
name|QSslCertificate
operator|::
name|publicKey
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|x509
condition|)
return|return
name|QSslKey
argument_list|()
return|;
name|QSslKey
name|key
decl_stmt|;
name|key
operator|.
name|d
operator|->
name|type
operator|=
name|QSsl
operator|::
name|PublicKey
expr_stmt|;
name|X509_PUBKEY
modifier|*
name|xkey
init|=
name|d
operator|->
name|x509
operator|->
name|cert_info
operator|->
name|key
decl_stmt|;
name|EVP_PKEY
modifier|*
name|pkey
init|=
name|q_X509_PUBKEY_get
argument_list|(
name|xkey
argument_list|)
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|pkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|q_EVP_PKEY_type
argument_list|(
name|pkey
operator|->
name|type
argument_list|)
operator|==
name|EVP_PKEY_RSA
condition|)
block|{
name|key
operator|.
name|d
operator|->
name|rsa
operator|=
name|q_EVP_PKEY_get1_RSA
argument_list|(
name|pkey
argument_list|)
expr_stmt|;
name|key
operator|.
name|d
operator|->
name|algorithm
operator|=
name|QSsl
operator|::
name|Rsa
expr_stmt|;
name|key
operator|.
name|d
operator|->
name|isNull
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|q_EVP_PKEY_type
argument_list|(
name|pkey
operator|->
name|type
argument_list|)
operator|==
name|EVP_PKEY_DSA
condition|)
block|{
name|key
operator|.
name|d
operator|->
name|dsa
operator|=
name|q_EVP_PKEY_get1_DSA
argument_list|(
name|pkey
argument_list|)
expr_stmt|;
name|key
operator|.
name|d
operator|->
name|algorithm
operator|=
name|QSsl
operator|::
name|Dsa
expr_stmt|;
name|key
operator|.
name|d
operator|->
name|isNull
operator|=
literal|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|q_EVP_PKEY_type
argument_list|(
name|pkey
operator|->
name|type
argument_list|)
operator|==
name|EVP_PKEY_DH
condition|)
block|{
comment|// DH unsupported
block|}
else|else
block|{
comment|// error?
block|}
name|q_EVP_PKEY_free
argument_list|(
name|pkey
argument_list|)
expr_stmt|;
return|return
name|key
return|;
block|}
end_function
begin_comment
comment|/*  * Convert unknown extensions to a QVariant.  */
end_comment
begin_function
DECL|function|x509UnknownExtensionToValue
specifier|static
name|QVariant
name|x509UnknownExtensionToValue
parameter_list|(
name|X509_EXTENSION
modifier|*
name|ext
parameter_list|)
block|{
comment|// Get the extension specific method object if available
comment|// we cast away the const-ness here because some versions of openssl
comment|// don't use const for the parameters in the functions pointers stored
comment|// in the object.
name|X509V3_EXT_METHOD
modifier|*
name|meth
init|=
cast|const_cast
argument_list|<
name|X509V3_EXT_METHOD
operator|*
argument_list|>
argument_list|(
name|q_X509V3_EXT_get
argument_list|(
name|ext
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|meth
condition|)
block|{
name|ASN1_OCTET_STRING
modifier|*
name|value
init|=
name|q_X509_EXTENSION_get_data
argument_list|(
name|ext
argument_list|)
decl_stmt|;
name|QByteArray
name|result
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|char
operator|*
argument_list|>
argument_list|(
name|q_ASN1_STRING_data
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|,
name|q_ASN1_STRING_length
argument_list|(
name|value
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|result
return|;
block|}
comment|//const unsigned char *data = ext->value->data;
name|void
modifier|*
name|ext_internal
init|=
name|q_X509V3_EXT_d2i
argument_list|(
name|ext
argument_list|)
decl_stmt|;
comment|// If this extension can be converted
if|if
condition|(
name|meth
operator|->
name|i2v
operator|&&
name|ext_internal
condition|)
block|{
name|STACK_OF
argument_list|(
name|CONF_VALUE
argument_list|)
operator|*
name|val
operator|=
name|meth
operator|->
name|i2v
argument_list|(
name|meth
argument_list|,
name|ext_internal
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|QVariantMap
name|map
decl_stmt|;
name|QVariantList
name|list
decl_stmt|;
name|bool
name|isMap
init|=
literal|false
decl_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|q_SKM_sk_num
argument_list|(
name|CONF_VALUE
argument_list|,
name|val
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|CONF_VALUE
modifier|*
name|nval
init|=
name|q_SKM_sk_value
argument_list|(
name|CONF_VALUE
argument_list|,
name|val
argument_list|,
name|j
argument_list|)
decl_stmt|;
if|if
condition|(
name|nval
operator|->
name|name
operator|&&
name|nval
operator|->
name|value
condition|)
block|{
name|isMap
operator|=
literal|true
expr_stmt|;
name|map
index|[
name|QString
operator|::
name|fromUtf8
argument_list|(
name|nval
operator|->
name|name
argument_list|)
index|]
operator|=
name|QString
operator|::
name|fromUtf8
argument_list|(
name|nval
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nval
operator|->
name|name
condition|)
block|{
name|list
operator|<<
name|QString
operator|::
name|fromUtf8
argument_list|(
name|nval
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nval
operator|->
name|value
condition|)
block|{
name|list
operator|<<
name|QString
operator|::
name|fromUtf8
argument_list|(
name|nval
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|isMap
condition|)
return|return
name|map
return|;
else|else
return|return
name|list
return|;
block|}
elseif|else
if|if
condition|(
name|meth
operator|->
name|i2s
operator|&&
name|ext_internal
condition|)
block|{
comment|//qDebug()<< meth->i2s(meth, ext_internal);
name|QVariant
name|result
argument_list|(
name|QString
operator|::
name|fromUtf8
argument_list|(
name|meth
operator|->
name|i2s
argument_list|(
name|meth
argument_list|,
name|ext_internal
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|result
return|;
block|}
elseif|else
if|if
condition|(
name|meth
operator|->
name|i2r
operator|&&
name|ext_internal
condition|)
block|{
name|QByteArray
name|result
decl_stmt|;
name|BIO
modifier|*
name|bio
init|=
name|q_BIO_new
argument_list|(
name|q_BIO_s_mem
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|bio
condition|)
return|return
name|result
return|;
name|meth
operator|->
name|i2r
argument_list|(
name|meth
argument_list|,
name|ext_internal
argument_list|,
name|bio
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|char
modifier|*
name|bio_buffer
decl_stmt|;
name|long
name|bio_size
init|=
name|q_BIO_get_mem_data
argument_list|(
name|bio
argument_list|,
operator|&
name|bio_buffer
argument_list|)
decl_stmt|;
name|result
operator|=
name|QByteArray
argument_list|(
name|bio_buffer
argument_list|,
name|bio_size
argument_list|)
expr_stmt|;
name|q_BIO_free
argument_list|(
name|bio
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
return|return
name|QVariant
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*  * Convert extensions to a variant. The naming of the keys of the map are  * taken from RFC 5280, however we decided the capitalisation in the RFC  * was too silly for the real world.  */
end_comment
begin_function
DECL|function|x509ExtensionToValue
specifier|static
name|QVariant
name|x509ExtensionToValue
parameter_list|(
name|X509_EXTENSION
modifier|*
name|ext
parameter_list|)
block|{
name|ASN1_OBJECT
modifier|*
name|obj
init|=
name|q_X509_EXTENSION_get_object
argument_list|(
name|ext
argument_list|)
decl_stmt|;
name|int
name|nid
init|=
name|q_OBJ_obj2nid
argument_list|(
name|obj
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|nid
condition|)
block|{
case|case
name|NID_basic_constraints
case|:
block|{
name|BASIC_CONSTRAINTS
modifier|*
name|basic
init|=
cast|reinterpret_cast
argument_list|<
name|BASIC_CONSTRAINTS
operator|*
argument_list|>
argument_list|(
name|q_X509V3_EXT_d2i
argument_list|(
name|ext
argument_list|)
argument_list|)
decl_stmt|;
name|QVariantMap
name|result
decl_stmt|;
name|result
index|[
name|QLatin1String
argument_list|(
literal|"ca"
argument_list|)
index|]
operator|=
name|basic
operator|->
name|ca
condition|?
literal|true
else|:
literal|false
expr_stmt|;
if|if
condition|(
name|basic
operator|->
name|pathlen
condition|)
name|result
index|[
name|QLatin1String
argument_list|(
literal|"pathLenConstraint"
argument_list|)
index|]
operator|=
operator|(
name|qlonglong
operator|)
name|q_ASN1_INTEGER_get
argument_list|(
name|basic
operator|->
name|pathlen
argument_list|)
expr_stmt|;
name|q_BASIC_CONSTRAINTS_free
argument_list|(
name|basic
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
break|break;
case|case
name|NID_info_access
case|:
block|{
name|AUTHORITY_INFO_ACCESS
modifier|*
name|info
init|=
cast|reinterpret_cast
argument_list|<
name|AUTHORITY_INFO_ACCESS
operator|*
argument_list|>
argument_list|(
name|q_X509V3_EXT_d2i
argument_list|(
name|ext
argument_list|)
argument_list|)
decl_stmt|;
name|QVariantMap
name|result
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|q_SKM_sk_num
argument_list|(
name|ACCESS_DESCRIPTION
argument_list|,
name|info
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|ACCESS_DESCRIPTION
modifier|*
name|ad
init|=
name|q_SKM_sk_value
argument_list|(
name|ACCESS_DESCRIPTION
argument_list|,
name|info
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|GENERAL_NAME
modifier|*
name|name
init|=
name|ad
operator|->
name|location
decl_stmt|;
if|if
condition|(
name|name
operator|->
name|type
operator|==
name|GEN_URI
condition|)
block|{
name|int
name|len
init|=
name|q_ASN1_STRING_length
argument_list|(
name|name
operator|->
name|d
operator|.
name|uniformResourceIdentifier
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
operator|||
name|len
operator|>=
literal|8192
condition|)
block|{
comment|// broken name
continue|continue;
block|}
specifier|const
name|char
modifier|*
name|uriStr
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|char
operator|*
argument_list|>
argument_list|(
name|q_ASN1_STRING_data
argument_list|(
name|name
operator|->
name|d
operator|.
name|uniformResourceIdentifier
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|QString
name|uri
init|=
name|QString
operator|::
name|fromUtf8
argument_list|(
name|uriStr
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|result
index|[
name|QString
operator|::
name|fromUtf8
argument_list|(
name|QSslCertificatePrivate
operator|::
name|asn1ObjectName
argument_list|(
name|ad
operator|->
name|method
argument_list|)
argument_list|)
index|]
operator|=
name|uri
expr_stmt|;
block|}
else|else
block|{
name|qWarning
argument_list|()
operator|<<
literal|"Strange location type"
operator|<<
name|name
operator|->
name|type
expr_stmt|;
block|}
block|}
if|#
directive|if
name|OPENSSL_VERSION_NUMBER
operator|>=
literal|0x10000000L
name|q_sk_pop_free
argument_list|(
operator|(
name|_STACK
operator|*
operator|)
name|info
argument_list|,
cast|reinterpret_cast
argument_list|<
name|void
operator|(
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
argument_list|>
argument_list|(
name|q_sk_free
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|q_sk_pop_free
argument_list|(
operator|(
name|STACK
operator|*
operator|)
name|info
argument_list|,
cast|reinterpret_cast
argument_list|<
name|void
operator|(
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
argument_list|>
argument_list|(
name|q_sk_free
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|result
return|;
block|}
break|break;
case|case
name|NID_subject_key_identifier
case|:
block|{
name|void
modifier|*
name|ext_internal
init|=
name|q_X509V3_EXT_d2i
argument_list|(
name|ext
argument_list|)
decl_stmt|;
comment|// we cast away the const-ness here because some versions of openssl
comment|// don't use const for the parameters in the functions pointers stored
comment|// in the object.
name|X509V3_EXT_METHOD
modifier|*
name|meth
init|=
cast|const_cast
argument_list|<
name|X509V3_EXT_METHOD
operator|*
argument_list|>
argument_list|(
name|q_X509V3_EXT_get
argument_list|(
name|ext
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|QVariant
argument_list|(
name|QString
operator|::
name|fromUtf8
argument_list|(
name|meth
operator|->
name|i2s
argument_list|(
name|meth
argument_list|,
name|ext_internal
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
break|break;
case|case
name|NID_authority_key_identifier
case|:
block|{
name|AUTHORITY_KEYID
modifier|*
name|auth_key
init|=
cast|reinterpret_cast
argument_list|<
name|AUTHORITY_KEYID
operator|*
argument_list|>
argument_list|(
name|q_X509V3_EXT_d2i
argument_list|(
name|ext
argument_list|)
argument_list|)
decl_stmt|;
name|QVariantMap
name|result
decl_stmt|;
comment|// keyid
if|if
condition|(
name|auth_key
operator|->
name|keyid
condition|)
block|{
name|QByteArray
name|keyid
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|char
operator|*
argument_list|>
argument_list|(
name|auth_key
operator|->
name|keyid
operator|->
name|data
argument_list|)
argument_list|,
name|auth_key
operator|->
name|keyid
operator|->
name|length
argument_list|)
decl_stmt|;
name|result
index|[
name|QLatin1String
argument_list|(
literal|"keyid"
argument_list|)
index|]
operator|=
name|keyid
operator|.
name|toHex
argument_list|()
expr_stmt|;
block|}
comment|// issuer
comment|// TODO: GENERAL_NAMES
comment|// serial
if|if
condition|(
name|auth_key
operator|->
name|serial
condition|)
name|result
index|[
name|QLatin1String
argument_list|(
literal|"serial"
argument_list|)
index|]
operator|=
operator|(
name|qlonglong
operator|)
name|q_ASN1_INTEGER_get
argument_list|(
name|auth_key
operator|->
name|serial
argument_list|)
expr_stmt|;
name|q_AUTHORITY_KEYID_free
argument_list|(
name|auth_key
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
break|break;
block|}
return|return
name|QVariant
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|convertExtension
name|QSslCertificateExtension
name|QSslCertificatePrivate
operator|::
name|convertExtension
parameter_list|(
name|X509_EXTENSION
modifier|*
name|ext
parameter_list|)
block|{
name|QSslCertificateExtension
name|result
decl_stmt|;
name|ASN1_OBJECT
modifier|*
name|obj
init|=
name|q_X509_EXTENSION_get_object
argument_list|(
name|ext
argument_list|)
decl_stmt|;
name|QByteArray
name|oid
init|=
name|QSslCertificatePrivate
operator|::
name|asn1ObjectId
argument_list|(
name|obj
argument_list|)
decl_stmt|;
name|QByteArray
name|name
init|=
name|QSslCertificatePrivate
operator|::
name|asn1ObjectName
argument_list|(
name|obj
argument_list|)
decl_stmt|;
name|result
operator|.
name|d
operator|->
name|oid
operator|=
name|QString
operator|::
name|fromUtf8
argument_list|(
name|oid
argument_list|)
expr_stmt|;
name|result
operator|.
name|d
operator|->
name|name
operator|=
name|QString
operator|::
name|fromUtf8
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|bool
name|critical
init|=
name|q_X509_EXTENSION_get_critical
argument_list|(
name|ext
argument_list|)
decl_stmt|;
name|result
operator|.
name|d
operator|->
name|critical
operator|=
name|critical
expr_stmt|;
comment|// Lets see if we have custom support for this one
name|QVariant
name|extensionValue
init|=
name|x509ExtensionToValue
argument_list|(
name|ext
argument_list|)
decl_stmt|;
if|if
condition|(
name|extensionValue
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|result
operator|.
name|d
operator|->
name|value
operator|=
name|extensionValue
expr_stmt|;
name|result
operator|.
name|d
operator|->
name|supported
operator|=
literal|true
expr_stmt|;
return|return
name|result
return|;
block|}
name|extensionValue
operator|=
name|x509UnknownExtensionToValue
argument_list|(
name|ext
argument_list|)
expr_stmt|;
if|if
condition|(
name|extensionValue
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|result
operator|.
name|d
operator|->
name|value
operator|=
name|extensionValue
expr_stmt|;
name|result
operator|.
name|d
operator|->
name|supported
operator|=
literal|false
expr_stmt|;
return|return
name|result
return|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a list containing the X509 extensions of this certificate.     \since 5.0  */
end_comment
begin_function
DECL|function|extensions
name|QList
argument_list|<
name|QSslCertificateExtension
argument_list|>
name|QSslCertificate
operator|::
name|extensions
parameter_list|()
specifier|const
block|{
name|QList
argument_list|<
name|QSslCertificateExtension
argument_list|>
name|result
decl_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|x509
condition|)
return|return
name|result
return|;
name|int
name|count
init|=
name|q_X509_get_ext_count
argument_list|(
name|d
operator|->
name|x509
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|X509_EXTENSION
modifier|*
name|ext
init|=
name|q_X509_get_ext
argument_list|(
name|d
operator|->
name|x509
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|result
operator|<<
name|QSslCertificatePrivate
operator|::
name|convertExtension
argument_list|(
name|ext
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!     Returns this certificate converted to a PEM (Base64) encoded     representation. */
end_comment
begin_function
DECL|function|toPem
name|QByteArray
name|QSslCertificate
operator|::
name|toPem
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|x509
condition|)
return|return
name|QByteArray
argument_list|()
return|;
return|return
name|d
operator|->
name|QByteArray_from_X509
argument_list|(
name|d
operator|->
name|x509
argument_list|,
name|QSsl
operator|::
name|Pem
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns this certificate converted to a DER (binary) encoded     representation. */
end_comment
begin_function
DECL|function|toDer
name|QByteArray
name|QSslCertificate
operator|::
name|toDer
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|x509
condition|)
return|return
name|QByteArray
argument_list|()
return|;
return|return
name|d
operator|->
name|QByteArray_from_X509
argument_list|(
name|d
operator|->
name|x509
argument_list|,
name|QSsl
operator|::
name|Der
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns this certificate converted to a human-readable text     representation.      \since 5.0 */
end_comment
begin_function
DECL|function|toText
name|QString
name|QSslCertificate
operator|::
name|toText
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|x509
condition|)
return|return
name|QString
argument_list|()
return|;
return|return
name|d
operator|->
name|text_from_X509
argument_list|(
name|d
operator|->
name|x509
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Searches all files in the \a path for certificates encoded in the     specified \a format and returns them in a list. \e must be a file or a     pattern matching one or more files, as specified by \a syntax.      Example:      \snippet code/src_network_ssl_qsslcertificate.cpp 0      \sa fromData() */
end_comment
begin_function
DECL|function|fromPath
name|QList
argument_list|<
name|QSslCertificate
argument_list|>
name|QSslCertificate
operator|::
name|fromPath
parameter_list|(
specifier|const
name|QString
modifier|&
name|path
parameter_list|,
name|QSsl
operator|::
name|EncodingFormat
name|format
parameter_list|,
name|QRegExp
operator|::
name|PatternSyntax
name|syntax
parameter_list|)
block|{
comment|// $, (,), *, +, ., ?, [, ,], ^, {, | and }.
comment|// make sure to use the same path separators on Windows and Unix like systems.
name|QString
name|sourcePath
init|=
name|QDir
operator|::
name|fromNativeSeparators
argument_list|(
name|path
argument_list|)
decl_stmt|;
comment|// Find the path without the filename
name|QString
name|pathPrefix
init|=
name|sourcePath
operator|.
name|left
argument_list|(
name|sourcePath
operator|.
name|lastIndexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|// Check if the path contains any special chars
name|int
name|pos
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|syntax
operator|==
name|QRegExp
operator|::
name|Wildcard
condition|)
name|pos
operator|=
name|pathPrefix
operator|.
name|indexOf
argument_list|(
name|QRegExp
argument_list|(
name|QLatin1String
argument_list|(
literal|"[*?[]"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|syntax
operator|!=
name|QRegExp
operator|::
name|FixedString
condition|)
name|pos
operator|=
name|sourcePath
operator|.
name|indexOf
argument_list|(
name|QRegExp
argument_list|(
name|QLatin1String
argument_list|(
literal|"[\\$\\(\\)\\*\\+\\.\\?\\[\\]\\^\\{\\}\\|]"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// there was a special char in the path so cut of the part containing that char.
name|pathPrefix
operator|=
name|pathPrefix
operator|.
name|left
argument_list|(
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|pathPrefix
operator|.
name|contains
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
condition|)
name|pathPrefix
operator|=
name|pathPrefix
operator|.
name|left
argument_list|(
name|pathPrefix
operator|.
name|lastIndexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|pathPrefix
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// Check if the path is a file.
if|if
condition|(
name|QFileInfo
argument_list|(
name|sourcePath
argument_list|)
operator|.
name|isFile
argument_list|()
condition|)
block|{
name|QFile
name|file
argument_list|(
name|sourcePath
argument_list|)
decl_stmt|;
if|if
condition|(
name|file
operator|.
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
operator||
name|QIODevice
operator|::
name|Text
argument_list|)
condition|)
return|return
name|QSslCertificate
operator|::
name|fromData
argument_list|(
name|file
operator|.
name|readAll
argument_list|()
argument_list|,
name|format
argument_list|)
return|;
return|return
name|QList
argument_list|<
name|QSslCertificate
argument_list|>
argument_list|()
return|;
block|}
block|}
comment|// Special case - if the prefix ends up being nothing, use "." instead.
name|int
name|startIndex
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|pathPrefix
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|pathPrefix
operator|=
name|QLatin1String
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
name|startIndex
operator|=
literal|2
expr_stmt|;
block|}
comment|// The path can be a file or directory.
name|QList
argument_list|<
name|QSslCertificate
argument_list|>
name|certs
decl_stmt|;
name|QRegExp
name|pattern
argument_list|(
name|sourcePath
argument_list|,
name|Qt
operator|::
name|CaseSensitive
argument_list|,
name|syntax
argument_list|)
decl_stmt|;
name|QDirIterator
name|it
argument_list|(
name|pathPrefix
argument_list|,
name|QDir
operator|::
name|Files
argument_list|,
name|QDirIterator
operator|::
name|FollowSymlinks
operator||
name|QDirIterator
operator|::
name|Subdirectories
argument_list|)
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|QString
name|filePath
init|=
name|startIndex
operator|==
literal|0
condition|?
name|it
operator|.
name|next
argument_list|()
else|:
name|it
operator|.
name|next
argument_list|()
operator|.
name|mid
argument_list|(
name|startIndex
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|pattern
operator|.
name|exactMatch
argument_list|(
name|filePath
argument_list|)
condition|)
continue|continue;
name|QFile
name|file
argument_list|(
name|filePath
argument_list|)
decl_stmt|;
if|if
condition|(
name|file
operator|.
name|open
argument_list|(
name|QIODevice
operator|::
name|ReadOnly
operator||
name|QIODevice
operator|::
name|Text
argument_list|)
condition|)
name|certs
operator|+=
name|QSslCertificate
operator|::
name|fromData
argument_list|(
name|file
operator|.
name|readAll
argument_list|()
argument_list|,
name|format
argument_list|)
expr_stmt|;
block|}
return|return
name|certs
return|;
block|}
end_function
begin_comment
comment|/*!     Searches for and parses all certificates in \a device that are     encoded in the specified \a format and returns them in a list of     certificates.      \sa fromData() */
end_comment
begin_function
DECL|function|fromDevice
name|QList
argument_list|<
name|QSslCertificate
argument_list|>
name|QSslCertificate
operator|::
name|fromDevice
parameter_list|(
name|QIODevice
modifier|*
name|device
parameter_list|,
name|QSsl
operator|::
name|EncodingFormat
name|format
parameter_list|)
block|{
if|if
condition|(
operator|!
name|device
condition|)
block|{
name|qWarning
argument_list|(
literal|"QSslCertificate::fromDevice: cannot read from a null device"
argument_list|)
expr_stmt|;
return|return
name|QList
argument_list|<
name|QSslCertificate
argument_list|>
argument_list|()
return|;
block|}
return|return
name|fromData
argument_list|(
name|device
operator|->
name|readAll
argument_list|()
argument_list|,
name|format
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Searches for and parses all certificates in \a data that are     encoded in the specified \a format and returns them in a list of     certificates.      \sa fromDevice() */
end_comment
begin_function
DECL|function|fromData
name|QList
argument_list|<
name|QSslCertificate
argument_list|>
name|QSslCertificate
operator|::
name|fromData
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|data
parameter_list|,
name|QSsl
operator|::
name|EncodingFormat
name|format
parameter_list|)
block|{
return|return
operator|(
name|format
operator|==
name|QSsl
operator|::
name|Pem
operator|)
condition|?
name|QSslCertificatePrivate
operator|::
name|certificatesFromPem
argument_list|(
name|data
argument_list|)
else|:
name|QSslCertificatePrivate
operator|::
name|certificatesFromDer
argument_list|(
name|data
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Verifies a certificate chain. The chain to be verified is passed in the     \a certificateChain parameter. The first certificate in the list should     be the leaf certificate of the chain to be verified. If \a hostName is     specified then the certificate is also checked to see if it is valid for     the specified host name.      Note that the root (CA) certificate should not be included in the list to be verified,     this will be looked up automatically either using the CA list specified by     QSslSocket::defaultCaCertificates() or, if possible, it will be loaded on demand     on Unix.      \since 5.0  */
end_comment
begin_function
DECL|function|verify
name|QList
argument_list|<
name|QSslError
argument_list|>
name|QSslCertificate
operator|::
name|verify
parameter_list|(
name|QList
argument_list|<
name|QSslCertificate
argument_list|>
name|certificateChain
parameter_list|,
specifier|const
name|QString
modifier|&
name|hostName
parameter_list|)
block|{
return|return
name|QSslSocketBackendPrivate
operator|::
name|verify
argument_list|(
name|certificateChain
argument_list|,
name|hostName
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|init
name|void
name|QSslCertificatePrivate
operator|::
name|init
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|data
parameter_list|,
name|QSsl
operator|::
name|EncodingFormat
name|format
parameter_list|)
block|{
if|if
condition|(
operator|!
name|data
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QList
argument_list|<
name|QSslCertificate
argument_list|>
name|certs
init|=
operator|(
name|format
operator|==
name|QSsl
operator|::
name|Pem
operator|)
condition|?
name|certificatesFromPem
argument_list|(
name|data
argument_list|,
literal|1
argument_list|)
else|:
name|certificatesFromDer
argument_list|(
name|data
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|certs
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
operator|*
name|this
operator|=
operator|*
name|certs
operator|.
name|first
argument_list|()
operator|.
name|d
expr_stmt|;
if|if
condition|(
name|x509
condition|)
name|x509
operator|=
name|q_X509_dup
argument_list|(
name|x509
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function
begin_define
DECL|macro|BEGINCERTSTRING
define|#
directive|define
name|BEGINCERTSTRING
value|"-----BEGIN CERTIFICATE-----"
end_define
begin_define
DECL|macro|ENDCERTSTRING
define|#
directive|define
name|ENDCERTSTRING
value|"-----END CERTIFICATE-----"
end_define
begin_comment
comment|// ### refactor against QSsl::pemFromDer() etc. (to avoid redundant implementations)
end_comment
begin_function
DECL|function|QByteArray_from_X509
name|QByteArray
name|QSslCertificatePrivate
operator|::
name|QByteArray_from_X509
parameter_list|(
name|X509
modifier|*
name|x509
parameter_list|,
name|QSsl
operator|::
name|EncodingFormat
name|format
parameter_list|)
block|{
if|if
condition|(
operator|!
name|x509
condition|)
block|{
name|qWarning
argument_list|(
literal|"QSslSocketBackendPrivate::X509_to_QByteArray: null X509"
argument_list|)
expr_stmt|;
return|return
name|QByteArray
argument_list|()
return|;
block|}
comment|// Use i2d_X509 to convert the X509 to an array.
name|int
name|length
init|=
name|q_i2d_X509
argument_list|(
name|x509
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|QByteArray
name|array
decl_stmt|;
name|array
operator|.
name|resize
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|char
modifier|*
name|data
init|=
name|array
operator|.
name|data
argument_list|()
decl_stmt|;
name|char
modifier|*
modifier|*
name|dataP
init|=
operator|&
name|data
decl_stmt|;
name|unsigned
name|char
modifier|*
modifier|*
name|dataPu
init|=
operator|(
name|unsigned
name|char
operator|*
operator|*
operator|)
name|dataP
decl_stmt|;
if|if
condition|(
name|q_i2d_X509
argument_list|(
name|x509
argument_list|,
name|dataPu
argument_list|)
operator|<
literal|0
condition|)
return|return
name|QByteArray
argument_list|()
return|;
if|if
condition|(
name|format
operator|==
name|QSsl
operator|::
name|Der
condition|)
return|return
name|array
return|;
comment|// Convert to Base64 - wrap at 64 characters.
name|array
operator|=
name|array
operator|.
name|toBase64
argument_list|()
expr_stmt|;
name|QByteArray
name|tmp
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<=
name|array
operator|.
name|size
argument_list|()
operator|-
literal|64
condition|;
name|i
operator|+=
literal|64
control|)
block|{
name|tmp
operator|+=
name|QByteArray
operator|::
name|fromRawData
argument_list|(
name|array
operator|.
name|data
argument_list|()
operator|+
name|i
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|tmp
operator|+=
literal|'\n'
expr_stmt|;
block|}
if|if
condition|(
name|int
name|remainder
init|=
name|array
operator|.
name|size
argument_list|()
operator|%
literal|64
condition|)
block|{
name|tmp
operator|+=
name|QByteArray
operator|::
name|fromRawData
argument_list|(
name|array
operator|.
name|data
argument_list|()
operator|+
name|array
operator|.
name|size
argument_list|()
operator|-
name|remainder
argument_list|,
name|remainder
argument_list|)
expr_stmt|;
name|tmp
operator|+=
literal|'\n'
expr_stmt|;
block|}
return|return
name|BEGINCERTSTRING
literal|"\n"
operator|+
name|tmp
operator|+
name|ENDCERTSTRING
literal|"\n"
return|;
block|}
end_function
begin_function
DECL|function|text_from_X509
name|QString
name|QSslCertificatePrivate
operator|::
name|text_from_X509
parameter_list|(
name|X509
modifier|*
name|x509
parameter_list|)
block|{
if|if
condition|(
operator|!
name|x509
condition|)
block|{
name|qWarning
argument_list|(
literal|"QSslSocketBackendPrivate::text_from_X509: null X509"
argument_list|)
expr_stmt|;
return|return
name|QString
argument_list|()
return|;
block|}
name|QByteArray
name|result
decl_stmt|;
name|BIO
modifier|*
name|bio
init|=
name|q_BIO_new
argument_list|(
name|q_BIO_s_mem
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|bio
condition|)
return|return
name|QString
argument_list|()
return|;
name|q_X509_print
argument_list|(
name|bio
argument_list|,
name|x509
argument_list|)
expr_stmt|;
name|QVarLengthArray
argument_list|<
name|char
argument_list|,
literal|16384
argument_list|>
name|data
decl_stmt|;
name|int
name|count
init|=
name|q_BIO_read
argument_list|(
name|bio
argument_list|,
name|data
operator|.
name|data
argument_list|()
argument_list|,
literal|16384
argument_list|)
decl_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|result
operator|=
name|QByteArray
argument_list|(
name|data
operator|.
name|data
argument_list|()
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
name|q_BIO_free
argument_list|(
name|bio
argument_list|)
expr_stmt|;
return|return
name|QString
operator|::
name|fromLatin1
argument_list|(
name|result
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|asn1ObjectId
name|QByteArray
name|QSslCertificatePrivate
operator|::
name|asn1ObjectId
parameter_list|(
name|ASN1_OBJECT
modifier|*
name|object
parameter_list|)
block|{
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
comment|// The openssl docs a buffer length of 80 should be more than enough
name|q_OBJ_obj2txt
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|object
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|// the 1 says always use the oid not the long name
return|return
name|QByteArray
argument_list|(
name|buf
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|asn1ObjectName
name|QByteArray
name|QSslCertificatePrivate
operator|::
name|asn1ObjectName
parameter_list|(
name|ASN1_OBJECT
modifier|*
name|object
parameter_list|)
block|{
name|int
name|nid
init|=
name|q_OBJ_obj2nid
argument_list|(
name|object
argument_list|)
decl_stmt|;
if|if
condition|(
name|nid
operator|!=
name|NID_undef
condition|)
return|return
name|QByteArray
argument_list|(
name|q_OBJ_nid2sn
argument_list|(
name|nid
argument_list|)
argument_list|)
return|;
return|return
name|asn1ObjectId
argument_list|(
name|object
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|_q_mapFromX509Name
specifier|static
name|QMap
argument_list|<
name|QByteArray
argument_list|,
name|QString
argument_list|>
name|_q_mapFromX509Name
parameter_list|(
name|X509_NAME
modifier|*
name|name
parameter_list|)
block|{
name|QMap
argument_list|<
name|QByteArray
argument_list|,
name|QString
argument_list|>
name|info
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|q_X509_NAME_entry_count
argument_list|(
name|name
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
name|X509_NAME_ENTRY
modifier|*
name|e
init|=
name|q_X509_NAME_get_entry
argument_list|(
name|name
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|QByteArray
name|name
init|=
name|QSslCertificatePrivate
operator|::
name|asn1ObjectName
argument_list|(
name|q_X509_NAME_ENTRY_get_object
argument_list|(
name|e
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|char
modifier|*
name|data
init|=
literal|0
decl_stmt|;
name|int
name|size
init|=
name|q_ASN1_STRING_to_UTF8
argument_list|(
operator|&
name|data
argument_list|,
name|q_X509_NAME_ENTRY_get_data
argument_list|(
name|e
argument_list|)
argument_list|)
decl_stmt|;
name|info
operator|.
name|insertMulti
argument_list|(
name|name
argument_list|,
name|QString
operator|::
name|fromUtf8
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|q_CRYPTO_free
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
return|return
name|info
return|;
block|}
end_function
begin_function
DECL|function|QSslCertificate_from_X509
name|QSslCertificate
name|QSslCertificatePrivate
operator|::
name|QSslCertificate_from_X509
parameter_list|(
name|X509
modifier|*
name|x509
parameter_list|)
block|{
name|QSslCertificate
name|certificate
decl_stmt|;
if|if
condition|(
operator|!
name|x509
operator|||
operator|!
name|QSslSocket
operator|::
name|supportsSsl
argument_list|()
condition|)
return|return
name|certificate
return|;
name|ASN1_TIME
modifier|*
name|nbef
init|=
name|q_X509_get_notBefore
argument_list|(
name|x509
argument_list|)
decl_stmt|;
name|ASN1_TIME
modifier|*
name|naft
init|=
name|q_X509_get_notAfter
argument_list|(
name|x509
argument_list|)
decl_stmt|;
name|certificate
operator|.
name|d
operator|->
name|notValidBefore
operator|=
name|q_getTimeFromASN1
argument_list|(
name|nbef
argument_list|)
expr_stmt|;
name|certificate
operator|.
name|d
operator|->
name|notValidAfter
operator|=
name|q_getTimeFromASN1
argument_list|(
name|naft
argument_list|)
expr_stmt|;
name|certificate
operator|.
name|d
operator|->
name|null
operator|=
literal|false
expr_stmt|;
name|certificate
operator|.
name|d
operator|->
name|x509
operator|=
name|q_X509_dup
argument_list|(
name|x509
argument_list|)
expr_stmt|;
return|return
name|certificate
return|;
block|}
end_function
begin_function
DECL|function|matchLineFeed
specifier|static
name|bool
name|matchLineFeed
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|pem
parameter_list|,
name|int
modifier|*
name|offset
parameter_list|)
block|{
name|char
name|ch
init|=
literal|0
decl_stmt|;
comment|// ignore extra whitespace at the end of the line
while|while
condition|(
operator|*
name|offset
operator|<
name|pem
operator|.
name|size
argument_list|()
operator|&&
operator|(
name|ch
operator|=
name|pem
operator|.
name|at
argument_list|(
operator|*
name|offset
argument_list|)
operator|)
operator|==
literal|' '
condition|)
operator|++
operator|*
name|offset
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'\n'
condition|)
block|{
operator|*
name|offset
operator|+=
literal|1
expr_stmt|;
return|return
literal|true
return|;
block|}
if|if
condition|(
name|ch
operator|==
literal|'\r'
operator|&&
name|pem
operator|.
name|size
argument_list|()
operator|>
operator|(
operator|*
name|offset
operator|+
literal|1
operator|)
operator|&&
name|pem
operator|.
name|at
argument_list|(
operator|*
name|offset
operator|+
literal|1
argument_list|)
operator|==
literal|'\n'
condition|)
block|{
operator|*
name|offset
operator|+=
literal|2
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|certificatesFromPem
name|QList
argument_list|<
name|QSslCertificate
argument_list|>
name|QSslCertificatePrivate
operator|::
name|certificatesFromPem
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|pem
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|QList
argument_list|<
name|QSslCertificate
argument_list|>
name|certificates
decl_stmt|;
name|QSslSocketPrivate
operator|::
name|ensureInitialized
argument_list|()
expr_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|count
operator|==
operator|-
literal|1
operator|||
name|certificates
operator|.
name|size
argument_list|()
operator|<
name|count
condition|)
block|{
name|int
name|startPos
init|=
name|pem
operator|.
name|indexOf
argument_list|(
name|BEGINCERTSTRING
argument_list|,
name|offset
argument_list|)
decl_stmt|;
if|if
condition|(
name|startPos
operator|==
operator|-
literal|1
condition|)
break|break;
name|startPos
operator|+=
sizeof|sizeof
argument_list|(
name|BEGINCERTSTRING
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|matchLineFeed
argument_list|(
name|pem
argument_list|,
operator|&
name|startPos
argument_list|)
condition|)
break|break;
name|int
name|endPos
init|=
name|pem
operator|.
name|indexOf
argument_list|(
name|ENDCERTSTRING
argument_list|,
name|startPos
argument_list|)
decl_stmt|;
if|if
condition|(
name|endPos
operator|==
operator|-
literal|1
condition|)
break|break;
name|offset
operator|=
name|endPos
operator|+
sizeof|sizeof
argument_list|(
name|ENDCERTSTRING
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|offset
operator|<
name|pem
operator|.
name|size
argument_list|()
operator|&&
operator|!
name|matchLineFeed
argument_list|(
name|pem
argument_list|,
operator|&
name|offset
argument_list|)
condition|)
break|break;
name|QByteArray
name|decoded
init|=
name|QByteArray
operator|::
name|fromBase64
argument_list|(
name|QByteArray
operator|::
name|fromRawData
argument_list|(
name|pem
operator|.
name|data
argument_list|()
operator|+
name|startPos
argument_list|,
name|endPos
operator|-
name|startPos
argument_list|)
argument_list|)
decl_stmt|;
if|#
directive|if
name|OPENSSL_VERSION_NUMBER
operator|>=
literal|0x00908000L
specifier|const
name|unsigned
name|char
modifier|*
name|data
init|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|decoded
operator|.
name|data
argument_list|()
decl_stmt|;
else|#
directive|else
name|unsigned
name|char
modifier|*
name|data
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|decoded
operator|.
name|data
argument_list|()
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|X509
modifier|*
name|x509
init|=
name|q_d2i_X509
argument_list|(
literal|0
argument_list|,
operator|&
name|data
argument_list|,
name|decoded
operator|.
name|size
argument_list|()
argument_list|)
condition|)
block|{
name|certificates
operator|<<
name|QSslCertificate_from_X509
argument_list|(
name|x509
argument_list|)
expr_stmt|;
name|q_X509_free
argument_list|(
name|x509
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|certificates
return|;
block|}
end_function
begin_function
DECL|function|certificatesFromDer
name|QList
argument_list|<
name|QSslCertificate
argument_list|>
name|QSslCertificatePrivate
operator|::
name|certificatesFromDer
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|der
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|QList
argument_list|<
name|QSslCertificate
argument_list|>
name|certificates
decl_stmt|;
name|QSslSocketPrivate
operator|::
name|ensureInitialized
argument_list|()
expr_stmt|;
if|#
directive|if
name|OPENSSL_VERSION_NUMBER
operator|>=
literal|0x00908000L
specifier|const
name|unsigned
name|char
modifier|*
name|data
init|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|der
operator|.
name|data
argument_list|()
decl_stmt|;
else|#
directive|else
name|unsigned
name|char
modifier|*
name|data
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|der
operator|.
name|data
argument_list|()
decl_stmt|;
endif|#
directive|endif
name|int
name|size
init|=
name|der
operator|.
name|size
argument_list|()
decl_stmt|;
while|while
condition|(
name|count
operator|==
operator|-
literal|1
operator|||
name|certificates
operator|.
name|size
argument_list|()
operator|<
name|count
condition|)
block|{
if|if
condition|(
name|X509
modifier|*
name|x509
init|=
name|q_d2i_X509
argument_list|(
literal|0
argument_list|,
operator|&
name|data
argument_list|,
name|size
argument_list|)
condition|)
block|{
name|certificates
operator|<<
name|QSslCertificate_from_X509
argument_list|(
name|x509
argument_list|)
expr_stmt|;
name|q_X509_free
argument_list|(
name|x509
argument_list|)
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
name|size
operator|-=
operator|(
operator|(
name|char
operator|*
operator|)
name|data
operator|-
name|der
operator|.
name|data
argument_list|()
operator|)
expr_stmt|;
block|}
return|return
name|certificates
return|;
block|}
end_function
begin_comment
comment|// These certificates are known to be fraudulent and were created during the comodo
end_comment
begin_comment
comment|// compromise. See http://www.comodo.com/Comodo-Fraud-Incident-2011-03-23.html
end_comment
begin_decl_stmt
DECL|variable|certificate_blacklist
specifier|static
specifier|const
name|char
modifier|*
name|certificate_blacklist
index|[]
init|=
block|{
literal|"04:7e:cb:e9:fc:a5:5f:7b:d0:9e:ae:36:e1:0c:ae:1e"
block|,
literal|"mail.google.com"
block|,
comment|// Comodo
literal|"f5:c8:6a:f3:61:62:f1:3a:64:f5:4f:6d:c9:58:7c:06"
block|,
literal|"www.google.com"
block|,
comment|// Comodo
literal|"d7:55:8f:da:f5:f1:10:5b:b2:13:28:2b:70:77:29:a3"
block|,
literal|"login.yahoo.com"
block|,
comment|// Comodo
literal|"39:2a:43:4f:0e:07:df:1f:8a:a3:05:de:34:e0:c2:29"
block|,
literal|"login.yahoo.com"
block|,
comment|// Comodo
literal|"3e:75:ce:d4:6b:69:30:21:21:88:30:ae:86:a8:2a:71"
block|,
literal|"login.yahoo.com"
block|,
comment|// Comodo
literal|"e9:02:8b:95:78:e4:15:dc:1a:71:0a:2b:88:15:44:47"
block|,
literal|"login.skype.com"
block|,
comment|// Comodo
literal|"92:39:d5:34:8f:40:d1:69:5a:74:54:70:e1:f2:3f:43"
block|,
literal|"addons.mozilla.org"
block|,
comment|// Comodo
literal|"b0:b7:13:3e:d0:96:f9:b5:6f:ae:91:c8:74:bd:3a:c0"
block|,
literal|"login.live.com"
block|,
comment|// Comodo
literal|"d8:f3:5f:4e:b7:87:2b:2d:ab:06:92:e3:15:38:2f:b0"
block|,
literal|"global trustee"
block|,
comment|// Comodo
literal|"05:e2:e6:a4:cd:09:ea:54:d6:65:b0:75:fe:22:a2:56"
block|,
literal|"*.google.com"
block|,
comment|// leaf certificate issued by DigiNotar
literal|"0c:76:da:9c:91:0c:4e:2c:9e:fe:15:d0:58:93:3c:4c"
block|,
literal|"DigiNotar Root CA"
block|,
comment|// DigiNotar root
literal|"f1:4a:13:f4:87:2b:56:dc:39:df:84:ca:7a:a1:06:49"
block|,
literal|"DigiNotar Services CA"
block|,
comment|// DigiNotar intermediate signed by DigiNotar Root
literal|"36:16:71:55:43:42:1b:9d:e6:cb:a3:64:41:df:24:38"
block|,
literal|"DigiNotar Services 1024 CA"
block|,
comment|// DigiNotar intermediate signed by DigiNotar Root
literal|"0a:82:bd:1e:14:4e:88:14:d7:5b:1a:55:27:be:bf:3e"
block|,
literal|"DigiNotar Root CA G2"
block|,
comment|// other DigiNotar Root CA
literal|"a4:b6:ce:e3:2e:d3:35:46:26:3c:b3:55:3a:a8:92:21"
block|,
literal|"CertiID Enterprise Certificate Authority"
block|,
comment|// DigiNotar intermediate signed by "DigiNotar Root CA G2"
literal|"5b:d5:60:9c:64:17:68:cf:21:0e:35:fd:fb:05:ad:41"
block|,
literal|"DigiNotar Qualified CA"
block|,
comment|// DigiNotar intermediate signed by DigiNotar Root
literal|"46:9c:2c:b0"
block|,
literal|"DigiNotar Services 1024 CA"
block|,
comment|// DigiNotar intermediate cross-signed by Entrust
literal|"07:27:10:0d"
block|,
literal|"DigiNotar Cyber CA"
block|,
comment|// DigiNotar intermediate cross-signed by CyberTrust
literal|"07:27:0f:f9"
block|,
literal|"DigiNotar Cyber CA"
block|,
comment|// DigiNotar intermediate cross-signed by CyberTrust
literal|"07:27:10:03"
block|,
literal|"DigiNotar Cyber CA"
block|,
comment|// DigiNotar intermediate cross-signed by CyberTrust
literal|"01:31:69:b0"
block|,
literal|"DigiNotar PKIoverheid CA Overheid en Bedrijven"
block|,
comment|// DigiNotar intermediate cross-signed by the Dutch government
literal|"01:31:34:bf"
block|,
literal|"DigiNotar PKIoverheid CA Organisatie - G2"
block|,
comment|// DigiNotar intermediate cross-signed by the Dutch government
literal|"d6:d0:29:77:f1:49:fd:1a:83:f2:b9:ea:94:8c:5c:b4"
block|,
literal|"DigiNotar Extended Validation CA"
block|,
comment|// DigiNotar intermediate signed by DigiNotar EV Root
literal|"1e:7d:7a:53:3d:45:30:41:96:40:0f:71:48:1f:45:04"
block|,
literal|"DigiNotar Public CA 2025"
block|,
comment|// DigiNotar intermediate
comment|//    "(has not been seen in the wild so far)", "DigiNotar Public CA - G2", // DigiNotar intermediate
comment|//    "(has not been seen in the wild so far)", "Koninklijke Notariele Beroepsorganisatie CA", // compromised during DigiNotar breach
comment|//    "(has not been seen in the wild so far)", "Stichting TTP Infos CA," // compromised during DigiNotar breach
literal|"46:9c:2c:af"
block|,
literal|"DigiNotar Root CA"
block|,
comment|// DigiNotar intermediate cross-signed by Entrust
literal|"46:9c:3c:c9"
block|,
literal|"DigiNotar Root CA"
block|,
comment|// DigiNotar intermediate cross-signed by Entrust
literal|"07:27:14:a9"
block|,
literal|"Digisign Server ID (Enrich)"
block|,
comment|// (Malaysian) Digicert Sdn. Bhd. cross-signed by Verizon CyberTrust
literal|"4c:0e:63:6a"
block|,
literal|"Digisign Server ID - (Enrich)"
block|,
comment|// (Malaysian) Digicert Sdn. Bhd. cross-signed by Entrust
literal|"72:03:21:05:c5:0c:08:57:3d:8e:a5:30:4e:fe:e8:b0"
block|,
literal|"UTN-USERFirst-Hardware"
block|,
comment|// comodogate test certificate
literal|"41"
block|,
literal|"MD5 Collisions Inc. (http://www.phreedom.org/md5)"
block|,
comment|// http://www.phreedom.org/research/rogue-ca/
literal|0
block|}
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|isBlacklisted
name|bool
name|QSslCertificatePrivate
operator|::
name|isBlacklisted
parameter_list|(
specifier|const
name|QSslCertificate
modifier|&
name|certificate
parameter_list|)
block|{
for|for
control|(
name|int
name|a
init|=
literal|0
init|;
name|certificate_blacklist
index|[
name|a
index|]
operator|!=
literal|0
condition|;
name|a
operator|++
control|)
block|{
name|QString
name|blacklistedCommonName
init|=
name|QString
operator|::
name|fromUtf8
argument_list|(
name|certificate_blacklist
index|[
operator|(
name|a
operator|+
literal|1
operator|)
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|certificate
operator|.
name|serialNumber
argument_list|()
operator|==
name|certificate_blacklist
index|[
name|a
operator|++
index|]
operator|&&
operator|(
name|certificate
operator|.
name|subjectInfo
argument_list|(
name|QSslCertificate
operator|::
name|CommonName
argument_list|)
operator|.
name|contains
argument_list|(
name|blacklistedCommonName
argument_list|)
operator|||
name|certificate
operator|.
name|issuerInfo
argument_list|(
name|QSslCertificate
operator|::
name|CommonName
argument_list|)
operator|.
name|contains
argument_list|(
name|blacklistedCommonName
argument_list|)
operator|)
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DEBUG_STREAM
end_ifndef
begin_function
DECL|function|operator <<
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|debug
parameter_list|,
specifier|const
name|QSslCertificate
modifier|&
name|certificate
parameter_list|)
block|{
name|debug
operator|<<
literal|"QSslCertificate("
operator|<<
name|certificate
operator|.
name|version
argument_list|()
operator|<<
literal|','
operator|<<
name|certificate
operator|.
name|serialNumber
argument_list|()
operator|<<
literal|','
operator|<<
name|certificate
operator|.
name|digest
argument_list|()
operator|.
name|toBase64
argument_list|()
operator|<<
literal|','
operator|<<
name|certificate
operator|.
name|issuerInfo
argument_list|(
name|QSslCertificate
operator|::
name|Organization
argument_list|)
operator|<<
literal|','
operator|<<
name|certificate
operator|.
name|subjectInfo
argument_list|(
name|QSslCertificate
operator|::
name|Organization
argument_list|)
operator|<<
literal|','
operator|<<
name|certificate
operator|.
name|subjectAlternativeNames
argument_list|()
ifndef|#
directive|ifndef
name|QT_NO_DATESTRING
operator|<<
literal|','
operator|<<
name|certificate
operator|.
name|effectiveDate
argument_list|()
operator|<<
literal|','
operator|<<
name|certificate
operator|.
name|expiryDate
argument_list|()
endif|#
directive|endif
operator|<<
literal|')'
expr_stmt|;
return|return
name|debug
return|;
block|}
end_function
begin_function
DECL|function|operator <<
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|debug
parameter_list|,
name|QSslCertificate
operator|::
name|SubjectInfo
name|info
parameter_list|)
block|{
switch|switch
condition|(
name|info
condition|)
block|{
case|case
name|QSslCertificate
operator|::
name|Organization
case|:
name|debug
operator|<<
literal|"Organization"
expr_stmt|;
break|break;
case|case
name|QSslCertificate
operator|::
name|CommonName
case|:
name|debug
operator|<<
literal|"CommonName"
expr_stmt|;
break|break;
case|case
name|QSslCertificate
operator|::
name|CountryName
case|:
name|debug
operator|<<
literal|"CountryName"
expr_stmt|;
break|break;
case|case
name|QSslCertificate
operator|::
name|LocalityName
case|:
name|debug
operator|<<
literal|"LocalityName"
expr_stmt|;
break|break;
case|case
name|QSslCertificate
operator|::
name|OrganizationalUnitName
case|:
name|debug
operator|<<
literal|"OrganizationalUnitName"
expr_stmt|;
break|break;
case|case
name|QSslCertificate
operator|::
name|StateOrProvinceName
case|:
name|debug
operator|<<
literal|"StateOrProvinceName"
expr_stmt|;
break|break;
case|case
name|QSslCertificate
operator|::
name|DistinguishedNameQualifier
case|:
name|debug
operator|<<
literal|"DistinguishedNameQualifier"
expr_stmt|;
break|break;
case|case
name|QSslCertificate
operator|::
name|SerialNumber
case|:
name|debug
operator|<<
literal|"SerialNumber"
expr_stmt|;
break|break;
case|case
name|QSslCertificate
operator|::
name|EmailAddress
case|:
name|debug
operator|<<
literal|"EmailAddress"
expr_stmt|;
break|break;
block|}
return|return
name|debug
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
