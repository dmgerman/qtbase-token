begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2014 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtNetwork module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_comment
comment|/*!     \class QSslCertificate     \brief The QSslCertificate class provides a convenient API for an X509 certificate.     \since 4.3      \reentrant     \ingroup network     \ingroup ssl     \ingroup shared     \inmodule QtNetwork      QSslCertificate stores an X509 certificate, and is commonly used     to verify the identity and store information about the local host,     a remotely connected peer, or a trusted third party Certificate     Authority.      There are many ways to construct a QSslCertificate. The most     common way is to call QSslSocket::peerCertificate(), which returns     a QSslCertificate object, or QSslSocket::peerCertificateChain(),     which returns a list of them. You can also load certificates from     a DER (binary) or PEM (Base64) encoded bundle, typically stored as     one or more local files, or in a Qt Resource.      You can call isNull() to check if your certificate is null. By default,     QSslCertificate constructs a null certificate. A null certificate is     invalid, but an invalid certificate is not necessarily null. If you want     to reset all contents in a certificate, call clear().      After loading a certificate, you can find information about the     certificate, its subject, and its issuer, by calling one of the     many accessor functions, including version(), serialNumber(),     issuerInfo() and subjectInfo(). You can call effectiveDate() and     expiryDate() to check when the certificate starts being     effective and when it expires.     The publicKey() function returns the certificate     subject's public key as a QSslKey. You can call issuerInfo() or     subjectInfo() to get detailed information about the certificate     issuer and its subject.      Internally, QSslCertificate is stored as an X509 structure. You     can access this handle by calling handle(), but the results are     likely to not be portable.      \sa QSslSocket, QSslKey, QSslCipher, QSslError */
end_comment
begin_comment
comment|/*!     \enum QSslCertificate::SubjectInfo      Describes keys that you can pass to QSslCertificate::issuerInfo() or     QSslCertificate::subjectInfo() to get information about the certificate     issuer or subject.      \value Organization "O" The name of the organization.      \value CommonName "CN" The common name; most often this is used to store     the host name.      \value LocalityName "L" The locality.      \value OrganizationalUnitName "OU" The organizational unit name.      \value CountryName "C" The country.      \value StateOrProvinceName "ST" The state or province.      \value DistinguishedNameQualifier The distinguished name qualifier      \value SerialNumber The certificate's serial number      \value EmailAddress The email address associated with the certificate */
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_OPENSSL
end_ifndef
begin_include
include|#
directive|include
file|"qsslsocket_openssl_symbols_p.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_WINRT
end_ifdef
begin_include
include|#
directive|include
file|"qsslsocket_winrt_p.h"
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|"qsslcertificate.h"
end_include
begin_include
include|#
directive|include
file|"qsslcertificate_p.h"
end_include
begin_include
include|#
directive|include
file|"qasn1element_p.h"
end_include
begin_include
include|#
directive|include
file|"qsslkey_p.h"
end_include
begin_include
include|#
directive|include
file|<QtCore/qdir.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qdiriterator.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qfile.h>
end_include
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_comment
comment|/*!     Constructs a QSslCertificate by reading \a format encoded data     from \a device and using the first certificate found. You can     later call isNull() to see if \a device contained a certificate,     and if this certificate was loaded successfully. */
end_comment
begin_constructor
DECL|function|QSslCertificate
name|QSslCertificate
operator|::
name|QSslCertificate
parameter_list|(
name|QIODevice
modifier|*
name|device
parameter_list|,
name|QSsl
operator|::
name|EncodingFormat
name|format
parameter_list|)
member_init_list|:
name|d
argument_list|(
operator|new
name|QSslCertificatePrivate
argument_list|)
block|{
name|QSslSocketPrivate
operator|::
name|ensureInitialized
argument_list|()
expr_stmt|;
if|if
condition|(
name|device
condition|)
name|d
operator|->
name|init
argument_list|(
name|device
operator|->
name|readAll
argument_list|()
argument_list|,
name|format
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a QSslCertificate by parsing the \a format encoded     \a data and using the first available certificate found. You can     later call isNull() to see if \a data contained a certificate,     and if this certificate was loaded successfully. */
end_comment
begin_constructor
DECL|function|QSslCertificate
name|QSslCertificate
operator|::
name|QSslCertificate
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|data
parameter_list|,
name|QSsl
operator|::
name|EncodingFormat
name|format
parameter_list|)
member_init_list|:
name|d
argument_list|(
operator|new
name|QSslCertificatePrivate
argument_list|)
block|{
name|QSslSocketPrivate
operator|::
name|ensureInitialized
argument_list|()
expr_stmt|;
name|d
operator|->
name|init
argument_list|(
name|data
argument_list|,
name|format
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs an identical copy of \a other. */
end_comment
begin_constructor
DECL|function|QSslCertificate
name|QSslCertificate
operator|::
name|QSslCertificate
parameter_list|(
specifier|const
name|QSslCertificate
modifier|&
name|other
parameter_list|)
member_init_list|:
name|d
argument_list|(
name|other
operator|.
name|d
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Destroys the QSslCertificate. */
end_comment
begin_destructor
DECL|function|~QSslCertificate
name|QSslCertificate
operator|::
name|~
name|QSslCertificate
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     Copies the contents of \a other into this certificate, making the two     certificates identical. */
end_comment
begin_function
DECL|function|operator =
name|QSslCertificate
modifier|&
name|QSslCertificate
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QSslCertificate
modifier|&
name|other
parameter_list|)
block|{
name|d
operator|=
name|other
operator|.
name|d
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QSslCertificate::swap(QSslCertificate&other)     \since 5.0      Swaps this certificate instance with \a other. This function is     very fast and never fails. */
end_comment
begin_comment
comment|/*!     \fn bool QSslCertificate::operator==(const QSslCertificate&other) const      Returns \c true if this certificate is the same as \a other; otherwise     returns \c false. */
end_comment
begin_comment
comment|/*!     \fn bool QSslCertificate::operator!=(const QSslCertificate&other) const      Returns \c true if this certificate is not the same as \a other; otherwise     returns \c false. */
end_comment
begin_comment
comment|/*!     \fn bool QSslCertificate::isNull() const      Returns \c true if this is a null certificate (i.e., a certificate     with no contents); otherwise returns \c false.      By default, QSslCertificate constructs a null certificate.      \sa clear() */
end_comment
begin_if
if|#
directive|if
name|QT_DEPRECATED_SINCE
argument_list|(
literal|5
operator|,
literal|0
argument_list|)
end_if
begin_comment
comment|/*!     \fn bool QSslCertificate::isValid() const     \obsolete      To verify a certificate, use verify().     To check if a certificate is blacklisted, use isBlacklisted().     To check if a certificate has expired or is not yet valid, compare     expiryDate() and effectiveDate() with QDateTime::currentDateTime()      This function checks that the current     date-time is within the date-time range during which the     certificate is considered valid, and checks that the     certificate is not in a blacklist of fraudulent certificates.      \sa isNull(), verify(), isBlacklisted(), expiryDate(), effectiveDate() */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     Returns \c true if this certificate is blacklisted; otherwise     returns \c false.      \sa isNull() */
end_comment
begin_function
DECL|function|isBlacklisted
name|bool
name|QSslCertificate
operator|::
name|isBlacklisted
parameter_list|()
specifier|const
block|{
return|return
name|QSslCertificatePrivate
operator|::
name|isBlacklisted
argument_list|(
operator|*
name|this
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QSslCertificate::isSelfSigned() const     \since 5.4      Returns \c true if this certificate is self signed; otherwise     returns \c false.      A certificate is considered self-signed its issuer and subject     are identical. */
end_comment
begin_comment
comment|/*!     Clears the contents of this certificate, making it a null     certificate.      \sa isNull() */
end_comment
begin_function
DECL|function|clear
name|void
name|QSslCertificate
operator|::
name|clear
parameter_list|()
block|{
if|if
condition|(
name|isNull
argument_list|()
condition|)
return|return;
name|d
operator|=
operator|new
name|QSslCertificatePrivate
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn QByteArray QSslCertificate::version() const     Returns the certificate's version string. */
end_comment
begin_comment
comment|/*!     \fn QByteArray QSslCertificate::serialNumber() const      Returns the certificate's serial number string in hexadecimal format. */
end_comment
begin_comment
comment|/*!     Returns a cryptographic digest of this certificate. By default,     an MD5 digest will be generated, but you can also specify a     custom \a algorithm. */
end_comment
begin_function
DECL|function|digest
name|QByteArray
name|QSslCertificate
operator|::
name|digest
parameter_list|(
name|QCryptographicHash
operator|::
name|Algorithm
name|algorithm
parameter_list|)
specifier|const
block|{
return|return
name|QCryptographicHash
operator|::
name|hash
argument_list|(
name|toDer
argument_list|()
argument_list|,
name|algorithm
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   \fn QString QSslCertificate::issuerInfo(SubjectInfo subject) const    Returns the issuer information for the \a subject from the   certificate, or an empty list if there is no information for   \a subject in the certificate. There can be more than one entry   of each type.    \sa subjectInfo() */
end_comment
begin_comment
comment|/*!   \fn QStringList QSslCertificate::issuerInfo(const QByteArray&attribute) const    Returns the issuer information for \a attribute from the certificate,   or an empty list if there is no information for \a attribute in the   certificate. There can be more than one entry for an attribute.    \sa subjectInfo() */
end_comment
begin_comment
comment|/*!   \fn QString QSslCertificate::subjectInfo(SubjectInfo subject) const    Returns the information for the \a subject, or an empty list if   there is no information for \a subject in the certificate. There   can be more than one entry of each type.      \sa issuerInfo() */
end_comment
begin_comment
comment|/*!     \fn QStringList QSslCertificate::subjectInfo(const QByteArray&attribute) const      Returns the subject information for \a attribute, or an empty list if     there is no information for \a attribute in the certificate. There     can be more than one entry for an attribute.      \sa issuerInfo() */
end_comment
begin_comment
comment|/*!     \fn QList<QByteArray> QSslCertificate::subjectInfoAttributes() const      \since 5.0     Returns a list of the attributes that have values in the subject     information of this certificate. The information associated     with a given attribute can be accessed using the subjectInfo()     method. Note that this list may include the OIDs for any     elements that are not known by the SSL backend.      \sa subjectInfo() */
end_comment
begin_comment
comment|/*!     \fn QList<QByteArray> QSslCertificate::issuerInfoAttributes() const      \since 5.0     Returns a list of the attributes that have values in the issuer     information of this certificate. The information associated     with a given attribute can be accessed using the issuerInfo()     method. Note that this list may include the OIDs for any     elements that are not known by the SSL backend.      \sa subjectInfo() */
end_comment
begin_if
if|#
directive|if
name|QT_DEPRECATED_SINCE
argument_list|(
literal|5
operator|,
literal|0
argument_list|)
end_if
begin_comment
comment|/*!   \fn QMultiMap<QSsl::AlternateNameEntryType, QString> QSslCertificate::alternateSubjectNames() const   \obsolete    Use QSslCertificate::subjectAlternativeNames(); */
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!   \fn QMultiMap<QSsl::AlternativeNameEntryType, QString> QSslCertificate::subjectAlternativeNames() const    Returns the list of alternative subject names for this   certificate. The alternative names typically contain host   names, optionally with wildcards, that are valid for this   certificate.    These names are tested against the connected peer's host name, if   either the subject information for \l CommonName doesn't define a   valid host name, or the subject info name doesn't match the peer's   host name.    \sa subjectInfo() */
end_comment
begin_comment
comment|/*!   \fn QDateTime QSslCertificate::effectiveDate() const    Returns the date-time that the certificate becomes valid, or an   empty QDateTime if this is a null certificate.    \sa expiryDate() */
end_comment
begin_comment
comment|/*!   \fn QDateTime QSslCertificate::expiryDate() const    Returns the date-time that the certificate expires, or an empty   QDateTime if this is a null certificate.      \sa effectiveDate() */
end_comment
begin_comment
comment|/*!     \fn Qt::HANDLE QSslCertificate::handle() const     Returns a pointer to the native certificate handle, if there is     one, or a null pointer otherwise.      You can use this handle, together with the native API, to access     extended information about the certificate.      \warning Use of this function has a high probability of being     non-portable, and its return value may vary from platform to     platform or change from minor release to minor release. */
end_comment
begin_comment
comment|/*!     \fn QSslKey QSslCertificate::publicKey() const     Returns the certificate subject's public key. */
end_comment
begin_comment
comment|/*!     \fn QList<QSslCertificateExtension> QSslCertificate::extensions() const      Returns a list containing the X509 extensions of this certificate.     \since 5.0  */
end_comment
begin_comment
comment|/*!     \fn QByteArray QSslCertificate::toPem() const      Returns this certificate converted to a PEM (Base64) encoded     representation. */
end_comment
begin_comment
comment|/*!     \fn QByteArray QSslCertificate::toDer() const      Returns this certificate converted to a DER (binary) encoded     representation. */
end_comment
begin_comment
comment|/*!     \fn QString QSslCertificate::toText() const      Returns this certificate converted to a human-readable text     representation.      \since 5.0 */
end_comment
begin_comment
comment|/*!     Searches all files in the \a path for certificates encoded in the     specified \a format and returns them in a list. \e must be a file or a     pattern matching one or more files, as specified by \a syntax.      Example:      \snippet code/src_network_ssl_qsslcertificate.cpp 0      \sa fromData() */
end_comment
begin_function
DECL|function|fromPath
name|QList
argument_list|<
name|QSslCertificate
argument_list|>
name|QSslCertificate
operator|::
name|fromPath
parameter_list|(
specifier|const
name|QString
modifier|&
name|path
parameter_list|,
name|QSsl
operator|::
name|EncodingFormat
name|format
parameter_list|,
name|QRegExp
operator|::
name|PatternSyntax
name|syntax
parameter_list|)
block|{
comment|// $, (,), *, +, ., ?, [, ,], ^, {, | and }.
comment|// make sure to use the same path separators on Windows and Unix like systems.
name|QString
name|sourcePath
init|=
name|QDir
operator|::
name|fromNativeSeparators
argument_list|(
name|path
argument_list|)
decl_stmt|;
comment|// Find the path without the filename
name|QString
name|pathPrefix
init|=
name|sourcePath
operator|.
name|left
argument_list|(
name|sourcePath
operator|.
name|lastIndexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
comment|// Check if the path contains any special chars
name|int
name|pos
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|syntax
operator|==
name|QRegExp
operator|::
name|Wildcard
condition|)
name|pos
operator|=
name|pathPrefix
operator|.
name|indexOf
argument_list|(
name|QRegExp
argument_list|(
name|QLatin1String
argument_list|(
literal|"[*?[]"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|syntax
operator|!=
name|QRegExp
operator|::
name|FixedString
condition|)
name|pos
operator|=
name|sourcePath
operator|.
name|indexOf
argument_list|(
name|QRegExp
argument_list|(
name|QLatin1String
argument_list|(
literal|"[\\$\\(\\)\\*\\+\\.\\?\\[\\]\\^\\{\\}\\|]"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// there was a special char in the path so cut of the part containing that char.
name|pathPrefix
operator|=
name|pathPrefix
operator|.
name|left
argument_list|(
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|pathPrefix
operator|.
name|contains
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
condition|)
name|pathPrefix
operator|=
name|pathPrefix
operator|.
name|left
argument_list|(
name|pathPrefix
operator|.
name|lastIndexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|pathPrefix
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// Check if the path is a file.
if|if
condition|(
name|QFileInfo
argument_list|(
name|sourcePath
argument_list|)
operator|.
name|isFile
argument_list|()
condition|)
block|{
name|QFile
name|file
argument_list|(
name|sourcePath
argument_list|)
decl_stmt|;
name|QIODevice
operator|::
name|OpenMode
name|openMode
init|=
name|QIODevice
operator|::
name|ReadOnly
decl_stmt|;
if|if
condition|(
name|format
operator|==
name|QSsl
operator|::
name|Pem
condition|)
name|openMode
operator||=
name|QIODevice
operator|::
name|Text
expr_stmt|;
if|if
condition|(
name|file
operator|.
name|open
argument_list|(
name|openMode
argument_list|)
condition|)
return|return
name|QSslCertificate
operator|::
name|fromData
argument_list|(
name|file
operator|.
name|readAll
argument_list|()
argument_list|,
name|format
argument_list|)
return|;
return|return
name|QList
argument_list|<
name|QSslCertificate
argument_list|>
argument_list|()
return|;
block|}
block|}
comment|// Special case - if the prefix ends up being nothing, use "." instead.
name|int
name|startIndex
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|pathPrefix
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|pathPrefix
operator|=
name|QLatin1String
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
name|startIndex
operator|=
literal|2
expr_stmt|;
block|}
comment|// The path can be a file or directory.
name|QList
argument_list|<
name|QSslCertificate
argument_list|>
name|certs
decl_stmt|;
name|QRegExp
name|pattern
argument_list|(
name|sourcePath
argument_list|,
name|Qt
operator|::
name|CaseSensitive
argument_list|,
name|syntax
argument_list|)
decl_stmt|;
name|QDirIterator
name|it
argument_list|(
name|pathPrefix
argument_list|,
name|QDir
operator|::
name|Files
argument_list|,
name|QDirIterator
operator|::
name|FollowSymlinks
operator||
name|QDirIterator
operator|::
name|Subdirectories
argument_list|)
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|QString
name|filePath
init|=
name|startIndex
operator|==
literal|0
condition|?
name|it
operator|.
name|next
argument_list|()
else|:
name|it
operator|.
name|next
argument_list|()
operator|.
name|mid
argument_list|(
name|startIndex
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|pattern
operator|.
name|exactMatch
argument_list|(
name|filePath
argument_list|)
condition|)
continue|continue;
name|QFile
name|file
argument_list|(
name|filePath
argument_list|)
decl_stmt|;
name|QIODevice
operator|::
name|OpenMode
name|openMode
init|=
name|QIODevice
operator|::
name|ReadOnly
decl_stmt|;
if|if
condition|(
name|format
operator|==
name|QSsl
operator|::
name|Pem
condition|)
name|openMode
operator||=
name|QIODevice
operator|::
name|Text
expr_stmt|;
if|if
condition|(
name|file
operator|.
name|open
argument_list|(
name|openMode
argument_list|)
condition|)
name|certs
operator|+=
name|QSslCertificate
operator|::
name|fromData
argument_list|(
name|file
operator|.
name|readAll
argument_list|()
argument_list|,
name|format
argument_list|)
expr_stmt|;
block|}
return|return
name|certs
return|;
block|}
end_function
begin_comment
comment|/*!     Searches for and parses all certificates in \a device that are     encoded in the specified \a format and returns them in a list of     certificates.      \sa fromData() */
end_comment
begin_function
DECL|function|fromDevice
name|QList
argument_list|<
name|QSslCertificate
argument_list|>
name|QSslCertificate
operator|::
name|fromDevice
parameter_list|(
name|QIODevice
modifier|*
name|device
parameter_list|,
name|QSsl
operator|::
name|EncodingFormat
name|format
parameter_list|)
block|{
if|if
condition|(
operator|!
name|device
condition|)
block|{
name|qWarning
argument_list|(
literal|"QSslCertificate::fromDevice: cannot read from a null device"
argument_list|)
expr_stmt|;
return|return
name|QList
argument_list|<
name|QSslCertificate
argument_list|>
argument_list|()
return|;
block|}
return|return
name|fromData
argument_list|(
name|device
operator|->
name|readAll
argument_list|()
argument_list|,
name|format
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Searches for and parses all certificates in \a data that are     encoded in the specified \a format and returns them in a list of     certificates.      \sa fromDevice() */
end_comment
begin_function
DECL|function|fromData
name|QList
argument_list|<
name|QSslCertificate
argument_list|>
name|QSslCertificate
operator|::
name|fromData
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|data
parameter_list|,
name|QSsl
operator|::
name|EncodingFormat
name|format
parameter_list|)
block|{
return|return
operator|(
name|format
operator|==
name|QSsl
operator|::
name|Pem
operator|)
condition|?
name|QSslCertificatePrivate
operator|::
name|certificatesFromPem
argument_list|(
name|data
argument_list|)
else|:
name|QSslCertificatePrivate
operator|::
name|certificatesFromDer
argument_list|(
name|data
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Verifies a certificate chain. The chain to be verified is passed in the     \a certificateChain parameter. The first certificate in the list should     be the leaf certificate of the chain to be verified. If \a hostName is     specified then the certificate is also checked to see if it is valid for     the specified host name.      Note that the root (CA) certificate should not be included in the list to be verified,     this will be looked up automatically either using the CA list specified by     QSslSocket::defaultCaCertificates() or, if possible, it will be loaded on demand     on Unix.      \since 5.0  */
end_comment
begin_function
DECL|function|verify
name|QList
argument_list|<
name|QSslError
argument_list|>
name|QSslCertificate
operator|::
name|verify
parameter_list|(
name|QList
argument_list|<
name|QSslCertificate
argument_list|>
name|certificateChain
parameter_list|,
specifier|const
name|QString
modifier|&
name|hostName
parameter_list|)
block|{
return|return
name|QSslSocketBackendPrivate
operator|::
name|verify
argument_list|(
name|certificateChain
argument_list|,
name|hostName
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!   \since 5.4    Imports a PKCS#12 (pfx) file from the specified \a device. A PKCS#12   file is a bundle that can contain a number of certificates and keys.   This method reads a single \a key, its \a certificate and any   associated \a caCertificates from the bundle. If a \a passPhrase is   specified then this will be used to decrypt the bundle. Returns   \c true if the PKCS#12 file was successfully loaded.    \note The \a device must be open and ready to be read from.  */
end_comment
begin_function
DECL|function|importPKCS12
name|bool
name|QSslCertificate
operator|::
name|importPKCS12
parameter_list|(
name|QIODevice
modifier|*
name|device
parameter_list|,
name|QSslKey
modifier|*
name|key
parameter_list|,
name|QSslCertificate
modifier|*
name|certificate
parameter_list|,
name|QList
argument_list|<
name|QSslCertificate
argument_list|>
modifier|*
name|caCertificates
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|passPhrase
parameter_list|)
block|{
return|return
name|QSslSocketBackendPrivate
operator|::
name|importPKCS12
argument_list|(
name|device
argument_list|,
name|key
argument_list|,
name|certificate
argument_list|,
name|caCertificates
argument_list|,
name|passPhrase
argument_list|)
return|;
block|}
end_function
begin_comment
comment|// These certificates are known to be fraudulent and were created during the comodo
end_comment
begin_comment
comment|// compromise. See http://www.comodo.com/Comodo-Fraud-Incident-2011-03-23.html
end_comment
begin_decl_stmt
DECL|variable|certificate_blacklist
specifier|static
specifier|const
name|char
modifier|*
name|certificate_blacklist
index|[]
init|=
block|{
literal|"04:7e:cb:e9:fc:a5:5f:7b:d0:9e:ae:36:e1:0c:ae:1e"
block|,
literal|"mail.google.com"
block|,
comment|// Comodo
literal|"f5:c8:6a:f3:61:62:f1:3a:64:f5:4f:6d:c9:58:7c:06"
block|,
literal|"www.google.com"
block|,
comment|// Comodo
literal|"d7:55:8f:da:f5:f1:10:5b:b2:13:28:2b:70:77:29:a3"
block|,
literal|"login.yahoo.com"
block|,
comment|// Comodo
literal|"39:2a:43:4f:0e:07:df:1f:8a:a3:05:de:34:e0:c2:29"
block|,
literal|"login.yahoo.com"
block|,
comment|// Comodo
literal|"3e:75:ce:d4:6b:69:30:21:21:88:30:ae:86:a8:2a:71"
block|,
literal|"login.yahoo.com"
block|,
comment|// Comodo
literal|"e9:02:8b:95:78:e4:15:dc:1a:71:0a:2b:88:15:44:47"
block|,
literal|"login.skype.com"
block|,
comment|// Comodo
literal|"92:39:d5:34:8f:40:d1:69:5a:74:54:70:e1:f2:3f:43"
block|,
literal|"addons.mozilla.org"
block|,
comment|// Comodo
literal|"b0:b7:13:3e:d0:96:f9:b5:6f:ae:91:c8:74:bd:3a:c0"
block|,
literal|"login.live.com"
block|,
comment|// Comodo
literal|"d8:f3:5f:4e:b7:87:2b:2d:ab:06:92:e3:15:38:2f:b0"
block|,
literal|"global trustee"
block|,
comment|// Comodo
literal|"05:e2:e6:a4:cd:09:ea:54:d6:65:b0:75:fe:22:a2:56"
block|,
literal|"*.google.com"
block|,
comment|// leaf certificate issued by DigiNotar
literal|"0c:76:da:9c:91:0c:4e:2c:9e:fe:15:d0:58:93:3c:4c"
block|,
literal|"DigiNotar Root CA"
block|,
comment|// DigiNotar root
literal|"f1:4a:13:f4:87:2b:56:dc:39:df:84:ca:7a:a1:06:49"
block|,
literal|"DigiNotar Services CA"
block|,
comment|// DigiNotar intermediate signed by DigiNotar Root
literal|"36:16:71:55:43:42:1b:9d:e6:cb:a3:64:41:df:24:38"
block|,
literal|"DigiNotar Services 1024 CA"
block|,
comment|// DigiNotar intermediate signed by DigiNotar Root
literal|"0a:82:bd:1e:14:4e:88:14:d7:5b:1a:55:27:be:bf:3e"
block|,
literal|"DigiNotar Root CA G2"
block|,
comment|// other DigiNotar Root CA
literal|"a4:b6:ce:e3:2e:d3:35:46:26:3c:b3:55:3a:a8:92:21"
block|,
literal|"CertiID Enterprise Certificate Authority"
block|,
comment|// DigiNotar intermediate signed by "DigiNotar Root CA G2"
literal|"5b:d5:60:9c:64:17:68:cf:21:0e:35:fd:fb:05:ad:41"
block|,
literal|"DigiNotar Qualified CA"
block|,
comment|// DigiNotar intermediate signed by DigiNotar Root
literal|"46:9c:2c:b0"
block|,
literal|"DigiNotar Services 1024 CA"
block|,
comment|// DigiNotar intermediate cross-signed by Entrust
literal|"07:27:10:0d"
block|,
literal|"DigiNotar Cyber CA"
block|,
comment|// DigiNotar intermediate cross-signed by CyberTrust
literal|"07:27:0f:f9"
block|,
literal|"DigiNotar Cyber CA"
block|,
comment|// DigiNotar intermediate cross-signed by CyberTrust
literal|"07:27:10:03"
block|,
literal|"DigiNotar Cyber CA"
block|,
comment|// DigiNotar intermediate cross-signed by CyberTrust
literal|"01:31:69:b0"
block|,
literal|"DigiNotar PKIoverheid CA Overheid en Bedrijven"
block|,
comment|// DigiNotar intermediate cross-signed by the Dutch government
literal|"01:31:34:bf"
block|,
literal|"DigiNotar PKIoverheid CA Organisatie - G2"
block|,
comment|// DigiNotar intermediate cross-signed by the Dutch government
literal|"d6:d0:29:77:f1:49:fd:1a:83:f2:b9:ea:94:8c:5c:b4"
block|,
literal|"DigiNotar Extended Validation CA"
block|,
comment|// DigiNotar intermediate signed by DigiNotar EV Root
literal|"1e:7d:7a:53:3d:45:30:41:96:40:0f:71:48:1f:45:04"
block|,
literal|"DigiNotar Public CA 2025"
block|,
comment|// DigiNotar intermediate
comment|//    "(has not been seen in the wild so far)", "DigiNotar Public CA - G2", // DigiNotar intermediate
comment|//    "(has not been seen in the wild so far)", "Koninklijke Notariele Beroepsorganisatie CA", // compromised during DigiNotar breach
comment|//    "(has not been seen in the wild so far)", "Stichting TTP Infos CA," // compromised during DigiNotar breach
literal|"46:9c:2c:af"
block|,
literal|"DigiNotar Root CA"
block|,
comment|// DigiNotar intermediate cross-signed by Entrust
literal|"46:9c:3c:c9"
block|,
literal|"DigiNotar Root CA"
block|,
comment|// DigiNotar intermediate cross-signed by Entrust
literal|"07:27:14:a9"
block|,
literal|"Digisign Server ID (Enrich)"
block|,
comment|// (Malaysian) Digicert Sdn. Bhd. cross-signed by Verizon CyberTrust
literal|"4c:0e:63:6a"
block|,
literal|"Digisign Server ID - (Enrich)"
block|,
comment|// (Malaysian) Digicert Sdn. Bhd. cross-signed by Entrust
literal|"72:03:21:05:c5:0c:08:57:3d:8e:a5:30:4e:fe:e8:b0"
block|,
literal|"UTN-USERFirst-Hardware"
block|,
comment|// comodogate test certificate
literal|"41"
block|,
literal|"MD5 Collisions Inc. (http://www.phreedom.org/md5)"
block|,
comment|// http://www.phreedom.org/research/rogue-ca/
literal|"08:27"
block|,
literal|"*.EGO.GOV.TR"
block|,
comment|// Turktrust mis-issued intermediate certificate
literal|"08:64"
block|,
literal|"e-islem.kktcmerkezbankasi.org"
block|,
comment|// Turktrust mis-issued intermediate certificate
literal|"03:1d:a7"
block|,
literal|"AC DG Tr\xC3\xA9sor SSL"
block|,
comment|// intermediate certificate linking back to ANSSI French National Security Agency
literal|"27:83"
block|,
literal|"NIC Certifying Authority"
block|,
comment|// intermediate certificate from NIC India (2007)
literal|"27:92"
block|,
literal|"NIC CA 2011"
block|,
comment|// intermediate certificate from NIC India (2011)
literal|"27:b1"
block|,
literal|"NIC CA 2014"
block|,
comment|// intermediate certificate from NIC India (2014)
literal|0
block|}
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|parse
name|bool
name|QSslCertificatePrivate
operator|::
name|parse
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|data
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|QT_NO_OPENSSL
name|Q_UNUSED
argument_list|(
name|data
argument_list|)
expr_stmt|;
else|#
directive|else
name|QAsn1Element
name|root
decl_stmt|;
name|QDataStream
name|dataStream
argument_list|(
name|data
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|root
operator|.
name|read
argument_list|(
name|dataStream
argument_list|)
operator|||
name|root
operator|.
name|type
argument_list|()
operator|!=
name|QAsn1Element
operator|::
name|SequenceType
condition|)
return|return
literal|false
return|;
name|QDataStream
name|rootStream
argument_list|(
name|root
operator|.
name|value
argument_list|()
argument_list|)
decl_stmt|;
name|QAsn1Element
name|cert
decl_stmt|;
if|if
condition|(
operator|!
name|cert
operator|.
name|read
argument_list|(
name|rootStream
argument_list|)
operator|||
name|cert
operator|.
name|type
argument_list|()
operator|!=
name|QAsn1Element
operator|::
name|SequenceType
condition|)
return|return
literal|false
return|;
comment|// version or serial number
name|QAsn1Element
name|elem
decl_stmt|;
name|QDataStream
name|certStream
argument_list|(
name|cert
operator|.
name|value
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|elem
operator|.
name|read
argument_list|(
name|certStream
argument_list|)
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|elem
operator|.
name|type
argument_list|()
operator|==
name|QAsn1Element
operator|::
name|Context0Type
condition|)
block|{
name|QDataStream
name|versionStream
argument_list|(
name|elem
operator|.
name|value
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|elem
operator|.
name|read
argument_list|(
name|versionStream
argument_list|)
operator|||
name|elem
operator|.
name|type
argument_list|()
operator|!=
name|QAsn1Element
operator|::
name|IntegerType
condition|)
return|return
literal|false
return|;
name|versionString
operator|=
name|QByteArray
operator|::
name|number
argument_list|(
name|elem
operator|.
name|value
argument_list|()
index|[
literal|0
index|]
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|elem
operator|.
name|read
argument_list|(
name|certStream
argument_list|)
condition|)
return|return
literal|false
return|;
block|}
else|else
block|{
name|versionString
operator|=
name|QByteArray
operator|::
name|number
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|// serial number
if|if
condition|(
name|elem
operator|.
name|type
argument_list|()
operator|!=
name|QAsn1Element
operator|::
name|IntegerType
condition|)
return|return
literal|false
return|;
name|QByteArray
name|hexString
decl_stmt|;
name|hexString
operator|.
name|reserve
argument_list|(
name|elem
operator|.
name|value
argument_list|()
operator|.
name|size
argument_list|()
operator|*
literal|3
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|a
init|=
literal|0
init|;
name|a
operator|<
name|elem
operator|.
name|value
argument_list|()
operator|.
name|size
argument_list|()
condition|;
operator|++
name|a
control|)
block|{
specifier|const
name|quint8
name|b
init|=
name|elem
operator|.
name|value
argument_list|()
operator|.
name|at
argument_list|(
name|a
argument_list|)
decl_stmt|;
if|if
condition|(
name|b
operator|||
operator|!
name|hexString
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
comment|// skip leading zeros
name|hexString
operator|+=
name|QByteArray
operator|::
name|number
argument_list|(
name|b
argument_list|,
literal|16
argument_list|)
operator|.
name|rightJustified
argument_list|(
literal|2
argument_list|,
literal|'0'
argument_list|)
expr_stmt|;
name|hexString
operator|+=
literal|':'
expr_stmt|;
block|}
block|}
name|hexString
operator|.
name|chop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|serialNumberString
operator|=
name|hexString
expr_stmt|;
comment|// algorithm ID
if|if
condition|(
operator|!
name|elem
operator|.
name|read
argument_list|(
name|certStream
argument_list|)
operator|||
name|elem
operator|.
name|type
argument_list|()
operator|!=
name|QAsn1Element
operator|::
name|SequenceType
condition|)
return|return
literal|false
return|;
comment|//qDebug()<< "algorithm ID"<< elem.type()<< elem.length<< elem.value().toHex();
comment|// issuer info
if|if
condition|(
operator|!
name|elem
operator|.
name|read
argument_list|(
name|certStream
argument_list|)
operator|||
name|elem
operator|.
name|type
argument_list|()
operator|!=
name|QAsn1Element
operator|::
name|SequenceType
condition|)
return|return
literal|false
return|;
name|QByteArray
name|issuerDer
init|=
name|data
operator|.
name|mid
argument_list|(
name|dataStream
operator|.
name|device
argument_list|()
operator|->
name|pos
argument_list|()
operator|-
name|elem
operator|.
name|value
argument_list|()
operator|.
name|length
argument_list|()
argument_list|,
name|elem
operator|.
name|value
argument_list|()
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
name|issuerInfo
operator|=
name|elem
operator|.
name|toInfo
argument_list|()
expr_stmt|;
comment|// validity period
if|if
condition|(
operator|!
name|elem
operator|.
name|read
argument_list|(
name|certStream
argument_list|)
operator|||
name|elem
operator|.
name|type
argument_list|()
operator|!=
name|QAsn1Element
operator|::
name|SequenceType
condition|)
return|return
literal|false
return|;
name|QDataStream
name|validityStream
argument_list|(
name|elem
operator|.
name|value
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|elem
operator|.
name|read
argument_list|(
name|validityStream
argument_list|)
operator|||
operator|(
name|elem
operator|.
name|type
argument_list|()
operator|!=
name|QAsn1Element
operator|::
name|UtcTimeType
operator|&&
name|elem
operator|.
name|type
argument_list|()
operator|!=
name|QAsn1Element
operator|::
name|GeneralizedTimeType
operator|)
condition|)
return|return
literal|false
return|;
name|notValidBefore
operator|=
name|elem
operator|.
name|toDateTime
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|elem
operator|.
name|read
argument_list|(
name|validityStream
argument_list|)
operator|||
operator|(
name|elem
operator|.
name|type
argument_list|()
operator|!=
name|QAsn1Element
operator|::
name|UtcTimeType
operator|&&
name|elem
operator|.
name|type
argument_list|()
operator|!=
name|QAsn1Element
operator|::
name|GeneralizedTimeType
operator|)
condition|)
return|return
literal|false
return|;
name|notValidAfter
operator|=
name|elem
operator|.
name|toDateTime
argument_list|()
expr_stmt|;
comment|// subject name
if|if
condition|(
operator|!
name|elem
operator|.
name|read
argument_list|(
name|certStream
argument_list|)
operator|||
name|elem
operator|.
name|type
argument_list|()
operator|!=
name|QAsn1Element
operator|::
name|SequenceType
condition|)
return|return
literal|false
return|;
name|QByteArray
name|subjectDer
init|=
name|data
operator|.
name|mid
argument_list|(
name|dataStream
operator|.
name|device
argument_list|()
operator|->
name|pos
argument_list|()
operator|-
name|elem
operator|.
name|value
argument_list|()
operator|.
name|length
argument_list|()
argument_list|,
name|elem
operator|.
name|value
argument_list|()
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
name|subjectInfo
operator|=
name|elem
operator|.
name|toInfo
argument_list|()
expr_stmt|;
name|subjectMatchesIssuer
operator|=
name|issuerDer
operator|==
name|subjectDer
expr_stmt|;
comment|// public key
name|qint64
name|keyStart
init|=
name|certStream
operator|.
name|device
argument_list|()
operator|->
name|pos
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|elem
operator|.
name|read
argument_list|(
name|certStream
argument_list|)
operator|||
name|elem
operator|.
name|type
argument_list|()
operator|!=
name|QAsn1Element
operator|::
name|SequenceType
condition|)
return|return
literal|false
return|;
name|publicKeyDerData
operator|.
name|resize
argument_list|(
name|certStream
operator|.
name|device
argument_list|()
operator|->
name|pos
argument_list|()
operator|-
name|keyStart
argument_list|)
expr_stmt|;
name|QDataStream
name|keyStream
argument_list|(
name|elem
operator|.
name|value
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|elem
operator|.
name|read
argument_list|(
name|keyStream
argument_list|)
operator|||
name|elem
operator|.
name|type
argument_list|()
operator|!=
name|QAsn1Element
operator|::
name|SequenceType
condition|)
return|return
literal|false
return|;
comment|// key algorithm
if|if
condition|(
operator|!
name|elem
operator|.
name|read
argument_list|(
name|elem
operator|.
name|value
argument_list|()
argument_list|)
operator|||
name|elem
operator|.
name|type
argument_list|()
operator|!=
name|QAsn1Element
operator|::
name|ObjectIdentifierType
condition|)
return|return
literal|false
return|;
specifier|const
name|QByteArray
name|oid
init|=
name|elem
operator|.
name|toObjectId
argument_list|()
decl_stmt|;
if|if
condition|(
name|oid
operator|==
literal|"1.2.840.113549.1.1.1"
condition|)
name|publicKeyAlgorithm
operator|=
name|QSsl
operator|::
name|Rsa
expr_stmt|;
elseif|else
if|if
condition|(
name|oid
operator|==
literal|"1.2.840.10040.4.1"
condition|)
name|publicKeyAlgorithm
operator|=
name|QSsl
operator|::
name|Dsa
expr_stmt|;
else|else
name|publicKeyAlgorithm
operator|=
name|QSsl
operator|::
name|Opaque
expr_stmt|;
name|certStream
operator|.
name|device
argument_list|()
operator|->
name|seek
argument_list|(
name|keyStart
argument_list|)
expr_stmt|;
name|certStream
operator|.
name|readRawData
argument_list|(
name|publicKeyDerData
operator|.
name|data
argument_list|()
argument_list|,
name|publicKeyDerData
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|// extensions
while|while
condition|(
name|elem
operator|.
name|read
argument_list|(
name|certStream
argument_list|)
condition|)
block|{
if|if
condition|(
name|elem
operator|.
name|type
argument_list|()
operator|==
name|QAsn1Element
operator|::
name|Context3Type
condition|)
block|{
if|if
condition|(
name|elem
operator|.
name|read
argument_list|(
name|elem
operator|.
name|value
argument_list|()
argument_list|)
operator|&&
name|elem
operator|.
name|type
argument_list|()
operator|==
name|QAsn1Element
operator|::
name|SequenceType
condition|)
block|{
name|QDataStream
name|extStream
argument_list|(
name|elem
operator|.
name|value
argument_list|()
argument_list|)
decl_stmt|;
while|while
condition|(
name|elem
operator|.
name|read
argument_list|(
name|extStream
argument_list|)
operator|&&
name|elem
operator|.
name|type
argument_list|()
operator|==
name|QAsn1Element
operator|::
name|SequenceType
condition|)
block|{
name|QAsn1Element
name|oidElem
decl_stmt|,
name|valElem
decl_stmt|;
name|QDataStream
name|seqStream
argument_list|(
name|elem
operator|.
name|value
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|oidElem
operator|.
name|read
argument_list|(
name|seqStream
argument_list|)
operator|&&
name|oidElem
operator|.
name|type
argument_list|()
operator|==
name|QAsn1Element
operator|::
name|ObjectIdentifierType
operator|&&
name|valElem
operator|.
name|read
argument_list|(
name|seqStream
argument_list|)
operator|&&
name|valElem
operator|.
name|type
argument_list|()
operator|==
name|QAsn1Element
operator|::
name|OctetStringType
condition|)
block|{
comment|// alternative name
if|if
condition|(
name|oidElem
operator|.
name|toObjectId
argument_list|()
operator|==
name|QByteArray
argument_list|(
literal|"2.5.29.17"
argument_list|)
condition|)
block|{
name|QAsn1Element
name|sanElem
decl_stmt|;
if|if
condition|(
name|sanElem
operator|.
name|read
argument_list|(
name|valElem
operator|.
name|value
argument_list|()
argument_list|)
operator|&&
name|sanElem
operator|.
name|type
argument_list|()
operator|==
name|QAsn1Element
operator|::
name|SequenceType
condition|)
block|{
name|QDataStream
name|nameStream
argument_list|(
name|sanElem
operator|.
name|value
argument_list|()
argument_list|)
decl_stmt|;
name|QAsn1Element
name|nameElem
decl_stmt|;
while|while
condition|(
name|nameElem
operator|.
name|read
argument_list|(
name|nameStream
argument_list|)
condition|)
block|{
if|if
condition|(
name|nameElem
operator|.
name|type
argument_list|()
operator|==
name|QAsn1Element
operator|::
name|Rfc822NameType
condition|)
block|{
name|subjectAlternativeNames
operator|.
name|insert
argument_list|(
name|QSsl
operator|::
name|EmailEntry
argument_list|,
name|QString
operator|::
name|fromLatin1
argument_list|(
name|nameElem
operator|.
name|value
argument_list|()
argument_list|,
name|nameElem
operator|.
name|value
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nameElem
operator|.
name|type
argument_list|()
operator|==
name|QAsn1Element
operator|::
name|DnsNameType
condition|)
block|{
name|subjectAlternativeNames
operator|.
name|insert
argument_list|(
name|QSsl
operator|::
name|DnsEntry
argument_list|,
name|QString
operator|::
name|fromLatin1
argument_list|(
name|nameElem
operator|.
name|value
argument_list|()
argument_list|,
name|nameElem
operator|.
name|value
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
block|}
block|}
block|}
name|derData
operator|=
name|data
operator|.
name|left
argument_list|(
name|dataStream
operator|.
name|device
argument_list|()
operator|->
name|pos
argument_list|()
argument_list|)
expr_stmt|;
name|null
operator|=
literal|false
expr_stmt|;
endif|#
directive|endif
comment|// QT_NO_OPENSSL
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|isBlacklisted
name|bool
name|QSslCertificatePrivate
operator|::
name|isBlacklisted
parameter_list|(
specifier|const
name|QSslCertificate
modifier|&
name|certificate
parameter_list|)
block|{
for|for
control|(
name|int
name|a
init|=
literal|0
init|;
name|certificate_blacklist
index|[
name|a
index|]
operator|!=
literal|0
condition|;
name|a
operator|++
control|)
block|{
name|QString
name|blacklistedCommonName
init|=
name|QString
operator|::
name|fromUtf8
argument_list|(
name|certificate_blacklist
index|[
operator|(
name|a
operator|+
literal|1
operator|)
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|certificate
operator|.
name|serialNumber
argument_list|()
operator|==
name|certificate_blacklist
index|[
name|a
operator|++
index|]
operator|&&
operator|(
name|certificate
operator|.
name|subjectInfo
argument_list|(
name|QSslCertificate
operator|::
name|CommonName
argument_list|)
operator|.
name|contains
argument_list|(
name|blacklistedCommonName
argument_list|)
operator|||
name|certificate
operator|.
name|issuerInfo
argument_list|(
name|QSslCertificate
operator|::
name|CommonName
argument_list|)
operator|.
name|contains
argument_list|(
name|blacklistedCommonName
argument_list|)
operator|)
condition|)
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|subjectInfoToString
name|QByteArray
name|QSslCertificatePrivate
operator|::
name|subjectInfoToString
parameter_list|(
name|QSslCertificate
operator|::
name|SubjectInfo
name|info
parameter_list|)
block|{
name|QByteArray
name|str
decl_stmt|;
switch|switch
condition|(
name|info
condition|)
block|{
case|case
name|QSslCertificate
operator|::
name|Organization
case|:
name|str
operator|=
name|QByteArray
argument_list|(
literal|"O"
argument_list|)
expr_stmt|;
break|break;
case|case
name|QSslCertificate
operator|::
name|CommonName
case|:
name|str
operator|=
name|QByteArray
argument_list|(
literal|"CN"
argument_list|)
expr_stmt|;
break|break;
case|case
name|QSslCertificate
operator|::
name|LocalityName
case|:
name|str
operator|=
name|QByteArray
argument_list|(
literal|"L"
argument_list|)
expr_stmt|;
break|break;
case|case
name|QSslCertificate
operator|::
name|OrganizationalUnitName
case|:
name|str
operator|=
name|QByteArray
argument_list|(
literal|"OU"
argument_list|)
expr_stmt|;
break|break;
case|case
name|QSslCertificate
operator|::
name|CountryName
case|:
name|str
operator|=
name|QByteArray
argument_list|(
literal|"C"
argument_list|)
expr_stmt|;
break|break;
case|case
name|QSslCertificate
operator|::
name|StateOrProvinceName
case|:
name|str
operator|=
name|QByteArray
argument_list|(
literal|"ST"
argument_list|)
expr_stmt|;
break|break;
case|case
name|QSslCertificate
operator|::
name|DistinguishedNameQualifier
case|:
name|str
operator|=
name|QByteArray
argument_list|(
literal|"dnQualifier"
argument_list|)
expr_stmt|;
break|break;
case|case
name|QSslCertificate
operator|::
name|SerialNumber
case|:
name|str
operator|=
name|QByteArray
argument_list|(
literal|"serialNumber"
argument_list|)
expr_stmt|;
break|break;
case|case
name|QSslCertificate
operator|::
name|EmailAddress
case|:
name|str
operator|=
name|QByteArray
argument_list|(
literal|"emailAddress"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|str
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DEBUG_STREAM
end_ifndef
begin_function
DECL|function|operator <<
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|debug
parameter_list|,
specifier|const
name|QSslCertificate
modifier|&
name|certificate
parameter_list|)
block|{
name|debug
operator|<<
literal|"QSslCertificate("
operator|<<
name|certificate
operator|.
name|version
argument_list|()
operator|<<
literal|','
operator|<<
name|certificate
operator|.
name|serialNumber
argument_list|()
operator|<<
literal|','
operator|<<
name|certificate
operator|.
name|digest
argument_list|()
operator|.
name|toBase64
argument_list|()
operator|<<
literal|','
operator|<<
name|certificate
operator|.
name|issuerInfo
argument_list|(
name|QSslCertificate
operator|::
name|Organization
argument_list|)
operator|<<
literal|','
operator|<<
name|certificate
operator|.
name|subjectInfo
argument_list|(
name|QSslCertificate
operator|::
name|Organization
argument_list|)
operator|<<
literal|','
operator|<<
name|certificate
operator|.
name|subjectAlternativeNames
argument_list|()
ifndef|#
directive|ifndef
name|QT_NO_DATESTRING
operator|<<
literal|','
operator|<<
name|certificate
operator|.
name|effectiveDate
argument_list|()
operator|<<
literal|','
operator|<<
name|certificate
operator|.
name|expiryDate
argument_list|()
endif|#
directive|endif
operator|<<
literal|')'
expr_stmt|;
return|return
name|debug
return|;
block|}
end_function
begin_function
DECL|function|operator <<
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|debug
parameter_list|,
name|QSslCertificate
operator|::
name|SubjectInfo
name|info
parameter_list|)
block|{
switch|switch
condition|(
name|info
condition|)
block|{
case|case
name|QSslCertificate
operator|::
name|Organization
case|:
name|debug
operator|<<
literal|"Organization"
expr_stmt|;
break|break;
case|case
name|QSslCertificate
operator|::
name|CommonName
case|:
name|debug
operator|<<
literal|"CommonName"
expr_stmt|;
break|break;
case|case
name|QSslCertificate
operator|::
name|CountryName
case|:
name|debug
operator|<<
literal|"CountryName"
expr_stmt|;
break|break;
case|case
name|QSslCertificate
operator|::
name|LocalityName
case|:
name|debug
operator|<<
literal|"LocalityName"
expr_stmt|;
break|break;
case|case
name|QSslCertificate
operator|::
name|OrganizationalUnitName
case|:
name|debug
operator|<<
literal|"OrganizationalUnitName"
expr_stmt|;
break|break;
case|case
name|QSslCertificate
operator|::
name|StateOrProvinceName
case|:
name|debug
operator|<<
literal|"StateOrProvinceName"
expr_stmt|;
break|break;
case|case
name|QSslCertificate
operator|::
name|DistinguishedNameQualifier
case|:
name|debug
operator|<<
literal|"DistinguishedNameQualifier"
expr_stmt|;
break|break;
case|case
name|QSslCertificate
operator|::
name|SerialNumber
case|:
name|debug
operator|<<
literal|"SerialNumber"
expr_stmt|;
break|break;
case|case
name|QSslCertificate
operator|::
name|EmailAddress
case|:
name|debug
operator|<<
literal|"EmailAddress"
expr_stmt|;
break|break;
block|}
return|return
name|debug
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
