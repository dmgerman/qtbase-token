begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtNetwork module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_comment
comment|/**************************************************************************** ** ** In addition, as a special exception, the copyright holders listed above give ** permission to link the code of its release of Qt with the OpenSSL project's ** "OpenSSL" library (or modified versions of the "OpenSSL" library that use the ** same license as the original version), and distribute the linked executables. ** ** You must comply with the GNU General Public License version 2 in all ** respects for all of the code used other than the "OpenSSL" code.  If you ** modify this file, you may extend this exception to your version of the file, ** but you are not obligated to do so.  If you do not wish to do so, delete ** this exception statement from your version of this file. ** ****************************************************************************/
end_comment
begin_comment
comment|//#define QSSLSOCKET_DEBUG
end_comment
begin_comment
comment|//#define QT_DECRYPT_SSL_TRAFFIC
end_comment
begin_include
include|#
directive|include
file|"qsslsocket_openssl_p.h"
end_include
begin_include
include|#
directive|include
file|"qsslsocket_openssl_symbols_p.h"
end_include
begin_include
include|#
directive|include
file|"qsslsocket.h"
end_include
begin_include
include|#
directive|include
file|"qsslcertificate_p.h"
end_include
begin_include
include|#
directive|include
file|"qsslcipher_p.h"
end_include
begin_include
include|#
directive|include
file|"qsslkey_p.h"
end_include
begin_include
include|#
directive|include
file|<QtCore/qdatetime.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qdebug.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qdir.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qdiriterator.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qelapsedtimer.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qfile.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qfileinfo.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qmutex.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qthread.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qurl.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qvarlengtharray.h>
end_include
begin_include
include|#
directive|include
file|<QLibrary>
end_include
begin_comment
comment|// for loading the security lib for the CA store
end_comment
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_MACX
argument_list|)
DECL|macro|kSecTrustSettingsDomainSystem
define|#
directive|define
name|kSecTrustSettingsDomainSystem
value|2
comment|// so we do not need to include the header file
DECL|member|ptrSecCertificateCopyData
name|PtrSecCertificateCopyData
name|QSslSocketPrivate
operator|::
name|ptrSecCertificateCopyData
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|ptrSecTrustSettingsCopyCertificates
name|PtrSecTrustSettingsCopyCertificates
name|QSslSocketPrivate
operator|::
name|ptrSecTrustSettingsCopyCertificates
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|ptrSecTrustCopyAnchorCertificates
name|PtrSecTrustCopyAnchorCertificates
name|QSslSocketPrivate
operator|::
name|ptrSecTrustCopyAnchorCertificates
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
end_elif
begin_decl_stmt
name|PtrCertOpenSystemStoreW
name|QSslSocketPrivate
operator|::
name|ptrCertOpenSystemStoreW
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|PtrCertFindCertificateInStore
name|QSslSocketPrivate
operator|::
name|ptrCertFindCertificateInStore
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|PtrCertCloseStore
name|QSslSocketPrivate
operator|::
name|ptrCertCloseStore
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
DECL|member|s_libraryLoaded
name|bool
name|QSslSocketPrivate
operator|::
name|s_libraryLoaded
init|=
literal|false
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|s_loadedCiphersAndCerts
name|bool
name|QSslSocketPrivate
operator|::
name|s_loadedCiphersAndCerts
init|=
literal|false
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|s_loadRootCertsOnDemand
name|bool
name|QSslSocketPrivate
operator|::
name|s_loadRootCertsOnDemand
init|=
literal|false
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* \internal      From OpenSSL's thread(3) manual page:      OpenSSL can safely be used in multi-threaded applications provided that at     least two callback functions are set.      locking_function(int mode, int n, const char *file, int line) is needed to     perform locking on shared data structures.  (Note that OpenSSL uses a     number of global data structures that will be implicitly shared     whenever multiple threads use OpenSSL.)  Multi-threaded     applications will crash at random if it is not set.  ...     ...     id_function(void) is a function that returns a thread ID. It is not     needed on Windows nor on platforms where getpid() returns a different     ID for each thread (most notably Linux) */
end_comment
begin_class
DECL|class|QOpenSslLocks
class|class
name|QOpenSslLocks
block|{
public|public:
DECL|function|QOpenSslLocks
specifier|inline
name|QOpenSslLocks
parameter_list|()
member_init_list|:
name|initLocker
argument_list|(
name|QMutex
operator|::
name|Recursive
argument_list|)
member_init_list|,
name|locksLocker
argument_list|(
name|QMutex
operator|::
name|Recursive
argument_list|)
block|{
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|locksLocker
argument_list|)
decl_stmt|;
name|int
name|numLocks
init|=
name|q_CRYPTO_num_locks
argument_list|()
decl_stmt|;
name|locks
operator|=
operator|new
name|QMutex
operator|*
index|[
name|numLocks
index|]
expr_stmt|;
name|memset
argument_list|(
name|locks
argument_list|,
literal|0
argument_list|,
name|numLocks
operator|*
sizeof|sizeof
argument_list|(
name|QMutex
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|~QOpenSslLocks
specifier|inline
name|~
name|QOpenSslLocks
parameter_list|()
block|{
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|locksLocker
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|q_CRYPTO_num_locks
argument_list|()
condition|;
operator|++
name|i
control|)
operator|delete
name|locks
index|[
name|i
index|]
expr_stmt|;
operator|delete
index|[]
name|locks
expr_stmt|;
name|QSslSocketPrivate
operator|::
name|deinitialize
argument_list|()
expr_stmt|;
block|}
DECL|function|lock
specifier|inline
name|QMutex
modifier|*
name|lock
parameter_list|(
name|int
name|num
parameter_list|)
block|{
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|locksLocker
argument_list|)
decl_stmt|;
name|QMutex
modifier|*
name|tmp
init|=
name|locks
index|[
name|num
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|tmp
condition|)
name|tmp
operator|=
name|locks
index|[
name|num
index|]
operator|=
operator|new
name|QMutex
argument_list|(
name|QMutex
operator|::
name|Recursive
argument_list|)
expr_stmt|;
return|return
name|tmp
return|;
block|}
DECL|function|globalLock
name|QMutex
modifier|*
name|globalLock
parameter_list|()
block|{
return|return
operator|&
name|locksLocker
return|;
block|}
DECL|function|initLock
name|QMutex
modifier|*
name|initLock
parameter_list|()
block|{
return|return
operator|&
name|initLocker
return|;
block|}
private|private:
DECL|member|initLocker
name|QMutex
name|initLocker
decl_stmt|;
DECL|member|locksLocker
name|QMutex
name|locksLocker
decl_stmt|;
DECL|member|locks
name|QMutex
modifier|*
modifier|*
name|locks
decl_stmt|;
block|}
class|;
end_class
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|QOpenSslLocks
argument_list|,
argument|openssl_locks
argument_list|)
end_macro
begin_function
DECL|function|getErrorsFromOpenSsl
name|QString
name|QSslSocketBackendPrivate
operator|::
name|getErrorsFromOpenSsl
parameter_list|()
block|{
name|QString
name|errorString
decl_stmt|;
name|unsigned
name|long
name|errNum
decl_stmt|;
while|while
condition|(
operator|(
name|errNum
operator|=
name|q_ERR_get_error
argument_list|()
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|errorString
operator|.
name|isEmpty
argument_list|()
condition|)
name|errorString
operator|.
name|append
argument_list|(
name|QLatin1String
argument_list|(
literal|", "
argument_list|)
argument_list|)
expr_stmt|;
specifier|const
name|char
modifier|*
name|error
init|=
name|q_ERR_error_string
argument_list|(
name|errNum
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|errorString
operator|.
name|append
argument_list|(
name|QString
operator|::
name|fromLatin1
argument_list|(
name|error
argument_list|)
argument_list|)
expr_stmt|;
comment|// error is ascii according to man ERR_error_string
block|}
return|return
name|errorString
return|;
block|}
end_function
begin_extern
extern|extern
literal|"C"
block|{
DECL|function|locking_function
specifier|static
name|void
name|locking_function
parameter_list|(
name|int
name|mode
parameter_list|,
name|int
name|lockNumber
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
block|{
name|QMutex
modifier|*
name|mutex
init|=
name|openssl_locks
argument_list|()
operator|->
name|lock
argument_list|(
name|lockNumber
argument_list|)
decl_stmt|;
comment|// Lock or unlock it
if|if
condition|(
name|mode
operator|&
name|CRYPTO_LOCK
condition|)
name|mutex
operator|->
name|lock
argument_list|()
expr_stmt|;
else|else
name|mutex
operator|->
name|unlock
argument_list|()
expr_stmt|;
block|}
DECL|function|id_function
specifier|static
name|unsigned
name|long
name|id_function
parameter_list|()
block|{
return|return
operator|(
name|quintptr
operator|)
name|QThread
operator|::
name|currentThreadId
argument_list|()
return|;
block|}
block|}
end_extern
begin_comment
comment|// extern "C"
end_comment
begin_constructor
DECL|function|QSslSocketBackendPrivate
name|QSslSocketBackendPrivate
operator|::
name|QSslSocketBackendPrivate
parameter_list|()
member_init_list|:
name|ssl
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|readBio
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|writeBio
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|session
argument_list|(
literal|0
argument_list|)
block|{
comment|// Calls SSL_library_init().
name|ensureInitialized
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QSslSocketBackendPrivate
name|QSslSocketBackendPrivate
operator|::
name|~
name|QSslSocketBackendPrivate
parameter_list|()
block|{
name|destroySslContext
argument_list|()
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|QSslCipher_from_SSL_CIPHER
name|QSslCipher
name|QSslSocketBackendPrivate
operator|::
name|QSslCipher_from_SSL_CIPHER
parameter_list|(
name|SSL_CIPHER
modifier|*
name|cipher
parameter_list|)
block|{
name|QSslCipher
name|ciph
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|QString
name|descriptionOneLine
init|=
name|QString
operator|::
name|fromLatin1
argument_list|(
name|q_SSL_CIPHER_description
argument_list|(
name|cipher
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|QStringList
name|descriptionList
init|=
name|descriptionOneLine
operator|.
name|split
argument_list|(
name|QLatin1String
argument_list|(
literal|" "
argument_list|)
argument_list|,
name|QString
operator|::
name|SkipEmptyParts
argument_list|)
decl_stmt|;
if|if
condition|(
name|descriptionList
operator|.
name|size
argument_list|()
operator|>
literal|5
condition|)
block|{
comment|// ### crude code.
name|ciph
operator|.
name|d
operator|->
name|isNull
operator|=
literal|false
expr_stmt|;
name|ciph
operator|.
name|d
operator|->
name|name
operator|=
name|descriptionList
operator|.
name|at
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|QString
name|protoString
init|=
name|descriptionList
operator|.
name|at
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|ciph
operator|.
name|d
operator|->
name|protocolString
operator|=
name|protoString
expr_stmt|;
name|ciph
operator|.
name|d
operator|->
name|protocol
operator|=
name|QSsl
operator|::
name|UnknownProtocol
expr_stmt|;
if|if
condition|(
name|protoString
operator|==
name|QLatin1String
argument_list|(
literal|"SSLv3"
argument_list|)
condition|)
name|ciph
operator|.
name|d
operator|->
name|protocol
operator|=
name|QSsl
operator|::
name|SslV3
expr_stmt|;
elseif|else
if|if
condition|(
name|protoString
operator|==
name|QLatin1String
argument_list|(
literal|"SSLv2"
argument_list|)
condition|)
name|ciph
operator|.
name|d
operator|->
name|protocol
operator|=
name|QSsl
operator|::
name|SslV2
expr_stmt|;
elseif|else
if|if
condition|(
name|protoString
operator|==
name|QLatin1String
argument_list|(
literal|"TLSv1"
argument_list|)
condition|)
name|ciph
operator|.
name|d
operator|->
name|protocol
operator|=
name|QSsl
operator|::
name|TlsV1_0
expr_stmt|;
elseif|else
if|if
condition|(
name|protoString
operator|==
name|QLatin1String
argument_list|(
literal|"TLSv1.1"
argument_list|)
condition|)
name|ciph
operator|.
name|d
operator|->
name|protocol
operator|=
name|QSsl
operator|::
name|TlsV1_1
expr_stmt|;
elseif|else
if|if
condition|(
name|protoString
operator|==
name|QLatin1String
argument_list|(
literal|"TLSv1.2"
argument_list|)
condition|)
name|ciph
operator|.
name|d
operator|->
name|protocol
operator|=
name|QSsl
operator|::
name|TlsV1_2
expr_stmt|;
if|if
condition|(
name|descriptionList
operator|.
name|at
argument_list|(
literal|2
argument_list|)
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"Kx="
argument_list|)
argument_list|)
condition|)
name|ciph
operator|.
name|d
operator|->
name|keyExchangeMethod
operator|=
name|descriptionList
operator|.
name|at
argument_list|(
literal|2
argument_list|)
operator|.
name|mid
argument_list|(
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|descriptionList
operator|.
name|at
argument_list|(
literal|3
argument_list|)
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"Au="
argument_list|)
argument_list|)
condition|)
name|ciph
operator|.
name|d
operator|->
name|authenticationMethod
operator|=
name|descriptionList
operator|.
name|at
argument_list|(
literal|3
argument_list|)
operator|.
name|mid
argument_list|(
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|descriptionList
operator|.
name|at
argument_list|(
literal|4
argument_list|)
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"Enc="
argument_list|)
argument_list|)
condition|)
name|ciph
operator|.
name|d
operator|->
name|encryptionMethod
operator|=
name|descriptionList
operator|.
name|at
argument_list|(
literal|4
argument_list|)
operator|.
name|mid
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|ciph
operator|.
name|d
operator|->
name|exportable
operator|=
operator|(
name|descriptionList
operator|.
name|size
argument_list|()
operator|>
literal|6
operator|&&
name|descriptionList
operator|.
name|at
argument_list|(
literal|6
argument_list|)
operator|==
name|QLatin1String
argument_list|(
literal|"export"
argument_list|)
operator|)
expr_stmt|;
name|ciph
operator|.
name|d
operator|->
name|bits
operator|=
name|cipher
operator|->
name|strength_bits
expr_stmt|;
name|ciph
operator|.
name|d
operator|->
name|supportedBits
operator|=
name|cipher
operator|->
name|alg_bits
expr_stmt|;
block|}
return|return
name|ciph
return|;
block|}
end_function
begin_comment
comment|// ### This list is shared between all threads, and protected by a
end_comment
begin_comment
comment|// mutex. Investigate using thread local storage instead.
end_comment
begin_struct
DECL|struct|QSslErrorList
struct|struct
name|QSslErrorList
block|{
DECL|member|mutex
name|QMutex
name|mutex
decl_stmt|;
DECL|member|errors
name|QList
argument_list|<
name|QPair
argument_list|<
name|int
argument_list|,
name|int
argument_list|>
argument_list|>
name|errors
decl_stmt|;
block|}
struct|;
end_struct
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|QSslErrorList
argument_list|,
argument|_q_sslErrorList
argument_list|)
end_macro
begin_function
DECL|function|q_X509Callback
name|int
name|q_X509Callback
parameter_list|(
name|int
name|ok
parameter_list|,
name|X509_STORE_CTX
modifier|*
name|ctx
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ok
condition|)
block|{
comment|// Store the error and at which depth the error was detected.
name|_q_sslErrorList
argument_list|()
operator|->
name|errors
operator|<<
name|qMakePair
argument_list|<
name|int
argument_list|,
name|int
argument_list|>
argument_list|(
name|q_X509_STORE_CTX_get_error
argument_list|(
name|ctx
argument_list|)
argument_list|,
name|q_X509_STORE_CTX_get_error_depth
argument_list|(
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QSSLSOCKET_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"verification error: dumping bad certificate"
expr_stmt|;
name|qDebug
argument_list|()
operator|<<
name|QSslCertificatePrivate
operator|::
name|QSslCertificate_from_X509
argument_list|(
name|q_X509_STORE_CTX_get_current_cert
argument_list|(
name|ctx
argument_list|)
argument_list|)
operator|.
name|toPem
argument_list|()
expr_stmt|;
name|qDebug
argument_list|()
operator|<<
literal|"dumping chain"
expr_stmt|;
foreach|foreach
control|(
name|QSslCertificate
name|cert
decl|,
name|QSslSocketBackendPrivate
operator|::
name|STACKOFX509_to_QSslCertificates
argument_list|(
name|q_X509_STORE_CTX_get_chain
argument_list|(
name|ctx
argument_list|)
argument_list|)
control|)
block|{
name|QString
name|certFormat
argument_list|(
name|QStringLiteral
argument_list|(
literal|"O=%1 CN=%2 L=%3 OU=%4 C=%5 ST=%6"
argument_list|)
argument_list|)
decl_stmt|;
name|qDebug
argument_list|()
operator|<<
literal|"Issuer:"
operator|<<
literal|"O="
operator|<<
name|cert
operator|.
name|issuerInfo
argument_list|(
name|QSslCertificate
operator|::
name|Organization
argument_list|)
operator|<<
literal|"CN="
operator|<<
name|cert
operator|.
name|issuerInfo
argument_list|(
name|QSslCertificate
operator|::
name|CommonName
argument_list|)
operator|<<
literal|"L="
operator|<<
name|cert
operator|.
name|issuerInfo
argument_list|(
name|QSslCertificate
operator|::
name|LocalityName
argument_list|)
operator|<<
literal|"OU="
operator|<<
name|cert
operator|.
name|issuerInfo
argument_list|(
name|QSslCertificate
operator|::
name|OrganizationalUnitName
argument_list|)
operator|<<
literal|"C="
operator|<<
name|cert
operator|.
name|issuerInfo
argument_list|(
name|QSslCertificate
operator|::
name|CountryName
argument_list|)
operator|<<
literal|"ST="
operator|<<
name|cert
operator|.
name|issuerInfo
argument_list|(
name|QSslCertificate
operator|::
name|StateOrProvinceName
argument_list|)
expr_stmt|;
name|qDebug
argument_list|()
operator|<<
literal|"Subject:"
operator|<<
literal|"O="
operator|<<
name|cert
operator|.
name|subjectInfo
argument_list|(
name|QSslCertificate
operator|::
name|Organization
argument_list|)
operator|<<
literal|"CN="
operator|<<
name|cert
operator|.
name|subjectInfo
argument_list|(
name|QSslCertificate
operator|::
name|CommonName
argument_list|)
operator|<<
literal|"L="
operator|<<
name|cert
operator|.
name|subjectInfo
argument_list|(
name|QSslCertificate
operator|::
name|LocalityName
argument_list|)
operator|<<
literal|"OU="
operator|<<
name|cert
operator|.
name|subjectInfo
argument_list|(
name|QSslCertificate
operator|::
name|OrganizationalUnitName
argument_list|)
operator|<<
literal|"C="
operator|<<
name|cert
operator|.
name|subjectInfo
argument_list|(
name|QSslCertificate
operator|::
name|CountryName
argument_list|)
operator|<<
literal|"ST="
operator|<<
name|cert
operator|.
name|subjectInfo
argument_list|(
name|QSslCertificate
operator|::
name|StateOrProvinceName
argument_list|)
expr_stmt|;
name|qDebug
argument_list|()
operator|<<
literal|"Valid:"
operator|<<
name|cert
operator|.
name|effectiveDate
argument_list|()
operator|<<
literal|"-"
operator|<<
name|cert
operator|.
name|expiryDate
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
block|}
comment|// Always return OK to allow verification to continue. We're handle the
comment|// errors gracefully after collecting all errors, after verification has
comment|// completed.
return|return
literal|1
return|;
block|}
end_function
begin_function
DECL|function|setupOpenSslOptions
name|long
name|QSslSocketBackendPrivate
operator|::
name|setupOpenSslOptions
parameter_list|(
name|QSsl
operator|::
name|SslProtocol
name|protocol
parameter_list|,
name|QSsl
operator|::
name|SslOptions
name|sslOptions
parameter_list|)
block|{
name|long
name|options
decl_stmt|;
if|if
condition|(
name|protocol
operator|==
name|QSsl
operator|::
name|TlsV1SslV3
operator|||
name|protocol
operator|==
name|QSsl
operator|::
name|SecureProtocols
condition|)
name|options
operator|=
name|SSL_OP_ALL
operator||
name|SSL_OP_NO_SSLv2
expr_stmt|;
else|else
name|options
operator|=
name|SSL_OP_ALL
expr_stmt|;
comment|// This option is disabled by default, so we need to be able to clear it
if|if
condition|(
name|sslOptions
operator|&
name|QSsl
operator|::
name|SslOptionDisableEmptyFragments
condition|)
name|options
operator||=
name|SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS
expr_stmt|;
else|else
name|options
operator|&=
operator|~
name|SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS
expr_stmt|;
ifdef|#
directive|ifdef
name|SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION
comment|// This option is disabled by default, so we need to be able to clear it
if|if
condition|(
name|sslOptions
operator|&
name|QSsl
operator|::
name|SslOptionDisableLegacyRenegotiation
condition|)
name|options
operator|&=
operator|~
name|SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION
expr_stmt|;
else|else
name|options
operator||=
name|SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SSL_OP_NO_TICKET
if|if
condition|(
name|sslOptions
operator|&
name|QSsl
operator|::
name|SslOptionDisableSessionTickets
condition|)
name|options
operator||=
name|SSL_OP_NO_TICKET
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SSL_OP_NO_COMPRESSION
if|if
condition|(
name|sslOptions
operator|&
name|QSsl
operator|::
name|SslOptionDisableCompression
condition|)
name|options
operator||=
name|SSL_OP_NO_COMPRESSION
expr_stmt|;
endif|#
directive|endif
return|return
name|options
return|;
block|}
end_function
begin_function
DECL|function|initSslContext
name|bool
name|QSslSocketBackendPrivate
operator|::
name|initSslContext
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QSslSocket
argument_list|)
expr_stmt|;
comment|// If no external context was set (e.g. bei QHttpNetworkConnection) we will create a default context
if|if
condition|(
operator|!
name|sslContextPointer
condition|)
block|{
comment|// create a deep copy of our configuration
name|QSslConfigurationPrivate
modifier|*
name|configurationCopy
init|=
operator|new
name|QSslConfigurationPrivate
argument_list|(
name|configuration
argument_list|)
decl_stmt|;
name|configurationCopy
operator|->
name|ref
operator|.
name|store
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|// the QSslConfiguration constructor refs up
name|sslContextPointer
operator|=
name|QSharedPointer
argument_list|<
name|QSslContext
argument_list|>
argument_list|(
name|QSslContext
operator|::
name|fromConfiguration
argument_list|(
name|mode
argument_list|,
name|configurationCopy
argument_list|,
name|allowRootCertOnDemandLoading
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sslContextPointer
operator|->
name|error
argument_list|()
operator|!=
name|QSslError
operator|::
name|NoError
condition|)
block|{
name|q
operator|->
name|setErrorString
argument_list|(
name|sslContextPointer
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
name|q
operator|->
name|setSocketError
argument_list|(
name|QAbstractSocket
operator|::
name|SslInvalidUserDataError
argument_list|)
expr_stmt|;
emit|emit
name|q
operator|->
name|error
argument_list|(
name|QAbstractSocket
operator|::
name|SslInvalidUserDataError
argument_list|)
emit|;
name|sslContextPointer
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// deletes the QSslContext
return|return
literal|false
return|;
block|}
comment|// Create and initialize SSL session
if|if
condition|(
operator|!
operator|(
name|ssl
operator|=
name|sslContextPointer
operator|->
name|createSsl
argument_list|()
operator|)
condition|)
block|{
comment|// ### Bad error code
name|q
operator|->
name|setErrorString
argument_list|(
name|QSslSocket
operator|::
name|tr
argument_list|(
literal|"Error creating SSL session, %1"
argument_list|)
operator|.
name|arg
argument_list|(
name|getErrorsFromOpenSsl
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|->
name|setSocketError
argument_list|(
name|QAbstractSocket
operator|::
name|SslInternalError
argument_list|)
expr_stmt|;
emit|emit
name|q
operator|->
name|error
argument_list|(
name|QAbstractSocket
operator|::
name|SslInternalError
argument_list|)
emit|;
return|return
literal|false
return|;
block|}
if|#
directive|if
name|OPENSSL_VERSION_NUMBER
operator|>=
literal|0x0090806fL
operator|&&
operator|!
name|defined
argument_list|(
name|OPENSSL_NO_TLSEXT
argument_list|)
if|if
condition|(
operator|(
name|configuration
operator|.
name|protocol
operator|==
name|QSsl
operator|::
name|TlsV1SslV3
operator|||
name|configuration
operator|.
name|protocol
operator|==
name|QSsl
operator|::
name|TlsV1_0
operator|||
name|configuration
operator|.
name|protocol
operator|==
name|QSsl
operator|::
name|TlsV1_1
operator|||
name|configuration
operator|.
name|protocol
operator|==
name|QSsl
operator|::
name|TlsV1_2
operator|||
name|configuration
operator|.
name|protocol
operator|==
name|QSsl
operator|::
name|SecureProtocols
operator|||
name|configuration
operator|.
name|protocol
operator|==
name|QSsl
operator|::
name|AnyProtocol
operator|)
operator|&&
name|mode
operator|==
name|QSslSocket
operator|::
name|SslClientMode
operator|&&
name|q_SSLeay
argument_list|()
operator|>=
literal|0x00090806fL
condition|)
block|{
comment|// Set server hostname on TLS extension. RFC4366 section 3.1 requires it in ACE format.
name|QString
name|tlsHostName
init|=
name|verificationPeerName
operator|.
name|isEmpty
argument_list|()
condition|?
name|q
operator|->
name|peerName
argument_list|()
else|:
name|verificationPeerName
decl_stmt|;
if|if
condition|(
name|tlsHostName
operator|.
name|isEmpty
argument_list|()
condition|)
name|tlsHostName
operator|=
name|hostName
expr_stmt|;
name|QByteArray
name|ace
init|=
name|QUrl
operator|::
name|toAce
argument_list|(
name|tlsHostName
argument_list|)
decl_stmt|;
comment|// only send the SNI header if the URL is valid and not an IP
if|if
condition|(
operator|!
name|ace
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|QHostAddress
argument_list|()
operator|.
name|setAddress
argument_list|(
name|tlsHostName
argument_list|)
operator|&&
operator|!
operator|(
name|configuration
operator|.
name|sslOptions
operator|&
name|QSsl
operator|::
name|SslOptionDisableServerNameIndication
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|q_SSL_ctrl
argument_list|(
name|ssl
argument_list|,
name|SSL_CTRL_SET_TLSEXT_HOSTNAME
argument_list|,
name|TLSEXT_NAMETYPE_host_name
argument_list|,
name|ace
operator|.
name|data
argument_list|()
argument_list|)
condition|)
name|qWarning
argument_list|(
literal|"could not set SSL_CTRL_SET_TLSEXT_HOSTNAME, Server Name Indication disabled"
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|// Clear the session.
name|errorList
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// Initialize memory BIOs for encryption and decryption.
name|readBio
operator|=
name|q_BIO_new
argument_list|(
name|q_BIO_s_mem
argument_list|()
argument_list|)
expr_stmt|;
name|writeBio
operator|=
name|q_BIO_new
argument_list|(
name|q_BIO_s_mem
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|readBio
operator|||
operator|!
name|writeBio
condition|)
block|{
name|q
operator|->
name|setErrorString
argument_list|(
name|QSslSocket
operator|::
name|tr
argument_list|(
literal|"Error creating SSL session: %1"
argument_list|)
operator|.
name|arg
argument_list|(
name|getErrorsFromOpenSsl
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|->
name|setSocketError
argument_list|(
name|QAbstractSocket
operator|::
name|SslInternalError
argument_list|)
expr_stmt|;
emit|emit
name|q
operator|->
name|error
argument_list|(
name|QAbstractSocket
operator|::
name|SslInternalError
argument_list|)
emit|;
return|return
literal|false
return|;
block|}
comment|// Assign the bios.
name|q_SSL_set_bio
argument_list|(
name|ssl
argument_list|,
name|readBio
argument_list|,
name|writeBio
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|QSslSocket
operator|::
name|SslClientMode
condition|)
name|q_SSL_set_connect_state
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
else|else
name|q_SSL_set_accept_state
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|destroySslContext
name|void
name|QSslSocketBackendPrivate
operator|::
name|destroySslContext
parameter_list|()
block|{
if|if
condition|(
name|ssl
condition|)
block|{
name|q_SSL_free
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
name|ssl
operator|=
literal|0
expr_stmt|;
block|}
name|sslContextPointer
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|deinitialize
name|void
name|QSslSocketPrivate
operator|::
name|deinitialize
parameter_list|()
block|{
name|q_CRYPTO_set_id_callback
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|q_CRYPTO_set_locking_callback
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|q_ERR_free_strings
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal      Does the minimum amount of initialization to determine whether SSL     is supported or not. */
end_comment
begin_function
DECL|function|supportsSsl
name|bool
name|QSslSocketPrivate
operator|::
name|supportsSsl
parameter_list|()
block|{
return|return
name|ensureLibraryLoaded
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|ensureLibraryLoaded
name|bool
name|QSslSocketPrivate
operator|::
name|ensureLibraryLoaded
parameter_list|()
block|{
if|if
condition|(
operator|!
name|q_resolveOpenSslSymbols
argument_list|()
condition|)
return|return
literal|false
return|;
comment|// Check if the library itself needs to be initialized.
name|QMutexLocker
name|locker
argument_list|(
name|openssl_locks
argument_list|()
operator|->
name|initLock
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|s_libraryLoaded
condition|)
block|{
name|s_libraryLoaded
operator|=
literal|true
expr_stmt|;
comment|// Initialize OpenSSL.
name|q_CRYPTO_set_id_callback
argument_list|(
name|id_function
argument_list|)
expr_stmt|;
name|q_CRYPTO_set_locking_callback
argument_list|(
name|locking_function
argument_list|)
expr_stmt|;
if|if
condition|(
name|q_SSL_library_init
argument_list|()
operator|!=
literal|1
condition|)
return|return
literal|false
return|;
name|q_SSL_load_error_strings
argument_list|()
expr_stmt|;
name|q_OpenSSL_add_all_algorithms
argument_list|()
expr_stmt|;
comment|// Initialize OpenSSL's random seed.
if|if
condition|(
operator|!
name|q_RAND_status
argument_list|()
condition|)
block|{
struct|struct
block|{
name|int
name|msec
decl_stmt|;
name|int
name|sec
decl_stmt|;
name|void
modifier|*
name|stack
decl_stmt|;
block|}
name|randomish
struct|;
name|int
name|attempts
init|=
literal|500
decl_stmt|;
do|do
block|{
if|if
condition|(
name|attempts
operator|<
literal|500
condition|)
block|{
ifdef|#
directive|ifdef
name|Q_OS_UNIX
name|struct
name|timespec
name|ts
init|=
block|{
literal|0
block|,
literal|33333333
block|}
decl_stmt|;
name|nanosleep
argument_list|(
operator|&
name|ts
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|Sleep
argument_list|(
literal|3
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|randomish
operator|.
name|msec
operator|=
name|attempts
expr_stmt|;
block|}
name|randomish
operator|.
name|stack
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|randomish
expr_stmt|;
name|randomish
operator|.
name|msec
operator|=
name|QTime
operator|::
name|currentTime
argument_list|()
operator|.
name|msec
argument_list|()
expr_stmt|;
name|randomish
operator|.
name|sec
operator|=
name|QTime
operator|::
name|currentTime
argument_list|()
operator|.
name|second
argument_list|()
expr_stmt|;
name|q_RAND_seed
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
operator|&
name|randomish
argument_list|,
sizeof|sizeof
argument_list|(
name|randomish
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|q_RAND_status
argument_list|()
operator|&&
operator|--
name|attempts
condition|)
do|;
if|if
condition|(
operator|!
name|attempts
condition|)
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|ensureCiphersAndCertsLoaded
name|void
name|QSslSocketPrivate
operator|::
name|ensureCiphersAndCertsLoaded
parameter_list|()
block|{
name|QMutexLocker
name|locker
argument_list|(
name|openssl_locks
argument_list|()
operator|->
name|initLock
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|s_loadedCiphersAndCerts
condition|)
return|return;
name|s_loadedCiphersAndCerts
operator|=
literal|true
expr_stmt|;
name|resetDefaultCiphers
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_LIBRARY
comment|//load symbols needed to receive certificates from system store
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_MACX
argument_list|)
name|QLibrary
name|securityLib
argument_list|(
literal|"/System/Library/Frameworks/Security.framework/Versions/Current/Security"
argument_list|)
decl_stmt|;
if|if
condition|(
name|securityLib
operator|.
name|load
argument_list|()
condition|)
block|{
name|ptrSecCertificateCopyData
operator|=
operator|(
name|PtrSecCertificateCopyData
operator|)
name|securityLib
operator|.
name|resolve
argument_list|(
literal|"SecCertificateCopyData"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptrSecCertificateCopyData
condition|)
name|qWarning
argument_list|(
literal|"could not resolve symbols in security library"
argument_list|)
expr_stmt|;
comment|// should never happen
name|ptrSecTrustSettingsCopyCertificates
operator|=
operator|(
name|PtrSecTrustSettingsCopyCertificates
operator|)
name|securityLib
operator|.
name|resolve
argument_list|(
literal|"SecTrustSettingsCopyCertificates"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptrSecTrustSettingsCopyCertificates
condition|)
block|{
comment|// method was introduced in Leopard, use legacy method if it's not there
name|ptrSecTrustCopyAnchorCertificates
operator|=
operator|(
name|PtrSecTrustCopyAnchorCertificates
operator|)
name|securityLib
operator|.
name|resolve
argument_list|(
literal|"SecTrustCopyAnchorCertificates"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptrSecTrustCopyAnchorCertificates
condition|)
name|qWarning
argument_list|(
literal|"could not resolve symbols in security library"
argument_list|)
expr_stmt|;
comment|// should never happen
block|}
block|}
else|else
block|{
name|qWarning
argument_list|(
literal|"could not load security library"
argument_list|)
expr_stmt|;
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
name|HINSTANCE
name|hLib
init|=
name|LoadLibraryW
argument_list|(
literal|L"Crypt32"
argument_list|)
decl_stmt|;
if|if
condition|(
name|hLib
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
name|ptrCertOpenSystemStoreW
operator|=
operator|(
name|PtrCertOpenSystemStoreW
operator|)
name|GetProcAddress
argument_list|(
name|hLib
argument_list|,
literal|L"CertOpenStore"
argument_list|)
expr_stmt|;
name|ptrCertFindCertificateInStore
operator|=
operator|(
name|PtrCertFindCertificateInStore
operator|)
name|GetProcAddress
argument_list|(
name|hLib
argument_list|,
literal|L"CertFindCertificateInStore"
argument_list|)
expr_stmt|;
name|ptrCertCloseStore
operator|=
operator|(
name|PtrCertCloseStore
operator|)
name|GetProcAddress
argument_list|(
name|hLib
argument_list|,
literal|L"CertCloseStore"
argument_list|)
expr_stmt|;
else|#
directive|else
name|ptrCertOpenSystemStoreW
operator|=
operator|(
name|PtrCertOpenSystemStoreW
operator|)
name|GetProcAddress
argument_list|(
name|hLib
argument_list|,
literal|"CertOpenSystemStoreW"
argument_list|)
expr_stmt|;
name|ptrCertFindCertificateInStore
operator|=
operator|(
name|PtrCertFindCertificateInStore
operator|)
name|GetProcAddress
argument_list|(
name|hLib
argument_list|,
literal|"CertFindCertificateInStore"
argument_list|)
expr_stmt|;
name|ptrCertCloseStore
operator|=
operator|(
name|PtrCertCloseStore
operator|)
name|GetProcAddress
argument_list|(
name|hLib
argument_list|,
literal|"CertCloseStore"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|ptrCertOpenSystemStoreW
operator|||
operator|!
name|ptrCertFindCertificateInStore
operator|||
operator|!
name|ptrCertCloseStore
condition|)
name|qWarning
argument_list|(
literal|"could not resolve symbols in crypt32 library"
argument_list|)
expr_stmt|;
comment|// should never happen
block|}
else|else
block|{
name|qWarning
argument_list|(
literal|"could not load crypt32 library"
argument_list|)
expr_stmt|;
comment|// should never happen
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_QNX
argument_list|)
name|s_loadRootCertsOnDemand
operator|=
literal|true
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_UNIX
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_MAC
argument_list|)
comment|// check whether we can enable on-demand root-cert loading (i.e. check whether the sym links are there)
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|dirs
init|=
name|unixRootCertDirectories
argument_list|()
decl_stmt|;
name|QStringList
name|symLinkFilter
decl_stmt|;
name|symLinkFilter
operator|<<
name|QLatin1String
argument_list|(
literal|"[0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f].[0-9]"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|a
init|=
literal|0
init|;
name|a
operator|<
name|dirs
operator|.
name|count
argument_list|()
condition|;
operator|++
name|a
control|)
block|{
name|QDirIterator
name|iterator
argument_list|(
name|QLatin1String
argument_list|(
name|dirs
operator|.
name|at
argument_list|(
name|a
argument_list|)
argument_list|)
argument_list|,
name|symLinkFilter
argument_list|,
name|QDir
operator|::
name|Files
argument_list|)
decl_stmt|;
if|if
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|s_loadRootCertsOnDemand
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
endif|#
directive|endif
endif|#
directive|endif
comment|//QT_NO_LIBRARY
comment|// if on-demand loading was not enabled, load the certs now
if|if
condition|(
operator|!
name|s_loadRootCertsOnDemand
condition|)
name|setDefaultCaCertificates
argument_list|(
name|systemCaCertificates
argument_list|()
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_WIN
comment|//Enabled for fetching additional root certs from windows update on windows 6+
comment|//This flag is set false by setDefaultCaCertificates() indicating the app uses
comment|//its own cert bundle rather than the system one.
comment|//Same logic that disables the unix on demand cert loading.
comment|//Unlike unix, we do preload the certificates from the cert store.
if|if
condition|(
operator|(
name|QSysInfo
operator|::
name|windowsVersion
argument_list|()
operator|&
name|QSysInfo
operator|::
name|WV_NT_based
operator|)
operator|>=
name|QSysInfo
operator|::
name|WV_6_0
condition|)
name|s_loadRootCertsOnDemand
operator|=
literal|true
expr_stmt|;
endif|#
directive|endif
block|}
end_function
begin_comment
comment|/*!     \internal      Declared static in QSslSocketPrivate, makes sure the SSL libraries have     been initialized. */
end_comment
begin_function
DECL|function|ensureInitialized
name|void
name|QSslSocketPrivate
operator|::
name|ensureInitialized
parameter_list|()
block|{
if|if
condition|(
operator|!
name|supportsSsl
argument_list|()
condition|)
return|return;
name|ensureCiphersAndCertsLoaded
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|sslLibraryVersionNumber
name|long
name|QSslSocketPrivate
operator|::
name|sslLibraryVersionNumber
parameter_list|()
block|{
if|if
condition|(
operator|!
name|supportsSsl
argument_list|()
condition|)
return|return
literal|0
return|;
return|return
name|q_SSLeay
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|sslLibraryVersionString
name|QString
name|QSslSocketPrivate
operator|::
name|sslLibraryVersionString
parameter_list|()
block|{
if|if
condition|(
operator|!
name|supportsSsl
argument_list|()
condition|)
return|return
name|QString
argument_list|()
return|;
specifier|const
name|char
modifier|*
name|versionString
init|=
name|q_SSLeay_version
argument_list|(
name|SSLEAY_VERSION
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|versionString
condition|)
return|return
name|QString
argument_list|()
return|;
return|return
name|QString
operator|::
name|fromLatin1
argument_list|(
name|versionString
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|sslLibraryBuildVersionNumber
name|long
name|QSslSocketPrivate
operator|::
name|sslLibraryBuildVersionNumber
parameter_list|()
block|{
return|return
name|OPENSSL_VERSION_NUMBER
return|;
block|}
end_function
begin_function
DECL|function|sslLibraryBuildVersionString
name|QString
name|QSslSocketPrivate
operator|::
name|sslLibraryBuildVersionString
parameter_list|()
block|{
return|return
name|QLatin1String
argument_list|(
name|OPENSSL_VERSION_TEXT
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      Declared static in QSslSocketPrivate, backend-dependent loading of     application-wide global ciphers. */
end_comment
begin_function
DECL|function|resetDefaultCiphers
name|void
name|QSslSocketPrivate
operator|::
name|resetDefaultCiphers
parameter_list|()
block|{
name|SSL_CTX
modifier|*
name|myCtx
init|=
name|q_SSL_CTX_new
argument_list|(
name|q_SSLv23_client_method
argument_list|()
argument_list|)
decl_stmt|;
name|SSL
modifier|*
name|mySsl
init|=
name|q_SSL_new
argument_list|(
name|myCtx
argument_list|)
decl_stmt|;
name|QList
argument_list|<
name|QSslCipher
argument_list|>
name|ciphers
decl_stmt|;
name|QList
argument_list|<
name|QSslCipher
argument_list|>
name|defaultCiphers
decl_stmt|;
name|STACK_OF
argument_list|(
name|SSL_CIPHER
argument_list|)
operator|*
name|supportedCiphers
operator|=
name|q_SSL_get_ciphers
argument_list|(
name|mySsl
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|q_sk_SSL_CIPHER_num
argument_list|(
name|supportedCiphers
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|SSL_CIPHER
modifier|*
name|cipher
init|=
name|q_sk_SSL_CIPHER_value
argument_list|(
name|supportedCiphers
argument_list|,
name|i
argument_list|)
condition|)
block|{
if|if
condition|(
name|cipher
operator|->
name|valid
condition|)
block|{
name|QSslCipher
name|ciph
init|=
name|QSslSocketBackendPrivate
operator|::
name|QSslCipher_from_SSL_CIPHER
argument_list|(
name|cipher
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ciph
operator|.
name|isNull
argument_list|()
condition|)
block|{
comment|// Unconditionally exclude ADH ciphers since they offer no MITM protection
if|if
condition|(
operator|!
name|ciph
operator|.
name|name
argument_list|()
operator|.
name|toLower
argument_list|()
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"adh"
argument_list|)
argument_list|)
condition|)
name|ciphers
operator|<<
name|ciph
expr_stmt|;
if|if
condition|(
name|ciph
operator|.
name|usedBits
argument_list|()
operator|>=
literal|128
condition|)
name|defaultCiphers
operator|<<
name|ciph
expr_stmt|;
block|}
block|}
block|}
block|}
name|q_SSL_CTX_free
argument_list|(
name|myCtx
argument_list|)
expr_stmt|;
name|q_SSL_free
argument_list|(
name|mySsl
argument_list|)
expr_stmt|;
name|setDefaultSupportedCiphers
argument_list|(
name|ciphers
argument_list|)
expr_stmt|;
name|setDefaultCiphers
argument_list|(
name|defaultCiphers
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|systemCaCertificates
name|QList
argument_list|<
name|QSslCertificate
argument_list|>
name|QSslSocketPrivate
operator|::
name|systemCaCertificates
parameter_list|()
block|{
name|ensureInitialized
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|QSSLSOCKET_DEBUG
name|QElapsedTimer
name|timer
decl_stmt|;
name|timer
operator|.
name|start
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|QList
argument_list|<
name|QSslCertificate
argument_list|>
name|systemCerts
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_MACX
argument_list|)
name|CFArrayRef
name|cfCerts
decl_stmt|;
name|OSStatus
name|status
init|=
literal|1
decl_stmt|;
name|CFDataRef
name|SecCertificateCopyData
argument_list|(
name|SecCertificateRef
name|certificate
argument_list|)
decl_stmt|;
if|if
condition|(
name|ptrSecCertificateCopyData
condition|)
block|{
if|if
condition|(
name|ptrSecTrustSettingsCopyCertificates
condition|)
name|status
operator|=
name|ptrSecTrustSettingsCopyCertificates
argument_list|(
name|kSecTrustSettingsDomainSystem
argument_list|,
operator|&
name|cfCerts
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ptrSecTrustCopyAnchorCertificates
condition|)
name|status
operator|=
name|ptrSecTrustCopyAnchorCertificates
argument_list|(
operator|&
name|cfCerts
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|status
condition|)
block|{
name|CFIndex
name|size
init|=
name|CFArrayGetCount
argument_list|(
name|cfCerts
argument_list|)
decl_stmt|;
for|for
control|(
name|CFIndex
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
operator|++
name|i
control|)
block|{
name|SecCertificateRef
name|cfCert
init|=
operator|(
name|SecCertificateRef
operator|)
name|CFArrayGetValueAtIndex
argument_list|(
name|cfCerts
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|CFDataRef
name|data
decl_stmt|;
name|data
operator|=
name|ptrSecCertificateCopyData
argument_list|(
name|cfCert
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
block|{
name|qWarning
argument_list|(
literal|"error retrieving a CA certificate from the system store"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QByteArray
name|rawCert
init|=
name|QByteArray
operator|::
name|fromRawData
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|CFDataGetBytePtr
argument_list|(
name|data
argument_list|)
argument_list|,
name|CFDataGetLength
argument_list|(
name|data
argument_list|)
argument_list|)
decl_stmt|;
name|systemCerts
operator|.
name|append
argument_list|(
name|QSslCertificate
operator|::
name|fromData
argument_list|(
name|rawCert
argument_list|,
name|QSsl
operator|::
name|Der
argument_list|)
argument_list|)
expr_stmt|;
name|CFRelease
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
block|}
name|CFRelease
argument_list|(
name|cfCerts
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// no detailed error handling here
name|qWarning
argument_list|(
literal|"could not retrieve system CA certificates"
argument_list|)
expr_stmt|;
block|}
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
if|if
condition|(
name|ptrCertOpenSystemStoreW
operator|&&
name|ptrCertFindCertificateInStore
operator|&&
name|ptrCertCloseStore
condition|)
block|{
name|HCERTSTORE
name|hSystemStore
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
name|hSystemStore
operator|=
name|ptrCertOpenSystemStoreW
argument_list|(
name|CERT_STORE_PROV_SYSTEM_W
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|CERT_STORE_NO_CRYPT_RELEASE_FLAG
operator||
name|CERT_SYSTEM_STORE_CURRENT_USER
argument_list|,
literal|L"ROOT"
argument_list|)
expr_stmt|;
else|#
directive|else
name|hSystemStore
operator|=
name|ptrCertOpenSystemStoreW
argument_list|(
literal|0
argument_list|,
literal|L"ROOT"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|hSystemStore
condition|)
block|{
name|PCCERT_CONTEXT
name|pc
init|=
name|NULL
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|pc
operator|=
name|ptrCertFindCertificateInStore
argument_list|(
name|hSystemStore
argument_list|,
name|X509_ASN_ENCODING
argument_list|,
literal|0
argument_list|,
name|CERT_FIND_ANY
argument_list|,
name|NULL
argument_list|,
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pc
condition|)
break|break;
name|QByteArray
name|der
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
operator|(
name|pc
operator|->
name|pbCertEncoded
operator|)
argument_list|,
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|pc
operator|->
name|cbCertEncoded
argument_list|)
argument_list|)
decl_stmt|;
name|QSslCertificate
name|cert
argument_list|(
name|der
argument_list|,
name|QSsl
operator|::
name|Der
argument_list|)
decl_stmt|;
name|systemCerts
operator|.
name|append
argument_list|(
name|cert
argument_list|)
expr_stmt|;
block|}
name|ptrCertCloseStore
argument_list|(
name|hSystemStore
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_UNIX
argument_list|)
name|QSet
argument_list|<
name|QString
argument_list|>
name|certFiles
decl_stmt|;
name|QDir
name|currentDir
decl_stmt|;
name|QStringList
name|nameFilters
decl_stmt|;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|directories
decl_stmt|;
name|QSsl
operator|::
name|EncodingFormat
name|platformEncodingFormat
decl_stmt|;
ifndef|#
directive|ifndef
name|Q_OS_ANDROID
name|directories
operator|=
name|unixRootCertDirectories
argument_list|()
expr_stmt|;
name|nameFilters
operator|<<
name|QLatin1String
argument_list|(
literal|"*.pem"
argument_list|)
operator|<<
name|QLatin1String
argument_list|(
literal|"*.crt"
argument_list|)
expr_stmt|;
name|platformEncodingFormat
operator|=
name|QSsl
operator|::
name|Pem
expr_stmt|;
else|#
directive|else
comment|// Q_OS_ANDROID
name|QByteArray
name|ministroPath
init|=
name|qgetenv
argument_list|(
literal|"MINISTRO_SSL_CERTS_PATH"
argument_list|)
decl_stmt|;
comment|// Set by Ministro
name|directories
operator|<<
name|ministroPath
expr_stmt|;
name|nameFilters
operator|<<
name|QLatin1String
argument_list|(
literal|"*.der"
argument_list|)
expr_stmt|;
name|platformEncodingFormat
operator|=
name|QSsl
operator|::
name|Der
expr_stmt|;
ifndef|#
directive|ifndef
name|Q_OS_ANDROID_NO_SDK
if|if
condition|(
name|ministroPath
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|certificateData
init|=
name|fetchSslCertificateData
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|certificateData
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|systemCerts
operator|.
name|append
argument_list|(
name|QSslCertificate
operator|::
name|fromData
argument_list|(
name|certificateData
operator|.
name|at
argument_list|(
name|i
argument_list|)
argument_list|,
name|QSsl
operator|::
name|Der
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
comment|//Q_OS_ANDROID_NO_SDK
endif|#
directive|endif
comment|//Q_OS_ANDROID
block|{
name|currentDir
operator|.
name|setNameFilters
argument_list|(
name|nameFilters
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|a
init|=
literal|0
init|;
name|a
operator|<
name|directories
operator|.
name|count
argument_list|()
condition|;
name|a
operator|++
control|)
block|{
name|currentDir
operator|.
name|setPath
argument_list|(
name|QLatin1String
argument_list|(
name|directories
operator|.
name|at
argument_list|(
name|a
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|QDirIterator
name|it
argument_list|(
name|currentDir
argument_list|)
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|it
operator|.
name|next
argument_list|()
expr_stmt|;
comment|// use canonical path here to not load the same certificate twice if symlinked
name|certFiles
operator|.
name|insert
argument_list|(
name|it
operator|.
name|fileInfo
argument_list|()
operator|.
name|canonicalFilePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|QSetIterator
argument_list|<
name|QString
argument_list|>
name|it
argument_list|(
name|certFiles
argument_list|)
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
name|systemCerts
operator|.
name|append
argument_list|(
name|QSslCertificate
operator|::
name|fromPath
argument_list|(
name|it
operator|.
name|next
argument_list|()
argument_list|,
name|platformEncodingFormat
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|Q_OS_ANDROID
name|systemCerts
operator|.
name|append
argument_list|(
name|QSslCertificate
operator|::
name|fromPath
argument_list|(
name|QLatin1String
argument_list|(
literal|"/etc/pki/tls/certs/ca-bundle.crt"
argument_list|)
argument_list|,
name|QSsl
operator|::
name|Pem
argument_list|)
argument_list|)
expr_stmt|;
comment|// Fedora, Mandriva
name|systemCerts
operator|.
name|append
argument_list|(
name|QSslCertificate
operator|::
name|fromPath
argument_list|(
name|QLatin1String
argument_list|(
literal|"/usr/local/share/certs/ca-root-nss.crt"
argument_list|)
argument_list|,
name|QSsl
operator|::
name|Pem
argument_list|)
argument_list|)
expr_stmt|;
comment|// FreeBSD's ca_root_nss
endif|#
directive|endif
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|QSSLSOCKET_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"systemCaCertificates retrieval time "
operator|<<
name|timer
operator|.
name|elapsed
argument_list|()
operator|<<
literal|"ms"
expr_stmt|;
name|qDebug
argument_list|()
operator|<<
literal|"imported "
operator|<<
name|systemCerts
operator|.
name|count
argument_list|()
operator|<<
literal|" certificates"
expr_stmt|;
endif|#
directive|endif
return|return
name|systemCerts
return|;
block|}
end_function
begin_function
DECL|function|startClientEncryption
name|void
name|QSslSocketBackendPrivate
operator|::
name|startClientEncryption
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QSslSocket
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|initSslContext
argument_list|()
condition|)
block|{
name|q
operator|->
name|setErrorString
argument_list|(
name|QSslSocket
operator|::
name|tr
argument_list|(
literal|"Unable to init SSL Context: %1"
argument_list|)
operator|.
name|arg
argument_list|(
name|getErrorsFromOpenSsl
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|->
name|setSocketError
argument_list|(
name|QAbstractSocket
operator|::
name|SslInternalError
argument_list|)
expr_stmt|;
emit|emit
name|q
operator|->
name|error
argument_list|(
name|QAbstractSocket
operator|::
name|SslInternalError
argument_list|)
emit|;
return|return;
block|}
comment|// Start connecting. This will place outgoing data in the BIO, so we
comment|// follow up with calling transmit().
name|startHandshake
argument_list|()
expr_stmt|;
name|transmit
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|startServerEncryption
name|void
name|QSslSocketBackendPrivate
operator|::
name|startServerEncryption
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QSslSocket
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|initSslContext
argument_list|()
condition|)
block|{
name|q
operator|->
name|setErrorString
argument_list|(
name|QSslSocket
operator|::
name|tr
argument_list|(
literal|"Unable to init SSL Context: %1"
argument_list|)
operator|.
name|arg
argument_list|(
name|getErrorsFromOpenSsl
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|->
name|setSocketError
argument_list|(
name|QAbstractSocket
operator|::
name|SslInternalError
argument_list|)
expr_stmt|;
emit|emit
name|q
operator|->
name|error
argument_list|(
name|QAbstractSocket
operator|::
name|SslInternalError
argument_list|)
emit|;
return|return;
block|}
comment|// Start connecting. This will place outgoing data in the BIO, so we
comment|// follow up with calling transmit().
name|startHandshake
argument_list|()
expr_stmt|;
name|transmit
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal      Transmits encrypted data between the BIOs and the socket. */
end_comment
begin_function
DECL|function|transmit
name|void
name|QSslSocketBackendPrivate
operator|::
name|transmit
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QSslSocket
argument_list|)
expr_stmt|;
comment|// If we don't have any SSL context, don't bother transmitting.
if|if
condition|(
operator|!
name|ssl
condition|)
return|return;
name|bool
name|transmitting
decl_stmt|;
do|do
block|{
name|transmitting
operator|=
literal|false
expr_stmt|;
comment|// If the connection is secure, we can transfer data from the write
comment|// buffer (in plain text) to the write BIO through SSL_write.
if|if
condition|(
name|connectionEncrypted
operator|&&
operator|!
name|writeBuffer
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|qint64
name|totalBytesWritten
init|=
literal|0
decl_stmt|;
name|int
name|nextDataBlockSize
decl_stmt|;
while|while
condition|(
operator|(
name|nextDataBlockSize
operator|=
name|writeBuffer
operator|.
name|nextDataBlockSize
argument_list|()
operator|)
operator|>
literal|0
condition|)
block|{
name|int
name|writtenBytes
init|=
name|q_SSL_write
argument_list|(
name|ssl
argument_list|,
name|writeBuffer
operator|.
name|readPointer
argument_list|()
argument_list|,
name|nextDataBlockSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|writtenBytes
operator|<=
literal|0
condition|)
block|{
name|int
name|error
init|=
name|q_SSL_get_error
argument_list|(
name|ssl
argument_list|,
name|writtenBytes
argument_list|)
decl_stmt|;
comment|//write can result in a want_write_error - not an error - continue transmitting
if|if
condition|(
name|error
operator|==
name|SSL_ERROR_WANT_WRITE
condition|)
block|{
name|transmitting
operator|=
literal|true
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|error
operator|==
name|SSL_ERROR_WANT_READ
condition|)
block|{
comment|//write can result in a want_read error, possibly due to renegotiation - not an error - stop transmitting
name|transmitting
operator|=
literal|false
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|// ### Better error handling.
name|q
operator|->
name|setErrorString
argument_list|(
name|QSslSocket
operator|::
name|tr
argument_list|(
literal|"Unable to write data: %1"
argument_list|)
operator|.
name|arg
argument_list|(
name|getErrorsFromOpenSsl
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|->
name|setSocketError
argument_list|(
name|QAbstractSocket
operator|::
name|SslInternalError
argument_list|)
expr_stmt|;
emit|emit
name|q
operator|->
name|error
argument_list|(
name|QAbstractSocket
operator|::
name|SslInternalError
argument_list|)
emit|;
return|return;
block|}
block|}
ifdef|#
directive|ifdef
name|QSSLSOCKET_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QSslSocketBackendPrivate::transmit: encrypted"
operator|<<
name|writtenBytes
operator|<<
literal|"bytes"
expr_stmt|;
endif|#
directive|endif
name|writeBuffer
operator|.
name|free
argument_list|(
name|writtenBytes
argument_list|)
expr_stmt|;
name|totalBytesWritten
operator|+=
name|writtenBytes
expr_stmt|;
if|if
condition|(
name|writtenBytes
operator|<
name|nextDataBlockSize
condition|)
block|{
comment|// break out of the writing loop and try again after we had read
name|transmitting
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|totalBytesWritten
operator|>
literal|0
condition|)
block|{
comment|// Don't emit bytesWritten() recursively.
if|if
condition|(
operator|!
name|emittedBytesWritten
condition|)
block|{
name|emittedBytesWritten
operator|=
literal|true
expr_stmt|;
emit|emit
name|q
operator|->
name|bytesWritten
argument_list|(
name|totalBytesWritten
argument_list|)
emit|;
name|emittedBytesWritten
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
comment|// Check if we've got any data to be written to the socket.
name|QVarLengthArray
argument_list|<
name|char
argument_list|,
literal|4096
argument_list|>
name|data
decl_stmt|;
name|int
name|pendingBytes
decl_stmt|;
while|while
condition|(
name|plainSocket
operator|->
name|isValid
argument_list|()
operator|&&
operator|(
name|pendingBytes
operator|=
name|q_BIO_pending
argument_list|(
name|writeBio
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
comment|// Read encrypted data from the write BIO into a buffer.
name|data
operator|.
name|resize
argument_list|(
name|pendingBytes
argument_list|)
expr_stmt|;
name|int
name|encryptedBytesRead
init|=
name|q_BIO_read
argument_list|(
name|writeBio
argument_list|,
name|data
operator|.
name|data
argument_list|()
argument_list|,
name|pendingBytes
argument_list|)
decl_stmt|;
comment|// Write encrypted data from the buffer to the socket.
name|qint64
name|actualWritten
init|=
name|plainSocket
operator|->
name|write
argument_list|(
name|data
operator|.
name|constData
argument_list|()
argument_list|,
name|encryptedBytesRead
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|QSSLSOCKET_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QSslSocketBackendPrivate::transmit: wrote"
operator|<<
name|encryptedBytesRead
operator|<<
literal|"encrypted bytes to the socket"
operator|<<
name|actualWritten
operator|<<
literal|"actual."
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|actualWritten
operator|<
literal|0
condition|)
block|{
comment|//plain socket write fails if it was in the pending close state.
name|q
operator|->
name|setErrorString
argument_list|(
name|plainSocket
operator|->
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
name|q
operator|->
name|setSocketError
argument_list|(
name|plainSocket
operator|->
name|error
argument_list|()
argument_list|)
expr_stmt|;
emit|emit
name|q
operator|->
name|error
argument_list|(
name|plainSocket
operator|->
name|error
argument_list|()
argument_list|)
emit|;
return|return;
block|}
name|transmitting
operator|=
literal|true
expr_stmt|;
block|}
comment|// Check if we've got any data to be read from the socket.
if|if
condition|(
operator|!
name|connectionEncrypted
operator|||
operator|!
name|readBufferMaxSize
operator|||
name|buffer
operator|.
name|size
argument_list|()
operator|<
name|readBufferMaxSize
condition|)
while|while
condition|(
operator|(
name|pendingBytes
operator|=
name|plainSocket
operator|->
name|bytesAvailable
argument_list|()
operator|)
operator|>
literal|0
condition|)
block|{
comment|// Read encrypted data from the socket into a buffer.
name|data
operator|.
name|resize
argument_list|(
name|pendingBytes
argument_list|)
expr_stmt|;
comment|// just peek() here because q_BIO_write could write less data than expected
name|int
name|encryptedBytesRead
init|=
name|plainSocket
operator|->
name|peek
argument_list|(
name|data
operator|.
name|data
argument_list|()
argument_list|,
name|pendingBytes
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|QSSLSOCKET_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QSslSocketBackendPrivate::transmit: read"
operator|<<
name|encryptedBytesRead
operator|<<
literal|"encrypted bytes from the socket"
expr_stmt|;
endif|#
directive|endif
comment|// Write encrypted data from the buffer into the read BIO.
name|int
name|writtenToBio
init|=
name|q_BIO_write
argument_list|(
name|readBio
argument_list|,
name|data
operator|.
name|constData
argument_list|()
argument_list|,
name|encryptedBytesRead
argument_list|)
decl_stmt|;
comment|// do the actual read() here and throw away the results.
if|if
condition|(
name|writtenToBio
operator|>
literal|0
condition|)
block|{
comment|// ### TODO: make this cheaper by not making it memcpy. E.g. make it work with data=0x0 or make it work with seek
name|plainSocket
operator|->
name|read
argument_list|(
name|data
operator|.
name|data
argument_list|()
argument_list|,
name|writtenToBio
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// ### Better error handling.
name|q
operator|->
name|setErrorString
argument_list|(
name|QSslSocket
operator|::
name|tr
argument_list|(
literal|"Unable to decrypt data: %1"
argument_list|)
operator|.
name|arg
argument_list|(
name|getErrorsFromOpenSsl
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|->
name|setSocketError
argument_list|(
name|QAbstractSocket
operator|::
name|SslInternalError
argument_list|)
expr_stmt|;
emit|emit
name|q
operator|->
name|error
argument_list|(
name|QAbstractSocket
operator|::
name|SslInternalError
argument_list|)
emit|;
return|return;
block|}
name|transmitting
operator|=
literal|true
expr_stmt|;
block|}
comment|// If the connection isn't secured yet, this is the time to retry the
comment|// connect / accept.
if|if
condition|(
operator|!
name|connectionEncrypted
condition|)
block|{
ifdef|#
directive|ifdef
name|QSSLSOCKET_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QSslSocketBackendPrivate::transmit: testing encryption"
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|startHandshake
argument_list|()
condition|)
block|{
ifdef|#
directive|ifdef
name|QSSLSOCKET_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QSslSocketBackendPrivate::transmit: encryption established"
expr_stmt|;
endif|#
directive|endif
name|connectionEncrypted
operator|=
literal|true
expr_stmt|;
name|transmitting
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|plainSocket
operator|->
name|state
argument_list|()
operator|!=
name|QAbstractSocket
operator|::
name|ConnectedState
condition|)
block|{
ifdef|#
directive|ifdef
name|QSSLSOCKET_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QSslSocketBackendPrivate::transmit: connection lost"
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
elseif|else
if|if
condition|(
name|paused
condition|)
block|{
comment|// just wait until the user continues
return|return;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|QSSLSOCKET_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QSslSocketBackendPrivate::transmit: encryption not done yet"
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|// If the request is small and the remote host closes the transmission
comment|// after sending, there's a chance that startHandshake() will already
comment|// have triggered a shutdown.
if|if
condition|(
operator|!
name|ssl
condition|)
continue|continue;
comment|// We always read everything from the SSL decryption buffers, even if
comment|// we have a readBufferMaxSize. There's no point in leaving data there
comment|// just so that readBuffer.size() == readBufferMaxSize.
name|int
name|readBytes
init|=
literal|0
decl_stmt|;
name|data
operator|.
name|resize
argument_list|(
literal|4096
argument_list|)
expr_stmt|;
operator|::
name|memset
argument_list|(
name|data
operator|.
name|data
argument_list|()
argument_list|,
literal|0
argument_list|,
name|data
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
do|do
block|{
comment|// Don't use SSL_pending(). It's very unreliable.
if|if
condition|(
operator|(
name|readBytes
operator|=
name|q_SSL_read
argument_list|(
name|ssl
argument_list|,
name|data
operator|.
name|data
argument_list|()
argument_list|,
name|data
operator|.
name|size
argument_list|()
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|QSSLSOCKET_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QSslSocketBackendPrivate::transmit: decrypted"
operator|<<
name|readBytes
operator|<<
literal|"bytes"
expr_stmt|;
endif|#
directive|endif
name|char
modifier|*
name|ptr
init|=
name|buffer
operator|.
name|reserve
argument_list|(
name|readBytes
argument_list|)
decl_stmt|;
operator|::
name|memcpy
argument_list|(
name|ptr
argument_list|,
name|data
operator|.
name|data
argument_list|()
argument_list|,
name|readBytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|readyReadEmittedPointer
condition|)
operator|*
name|readyReadEmittedPointer
operator|=
literal|true
expr_stmt|;
emit|emit
name|q
operator|->
name|readyRead
argument_list|()
emit|;
name|transmitting
operator|=
literal|true
expr_stmt|;
continue|continue;
block|}
comment|// Error.
switch|switch
condition|(
name|q_SSL_get_error
argument_list|(
name|ssl
argument_list|,
name|readBytes
argument_list|)
condition|)
block|{
case|case
name|SSL_ERROR_WANT_READ
case|:
case|case
name|SSL_ERROR_WANT_WRITE
case|:
comment|// Out of data.
break|break;
case|case
name|SSL_ERROR_ZERO_RETURN
case|:
comment|// The remote host closed the connection.
ifdef|#
directive|ifdef
name|QSSLSOCKET_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QSslSocketBackendPrivate::transmit: remote disconnect"
expr_stmt|;
endif|#
directive|endif
name|shutdown
operator|=
literal|true
expr_stmt|;
comment|// the other side shut down, make sure we do not send shutdown ourselves
name|q
operator|->
name|setErrorString
argument_list|(
name|QSslSocket
operator|::
name|tr
argument_list|(
literal|"The TLS/SSL connection has been closed"
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|->
name|setSocketError
argument_list|(
name|QAbstractSocket
operator|::
name|RemoteHostClosedError
argument_list|)
expr_stmt|;
emit|emit
name|q
operator|->
name|error
argument_list|(
name|QAbstractSocket
operator|::
name|RemoteHostClosedError
argument_list|)
emit|;
return|return;
case|case
name|SSL_ERROR_SYSCALL
case|:
comment|// some IO error
case|case
name|SSL_ERROR_SSL
case|:
comment|// error in the SSL library
comment|// we do not know exactly what the error is, nor whether we can recover from it,
comment|// so just return to prevent an endless loop in the outer "while" statement
name|q
operator|->
name|setErrorString
argument_list|(
name|QSslSocket
operator|::
name|tr
argument_list|(
literal|"Error while reading: %1"
argument_list|)
operator|.
name|arg
argument_list|(
name|getErrorsFromOpenSsl
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|->
name|setSocketError
argument_list|(
name|QAbstractSocket
operator|::
name|SslInternalError
argument_list|)
expr_stmt|;
emit|emit
name|q
operator|->
name|error
argument_list|(
name|QAbstractSocket
operator|::
name|SslInternalError
argument_list|)
emit|;
return|return;
default|default:
comment|// SSL_ERROR_WANT_CONNECT, SSL_ERROR_WANT_ACCEPT: can only happen with a
comment|// BIO_s_connect() or BIO_s_accept(), which we do not call.
comment|// SSL_ERROR_WANT_X509_LOOKUP: can only happen with a
comment|// SSL_CTX_set_client_cert_cb(), which we do not call.
comment|// So this default case should never be triggered.
name|q
operator|->
name|setErrorString
argument_list|(
name|QSslSocket
operator|::
name|tr
argument_list|(
literal|"Error while reading: %1"
argument_list|)
operator|.
name|arg
argument_list|(
name|getErrorsFromOpenSsl
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|->
name|setSocketError
argument_list|(
name|QAbstractSocket
operator|::
name|SslInternalError
argument_list|)
expr_stmt|;
emit|emit
name|q
operator|->
name|error
argument_list|(
name|QAbstractSocket
operator|::
name|SslInternalError
argument_list|)
emit|;
break|break;
block|}
block|}
do|while
condition|(
name|ssl
operator|&&
name|readBytes
operator|>
literal|0
condition|)
do|;
block|}
do|while
condition|(
name|ssl
operator|&&
name|transmitting
condition|)
do|;
block|}
end_function
begin_function
DECL|function|_q_OpenSSL_to_QSslError
specifier|static
name|QSslError
name|_q_OpenSSL_to_QSslError
parameter_list|(
name|int
name|errorCode
parameter_list|,
specifier|const
name|QSslCertificate
modifier|&
name|cert
parameter_list|)
block|{
name|QSslError
name|error
decl_stmt|;
switch|switch
condition|(
name|errorCode
condition|)
block|{
case|case
name|X509_V_OK
case|:
comment|// X509_V_OK is also reported if the peer had no certificate.
break|break;
case|case
name|X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT
case|:
name|error
operator|=
name|QSslError
argument_list|(
name|QSslError
operator|::
name|UnableToGetIssuerCertificate
argument_list|,
name|cert
argument_list|)
expr_stmt|;
break|break;
case|case
name|X509_V_ERR_UNABLE_TO_DECRYPT_CERT_SIGNATURE
case|:
name|error
operator|=
name|QSslError
argument_list|(
name|QSslError
operator|::
name|UnableToDecryptCertificateSignature
argument_list|,
name|cert
argument_list|)
expr_stmt|;
break|break;
case|case
name|X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY
case|:
name|error
operator|=
name|QSslError
argument_list|(
name|QSslError
operator|::
name|UnableToDecodeIssuerPublicKey
argument_list|,
name|cert
argument_list|)
expr_stmt|;
break|break;
case|case
name|X509_V_ERR_CERT_SIGNATURE_FAILURE
case|:
name|error
operator|=
name|QSslError
argument_list|(
name|QSslError
operator|::
name|CertificateSignatureFailed
argument_list|,
name|cert
argument_list|)
expr_stmt|;
break|break;
case|case
name|X509_V_ERR_CERT_NOT_YET_VALID
case|:
name|error
operator|=
name|QSslError
argument_list|(
name|QSslError
operator|::
name|CertificateNotYetValid
argument_list|,
name|cert
argument_list|)
expr_stmt|;
break|break;
case|case
name|X509_V_ERR_CERT_HAS_EXPIRED
case|:
name|error
operator|=
name|QSslError
argument_list|(
name|QSslError
operator|::
name|CertificateExpired
argument_list|,
name|cert
argument_list|)
expr_stmt|;
break|break;
case|case
name|X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD
case|:
name|error
operator|=
name|QSslError
argument_list|(
name|QSslError
operator|::
name|InvalidNotBeforeField
argument_list|,
name|cert
argument_list|)
expr_stmt|;
break|break;
case|case
name|X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD
case|:
name|error
operator|=
name|QSslError
argument_list|(
name|QSslError
operator|::
name|InvalidNotAfterField
argument_list|,
name|cert
argument_list|)
expr_stmt|;
break|break;
case|case
name|X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT
case|:
name|error
operator|=
name|QSslError
argument_list|(
name|QSslError
operator|::
name|SelfSignedCertificate
argument_list|,
name|cert
argument_list|)
expr_stmt|;
break|break;
case|case
name|X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN
case|:
name|error
operator|=
name|QSslError
argument_list|(
name|QSslError
operator|::
name|SelfSignedCertificateInChain
argument_list|,
name|cert
argument_list|)
expr_stmt|;
break|break;
case|case
name|X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY
case|:
name|error
operator|=
name|QSslError
argument_list|(
name|QSslError
operator|::
name|UnableToGetLocalIssuerCertificate
argument_list|,
name|cert
argument_list|)
expr_stmt|;
break|break;
case|case
name|X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE
case|:
name|error
operator|=
name|QSslError
argument_list|(
name|QSslError
operator|::
name|UnableToVerifyFirstCertificate
argument_list|,
name|cert
argument_list|)
expr_stmt|;
break|break;
case|case
name|X509_V_ERR_CERT_REVOKED
case|:
name|error
operator|=
name|QSslError
argument_list|(
name|QSslError
operator|::
name|CertificateRevoked
argument_list|,
name|cert
argument_list|)
expr_stmt|;
break|break;
case|case
name|X509_V_ERR_INVALID_CA
case|:
name|error
operator|=
name|QSslError
argument_list|(
name|QSslError
operator|::
name|InvalidCaCertificate
argument_list|,
name|cert
argument_list|)
expr_stmt|;
break|break;
case|case
name|X509_V_ERR_PATH_LENGTH_EXCEEDED
case|:
name|error
operator|=
name|QSslError
argument_list|(
name|QSslError
operator|::
name|PathLengthExceeded
argument_list|,
name|cert
argument_list|)
expr_stmt|;
break|break;
case|case
name|X509_V_ERR_INVALID_PURPOSE
case|:
name|error
operator|=
name|QSslError
argument_list|(
name|QSslError
operator|::
name|InvalidPurpose
argument_list|,
name|cert
argument_list|)
expr_stmt|;
break|break;
case|case
name|X509_V_ERR_CERT_UNTRUSTED
case|:
name|error
operator|=
name|QSslError
argument_list|(
name|QSslError
operator|::
name|CertificateUntrusted
argument_list|,
name|cert
argument_list|)
expr_stmt|;
break|break;
case|case
name|X509_V_ERR_CERT_REJECTED
case|:
name|error
operator|=
name|QSslError
argument_list|(
name|QSslError
operator|::
name|CertificateRejected
argument_list|,
name|cert
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|QSslError
argument_list|(
name|QSslError
operator|::
name|UnspecifiedError
argument_list|,
name|cert
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|error
return|;
block|}
end_function
begin_function
DECL|function|startHandshake
name|bool
name|QSslSocketBackendPrivate
operator|::
name|startHandshake
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QSslSocket
argument_list|)
expr_stmt|;
comment|// Check if the connection has been established. Get all errors from the
comment|// verification stage.
name|_q_sslErrorList
argument_list|()
operator|->
name|mutex
operator|.
name|lock
argument_list|()
expr_stmt|;
name|_q_sslErrorList
argument_list|()
operator|->
name|errors
operator|.
name|clear
argument_list|()
expr_stmt|;
name|int
name|result
init|=
operator|(
name|mode
operator|==
name|QSslSocket
operator|::
name|SslClientMode
operator|)
condition|?
name|q_SSL_connect
argument_list|(
name|ssl
argument_list|)
else|:
name|q_SSL_accept
argument_list|(
name|ssl
argument_list|)
decl_stmt|;
specifier|const
name|QList
argument_list|<
name|QPair
argument_list|<
name|int
argument_list|,
name|int
argument_list|>
argument_list|>
modifier|&
name|lastErrors
init|=
name|_q_sslErrorList
argument_list|()
operator|->
name|errors
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|lastErrors
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QPair
argument_list|<
name|int
argument_list|,
name|int
argument_list|>
modifier|&
name|currentError
init|=
name|lastErrors
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|// Initialize the peer certificate chain in order to find which certificate caused this error
if|if
condition|(
name|configuration
operator|.
name|peerCertificateChain
operator|.
name|isEmpty
argument_list|()
condition|)
name|configuration
operator|.
name|peerCertificateChain
operator|=
name|STACKOFX509_to_QSslCertificates
argument_list|(
name|q_SSL_get_peer_cert_chain
argument_list|(
name|ssl
argument_list|)
argument_list|)
expr_stmt|;
emit|emit
name|q
operator|->
name|peerVerifyError
argument_list|(
name|_q_OpenSSL_to_QSslError
argument_list|(
name|currentError
operator|.
name|first
argument_list|,
name|configuration
operator|.
name|peerCertificateChain
operator|.
name|value
argument_list|(
name|currentError
operator|.
name|second
argument_list|)
argument_list|)
argument_list|)
emit|;
if|if
condition|(
name|q
operator|->
name|state
argument_list|()
operator|!=
name|QAbstractSocket
operator|::
name|ConnectedState
condition|)
break|break;
block|}
name|errorList
operator|<<
name|lastErrors
expr_stmt|;
name|_q_sslErrorList
argument_list|()
operator|->
name|mutex
operator|.
name|unlock
argument_list|()
expr_stmt|;
comment|// Connection aborted during handshake phase.
if|if
condition|(
name|q
operator|->
name|state
argument_list|()
operator|!=
name|QAbstractSocket
operator|::
name|ConnectedState
condition|)
return|return
literal|false
return|;
comment|// Check if we're encrypted or not.
if|if
condition|(
name|result
operator|<=
literal|0
condition|)
block|{
switch|switch
condition|(
name|q_SSL_get_error
argument_list|(
name|ssl
argument_list|,
name|result
argument_list|)
condition|)
block|{
case|case
name|SSL_ERROR_WANT_READ
case|:
case|case
name|SSL_ERROR_WANT_WRITE
case|:
comment|// The handshake is not yet complete.
break|break;
default|default:
name|q
operator|->
name|setErrorString
argument_list|(
name|QSslSocket
operator|::
name|tr
argument_list|(
literal|"Error during SSL handshake: %1"
argument_list|)
operator|.
name|arg
argument_list|(
name|getErrorsFromOpenSsl
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|->
name|setSocketError
argument_list|(
name|QAbstractSocket
operator|::
name|SslHandshakeFailedError
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QSSLSOCKET_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QSslSocketBackendPrivate::startHandshake: error!"
operator|<<
name|q
operator|->
name|errorString
argument_list|()
expr_stmt|;
endif|#
directive|endif
emit|emit
name|q
operator|->
name|error
argument_list|(
name|QAbstractSocket
operator|::
name|SslHandshakeFailedError
argument_list|)
emit|;
name|q
operator|->
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
comment|// Store the peer certificate and chain. For clients, the peer certificate
comment|// chain includes the peer certificate; for servers, it doesn't. Both the
comment|// peer certificate and the chain may be empty if the peer didn't present
comment|// any certificate.
if|if
condition|(
name|configuration
operator|.
name|peerCertificateChain
operator|.
name|isEmpty
argument_list|()
condition|)
name|configuration
operator|.
name|peerCertificateChain
operator|=
name|STACKOFX509_to_QSslCertificates
argument_list|(
name|q_SSL_get_peer_cert_chain
argument_list|(
name|ssl
argument_list|)
argument_list|)
expr_stmt|;
name|X509
modifier|*
name|x509
init|=
name|q_SSL_get_peer_certificate
argument_list|(
name|ssl
argument_list|)
decl_stmt|;
name|configuration
operator|.
name|peerCertificate
operator|=
name|QSslCertificatePrivate
operator|::
name|QSslCertificate_from_X509
argument_list|(
name|x509
argument_list|)
expr_stmt|;
name|q_X509_free
argument_list|(
name|x509
argument_list|)
expr_stmt|;
comment|// Start translating errors.
name|QList
argument_list|<
name|QSslError
argument_list|>
name|errors
decl_stmt|;
comment|// check the whole chain for blacklisting (including root, as we check for subjectInfo and issuer)
foreach|foreach
control|(
specifier|const
name|QSslCertificate
modifier|&
name|cert
decl|,
name|configuration
operator|.
name|peerCertificateChain
control|)
block|{
if|if
condition|(
name|QSslCertificatePrivate
operator|::
name|isBlacklisted
argument_list|(
name|cert
argument_list|)
condition|)
block|{
name|QSslError
name|error
argument_list|(
name|QSslError
operator|::
name|CertificateBlacklisted
argument_list|,
name|cert
argument_list|)
decl_stmt|;
name|errors
operator|<<
name|error
expr_stmt|;
emit|emit
name|q
operator|->
name|peerVerifyError
argument_list|(
name|error
argument_list|)
emit|;
if|if
condition|(
name|q
operator|->
name|state
argument_list|()
operator|!=
name|QAbstractSocket
operator|::
name|ConnectedState
condition|)
return|return
literal|false
return|;
block|}
block|}
name|bool
name|doVerifyPeer
init|=
name|configuration
operator|.
name|peerVerifyMode
operator|==
name|QSslSocket
operator|::
name|VerifyPeer
operator|||
operator|(
name|configuration
operator|.
name|peerVerifyMode
operator|==
name|QSslSocket
operator|::
name|AutoVerifyPeer
operator|&&
name|mode
operator|==
name|QSslSocket
operator|::
name|SslClientMode
operator|)
decl_stmt|;
comment|// Check the peer certificate itself. First try the subject's common name
comment|// (CN) as a wildcard, then try all alternate subject name DNS entries the
comment|// same way.
if|if
condition|(
operator|!
name|configuration
operator|.
name|peerCertificate
operator|.
name|isNull
argument_list|()
condition|)
block|{
comment|// but only if we're a client connecting to a server
comment|// if we're the server, don't check CN
if|if
condition|(
name|mode
operator|==
name|QSslSocket
operator|::
name|SslClientMode
condition|)
block|{
name|QString
name|peerName
init|=
operator|(
name|verificationPeerName
operator|.
name|isEmpty
argument_list|()
condition|?
name|q
operator|->
name|peerName
argument_list|()
else|:
name|verificationPeerName
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|isMatchingHostname
argument_list|(
name|configuration
operator|.
name|peerCertificate
argument_list|,
name|peerName
argument_list|)
condition|)
block|{
comment|// No matches in common names or alternate names.
name|QSslError
name|error
argument_list|(
name|QSslError
operator|::
name|HostNameMismatch
argument_list|,
name|configuration
operator|.
name|peerCertificate
argument_list|)
decl_stmt|;
name|errors
operator|<<
name|error
expr_stmt|;
emit|emit
name|q
operator|->
name|peerVerifyError
argument_list|(
name|error
argument_list|)
emit|;
if|if
condition|(
name|q
operator|->
name|state
argument_list|()
operator|!=
name|QAbstractSocket
operator|::
name|ConnectedState
condition|)
return|return
literal|false
return|;
block|}
block|}
block|}
else|else
block|{
comment|// No peer certificate presented. Report as error if the socket
comment|// expected one.
if|if
condition|(
name|doVerifyPeer
condition|)
block|{
name|QSslError
name|error
argument_list|(
name|QSslError
operator|::
name|NoPeerCertificate
argument_list|)
decl_stmt|;
name|errors
operator|<<
name|error
expr_stmt|;
emit|emit
name|q
operator|->
name|peerVerifyError
argument_list|(
name|error
argument_list|)
emit|;
if|if
condition|(
name|q
operator|->
name|state
argument_list|()
operator|!=
name|QAbstractSocket
operator|::
name|ConnectedState
condition|)
return|return
literal|false
return|;
block|}
block|}
comment|// Translate errors from the error list into QSslErrors.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|errorList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QPair
argument_list|<
name|int
argument_list|,
name|int
argument_list|>
modifier|&
name|errorAndDepth
init|=
name|errorList
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|int
name|err
init|=
name|errorAndDepth
operator|.
name|first
decl_stmt|;
name|int
name|depth
init|=
name|errorAndDepth
operator|.
name|second
decl_stmt|;
name|errors
operator|<<
name|_q_OpenSSL_to_QSslError
argument_list|(
name|err
argument_list|,
name|configuration
operator|.
name|peerCertificateChain
operator|.
name|value
argument_list|(
name|depth
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|errors
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|sslErrors
operator|=
name|errors
expr_stmt|;
ifdef|#
directive|ifdef
name|Q_OS_WIN
comment|//Skip this if not using system CAs, or if the SSL errors are configured in advance to be ignorable
if|if
condition|(
name|doVerifyPeer
operator|&&
name|s_loadRootCertsOnDemand
operator|&&
name|allowRootCertOnDemandLoading
operator|&&
operator|!
name|verifyErrorsHaveBeenIgnored
argument_list|()
condition|)
block|{
comment|//Windows desktop versions starting from vista ship with minimal set of roots
comment|//and download on demand from the windows update server CA roots that are
comment|//trusted by MS.
comment|//However, this is only transparent if using WinINET - we have to trigger it
comment|//ourselves.
name|QSslCertificate
name|certToFetch
decl_stmt|;
name|bool
name|fetchCertificate
init|=
literal|true
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sslErrors
operator|.
name|count
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|sslErrors
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|error
argument_list|()
condition|)
block|{
case|case
name|QSslError
operator|::
name|UnableToGetLocalIssuerCertificate
case|:
comment|// site presented intermediate cert, but root is unknown
case|case
name|QSslError
operator|::
name|SelfSignedCertificateInChain
case|:
comment|// site presented a complete chain, but root is unknown
name|certToFetch
operator|=
name|sslErrors
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|certificate
argument_list|()
expr_stmt|;
break|break;
case|case
name|QSslError
operator|::
name|SelfSignedCertificate
case|:
case|case
name|QSslError
operator|::
name|CertificateBlacklisted
case|:
comment|//With these errors, we know it will be untrusted so save time by not asking windows
name|fetchCertificate
operator|=
literal|false
expr_stmt|;
break|break;
default|default:
ifdef|#
directive|ifdef
name|QSSLSOCKET_DEBUG
name|qDebug
argument_list|()
operator|<<
name|sslErrors
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|errorString
argument_list|()
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
block|}
if|if
condition|(
name|fetchCertificate
operator|&&
operator|!
name|certToFetch
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|fetchCaRootForCert
argument_list|(
name|certToFetch
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|checkSslErrors
argument_list|()
condition|)
return|return
literal|false
return|;
block|}
else|else
block|{
name|sslErrors
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|continueHandshake
argument_list|()
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|checkSslErrors
name|bool
name|QSslSocketBackendPrivate
operator|::
name|checkSslErrors
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QSslSocket
argument_list|)
expr_stmt|;
if|if
condition|(
name|sslErrors
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|true
return|;
emit|emit
name|q
operator|->
name|sslErrors
argument_list|(
name|sslErrors
argument_list|)
emit|;
name|bool
name|doVerifyPeer
init|=
name|configuration
operator|.
name|peerVerifyMode
operator|==
name|QSslSocket
operator|::
name|VerifyPeer
operator|||
operator|(
name|configuration
operator|.
name|peerVerifyMode
operator|==
name|QSslSocket
operator|::
name|AutoVerifyPeer
operator|&&
name|mode
operator|==
name|QSslSocket
operator|::
name|SslClientMode
operator|)
decl_stmt|;
name|bool
name|doEmitSslError
init|=
operator|!
name|verifyErrorsHaveBeenIgnored
argument_list|()
decl_stmt|;
comment|// check whether we need to emit an SSL handshake error
if|if
condition|(
name|doVerifyPeer
operator|&&
name|doEmitSslError
condition|)
block|{
if|if
condition|(
name|q
operator|->
name|pauseMode
argument_list|()
operator|&
name|QAbstractSocket
operator|::
name|PauseOnSslErrors
condition|)
block|{
name|pauseSocketNotifiers
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|paused
operator|=
literal|true
expr_stmt|;
block|}
else|else
block|{
name|q
operator|->
name|setErrorString
argument_list|(
name|sslErrors
operator|.
name|first
argument_list|()
operator|.
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
name|q
operator|->
name|setSocketError
argument_list|(
name|QAbstractSocket
operator|::
name|SslHandshakeFailedError
argument_list|)
expr_stmt|;
emit|emit
name|q
operator|->
name|error
argument_list|(
name|QAbstractSocket
operator|::
name|SslHandshakeFailedError
argument_list|)
emit|;
name|plainSocket
operator|->
name|disconnectFromHost
argument_list|()
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_WIN
end_ifdef
begin_function
DECL|function|fetchCaRootForCert
name|void
name|QSslSocketBackendPrivate
operator|::
name|fetchCaRootForCert
parameter_list|(
specifier|const
name|QSslCertificate
modifier|&
name|cert
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QSslSocket
argument_list|)
expr_stmt|;
comment|//The root certificate is downloaded from windows update, which blocks for 15 seconds in the worst case
comment|//so the request is done in a worker thread.
name|QWindowsCaRootFetcher
modifier|*
name|fetcher
init|=
operator|new
name|QWindowsCaRootFetcher
argument_list|(
name|cert
argument_list|,
name|mode
argument_list|)
decl_stmt|;
name|QObject
operator|::
name|connect
argument_list|(
name|fetcher
argument_list|,
name|SIGNAL
argument_list|(
name|finished
argument_list|(
name|QSslCertificate
argument_list|,
name|QSslCertificate
argument_list|)
argument_list|)
argument_list|,
name|q
argument_list|,
name|SLOT
argument_list|(
name|_q_caRootLoaded
argument_list|(
name|QSslCertificate
argument_list|,
name|QSslCertificate
argument_list|)
argument_list|)
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
name|QMetaObject
operator|::
name|invokeMethod
argument_list|(
name|fetcher
argument_list|,
literal|"start"
argument_list|,
name|Qt
operator|::
name|QueuedConnection
argument_list|)
expr_stmt|;
name|pauseSocketNotifiers
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|paused
operator|=
literal|true
expr_stmt|;
block|}
end_function
begin_comment
comment|//This is the callback from QWindowsCaRootFetcher, trustedRoot will be invalid (default constructed) if it failed.
end_comment
begin_function
DECL|function|_q_caRootLoaded
name|void
name|QSslSocketBackendPrivate
operator|::
name|_q_caRootLoaded
parameter_list|(
name|QSslCertificate
name|cert
parameter_list|,
name|QSslCertificate
name|trustedRoot
parameter_list|)
block|{
name|Q_Q
argument_list|(
name|QSslSocket
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|trustedRoot
operator|.
name|isNull
argument_list|()
operator|&&
operator|!
name|trustedRoot
operator|.
name|isBlacklisted
argument_list|()
condition|)
block|{
if|if
condition|(
name|s_loadRootCertsOnDemand
condition|)
block|{
comment|//Add the new root cert to default cert list for use by future sockets
name|QSslSocket
operator|::
name|addDefaultCaCertificate
argument_list|(
name|trustedRoot
argument_list|)
expr_stmt|;
block|}
comment|//Add the new root cert to this socket for future connections
name|q
operator|->
name|addCaCertificate
argument_list|(
name|trustedRoot
argument_list|)
expr_stmt|;
comment|//Remove the broken chain ssl errors (as chain is verified by windows)
for|for
control|(
name|int
name|i
init|=
name|sslErrors
operator|.
name|count
argument_list|()
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
name|sslErrors
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|certificate
argument_list|()
operator|==
name|cert
condition|)
block|{
switch|switch
condition|(
name|sslErrors
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|error
argument_list|()
condition|)
block|{
case|case
name|QSslError
operator|::
name|UnableToGetLocalIssuerCertificate
case|:
case|case
name|QSslError
operator|::
name|CertificateUntrusted
case|:
case|case
name|QSslError
operator|::
name|UnableToVerifyFirstCertificate
case|:
case|case
name|QSslError
operator|::
name|SelfSignedCertificateInChain
case|:
comment|// error can be ignored if OS says the chain is trusted
name|sslErrors
operator|.
name|removeAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|// error cannot be ignored
break|break;
block|}
block|}
block|}
block|}
comment|// Continue with remaining errors
if|if
condition|(
name|plainSocket
condition|)
name|plainSocket
operator|->
name|resume
argument_list|()
expr_stmt|;
name|paused
operator|=
literal|false
expr_stmt|;
if|if
condition|(
name|checkSslErrors
argument_list|()
condition|)
name|continueHandshake
argument_list|()
expr_stmt|;
block|}
end_function
begin_class
DECL|class|QWindowsCaRootFetcherThread
class|class
name|QWindowsCaRootFetcherThread
super|:
specifier|public
name|QThread
block|{
public|public:
DECL|function|QWindowsCaRootFetcherThread
name|QWindowsCaRootFetcherThread
parameter_list|()
block|{
name|qRegisterMetaType
argument_list|<
name|QSslCertificate
argument_list|>
argument_list|()
expr_stmt|;
name|setObjectName
argument_list|(
name|QStringLiteral
argument_list|(
literal|"QWindowsCaRootFetcher"
argument_list|)
argument_list|)
expr_stmt|;
name|start
argument_list|()
expr_stmt|;
block|}
DECL|function|~QWindowsCaRootFetcherThread
name|~
name|QWindowsCaRootFetcherThread
parameter_list|()
block|{
name|quit
argument_list|()
expr_stmt|;
name|wait
argument_list|(
literal|15500
argument_list|)
expr_stmt|;
comment|// worst case, a running request can block for 15 seconds
block|}
block|}
class|;
end_class
begin_expr_stmt
name|Q_GLOBAL_STATIC
argument_list|(
name|QWindowsCaRootFetcherThread
argument_list|,
name|windowsCaRootFetcherThread
argument_list|)
expr_stmt|;
end_expr_stmt
begin_constructor
DECL|function|QWindowsCaRootFetcher
name|QWindowsCaRootFetcher
operator|::
name|QWindowsCaRootFetcher
parameter_list|(
specifier|const
name|QSslCertificate
modifier|&
name|certificate
parameter_list|,
name|QSslSocket
operator|::
name|SslMode
name|sslMode
parameter_list|)
member_init_list|:
name|cert
argument_list|(
name|certificate
argument_list|)
member_init_list|,
name|mode
argument_list|(
name|sslMode
argument_list|)
block|{
name|moveToThread
argument_list|(
name|windowsCaRootFetcherThread
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QWindowsCaRootFetcher
name|QWindowsCaRootFetcher
operator|::
name|~
name|QWindowsCaRootFetcher
parameter_list|()
block|{ }
end_destructor
begin_function
DECL|function|start
name|void
name|QWindowsCaRootFetcher
operator|::
name|start
parameter_list|()
block|{
name|QByteArray
name|der
init|=
name|cert
operator|.
name|toDer
argument_list|()
decl_stmt|;
name|PCCERT_CONTEXT
name|wincert
init|=
name|CertCreateCertificateContext
argument_list|(
name|X509_ASN_ENCODING
argument_list|,
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|der
operator|.
name|constData
argument_list|()
argument_list|,
name|der
operator|.
name|length
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|wincert
condition|)
block|{
ifdef|#
directive|ifdef
name|QSSLSOCKET_DEBUG
name|qDebug
argument_list|(
literal|"QWindowsCaRootFetcher failed to convert certificate to windows form"
argument_list|)
expr_stmt|;
endif|#
directive|endif
emit|emit
name|finished
argument_list|(
name|cert
argument_list|,
name|QSslCertificate
argument_list|()
argument_list|)
emit|;
name|deleteLater
argument_list|()
expr_stmt|;
return|return;
block|}
name|CERT_CHAIN_PARA
name|parameters
decl_stmt|;
name|memset
argument_list|(
operator|&
name|parameters
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|parameters
argument_list|)
argument_list|)
expr_stmt|;
name|parameters
operator|.
name|cbSize
operator|=
sizeof|sizeof
argument_list|(
name|parameters
argument_list|)
expr_stmt|;
comment|// set key usage constraint
name|parameters
operator|.
name|RequestedUsage
operator|.
name|dwType
operator|=
name|USAGE_MATCH_TYPE_AND
expr_stmt|;
name|parameters
operator|.
name|RequestedUsage
operator|.
name|Usage
operator|.
name|cUsageIdentifier
operator|=
literal|1
expr_stmt|;
name|LPSTR
name|oid
init|=
call|(
name|LPSTR
call|)
argument_list|(
name|mode
operator|==
name|QSslSocket
operator|::
name|SslClientMode
condition|?
name|szOID_PKIX_KP_SERVER_AUTH
else|:
name|szOID_PKIX_KP_CLIENT_AUTH
argument_list|)
decl_stmt|;
name|parameters
operator|.
name|RequestedUsage
operator|.
name|Usage
operator|.
name|rgpszUsageIdentifier
operator|=
operator|&
name|oid
expr_stmt|;
ifdef|#
directive|ifdef
name|QSSLSOCKET_DEBUG
name|QElapsedTimer
name|stopwatch
decl_stmt|;
name|stopwatch
operator|.
name|start
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|PCCERT_CHAIN_CONTEXT
name|chain
decl_stmt|;
name|BOOL
name|result
init|=
name|CertGetCertificateChain
argument_list|(
literal|0
argument_list|,
comment|//default engine
name|wincert
argument_list|,
literal|0
argument_list|,
comment|//current date/time
literal|0
argument_list|,
comment|//default store
operator|&
name|parameters
argument_list|,
literal|0
argument_list|,
comment|//default dwFlags
literal|0
argument_list|,
comment|//reserved
operator|&
name|chain
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|QSSLSOCKET_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QWindowsCaRootFetcher"
operator|<<
name|stopwatch
operator|.
name|elapsed
argument_list|()
operator|<<
literal|"ms to get chain"
expr_stmt|;
endif|#
directive|endif
name|QSslCertificate
name|trustedRoot
decl_stmt|;
if|if
condition|(
name|result
condition|)
block|{
ifdef|#
directive|ifdef
name|QSSLSOCKET_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QWindowsCaRootFetcher - examining windows chains"
expr_stmt|;
if|if
condition|(
name|chain
operator|->
name|TrustStatus
operator|.
name|dwErrorStatus
operator|==
name|CERT_TRUST_NO_ERROR
condition|)
name|qDebug
argument_list|()
operator|<<
literal|" - TRUSTED"
expr_stmt|;
else|else
name|qDebug
argument_list|()
operator|<<
literal|" - NOT TRUSTED"
operator|<<
name|chain
operator|->
name|TrustStatus
operator|.
name|dwErrorStatus
expr_stmt|;
if|if
condition|(
name|chain
operator|->
name|TrustStatus
operator|.
name|dwInfoStatus
operator|&
name|CERT_TRUST_IS_SELF_SIGNED
condition|)
name|qDebug
argument_list|()
operator|<<
literal|" - SELF SIGNED"
expr_stmt|;
name|qDebug
argument_list|()
operator|<<
literal|"QSslSocketBackendPrivate::fetchCaRootForCert - dumping simple chains"
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|chain
operator|->
name|cChain
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|chain
operator|->
name|rgpChain
index|[
name|i
index|]
operator|->
name|TrustStatus
operator|.
name|dwErrorStatus
operator|==
name|CERT_TRUST_NO_ERROR
condition|)
name|qDebug
argument_list|()
operator|<<
literal|" - TRUSTED SIMPLE CHAIN"
operator|<<
name|i
expr_stmt|;
else|else
name|qDebug
argument_list|()
operator|<<
literal|" - UNTRUSTED SIMPLE CHAIN"
operator|<<
name|i
operator|<<
literal|"reason:"
operator|<<
name|chain
operator|->
name|rgpChain
index|[
name|i
index|]
operator|->
name|TrustStatus
operator|.
name|dwErrorStatus
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|chain
operator|->
name|rgpChain
index|[
name|i
index|]
operator|->
name|cElement
condition|;
name|j
operator|++
control|)
block|{
name|QSslCertificate
name|foundCert
argument_list|(
name|QByteArray
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|chain
operator|->
name|rgpChain
index|[
name|i
index|]
operator|->
name|rgpElement
index|[
name|j
index|]
operator|->
name|pCertContext
operator|->
name|pbCertEncoded
argument_list|,
name|chain
operator|->
name|rgpChain
index|[
name|i
index|]
operator|->
name|rgpElement
index|[
name|j
index|]
operator|->
name|pCertContext
operator|->
name|cbCertEncoded
argument_list|)
argument_list|,
name|QSsl
operator|::
name|Der
argument_list|)
decl_stmt|;
name|qDebug
argument_list|()
operator|<<
literal|"   - "
operator|<<
name|foundCert
expr_stmt|;
block|}
block|}
name|qDebug
argument_list|()
operator|<<
literal|" - and"
operator|<<
name|chain
operator|->
name|cLowerQualityChainContext
operator|<<
literal|"low quality chains"
expr_stmt|;
comment|//expect 0, we haven't asked for them
endif|#
directive|endif
comment|//based on http://msdn.microsoft.com/en-us/library/windows/desktop/aa377182%28v=vs.85%29.aspx
comment|//about the final chain rgpChain[cChain-1] which must begin with a trusted root to be valid
if|if
condition|(
name|chain
operator|->
name|TrustStatus
operator|.
name|dwErrorStatus
operator|==
name|CERT_TRUST_NO_ERROR
operator|&&
name|chain
operator|->
name|cChain
operator|>
literal|0
condition|)
block|{
specifier|const
name|PCERT_SIMPLE_CHAIN
name|finalChain
init|=
name|chain
operator|->
name|rgpChain
index|[
name|chain
operator|->
name|cChain
operator|-
literal|1
index|]
decl_stmt|;
comment|// http://msdn.microsoft.com/en-us/library/windows/desktop/aa377544%28v=vs.85%29.aspx
comment|// rgpElement[0] is the end certificate chain element. rgpElement[cElement-1] is the self-signed "root" certificate element.
if|if
condition|(
name|finalChain
operator|->
name|TrustStatus
operator|.
name|dwErrorStatus
operator|==
name|CERT_TRUST_NO_ERROR
operator|&&
name|finalChain
operator|->
name|cElement
operator|>
literal|0
condition|)
block|{
name|trustedRoot
operator|=
name|QSslCertificate
argument_list|(
name|QByteArray
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|finalChain
operator|->
name|rgpElement
index|[
name|finalChain
operator|->
name|cElement
operator|-
literal|1
index|]
operator|->
name|pCertContext
operator|->
name|pbCertEncoded
argument_list|,
name|finalChain
operator|->
name|rgpElement
index|[
name|finalChain
operator|->
name|cElement
operator|-
literal|1
index|]
operator|->
name|pCertContext
operator|->
name|cbCertEncoded
argument_list|)
argument_list|,
name|QSsl
operator|::
name|Der
argument_list|)
expr_stmt|;
block|}
block|}
name|CertFreeCertificateChain
argument_list|(
name|chain
argument_list|)
expr_stmt|;
block|}
name|CertFreeCertificateContext
argument_list|(
name|wincert
argument_list|)
expr_stmt|;
emit|emit
name|finished
argument_list|(
name|cert
argument_list|,
name|trustedRoot
argument_list|)
emit|;
name|deleteLater
argument_list|()
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|disconnectFromHost
name|void
name|QSslSocketBackendPrivate
operator|::
name|disconnectFromHost
parameter_list|()
block|{
if|if
condition|(
name|ssl
condition|)
block|{
if|if
condition|(
operator|!
name|shutdown
condition|)
block|{
name|q_SSL_shutdown
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
name|shutdown
operator|=
literal|true
expr_stmt|;
name|transmit
argument_list|()
expr_stmt|;
block|}
block|}
name|plainSocket
operator|->
name|disconnectFromHost
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|disconnected
name|void
name|QSslSocketBackendPrivate
operator|::
name|disconnected
parameter_list|()
block|{
if|if
condition|(
name|plainSocket
operator|->
name|bytesAvailable
argument_list|()
operator|<=
literal|0
condition|)
name|destroySslContext
argument_list|()
expr_stmt|;
comment|//if there is still buffered data in the plain socket, don't destroy the ssl context yet.
comment|//it will be destroyed when the socket is deleted.
block|}
end_function
begin_function
DECL|function|sessionCipher
name|QSslCipher
name|QSslSocketBackendPrivate
operator|::
name|sessionCipher
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|ssl
condition|)
return|return
name|QSslCipher
argument_list|()
return|;
if|#
directive|if
name|OPENSSL_VERSION_NUMBER
operator|>=
literal|0x10000000L
comment|// FIXME This is fairly evil, but needed to keep source level compatibility
comment|// with the OpenSSL 0.9.x implementation at maximum -- some other functions
comment|// don't take a const SSL_CIPHER* when they should
name|SSL_CIPHER
modifier|*
name|sessionCipher
init|=
cast|const_cast
argument_list|<
name|SSL_CIPHER
operator|*
argument_list|>
argument_list|(
name|q_SSL_get_current_cipher
argument_list|(
name|ssl
argument_list|)
argument_list|)
decl_stmt|;
else|#
directive|else
name|SSL_CIPHER
modifier|*
name|sessionCipher
init|=
name|q_SSL_get_current_cipher
argument_list|(
name|ssl
argument_list|)
decl_stmt|;
endif|#
directive|endif
return|return
name|sessionCipher
condition|?
name|QSslCipher_from_SSL_CIPHER
argument_list|(
name|sessionCipher
argument_list|)
else|:
name|QSslCipher
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|sessionProtocol
name|QSsl
operator|::
name|SslProtocol
name|QSslSocketBackendPrivate
operator|::
name|sessionProtocol
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|ssl
condition|)
return|return
name|QSsl
operator|::
name|UnknownProtocol
return|;
name|int
name|ver
init|=
name|q_SSL_version
argument_list|(
name|ssl
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|ver
condition|)
block|{
case|case
literal|0x2
case|:
return|return
name|QSsl
operator|::
name|SslV2
return|;
case|case
literal|0x300
case|:
return|return
name|QSsl
operator|::
name|SslV3
return|;
case|case
literal|0x301
case|:
return|return
name|QSsl
operator|::
name|TlsV1_0
return|;
case|case
literal|0x302
case|:
return|return
name|QSsl
operator|::
name|TlsV1_1
return|;
case|case
literal|0x303
case|:
return|return
name|QSsl
operator|::
name|TlsV1_2
return|;
block|}
return|return
name|QSsl
operator|::
name|UnknownProtocol
return|;
block|}
end_function
begin_function
DECL|function|continueHandshake
name|void
name|QSslSocketBackendPrivate
operator|::
name|continueHandshake
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QSslSocket
argument_list|)
expr_stmt|;
comment|// if we have a max read buffer size, reset the plain socket's to match
if|if
condition|(
name|readBufferMaxSize
condition|)
name|plainSocket
operator|->
name|setReadBufferSize
argument_list|(
name|readBufferMaxSize
argument_list|)
expr_stmt|;
if|#
directive|if
name|OPENSSL_VERSION_NUMBER
operator|>=
literal|0x0090806fL
operator|&&
operator|!
name|defined
argument_list|(
name|OPENSSL_NO_TLSEXT
argument_list|)
if|if
condition|(
name|q_SSL_ctrl
argument_list|(
operator|(
name|ssl
operator|)
argument_list|,
name|SSL_CTRL_GET_SESSION_REUSED
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
condition|)
name|configuration
operator|.
name|peerSessionShared
operator|=
literal|true
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|QT_DECRYPT_SSL_TRAFFIC
if|if
condition|(
name|ssl
operator|->
name|session
operator|&&
name|ssl
operator|->
name|s3
condition|)
block|{
specifier|const
name|char
modifier|*
name|mk
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|char
operator|*
argument_list|>
argument_list|(
name|ssl
operator|->
name|session
operator|->
name|master_key
argument_list|)
decl_stmt|;
name|QByteArray
name|masterKey
argument_list|(
name|mk
argument_list|,
name|ssl
operator|->
name|session
operator|->
name|master_key_length
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|random
init|=
cast|reinterpret_cast
argument_list|<
specifier|const
name|char
operator|*
argument_list|>
argument_list|(
name|ssl
operator|->
name|s3
operator|->
name|client_random
argument_list|)
decl_stmt|;
name|QByteArray
name|clientRandom
argument_list|(
name|random
argument_list|,
name|SSL3_RANDOM_SIZE
argument_list|)
decl_stmt|;
comment|// different format, needed for e.g. older Wireshark versions:
comment|//        const char *sid = reinterpret_cast<const char *>(ssl->session->session_id);
comment|//        QByteArray sessionID(sid, ssl->session->session_id_length);
comment|//        QByteArray debugLineRSA("RSA Session-ID:");
comment|//        debugLineRSA.append(sessionID.toHex().toUpper());
comment|//        debugLineRSA.append(" Master-Key:");
comment|//        debugLineRSA.append(masterKey.toHex().toUpper());
comment|//        debugLineRSA.append("\n");
name|QByteArray
name|debugLineClientRandom
argument_list|(
literal|"CLIENT_RANDOM "
argument_list|)
decl_stmt|;
name|debugLineClientRandom
operator|.
name|append
argument_list|(
name|clientRandom
operator|.
name|toHex
argument_list|()
operator|.
name|toUpper
argument_list|()
argument_list|)
expr_stmt|;
name|debugLineClientRandom
operator|.
name|append
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|debugLineClientRandom
operator|.
name|append
argument_list|(
name|masterKey
operator|.
name|toHex
argument_list|()
operator|.
name|toUpper
argument_list|()
argument_list|)
expr_stmt|;
name|debugLineClientRandom
operator|.
name|append
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|QString
name|sslKeyFile
init|=
name|QDir
operator|::
name|tempPath
argument_list|()
operator|+
name|QLatin1String
argument_list|(
literal|"/qt-ssl-keys"
argument_list|)
decl_stmt|;
name|QFile
name|file
argument_list|(
name|sslKeyFile
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|file
operator|.
name|open
argument_list|(
name|QIODevice
operator|::
name|Append
argument_list|)
condition|)
name|qWarning
argument_list|()
operator|<<
literal|"could not open file"
operator|<<
name|sslKeyFile
operator|<<
literal|"for appending"
expr_stmt|;
if|if
condition|(
operator|!
name|file
operator|.
name|write
argument_list|(
name|debugLineClientRandom
argument_list|)
condition|)
name|qWarning
argument_list|()
operator|<<
literal|"could not write to file"
operator|<<
name|sslKeyFile
expr_stmt|;
name|file
operator|.
name|close
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|qWarning
argument_list|(
literal|"could not decrypt SSL traffic"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|// Cache this SSL session inside the QSslContext
if|if
condition|(
operator|!
operator|(
name|configuration
operator|.
name|sslOptions
operator|&
name|QSsl
operator|::
name|SslOptionDisableSessionSharing
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|sslContextPointer
operator|->
name|cacheSession
argument_list|(
name|ssl
argument_list|)
condition|)
block|{
name|sslContextPointer
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// we could not cache the session
block|}
else|else
block|{
comment|// Cache the session for permanent usage as well
if|if
condition|(
operator|!
operator|(
name|configuration
operator|.
name|sslOptions
operator|&
name|QSsl
operator|::
name|SslOptionDisableSessionPersistence
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|sslContextPointer
operator|->
name|sessionASN1
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|configuration
operator|.
name|sslSession
operator|=
name|sslContextPointer
operator|->
name|sessionASN1
argument_list|()
expr_stmt|;
name|configuration
operator|.
name|sslSessionTicketLifeTimeHint
operator|=
name|sslContextPointer
operator|->
name|sessionTicketLifeTimeHint
argument_list|()
expr_stmt|;
block|}
block|}
block|}
if|#
directive|if
name|OPENSSL_VERSION_NUMBER
operator|>=
literal|0x1000100fL
operator|&&
operator|!
name|defined
argument_list|(
name|OPENSSL_NO_TLSEXT
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|OPENSSL_NO_NEXTPROTONEG
argument_list|)
specifier|const
name|unsigned
name|char
modifier|*
name|proto
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|proto_len
init|=
literal|0
decl_stmt|;
name|q_SSL_get0_next_proto_negotiated
argument_list|(
name|ssl
argument_list|,
operator|&
name|proto
argument_list|,
operator|&
name|proto_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|proto_len
condition|)
name|configuration
operator|.
name|nextNegotiatedProtocol
operator|=
name|QByteArray
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|char
operator|*
argument_list|>
argument_list|(
name|proto
argument_list|)
argument_list|,
name|proto_len
argument_list|)
expr_stmt|;
else|else
name|configuration
operator|.
name|nextNegotiatedProtocol
operator|.
name|clear
argument_list|()
expr_stmt|;
name|configuration
operator|.
name|nextProtocolNegotiationStatus
operator|=
name|sslContextPointer
operator|->
name|npnContext
argument_list|()
operator|.
name|status
expr_stmt|;
endif|#
directive|endif
comment|// OPENSSL_VERSION_NUMBER>= 0x1000100fL ...
name|connectionEncrypted
operator|=
literal|true
expr_stmt|;
emit|emit
name|q
operator|->
name|encrypted
argument_list|()
emit|;
if|if
condition|(
name|autoStartHandshake
operator|&&
name|pendingClose
condition|)
block|{
name|pendingClose
operator|=
literal|false
expr_stmt|;
name|q
operator|->
name|disconnectFromHost
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_decl_stmt
name|QList
argument_list|<
name|QSslCertificate
argument_list|>
name|QSslSocketBackendPrivate
operator|::
name|STACKOFX509_to_QSslCertificates
argument_list|(
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
name|x509
argument_list|)
argument_list|{
name|ensureInitialized
argument_list|()
argument_list|;
name|QList
argument_list|<
name|QSslCertificate
argument_list|>
name|certificates
argument_list|;     for
operator|(
name|int
name|i
operator|=
literal|0
expr|;
name|i
operator|<
name|q_sk_X509_num
argument_list|(
name|x509
argument_list|)
expr|;
operator|++
name|i
operator|)
block|{
if|if
condition|(
name|X509
modifier|*
name|entry
type|=
name|q_sk_X509_value
type|(
name|x509
condition|,
name|i
condition|))             certificates<< QSslCertificatePrivate::QSslCertificate_from_X509(entry)
empty_stmt|;
block|}
return|return
name|certificates
return|;
end_decl_stmt
begin_macro
unit|}  bool
DECL|function|isMatchingHostname
name|QSslSocketBackendPrivate
end_macro
begin_expr_stmt
DECL|function|isMatchingHostname
operator|::
name|isMatchingHostname
operator|(
specifier|const
name|QSslCertificate
operator|&
name|cert
operator|,
specifier|const
name|QString
operator|&
name|peerName
operator|)
block|{
name|QStringList
name|commonNameList
operator|=
name|cert
operator|.
name|subjectInfo
argument_list|(
name|QSslCertificate
operator|::
name|CommonName
argument_list|)
block|;
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|commonName
decl|,
name|commonNameList
control|)
block|{
if|if
condition|(
name|isMatchingHostname
argument_list|(
name|commonName
operator|.
name|toLower
argument_list|()
argument_list|,
name|peerName
operator|.
name|toLower
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
end_expr_stmt
begin_expr_stmt
unit|}      foreach
operator|(
specifier|const
name|QString
operator|&
name|altName
operator|,
name|cert
operator|.
name|subjectAlternativeNames
argument_list|()
operator|.
name|values
argument_list|(
name|QSsl
operator|::
name|DnsEntry
argument_list|)
operator|)
block|{
if|if
condition|(
name|isMatchingHostname
argument_list|(
name|altName
operator|.
name|toLower
argument_list|()
argument_list|,
name|peerName
operator|.
name|toLower
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
end_expr_stmt
begin_expr_stmt
unit|}      return
literal|false
expr_stmt|;
end_expr_stmt
begin_macro
unit|}  bool
DECL|function|isMatchingHostname
name|QSslSocketBackendPrivate
end_macro
begin_expr_stmt
DECL|function|isMatchingHostname
operator|::
name|isMatchingHostname
operator|(
specifier|const
name|QString
operator|&
name|cn
operator|,
specifier|const
name|QString
operator|&
name|hostname
operator|)
block|{
name|int
name|wildcard
operator|=
name|cn
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'*'
argument_list|)
argument_list|)
block|;
comment|// Check this is a wildcard cert, if not then just compare the strings
if|if
condition|(
name|wildcard
operator|<
literal|0
condition|)
return|return
name|cn
operator|==
name|hostname
return|;
name|int
name|firstCnDot
operator|=
name|cn
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt
begin_decl_stmt
name|int
name|secondCnDot
init|=
name|cn
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
argument_list|,
name|firstCnDot
operator|+
literal|1
argument_list|)
decl_stmt|;
end_decl_stmt
begin_comment
comment|// Check at least 3 components
end_comment
begin_if
if|if
condition|(
operator|(
operator|-
literal|1
operator|==
name|secondCnDot
operator|)
operator|||
operator|(
name|secondCnDot
operator|+
literal|1
operator|>=
name|cn
operator|.
name|length
argument_list|()
operator|)
condition|)
return|return
literal|false
return|;
end_if
begin_comment
comment|// Check * is last character of 1st component (ie. there's a following .)
end_comment
begin_if
if|if
condition|(
name|wildcard
operator|+
literal|1
operator|!=
name|firstCnDot
condition|)
return|return
literal|false
return|;
end_if
begin_comment
comment|// Check only one star
end_comment
begin_if
if|if
condition|(
name|cn
operator|.
name|lastIndexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'*'
argument_list|)
argument_list|)
operator|!=
name|wildcard
condition|)
return|return
literal|false
return|;
end_if
begin_comment
comment|// Check characters preceding * (if any) match
end_comment
begin_if
if|if
condition|(
name|wildcard
operator|&&
operator|(
name|hostname
operator|.
name|leftRef
argument_list|(
name|wildcard
argument_list|)
operator|!=
name|cn
operator|.
name|leftRef
argument_list|(
name|wildcard
argument_list|)
operator|)
condition|)
return|return
literal|false
return|;
end_if
begin_comment
comment|// Check characters following first . match
end_comment
begin_if
if|if
condition|(
name|hostname
operator|.
name|midRef
argument_list|(
name|hostname
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|cn
operator|.
name|midRef
argument_list|(
name|firstCnDot
argument_list|)
condition|)
return|return
literal|false
return|;
end_if
begin_comment
comment|// Check if the hostname is an IP address, if so then wildcards are not allowed
end_comment
begin_function_decl
name|QHostAddress
name|addr
parameter_list|(
name|hostname
parameter_list|)
function_decl|;
end_function_decl
begin_if
if|if
condition|(
operator|!
name|addr
operator|.
name|isNull
argument_list|()
condition|)
return|return
literal|false
return|;
end_if
begin_comment
comment|// Ok, I guess this was a wildcard CN and the hostname matches.
end_comment
begin_return
return|return
literal|true
return|;
end_return
begin_expr_stmt
unit|}  QList
DECL|function|verify
operator|<
name|QSslError
operator|>
name|QSslSocketBackendPrivate
operator|::
name|verify
operator|(
name|QList
argument_list|<
name|QSslCertificate
argument_list|>
name|certificateChain
operator|,
specifier|const
name|QString
operator|&
name|hostName
operator|)
block|{
name|QList
argument_list|<
name|QSslError
argument_list|>
name|errors
block|;
if|if
condition|(
name|certificateChain
operator|.
name|count
argument_list|()
operator|<=
literal|0
condition|)
block|{
name|errors
operator|<<
name|QSslError
argument_list|(
name|QSslError
operator|::
name|UnspecifiedError
argument_list|)
expr_stmt|;
return|return
name|errors
return|;
block|}
comment|// Setup the store with the default CA certificates
name|X509_STORE
operator|*
name|certStore
operator|=
name|q_X509_STORE_new
argument_list|()
expr_stmt|;
end_expr_stmt
begin_if
if|if
condition|(
operator|!
name|certStore
condition|)
block|{
name|qWarning
argument_list|()
operator|<<
literal|"Unable to create certificate store"
expr_stmt|;
name|errors
operator|<<
name|QSslError
argument_list|(
name|QSslError
operator|::
name|UnspecifiedError
argument_list|)
expr_stmt|;
return|return
name|errors
return|;
block|}
end_if
begin_if
if|if
condition|(
name|s_loadRootCertsOnDemand
condition|)
block|{
name|setDefaultCaCertificates
argument_list|(
name|defaultCaCertificates
argument_list|()
operator|+
name|systemCaCertificates
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_if
begin_foreach
foreach|foreach
control|(
specifier|const
name|QSslCertificate
modifier|&
name|caCertificate
decl|,
name|QSslSocket
operator|::
name|defaultCaCertificates
argument_list|()
control|)
block|{
comment|// From https://www.openssl.org/docs/ssl/SSL_CTX_load_verify_locations.html:
comment|//
comment|// If several CA certificates matching the name, key identifier, and
comment|// serial number condition are available, only the first one will be
comment|// examined. This may lead to unexpected results if the same CA
comment|// certificate is available with different expiration dates. If a
comment|// ``certificate expired'' verification error occurs, no other
comment|// certificate will be searched. Make sure to not have expired
comment|// certificates mixed with valid ones.
comment|//
comment|// See also: QSslContext::fromConfiguration()
if|if
condition|(
name|caCertificate
operator|.
name|expiryDate
argument_list|()
operator|>=
name|QDateTime
operator|::
name|currentDateTime
argument_list|()
condition|)
block|{
name|q_X509_STORE_add_cert
argument_list|(
name|certStore
argument_list|,
cast|reinterpret_cast
argument_list|<
name|X509
operator|*
argument_list|>
argument_list|(
name|caCertificate
operator|.
name|handle
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_foreach
begin_decl_stmt
name|QMutexLocker
name|sslErrorListMutexLocker
argument_list|(
operator|&
name|_q_sslErrorList
argument_list|()
operator|->
name|mutex
argument_list|)
decl_stmt|;
end_decl_stmt
begin_comment
comment|// Register a custom callback to get all verification errors.
end_comment
begin_expr_stmt
name|X509_STORE_set_verify_cb_func
argument_list|(
name|certStore
argument_list|,
name|q_X509Callback
argument_list|)
expr_stmt|;
end_expr_stmt
begin_comment
comment|// Build the chain of intermediate certificates
end_comment
begin_expr_stmt
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
name|intermediates
operator|=
literal|0
expr_stmt|;
end_expr_stmt
begin_if
if|if
condition|(
name|certificateChain
operator|.
name|length
argument_list|()
operator|>
literal|1
condition|)
block|{
name|intermediates
operator|=
operator|(
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
operator|)
name|q_sk_new_null
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|intermediates
condition|)
block|{
name|q_X509_STORE_free
argument_list|(
name|certStore
argument_list|)
expr_stmt|;
name|errors
operator|<<
name|QSslError
argument_list|(
name|QSslError
operator|::
name|UnspecifiedError
argument_list|)
expr_stmt|;
return|return
name|errors
return|;
block|}
name|bool
name|first
init|=
literal|true
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|QSslCertificate
modifier|&
name|cert
decl|,
name|certificateChain
control|)
block|{
if|if
condition|(
name|first
condition|)
block|{
name|first
operator|=
literal|false
expr_stmt|;
continue|continue;
block|}
if|#
directive|if
name|OPENSSL_VERSION_NUMBER
operator|>=
literal|0x10000000L
name|q_sk_push
argument_list|(
operator|(
name|_STACK
operator|*
operator|)
name|intermediates
argument_list|,
cast|reinterpret_cast
argument_list|<
name|X509
operator|*
argument_list|>
argument_list|(
name|cert
operator|.
name|handle
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|q_sk_push
argument_list|(
operator|(
name|STACK
operator|*
operator|)
name|intermediates
argument_list|,
cast|reinterpret_cast
argument_list|<
name|char
operator|*
argument_list|>
argument_list|(
name|cert
operator|.
name|handle
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_if
begin_decl_stmt
name|X509_STORE_CTX
modifier|*
name|storeContext
init|=
name|q_X509_STORE_CTX_new
argument_list|()
decl_stmt|;
end_decl_stmt
begin_if
if|if
condition|(
operator|!
name|storeContext
condition|)
block|{
name|q_X509_STORE_free
argument_list|(
name|certStore
argument_list|)
expr_stmt|;
name|errors
operator|<<
name|QSslError
argument_list|(
name|QSslError
operator|::
name|UnspecifiedError
argument_list|)
expr_stmt|;
return|return
name|errors
return|;
block|}
end_if
begin_if
if|if
condition|(
operator|!
name|q_X509_STORE_CTX_init
argument_list|(
name|storeContext
argument_list|,
name|certStore
argument_list|,
cast|reinterpret_cast
argument_list|<
name|X509
operator|*
argument_list|>
argument_list|(
name|certificateChain
index|[
literal|0
index|]
operator|.
name|handle
argument_list|()
argument_list|)
argument_list|,
name|intermediates
argument_list|)
condition|)
block|{
name|q_X509_STORE_CTX_free
argument_list|(
name|storeContext
argument_list|)
expr_stmt|;
name|q_X509_STORE_free
argument_list|(
name|certStore
argument_list|)
expr_stmt|;
name|errors
operator|<<
name|QSslError
argument_list|(
name|QSslError
operator|::
name|UnspecifiedError
argument_list|)
expr_stmt|;
return|return
name|errors
return|;
block|}
end_if
begin_comment
comment|// Now we can actually perform the verification of the chain we have built.
end_comment
begin_comment
comment|// We ignore the result of this function since we process errors via the
end_comment
begin_comment
comment|// callback.
end_comment
begin_expr_stmt
operator|(
name|void
operator|)
name|q_X509_verify_cert
argument_list|(
name|storeContext
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|q_X509_STORE_CTX_free
argument_list|(
name|storeContext
argument_list|)
expr_stmt|;
end_expr_stmt
begin_if
if|#
directive|if
name|OPENSSL_VERSION_NUMBER
operator|>=
literal|0x10000000L
end_if
begin_expr_stmt
name|q_sk_free
argument_list|(
operator|(
name|_STACK
operator|*
operator|)
name|intermediates
argument_list|)
expr_stmt|;
end_expr_stmt
begin_else
else|#
directive|else
end_else
begin_expr_stmt
name|q_sk_free
argument_list|(
operator|(
name|STACK
operator|*
operator|)
name|intermediates
argument_list|)
expr_stmt|;
end_expr_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// Now process the errors
end_comment
begin_decl_stmt
specifier|const
name|QList
argument_list|<
name|QPair
argument_list|<
name|int
argument_list|,
name|int
argument_list|>
argument_list|>
name|errorList
init|=
name|_q_sslErrorList
argument_list|()
operator|->
name|errors
decl_stmt|;
end_decl_stmt
begin_expr_stmt
name|_q_sslErrorList
argument_list|()
operator|->
name|errors
operator|.
name|clear
argument_list|()
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|sslErrorListMutexLocker
operator|.
name|unlock
argument_list|()
expr_stmt|;
end_expr_stmt
begin_comment
comment|// Translate the errors
end_comment
begin_if
if|if
condition|(
name|QSslCertificatePrivate
operator|::
name|isBlacklisted
argument_list|(
name|certificateChain
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|QSslError
name|error
parameter_list|(
name|QSslError
operator|::
name|CertificateBlacklisted
parameter_list|,
name|certificateChain
index|[
literal|0
index|]
parameter_list|)
function_decl|;
name|errors
operator|<<
name|error
expr_stmt|;
block|}
end_if
begin_comment
comment|// Check the certificate name against the hostname if one was specified
end_comment
begin_if
if|if
condition|(
operator|(
operator|!
name|hostName
operator|.
name|isEmpty
argument_list|()
operator|)
operator|&&
operator|(
operator|!
name|isMatchingHostname
argument_list|(
name|certificateChain
index|[
literal|0
index|]
argument_list|,
name|hostName
argument_list|)
operator|)
condition|)
block|{
comment|// No matches in common names or alternate names.
name|QSslError
name|error
parameter_list|(
name|QSslError
operator|::
name|HostNameMismatch
parameter_list|,
name|certificateChain
index|[
literal|0
index|]
parameter_list|)
function_decl|;
name|errors
operator|<<
name|error
expr_stmt|;
block|}
end_if
begin_comment
comment|// Translate errors from the error list into QSslErrors.
end_comment
begin_for
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|errorList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QPair
argument_list|<
name|int
argument_list|,
name|int
argument_list|>
modifier|&
name|errorAndDepth
init|=
name|errorList
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|int
name|err
init|=
name|errorAndDepth
operator|.
name|first
decl_stmt|;
name|int
name|depth
init|=
name|errorAndDepth
operator|.
name|second
decl_stmt|;
name|errors
operator|<<
name|_q_OpenSSL_to_QSslError
argument_list|(
name|err
argument_list|,
name|certificateChain
operator|.
name|value
argument_list|(
name|depth
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_for
begin_expr_stmt
name|q_X509_STORE_free
argument_list|(
name|certStore
argument_list|)
expr_stmt|;
end_expr_stmt
begin_return
return|return
name|errors
return|;
end_return
begin_macro
unit|}  bool
DECL|function|importPKCS12
name|QSslSocketBackendPrivate
end_macro
begin_expr_stmt
DECL|function|importPKCS12
operator|::
name|importPKCS12
operator|(
name|QIODevice
operator|*
name|device
operator|,
name|QSslKey
operator|*
name|key
operator|,
name|QSslCertificate
operator|*
name|cert
operator|,
name|QList
argument_list|<
name|QSslCertificate
argument_list|>
operator|*
name|caCertificates
operator|,
specifier|const
name|QByteArray
operator|&
name|passPhrase
operator|)
block|{
if|if
condition|(
operator|!
name|supportsSsl
argument_list|()
condition|)
return|return
literal|false
return|;
comment|// These are required
name|Q_ASSERT
argument_list|(
name|device
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|Q_ASSERT
argument_list|(
name|key
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|Q_ASSERT
argument_list|(
name|cert
argument_list|)
expr_stmt|;
end_expr_stmt
begin_comment
comment|// Read the file into a BIO
end_comment
begin_decl_stmt
name|QByteArray
name|pkcs12data
init|=
name|device
operator|->
name|readAll
argument_list|()
decl_stmt|;
end_decl_stmt
begin_if
if|if
condition|(
name|pkcs12data
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
return|return
literal|false
return|;
end_if
begin_decl_stmt
name|BIO
modifier|*
name|bio
init|=
name|q_BIO_new_mem_buf
argument_list|(
cast|const_cast
argument_list|<
name|char
operator|*
argument_list|>
argument_list|(
name|pkcs12data
operator|.
name|constData
argument_list|()
argument_list|)
argument_list|,
name|pkcs12data
operator|.
name|size
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt
begin_comment
comment|// Create the PKCS#12 object
end_comment
begin_decl_stmt
name|PKCS12
modifier|*
name|p12
init|=
name|q_d2i_PKCS12_bio
argument_list|(
name|bio
argument_list|,
literal|0
argument_list|)
decl_stmt|;
end_decl_stmt
begin_if
if|if
condition|(
operator|!
name|p12
condition|)
block|{
name|qWarning
argument_list|(
literal|"Unable to read PKCS#12 structure, %s"
argument_list|,
name|q_ERR_error_string
argument_list|(
name|q_ERR_get_error
argument_list|()
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|q_BIO_free
argument_list|(
name|bio
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_if
begin_comment
comment|// Extract the data
end_comment
begin_decl_stmt
name|EVP_PKEY
modifier|*
name|pkey
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|X509
modifier|*
name|x509
decl_stmt|;
end_decl_stmt
begin_expr_stmt
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
name|ca
operator|=
literal|0
expr_stmt|;
end_expr_stmt
begin_if
if|if
condition|(
operator|!
name|q_PKCS12_parse
argument_list|(
name|p12
argument_list|,
name|passPhrase
operator|.
name|constData
argument_list|()
argument_list|,
operator|&
name|pkey
argument_list|,
operator|&
name|x509
argument_list|,
operator|&
name|ca
argument_list|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"Unable to parse PKCS#12 structure, %s"
argument_list|,
name|q_ERR_error_string
argument_list|(
name|q_ERR_get_error
argument_list|()
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|q_PKCS12_free
argument_list|(
name|p12
argument_list|)
expr_stmt|;
name|q_BIO_free
argument_list|(
name|bio
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_if
begin_comment
comment|// Convert to Qt types
end_comment
begin_if
if|if
condition|(
operator|!
name|key
operator|->
name|d
operator|->
name|fromEVP_PKEY
argument_list|(
name|pkey
argument_list|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"Unable to convert private key"
argument_list|)
expr_stmt|;
name|q_sk_pop_free
argument_list|(
cast|reinterpret_cast
argument_list|<
name|STACK
operator|*
argument_list|>
argument_list|(
name|ca
argument_list|)
argument_list|,
cast|reinterpret_cast
argument_list|<
name|void
operator|(
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
argument_list|>
argument_list|(
name|q_sk_free
argument_list|)
argument_list|)
expr_stmt|;
name|q_X509_free
argument_list|(
name|x509
argument_list|)
expr_stmt|;
name|q_EVP_PKEY_free
argument_list|(
name|pkey
argument_list|)
expr_stmt|;
name|q_PKCS12_free
argument_list|(
name|p12
argument_list|)
expr_stmt|;
name|q_BIO_free
argument_list|(
name|bio
argument_list|)
expr_stmt|;
return|return
literal|false
return|;
block|}
end_if
begin_expr_stmt
operator|*
name|cert
operator|=
name|QSslCertificatePrivate
operator|::
name|QSslCertificate_from_X509
argument_list|(
name|x509
argument_list|)
expr_stmt|;
end_expr_stmt
begin_if
if|if
condition|(
name|caCertificates
condition|)
operator|*
name|caCertificates
operator|=
name|QSslSocketBackendPrivate
operator|::
name|STACKOFX509_to_QSslCertificates
argument_list|(
name|ca
argument_list|)
expr_stmt|;
end_if
begin_comment
comment|// Clean up
end_comment
begin_expr_stmt
name|q_sk_pop_free
argument_list|(
cast|reinterpret_cast
argument_list|<
name|STACK
operator|*
argument_list|>
argument_list|(
name|ca
argument_list|)
argument_list|,
cast|reinterpret_cast
argument_list|<
name|void
operator|(
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
argument_list|>
argument_list|(
name|q_sk_free
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|q_X509_free
argument_list|(
name|x509
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|q_EVP_PKEY_free
argument_list|(
name|pkey
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|q_PKCS12_free
argument_list|(
name|p12
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|q_BIO_free
argument_list|(
name|bio
argument_list|)
expr_stmt|;
end_expr_stmt
begin_return
return|return
literal|true
return|;
end_return
unit|}   QT_END_NAMESPACE
end_unit
