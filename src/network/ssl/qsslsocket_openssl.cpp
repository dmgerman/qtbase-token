begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the QtNetwork module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_comment
comment|//#define QSSLSOCKET_DEBUG
end_comment
begin_include
include|#
directive|include
file|"qsslsocket_openssl_p.h"
end_include
begin_include
include|#
directive|include
file|"qsslsocket_openssl_symbols_p.h"
end_include
begin_include
include|#
directive|include
file|"qsslsocket.h"
end_include
begin_include
include|#
directive|include
file|"qsslcertificate_p.h"
end_include
begin_include
include|#
directive|include
file|"qsslcipher_p.h"
end_include
begin_include
include|#
directive|include
file|<QtCore/qdatetime.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qdebug.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qdir.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qdiriterator.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qelapsedtimer.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qfile.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qfileinfo.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qmutex.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qthread.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qurl.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/qvarlengtharray.h>
end_include
begin_include
include|#
directive|include
file|<QLibrary>
end_include
begin_comment
comment|// for loading the security lib for the CA store
end_comment
begin_if
if|#
directive|if
name|OPENSSL_VERSION_NUMBER
operator|>=
literal|0x0090806fL
operator|&&
operator|!
name|defined
argument_list|(
name|OPENSSL_NO_TLSEXT
argument_list|)
end_if
begin_comment
comment|// Symbian does not seem to have the symbol for SNI defined
end_comment
begin_ifndef
ifndef|#
directive|ifndef
name|SSL_CTRL_SET_TLSEXT_HOSTNAME
end_ifndef
begin_define
DECL|macro|SSL_CTRL_SET_TLSEXT_HOSTNAME
define|#
directive|define
name|SSL_CTRL_SET_TLSEXT_HOSTNAME
value|55
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
name|QT_BEGIN_NAMESPACE
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_MAC
argument_list|)
DECL|macro|kSecTrustSettingsDomainSystem
define|#
directive|define
name|kSecTrustSettingsDomainSystem
value|2
comment|// so we do not need to include the header file
DECL|member|ptrSecCertificateGetData
name|PtrSecCertificateGetData
name|QSslSocketPrivate
operator|::
name|ptrSecCertificateGetData
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|ptrSecTrustSettingsCopyCertificates
name|PtrSecTrustSettingsCopyCertificates
name|QSslSocketPrivate
operator|::
name|ptrSecTrustSettingsCopyCertificates
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|ptrSecTrustCopyAnchorCertificates
name|PtrSecTrustCopyAnchorCertificates
name|QSslSocketPrivate
operator|::
name|ptrSecTrustCopyAnchorCertificates
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
end_elif
begin_decl_stmt
name|PtrCertOpenSystemStoreW
name|QSslSocketPrivate
operator|::
name|ptrCertOpenSystemStoreW
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|PtrCertFindCertificateInStore
name|QSslSocketPrivate
operator|::
name|ptrCertFindCertificateInStore
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_decl_stmt
name|PtrCertCloseStore
name|QSslSocketPrivate
operator|::
name|ptrCertCloseStore
init|=
literal|0
decl_stmt|;
end_decl_stmt
begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_SYMBIAN
argument_list|)
end_elif
begin_include
include|#
directive|include
file|<e32base.h>
end_include
begin_include
include|#
directive|include
file|<e32std.h>
end_include
begin_include
include|#
directive|include
file|<e32debug.h>
end_include
begin_include
include|#
directive|include
file|<QtCore/private/qcore_symbian_p.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_decl_stmt
DECL|member|s_libraryLoaded
name|bool
name|QSslSocketPrivate
operator|::
name|s_libraryLoaded
init|=
literal|false
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|s_loadedCiphersAndCerts
name|bool
name|QSslSocketPrivate
operator|::
name|s_loadedCiphersAndCerts
init|=
literal|false
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|member|s_loadRootCertsOnDemand
name|bool
name|QSslSocketPrivate
operator|::
name|s_loadRootCertsOnDemand
init|=
literal|false
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* \internal      From OpenSSL's thread(3) manual page:      OpenSSL can safely be used in multi-threaded applications provided that at     least two callback functions are set.      locking_function(int mode, int n, const char *file, int line) is needed to     perform locking on shared data structures.  (Note that OpenSSL uses a     number of global data structures that will be implicitly shared     when-whenever ever multiple threads use OpenSSL.)  Multi-threaded     applications will crash at random if it is not set.  ...     ...     id_function(void) is a function that returns a thread ID. It is not     needed on Windows nor on platforms where getpid() returns a different     ID for each thread (most notably Linux) */
end_comment
begin_class
DECL|class|QOpenSslLocks
class|class
name|QOpenSslLocks
block|{
public|public:
DECL|function|QOpenSslLocks
specifier|inline
name|QOpenSslLocks
parameter_list|()
member_init_list|:
name|initLocker
argument_list|(
name|QMutex
operator|::
name|Recursive
argument_list|)
member_init_list|,
name|locksLocker
argument_list|(
name|QMutex
operator|::
name|Recursive
argument_list|)
block|{
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|locksLocker
argument_list|)
decl_stmt|;
name|int
name|numLocks
init|=
name|q_CRYPTO_num_locks
argument_list|()
decl_stmt|;
name|locks
operator|=
operator|new
name|QMutex
operator|*
index|[
name|numLocks
index|]
expr_stmt|;
name|memset
argument_list|(
name|locks
argument_list|,
literal|0
argument_list|,
name|numLocks
operator|*
sizeof|sizeof
argument_list|(
name|QMutex
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
DECL|function|~QOpenSslLocks
specifier|inline
name|~
name|QOpenSslLocks
parameter_list|()
block|{
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|locksLocker
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|q_CRYPTO_num_locks
argument_list|()
condition|;
operator|++
name|i
control|)
operator|delete
name|locks
index|[
name|i
index|]
expr_stmt|;
operator|delete
index|[]
name|locks
expr_stmt|;
name|QSslSocketPrivate
operator|::
name|deinitialize
argument_list|()
expr_stmt|;
block|}
DECL|function|lock
specifier|inline
name|QMutex
modifier|*
name|lock
parameter_list|(
name|int
name|num
parameter_list|)
block|{
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|locksLocker
argument_list|)
decl_stmt|;
name|QMutex
modifier|*
name|tmp
init|=
name|locks
index|[
name|num
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|tmp
condition|)
name|tmp
operator|=
name|locks
index|[
name|num
index|]
operator|=
operator|new
name|QMutex
argument_list|(
name|QMutex
operator|::
name|Recursive
argument_list|)
expr_stmt|;
return|return
name|tmp
return|;
block|}
DECL|function|globalLock
name|QMutex
modifier|*
name|globalLock
parameter_list|()
block|{
return|return
operator|&
name|locksLocker
return|;
block|}
DECL|function|initLock
name|QMutex
modifier|*
name|initLock
parameter_list|()
block|{
return|return
operator|&
name|initLocker
return|;
block|}
private|private:
DECL|member|initLocker
name|QMutex
name|initLocker
decl_stmt|;
DECL|member|locksLocker
name|QMutex
name|locksLocker
decl_stmt|;
DECL|member|locks
name|QMutex
modifier|*
modifier|*
name|locks
decl_stmt|;
block|}
class|;
end_class
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|QOpenSslLocks
argument_list|,
argument|openssl_locks
argument_list|)
end_macro
begin_extern
extern|extern
literal|"C"
block|{
DECL|function|locking_function
specifier|static
name|void
name|locking_function
parameter_list|(
name|int
name|mode
parameter_list|,
name|int
name|lockNumber
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
block|{
name|QMutex
modifier|*
name|mutex
init|=
name|openssl_locks
argument_list|()
operator|->
name|lock
argument_list|(
name|lockNumber
argument_list|)
decl_stmt|;
comment|// Lock or unlock it
if|if
condition|(
name|mode
operator|&
name|CRYPTO_LOCK
condition|)
name|mutex
operator|->
name|lock
argument_list|()
expr_stmt|;
else|else
name|mutex
operator|->
name|unlock
argument_list|()
expr_stmt|;
block|}
DECL|function|id_function
specifier|static
name|unsigned
name|long
name|id_function
parameter_list|()
block|{
return|return
operator|(
name|quintptr
operator|)
name|QThread
operator|::
name|currentThreadId
argument_list|()
return|;
block|}
block|}
end_extern
begin_comment
comment|// extern "C"
end_comment
begin_constructor
DECL|function|QSslSocketBackendPrivate
name|QSslSocketBackendPrivate
operator|::
name|QSslSocketBackendPrivate
parameter_list|()
member_init_list|:
name|ssl
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|ctx
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|pkey
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|readBio
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|writeBio
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|session
argument_list|(
literal|0
argument_list|)
block|{
comment|// Calls SSL_library_init().
name|ensureInitialized
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QSslSocketBackendPrivate
name|QSslSocketBackendPrivate
operator|::
name|~
name|QSslSocketBackendPrivate
parameter_list|()
block|{ }
end_destructor
begin_function
DECL|function|QSslCipher_from_SSL_CIPHER
name|QSslCipher
name|QSslSocketBackendPrivate
operator|::
name|QSslCipher_from_SSL_CIPHER
parameter_list|(
name|SSL_CIPHER
modifier|*
name|cipher
parameter_list|)
block|{
name|QSslCipher
name|ciph
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|QString
name|descriptionOneLine
init|=
name|QString
operator|::
name|fromLatin1
argument_list|(
name|q_SSL_CIPHER_description
argument_list|(
name|cipher
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
name|QStringList
name|descriptionList
init|=
name|descriptionOneLine
operator|.
name|split
argument_list|(
name|QLatin1String
argument_list|(
literal|" "
argument_list|)
argument_list|,
name|QString
operator|::
name|SkipEmptyParts
argument_list|)
decl_stmt|;
if|if
condition|(
name|descriptionList
operator|.
name|size
argument_list|()
operator|>
literal|5
condition|)
block|{
comment|// ### crude code.
name|ciph
operator|.
name|d
operator|->
name|isNull
operator|=
literal|false
expr_stmt|;
name|ciph
operator|.
name|d
operator|->
name|name
operator|=
name|descriptionList
operator|.
name|at
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|QString
name|protoString
init|=
name|descriptionList
operator|.
name|at
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|ciph
operator|.
name|d
operator|->
name|protocolString
operator|=
name|protoString
expr_stmt|;
name|ciph
operator|.
name|d
operator|->
name|protocol
operator|=
name|QSsl
operator|::
name|UnknownProtocol
expr_stmt|;
if|if
condition|(
name|protoString
operator|==
name|QLatin1String
argument_list|(
literal|"SSLv3"
argument_list|)
condition|)
name|ciph
operator|.
name|d
operator|->
name|protocol
operator|=
name|QSsl
operator|::
name|SslV3
expr_stmt|;
elseif|else
if|if
condition|(
name|protoString
operator|==
name|QLatin1String
argument_list|(
literal|"SSLv2"
argument_list|)
condition|)
name|ciph
operator|.
name|d
operator|->
name|protocol
operator|=
name|QSsl
operator|::
name|SslV2
expr_stmt|;
elseif|else
if|if
condition|(
name|protoString
operator|==
name|QLatin1String
argument_list|(
literal|"TLSv1"
argument_list|)
condition|)
name|ciph
operator|.
name|d
operator|->
name|protocol
operator|=
name|QSsl
operator|::
name|TlsV1
expr_stmt|;
if|if
condition|(
name|descriptionList
operator|.
name|at
argument_list|(
literal|2
argument_list|)
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"Kx="
argument_list|)
argument_list|)
condition|)
name|ciph
operator|.
name|d
operator|->
name|keyExchangeMethod
operator|=
name|descriptionList
operator|.
name|at
argument_list|(
literal|2
argument_list|)
operator|.
name|mid
argument_list|(
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|descriptionList
operator|.
name|at
argument_list|(
literal|3
argument_list|)
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"Au="
argument_list|)
argument_list|)
condition|)
name|ciph
operator|.
name|d
operator|->
name|authenticationMethod
operator|=
name|descriptionList
operator|.
name|at
argument_list|(
literal|3
argument_list|)
operator|.
name|mid
argument_list|(
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|descriptionList
operator|.
name|at
argument_list|(
literal|4
argument_list|)
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"Enc="
argument_list|)
argument_list|)
condition|)
name|ciph
operator|.
name|d
operator|->
name|encryptionMethod
operator|=
name|descriptionList
operator|.
name|at
argument_list|(
literal|4
argument_list|)
operator|.
name|mid
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|ciph
operator|.
name|d
operator|->
name|exportable
operator|=
operator|(
name|descriptionList
operator|.
name|size
argument_list|()
operator|>
literal|6
operator|&&
name|descriptionList
operator|.
name|at
argument_list|(
literal|6
argument_list|)
operator|==
name|QLatin1String
argument_list|(
literal|"export"
argument_list|)
operator|)
expr_stmt|;
name|ciph
operator|.
name|d
operator|->
name|bits
operator|=
name|cipher
operator|->
name|strength_bits
expr_stmt|;
name|ciph
operator|.
name|d
operator|->
name|supportedBits
operator|=
name|cipher
operator|->
name|alg_bits
expr_stmt|;
block|}
return|return
name|ciph
return|;
block|}
end_function
begin_comment
comment|// ### This list is shared between all threads, and protected by a
end_comment
begin_comment
comment|// mutex. Investigate using thread local storage instead.
end_comment
begin_struct
DECL|struct|QSslErrorList
struct|struct
name|QSslErrorList
block|{
DECL|member|mutex
name|QMutex
name|mutex
decl_stmt|;
DECL|member|errors
name|QList
argument_list|<
name|QPair
argument_list|<
name|int
argument_list|,
name|int
argument_list|>
argument_list|>
name|errors
decl_stmt|;
block|}
struct|;
end_struct
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|QSslErrorList
argument_list|,
argument|_q_sslErrorList
argument_list|)
end_macro
begin_function
DECL|function|q_X509Callback
specifier|static
name|int
name|q_X509Callback
parameter_list|(
name|int
name|ok
parameter_list|,
name|X509_STORE_CTX
modifier|*
name|ctx
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ok
condition|)
block|{
comment|// Store the error and at which depth the error was detected.
name|_q_sslErrorList
argument_list|()
operator|->
name|errors
operator|<<
name|qMakePair
argument_list|<
name|int
argument_list|,
name|int
argument_list|>
argument_list|(
name|ctx
operator|->
name|error
argument_list|,
name|ctx
operator|->
name|error_depth
argument_list|)
expr_stmt|;
block|}
comment|// Always return OK to allow verification to continue. We're handle the
comment|// errors gracefully after collecting all errors, after verification has
comment|// completed.
return|return
literal|1
return|;
block|}
end_function
begin_function
DECL|function|initSslContext
name|bool
name|QSslSocketBackendPrivate
operator|::
name|initSslContext
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QSslSocket
argument_list|)
expr_stmt|;
comment|// Create and initialize SSL context. Accept SSLv2, SSLv3 and TLSv1.
name|bool
name|client
init|=
operator|(
name|mode
operator|==
name|QSslSocket
operator|::
name|SslClientMode
operator|)
decl_stmt|;
name|bool
name|reinitialized
init|=
literal|false
decl_stmt|;
name|init_context
label|:
switch|switch
condition|(
name|configuration
operator|.
name|protocol
condition|)
block|{
case|case
name|QSsl
operator|::
name|SslV2
case|:
name|ctx
operator|=
name|q_SSL_CTX_new
argument_list|(
name|client
condition|?
name|q_SSLv2_client_method
argument_list|()
else|:
name|q_SSLv2_server_method
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|QSsl
operator|::
name|SslV3
case|:
name|ctx
operator|=
name|q_SSL_CTX_new
argument_list|(
name|client
condition|?
name|q_SSLv3_client_method
argument_list|()
else|:
name|q_SSLv3_server_method
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|QSsl
operator|::
name|SecureProtocols
case|:
comment|// SslV2 will be disabled below
case|case
name|QSsl
operator|::
name|TlsV1SslV3
case|:
comment|// SslV2 will be disabled below
case|case
name|QSsl
operator|::
name|AnyProtocol
case|:
default|default:
name|ctx
operator|=
name|q_SSL_CTX_new
argument_list|(
name|client
condition|?
name|q_SSLv23_client_method
argument_list|()
else|:
name|q_SSLv23_server_method
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|QSsl
operator|::
name|TlsV1
case|:
name|ctx
operator|=
name|q_SSL_CTX_new
argument_list|(
name|client
condition|?
name|q_TLSv1_client_method
argument_list|()
else|:
name|q_TLSv1_server_method
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|ctx
condition|)
block|{
comment|// After stopping Flash 10 the SSL library looses its ciphers. Try re-adding them
comment|// by re-initializing the library.
if|if
condition|(
operator|!
name|reinitialized
condition|)
block|{
name|reinitialized
operator|=
literal|true
expr_stmt|;
if|if
condition|(
name|q_SSL_library_init
argument_list|()
operator|==
literal|1
condition|)
goto|goto
name|init_context
goto|;
block|}
comment|// ### Bad error code
name|q
operator|->
name|setErrorString
argument_list|(
name|QSslSocket
operator|::
name|tr
argument_list|(
literal|"Error creating SSL context (%1)"
argument_list|)
operator|.
name|arg
argument_list|(
name|getErrorsFromOpenSsl
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|->
name|setSocketError
argument_list|(
name|QAbstractSocket
operator|::
name|UnknownSocketError
argument_list|)
expr_stmt|;
emit|emit
name|q
operator|->
name|error
argument_list|(
name|QAbstractSocket
operator|::
name|UnknownSocketError
argument_list|)
emit|;
return|return
literal|false
return|;
block|}
comment|// Enable all bug workarounds.
if|if
condition|(
name|configuration
operator|.
name|protocol
operator|==
name|QSsl
operator|::
name|TlsV1SslV3
operator|||
name|configuration
operator|.
name|protocol
operator|==
name|QSsl
operator|::
name|SecureProtocols
condition|)
block|{
name|q_SSL_CTX_set_options
argument_list|(
name|ctx
argument_list|,
name|SSL_OP_ALL
operator||
name|SSL_OP_NO_SSLv2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|q_SSL_CTX_set_options
argument_list|(
name|ctx
argument_list|,
name|SSL_OP_ALL
argument_list|)
expr_stmt|;
block|}
comment|// Initialize ciphers
name|QByteArray
name|cipherString
decl_stmt|;
name|int
name|first
init|=
literal|true
decl_stmt|;
name|QList
argument_list|<
name|QSslCipher
argument_list|>
name|ciphers
init|=
name|configuration
operator|.
name|ciphers
decl_stmt|;
if|if
condition|(
name|ciphers
operator|.
name|isEmpty
argument_list|()
condition|)
name|ciphers
operator|=
name|defaultCiphers
argument_list|()
expr_stmt|;
foreach|foreach
control|(
specifier|const
name|QSslCipher
modifier|&
name|cipher
decl|,
name|ciphers
control|)
block|{
if|if
condition|(
name|first
condition|)
name|first
operator|=
literal|false
expr_stmt|;
else|else
name|cipherString
operator|.
name|append
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
name|cipherString
operator|.
name|append
argument_list|(
name|cipher
operator|.
name|name
argument_list|()
operator|.
name|toLatin1
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|q_SSL_CTX_set_cipher_list
argument_list|(
name|ctx
argument_list|,
name|cipherString
operator|.
name|data
argument_list|()
argument_list|)
condition|)
block|{
comment|// ### Bad error code
name|q
operator|->
name|setErrorString
argument_list|(
name|QSslSocket
operator|::
name|tr
argument_list|(
literal|"Invalid or empty cipher list (%1)"
argument_list|)
operator|.
name|arg
argument_list|(
name|getErrorsFromOpenSsl
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|->
name|setSocketError
argument_list|(
name|QAbstractSocket
operator|::
name|UnknownSocketError
argument_list|)
expr_stmt|;
emit|emit
name|q
operator|->
name|error
argument_list|(
name|QAbstractSocket
operator|::
name|UnknownSocketError
argument_list|)
emit|;
return|return
literal|false
return|;
block|}
comment|// Add all our CAs to this store.
name|QList
argument_list|<
name|QSslCertificate
argument_list|>
name|expiredCerts
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|QSslCertificate
modifier|&
name|caCertificate
decl|,
name|q
operator|->
name|caCertificates
argument_list|()
control|)
block|{
comment|// add expired certs later, so that the
comment|// valid ones are used before the expired ones
if|if
condition|(
operator|!
name|caCertificate
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|expiredCerts
operator|.
name|append
argument_list|(
name|caCertificate
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|q_X509_STORE_add_cert
argument_list|(
name|ctx
operator|->
name|cert_store
argument_list|,
operator|(
name|X509
operator|*
operator|)
name|caCertificate
operator|.
name|handle
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|bool
name|addExpiredCerts
init|=
literal|true
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_MAC
argument_list|)
operator|&&
operator|(
name|MAC_OS_X_VERSION_MAX_ALLOWED
operator|==
name|MAC_OS_X_VERSION_10_5
operator|)
comment|//On Leopard SSL does not work if we add the expired certificates.
if|if
condition|(
name|QSysInfo
operator|::
name|MacintoshVersion
operator|==
name|QSysInfo
operator|::
name|MV_10_5
condition|)
name|addExpiredCerts
operator|=
literal|false
expr_stmt|;
endif|#
directive|endif
comment|// now add the expired certs
if|if
condition|(
name|addExpiredCerts
condition|)
block|{
foreach|foreach
control|(
specifier|const
name|QSslCertificate
modifier|&
name|caCertificate
decl|,
name|expiredCerts
control|)
block|{
name|q_X509_STORE_add_cert
argument_list|(
name|ctx
operator|->
name|cert_store
argument_list|,
operator|(
name|X509
operator|*
operator|)
name|caCertificate
operator|.
name|handle
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|s_loadRootCertsOnDemand
operator|&&
name|allowRootCertOnDemandLoading
condition|)
block|{
comment|// tell OpenSSL the directories where to look up the root certs on demand
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|unixDirs
init|=
name|unixRootCertDirectories
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|a
init|=
literal|0
init|;
name|a
operator|<
name|unixDirs
operator|.
name|count
argument_list|()
condition|;
operator|++
name|a
control|)
name|q_SSL_CTX_load_verify_locations
argument_list|(
name|ctx
argument_list|,
literal|0
argument_list|,
name|unixDirs
operator|.
name|at
argument_list|(
name|a
argument_list|)
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// Register a custom callback to get all verification errors.
name|X509_STORE_set_verify_cb_func
argument_list|(
name|ctx
operator|->
name|cert_store
argument_list|,
name|q_X509Callback
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|configuration
operator|.
name|localCertificate
operator|.
name|isNull
argument_list|()
condition|)
block|{
comment|// Require a private key as well.
if|if
condition|(
name|configuration
operator|.
name|privateKey
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|q
operator|->
name|setErrorString
argument_list|(
name|QSslSocket
operator|::
name|tr
argument_list|(
literal|"Cannot provide a certificate with no key, %1"
argument_list|)
operator|.
name|arg
argument_list|(
name|getErrorsFromOpenSsl
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
emit|emit
name|q
operator|->
name|error
argument_list|(
name|QAbstractSocket
operator|::
name|UnknownSocketError
argument_list|)
emit|;
return|return
literal|false
return|;
block|}
comment|// Load certificate
if|if
condition|(
operator|!
name|q_SSL_CTX_use_certificate
argument_list|(
name|ctx
argument_list|,
operator|(
name|X509
operator|*
operator|)
name|configuration
operator|.
name|localCertificate
operator|.
name|handle
argument_list|()
argument_list|)
condition|)
block|{
name|q
operator|->
name|setErrorString
argument_list|(
name|QSslSocket
operator|::
name|tr
argument_list|(
literal|"Error loading local certificate, %1"
argument_list|)
operator|.
name|arg
argument_list|(
name|getErrorsFromOpenSsl
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
emit|emit
name|q
operator|->
name|error
argument_list|(
name|QAbstractSocket
operator|::
name|UnknownSocketError
argument_list|)
emit|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|configuration
operator|.
name|privateKey
operator|.
name|algorithm
argument_list|()
operator|==
name|QSsl
operator|::
name|Opaque
condition|)
block|{
name|pkey
operator|=
cast|reinterpret_cast
argument_list|<
name|EVP_PKEY
operator|*
argument_list|>
argument_list|(
name|configuration
operator|.
name|privateKey
operator|.
name|handle
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Load private key
name|pkey
operator|=
name|q_EVP_PKEY_new
argument_list|()
expr_stmt|;
comment|// before we were using EVP_PKEY_assign_R* functions and did not use EVP_PKEY_free.
comment|// this lead to a memory leak. Now we use the *_set1_* functions which do not
comment|// take ownership of the RSA/DSA key instance because the QSslKey already has ownership.
if|if
condition|(
name|configuration
operator|.
name|privateKey
operator|.
name|algorithm
argument_list|()
operator|==
name|QSsl
operator|::
name|Rsa
condition|)
name|q_EVP_PKEY_set1_RSA
argument_list|(
name|pkey
argument_list|,
operator|(
name|RSA
operator|*
operator|)
name|configuration
operator|.
name|privateKey
operator|.
name|handle
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|q_EVP_PKEY_set1_DSA
argument_list|(
name|pkey
argument_list|,
operator|(
name|DSA
operator|*
operator|)
name|configuration
operator|.
name|privateKey
operator|.
name|handle
argument_list|()
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|q_SSL_CTX_use_PrivateKey
argument_list|(
name|ctx
argument_list|,
name|pkey
argument_list|)
condition|)
block|{
name|q
operator|->
name|setErrorString
argument_list|(
name|QSslSocket
operator|::
name|tr
argument_list|(
literal|"Error loading private key, %1"
argument_list|)
operator|.
name|arg
argument_list|(
name|getErrorsFromOpenSsl
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
emit|emit
name|q
operator|->
name|error
argument_list|(
name|QAbstractSocket
operator|::
name|UnknownSocketError
argument_list|)
emit|;
return|return
literal|false
return|;
block|}
if|if
condition|(
name|configuration
operator|.
name|privateKey
operator|.
name|algorithm
argument_list|()
operator|==
name|QSsl
operator|::
name|Opaque
condition|)
name|pkey
operator|=
literal|0
expr_stmt|;
comment|// Don't free the private key, it belongs to QSslKey
comment|// Check if the certificate matches the private key.
if|if
condition|(
operator|!
name|q_SSL_CTX_check_private_key
argument_list|(
name|ctx
argument_list|)
condition|)
block|{
name|q
operator|->
name|setErrorString
argument_list|(
name|QSslSocket
operator|::
name|tr
argument_list|(
literal|"Private key does not certify public key, %1"
argument_list|)
operator|.
name|arg
argument_list|(
name|getErrorsFromOpenSsl
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
emit|emit
name|q
operator|->
name|error
argument_list|(
name|QAbstractSocket
operator|::
name|UnknownSocketError
argument_list|)
emit|;
return|return
literal|false
return|;
block|}
block|}
comment|// Initialize peer verification.
if|if
condition|(
name|configuration
operator|.
name|peerVerifyMode
operator|==
name|QSslSocket
operator|::
name|VerifyNone
condition|)
block|{
name|q_SSL_CTX_set_verify
argument_list|(
name|ctx
argument_list|,
name|SSL_VERIFY_NONE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|q_SSL_CTX_set_verify
argument_list|(
name|ctx
argument_list|,
name|SSL_VERIFY_PEER
argument_list|,
name|q_X509Callback
argument_list|)
expr_stmt|;
block|}
comment|// Set verification depth.
if|if
condition|(
name|configuration
operator|.
name|peerVerifyDepth
operator|!=
literal|0
condition|)
name|q_SSL_CTX_set_verify_depth
argument_list|(
name|ctx
argument_list|,
name|configuration
operator|.
name|peerVerifyDepth
argument_list|)
expr_stmt|;
comment|// Create and initialize SSL session
if|if
condition|(
operator|!
operator|(
name|ssl
operator|=
name|q_SSL_new
argument_list|(
name|ctx
argument_list|)
operator|)
condition|)
block|{
comment|// ### Bad error code
name|q
operator|->
name|setErrorString
argument_list|(
name|QSslSocket
operator|::
name|tr
argument_list|(
literal|"Error creating SSL session, %1"
argument_list|)
operator|.
name|arg
argument_list|(
name|getErrorsFromOpenSsl
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|->
name|setSocketError
argument_list|(
name|QAbstractSocket
operator|::
name|UnknownSocketError
argument_list|)
expr_stmt|;
emit|emit
name|q
operator|->
name|error
argument_list|(
name|QAbstractSocket
operator|::
name|UnknownSocketError
argument_list|)
emit|;
return|return
literal|false
return|;
block|}
if|#
directive|if
name|OPENSSL_VERSION_NUMBER
operator|>=
literal|0x0090806fL
operator|&&
operator|!
name|defined
argument_list|(
name|OPENSSL_NO_TLSEXT
argument_list|)
if|if
condition|(
operator|(
name|configuration
operator|.
name|protocol
operator|==
name|QSsl
operator|::
name|TlsV1SslV3
operator|||
name|configuration
operator|.
name|protocol
operator|==
name|QSsl
operator|::
name|TlsV1
operator|||
name|configuration
operator|.
name|protocol
operator|==
name|QSsl
operator|::
name|SecureProtocols
operator|||
name|configuration
operator|.
name|protocol
operator|==
name|QSsl
operator|::
name|AnyProtocol
operator|)
operator|&&
name|client
operator|&&
name|q_SSLeay
argument_list|()
operator|>=
literal|0x00090806fL
condition|)
block|{
comment|// Set server hostname on TLS extension. RFC4366 section 3.1 requires it in ACE format.
name|QString
name|tlsHostName
init|=
name|verificationPeerName
operator|.
name|isEmpty
argument_list|()
condition|?
name|q
operator|->
name|peerName
argument_list|()
else|:
name|verificationPeerName
decl_stmt|;
if|if
condition|(
name|tlsHostName
operator|.
name|isEmpty
argument_list|()
condition|)
name|tlsHostName
operator|=
name|hostName
expr_stmt|;
name|QByteArray
name|ace
init|=
name|QUrl
operator|::
name|toAce
argument_list|(
name|tlsHostName
argument_list|)
decl_stmt|;
comment|// only send the SNI header if the URL is valid and not an IP
if|if
condition|(
operator|!
name|ace
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|QHostAddress
argument_list|()
operator|.
name|setAddress
argument_list|(
name|tlsHostName
argument_list|)
condition|)
block|{
if|#
directive|if
name|OPENSSL_VERSION_NUMBER
operator|>=
literal|0x10000000L
if|if
condition|(
operator|!
name|q_SSL_ctrl
argument_list|(
name|ssl
argument_list|,
name|SSL_CTRL_SET_TLSEXT_HOSTNAME
argument_list|,
name|TLSEXT_NAMETYPE_host_name
argument_list|,
name|ace
operator|.
name|data
argument_list|()
argument_list|)
condition|)
else|#
directive|else
if|if
condition|(
operator|!
name|q_SSL_ctrl
argument_list|(
name|ssl
argument_list|,
name|SSL_CTRL_SET_TLSEXT_HOSTNAME
argument_list|,
name|TLSEXT_NAMETYPE_host_name
argument_list|,
name|ace
operator|.
name|constData
argument_list|()
argument_list|)
condition|)
endif|#
directive|endif
name|qWarning
argument_list|(
literal|"could not set SSL_CTRL_SET_TLSEXT_HOSTNAME, Server Name Indication disabled"
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|// Clear the session.
name|q_SSL_clear
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
name|errorList
operator|.
name|clear
argument_list|()
expr_stmt|;
comment|// Initialize memory BIOs for encryption and decryption.
name|readBio
operator|=
name|q_BIO_new
argument_list|(
name|q_BIO_s_mem
argument_list|()
argument_list|)
expr_stmt|;
name|writeBio
operator|=
name|q_BIO_new
argument_list|(
name|q_BIO_s_mem
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|readBio
operator|||
operator|!
name|writeBio
condition|)
block|{
comment|// ### Bad error code
name|q
operator|->
name|setErrorString
argument_list|(
name|QSslSocket
operator|::
name|tr
argument_list|(
literal|"Error creating SSL session: %1"
argument_list|)
operator|.
name|arg
argument_list|(
name|getErrorsFromOpenSsl
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|->
name|setSocketError
argument_list|(
name|QAbstractSocket
operator|::
name|UnknownSocketError
argument_list|)
expr_stmt|;
emit|emit
name|q
operator|->
name|error
argument_list|(
name|QAbstractSocket
operator|::
name|UnknownSocketError
argument_list|)
emit|;
return|return
literal|false
return|;
block|}
comment|// Assign the bios.
name|q_SSL_set_bio
argument_list|(
name|ssl
argument_list|,
name|readBio
argument_list|,
name|writeBio
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|QSslSocket
operator|::
name|SslClientMode
condition|)
name|q_SSL_set_connect_state
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
else|else
name|q_SSL_set_accept_state
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_comment
comment|/*!     \internal */
end_comment
begin_function
DECL|function|deinitialize
name|void
name|QSslSocketPrivate
operator|::
name|deinitialize
parameter_list|()
block|{
name|q_CRYPTO_set_id_callback
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|q_CRYPTO_set_locking_callback
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal      Does the minimum amount of initialization to determine whether SSL     is supported or not. */
end_comment
begin_function
DECL|function|supportsSsl
name|bool
name|QSslSocketPrivate
operator|::
name|supportsSsl
parameter_list|()
block|{
return|return
name|ensureLibraryLoaded
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|ensureLibraryLoaded
name|bool
name|QSslSocketPrivate
operator|::
name|ensureLibraryLoaded
parameter_list|()
block|{
if|if
condition|(
operator|!
name|q_resolveOpenSslSymbols
argument_list|()
condition|)
return|return
literal|false
return|;
comment|// Check if the library itself needs to be initialized.
name|QMutexLocker
name|locker
argument_list|(
name|openssl_locks
argument_list|()
operator|->
name|initLock
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|s_libraryLoaded
condition|)
block|{
name|s_libraryLoaded
operator|=
literal|true
expr_stmt|;
comment|// Initialize OpenSSL.
name|q_CRYPTO_set_id_callback
argument_list|(
name|id_function
argument_list|)
expr_stmt|;
name|q_CRYPTO_set_locking_callback
argument_list|(
name|locking_function
argument_list|)
expr_stmt|;
if|if
condition|(
name|q_SSL_library_init
argument_list|()
operator|!=
literal|1
condition|)
return|return
literal|false
return|;
name|q_SSL_load_error_strings
argument_list|()
expr_stmt|;
name|q_OpenSSL_add_all_algorithms
argument_list|()
expr_stmt|;
comment|// Initialize OpenSSL's random seed.
if|if
condition|(
operator|!
name|q_RAND_status
argument_list|()
condition|)
block|{
struct|struct
block|{
name|int
name|msec
decl_stmt|;
name|int
name|sec
decl_stmt|;
name|void
modifier|*
name|stack
decl_stmt|;
block|}
name|randomish
struct|;
name|int
name|attempts
init|=
literal|500
decl_stmt|;
do|do
block|{
if|if
condition|(
name|attempts
operator|<
literal|500
condition|)
block|{
ifdef|#
directive|ifdef
name|Q_OS_UNIX
name|struct
name|timespec
name|ts
init|=
block|{
literal|0
block|,
literal|33333333
block|}
decl_stmt|;
name|nanosleep
argument_list|(
operator|&
name|ts
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|Sleep
argument_list|(
literal|3
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|randomish
operator|.
name|msec
operator|=
name|attempts
expr_stmt|;
block|}
name|randomish
operator|.
name|stack
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|randomish
expr_stmt|;
name|randomish
operator|.
name|msec
operator|=
name|QTime
operator|::
name|currentTime
argument_list|()
operator|.
name|msec
argument_list|()
expr_stmt|;
name|randomish
operator|.
name|sec
operator|=
name|QTime
operator|::
name|currentTime
argument_list|()
operator|.
name|second
argument_list|()
expr_stmt|;
name|q_RAND_seed
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
operator|&
name|randomish
argument_list|,
sizeof|sizeof
argument_list|(
name|randomish
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|q_RAND_status
argument_list|()
operator|&&
operator|--
name|attempts
condition|)
do|;
if|if
condition|(
operator|!
name|attempts
condition|)
return|return
literal|false
return|;
block|}
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|ensureCiphersAndCertsLoaded
name|void
name|QSslSocketPrivate
operator|::
name|ensureCiphersAndCertsLoaded
parameter_list|()
block|{
name|QMutexLocker
name|locker
argument_list|(
name|openssl_locks
argument_list|()
operator|->
name|initLock
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|s_loadedCiphersAndCerts
condition|)
return|return;
name|s_loadedCiphersAndCerts
operator|=
literal|true
expr_stmt|;
name|resetDefaultCiphers
argument_list|()
expr_stmt|;
comment|//load symbols needed to receive certificates from system store
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_MAC
argument_list|)
name|QLibrary
name|securityLib
argument_list|(
literal|"/System/Library/Frameworks/Security.framework/Versions/Current/Security"
argument_list|)
decl_stmt|;
if|if
condition|(
name|securityLib
operator|.
name|load
argument_list|()
condition|)
block|{
name|ptrSecCertificateGetData
operator|=
operator|(
name|PtrSecCertificateGetData
operator|)
name|securityLib
operator|.
name|resolve
argument_list|(
literal|"SecCertificateGetData"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptrSecCertificateGetData
condition|)
name|qWarning
argument_list|(
literal|"could not resolve symbols in security library"
argument_list|)
expr_stmt|;
comment|// should never happen
name|ptrSecTrustSettingsCopyCertificates
operator|=
operator|(
name|PtrSecTrustSettingsCopyCertificates
operator|)
name|securityLib
operator|.
name|resolve
argument_list|(
literal|"SecTrustSettingsCopyCertificates"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptrSecTrustSettingsCopyCertificates
condition|)
block|{
comment|// method was introduced in Leopard, use legacy method if it's not there
name|ptrSecTrustCopyAnchorCertificates
operator|=
operator|(
name|PtrSecTrustCopyAnchorCertificates
operator|)
name|securityLib
operator|.
name|resolve
argument_list|(
literal|"SecTrustCopyAnchorCertificates"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ptrSecTrustCopyAnchorCertificates
condition|)
name|qWarning
argument_list|(
literal|"could not resolve symbols in security library"
argument_list|)
expr_stmt|;
comment|// should never happen
block|}
block|}
else|else
block|{
name|qWarning
argument_list|(
literal|"could not load security library"
argument_list|)
expr_stmt|;
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
name|HINSTANCE
name|hLib
init|=
name|LoadLibraryW
argument_list|(
literal|L"Crypt32"
argument_list|)
decl_stmt|;
if|if
condition|(
name|hLib
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
name|ptrCertOpenSystemStoreW
operator|=
operator|(
name|PtrCertOpenSystemStoreW
operator|)
name|GetProcAddress
argument_list|(
name|hLib
argument_list|,
literal|L"CertOpenStore"
argument_list|)
expr_stmt|;
name|ptrCertFindCertificateInStore
operator|=
operator|(
name|PtrCertFindCertificateInStore
operator|)
name|GetProcAddress
argument_list|(
name|hLib
argument_list|,
literal|L"CertFindCertificateInStore"
argument_list|)
expr_stmt|;
name|ptrCertCloseStore
operator|=
operator|(
name|PtrCertCloseStore
operator|)
name|GetProcAddress
argument_list|(
name|hLib
argument_list|,
literal|L"CertCloseStore"
argument_list|)
expr_stmt|;
else|#
directive|else
name|ptrCertOpenSystemStoreW
operator|=
operator|(
name|PtrCertOpenSystemStoreW
operator|)
name|GetProcAddress
argument_list|(
name|hLib
argument_list|,
literal|"CertOpenSystemStoreW"
argument_list|)
expr_stmt|;
name|ptrCertFindCertificateInStore
operator|=
operator|(
name|PtrCertFindCertificateInStore
operator|)
name|GetProcAddress
argument_list|(
name|hLib
argument_list|,
literal|"CertFindCertificateInStore"
argument_list|)
expr_stmt|;
name|ptrCertCloseStore
operator|=
operator|(
name|PtrCertCloseStore
operator|)
name|GetProcAddress
argument_list|(
name|hLib
argument_list|,
literal|"CertCloseStore"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|ptrCertOpenSystemStoreW
operator|||
operator|!
name|ptrCertFindCertificateInStore
operator|||
operator|!
name|ptrCertCloseStore
condition|)
name|qWarning
argument_list|(
literal|"could not resolve symbols in crypt32 library"
argument_list|)
expr_stmt|;
comment|// should never happen
block|}
else|else
block|{
name|qWarning
argument_list|(
literal|"could not load crypt32 library"
argument_list|)
expr_stmt|;
comment|// should never happen
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_UNIX
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_SYMBIAN
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_MAC
argument_list|)
comment|// check whether we can enable on-demand root-cert loading (i.e. check whether the sym links are there)
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|dirs
init|=
name|unixRootCertDirectories
argument_list|()
decl_stmt|;
name|QStringList
name|symLinkFilter
decl_stmt|;
name|symLinkFilter
operator|<<
name|QLatin1String
argument_list|(
literal|"[0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f].[0-9]"
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|a
init|=
literal|0
init|;
name|a
operator|<
name|dirs
operator|.
name|count
argument_list|()
condition|;
operator|++
name|a
control|)
block|{
name|QDirIterator
name|iterator
argument_list|(
name|QLatin1String
argument_list|(
name|dirs
operator|.
name|at
argument_list|(
name|a
argument_list|)
argument_list|)
argument_list|,
name|symLinkFilter
argument_list|,
name|QDir
operator|::
name|Files
argument_list|)
decl_stmt|;
if|if
condition|(
name|iterator
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|s_loadRootCertsOnDemand
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
endif|#
directive|endif
comment|// if on-demand loading was not enabled, load the certs now
if|if
condition|(
operator|!
name|s_loadRootCertsOnDemand
condition|)
name|setDefaultCaCertificates
argument_list|(
name|systemCaCertificates
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal      Declared static in QSslSocketPrivate, makes sure the SSL libraries have     been initialized. */
end_comment
begin_function
DECL|function|ensureInitialized
name|void
name|QSslSocketPrivate
operator|::
name|ensureInitialized
parameter_list|()
block|{
if|if
condition|(
operator|!
name|supportsSsl
argument_list|()
condition|)
return|return;
name|ensureCiphersAndCertsLoaded
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|sslLibraryVersionNumber
name|long
name|QSslSocketPrivate
operator|::
name|sslLibraryVersionNumber
parameter_list|()
block|{
return|return
name|q_SSLeay
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|sslLibraryVersionString
name|QString
name|QSslSocketPrivate
operator|::
name|sslLibraryVersionString
parameter_list|()
block|{
if|if
condition|(
operator|!
name|supportsSsl
argument_list|()
condition|)
return|return
name|QString
argument_list|()
return|;
specifier|const
name|char
modifier|*
name|versionString
init|=
name|q_SSLeay_version
argument_list|(
name|SSLEAY_VERSION
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|versionString
condition|)
return|return
name|QString
argument_list|()
return|;
return|return
name|QString
operator|::
name|fromLatin1
argument_list|(
name|versionString
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \internal      Declared static in QSslSocketPrivate, backend-dependent loading of     application-wide global ciphers. */
end_comment
begin_function
DECL|function|resetDefaultCiphers
name|void
name|QSslSocketPrivate
operator|::
name|resetDefaultCiphers
parameter_list|()
block|{
name|SSL_CTX
modifier|*
name|myCtx
init|=
name|q_SSL_CTX_new
argument_list|(
name|q_SSLv23_client_method
argument_list|()
argument_list|)
decl_stmt|;
name|SSL
modifier|*
name|mySsl
init|=
name|q_SSL_new
argument_list|(
name|myCtx
argument_list|)
decl_stmt|;
name|QList
argument_list|<
name|QSslCipher
argument_list|>
name|ciphers
decl_stmt|;
name|STACK_OF
argument_list|(
name|SSL_CIPHER
argument_list|)
operator|*
name|supportedCiphers
operator|=
name|q_SSL_get_ciphers
argument_list|(
name|mySsl
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|q_sk_SSL_CIPHER_num
argument_list|(
name|supportedCiphers
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|SSL_CIPHER
modifier|*
name|cipher
init|=
name|q_sk_SSL_CIPHER_value
argument_list|(
name|supportedCiphers
argument_list|,
name|i
argument_list|)
condition|)
block|{
if|if
condition|(
name|cipher
operator|->
name|valid
condition|)
block|{
name|QSslCipher
name|ciph
init|=
name|QSslSocketBackendPrivate
operator|::
name|QSslCipher_from_SSL_CIPHER
argument_list|(
name|cipher
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ciph
operator|.
name|isNull
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|ciph
operator|.
name|name
argument_list|()
operator|.
name|toLower
argument_list|()
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"adh"
argument_list|)
argument_list|)
condition|)
name|ciphers
operator|<<
name|ciph
expr_stmt|;
block|}
block|}
block|}
block|}
name|q_SSL_CTX_free
argument_list|(
name|myCtx
argument_list|)
expr_stmt|;
name|q_SSL_free
argument_list|(
name|mySsl
argument_list|)
expr_stmt|;
name|setDefaultSupportedCiphers
argument_list|(
name|ciphers
argument_list|)
expr_stmt|;
name|setDefaultCiphers
argument_list|(
name|ciphers
argument_list|)
expr_stmt|;
block|}
end_function
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_SYMBIAN
argument_list|)
end_if
begin_constructor
DECL|function|CSymbianCertificateRetriever
name|CSymbianCertificateRetriever
operator|::
name|CSymbianCertificateRetriever
parameter_list|()
member_init_list|:
name|CActive
argument_list|(
name|CActive
operator|::
name|EPriorityStandard
argument_list|)
member_init_list|,
name|iCertificatePtr
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
member_init_list|,
name|iSequenceError
argument_list|(
name|KErrNone
argument_list|)
block|{ }
end_constructor
begin_destructor
DECL|function|~CSymbianCertificateRetriever
name|CSymbianCertificateRetriever
operator|::
name|~
name|CSymbianCertificateRetriever
parameter_list|()
block|{
name|iThread
operator|.
name|Close
argument_list|()
expr_stmt|;
block|}
end_destructor
begin_function
DECL|function|NewL
name|CSymbianCertificateRetriever
modifier|*
name|CSymbianCertificateRetriever
operator|::
name|NewL
parameter_list|()
block|{
name|CSymbianCertificateRetriever
modifier|*
name|self
init|=
operator|new
operator|(
name|ELeave
operator|)
name|CSymbianCertificateRetriever
argument_list|()
decl_stmt|;
name|CleanupStack
operator|::
name|PushL
argument_list|(
name|self
argument_list|)
expr_stmt|;
name|self
operator|->
name|ConstructL
argument_list|()
expr_stmt|;
name|CleanupStack
operator|::
name|Pop
argument_list|()
expr_stmt|;
return|return
name|self
return|;
block|}
end_function
begin_function
DECL|function|GetCertificates
name|int
name|CSymbianCertificateRetriever
operator|::
name|GetCertificates
parameter_list|(
name|QList
argument_list|<
name|QByteArray
argument_list|>
modifier|&
name|certificates
parameter_list|)
block|{
name|iCertificates
operator|=
operator|&
name|certificates
expr_stmt|;
name|TRequestStatus
name|status
decl_stmt|;
name|iThread
operator|.
name|Logon
argument_list|(
name|status
argument_list|)
expr_stmt|;
name|iThread
operator|.
name|Resume
argument_list|()
expr_stmt|;
name|User
operator|::
name|WaitForRequest
argument_list|(
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|iThread
operator|.
name|ExitType
argument_list|()
operator|==
name|EExitKill
condition|)
return|return
name|KErrDied
return|;
else|else
return|return
name|status
operator|.
name|Int
argument_list|()
return|;
comment|// Logon() completes with the thread's exit value
block|}
end_function
begin_function
DECL|function|doThreadEntryL
name|void
name|CSymbianCertificateRetriever
operator|::
name|doThreadEntryL
parameter_list|()
block|{
name|CActiveScheduler
modifier|*
name|activeScheduler
init|=
operator|new
operator|(
name|ELeave
operator|)
name|CActiveScheduler
decl_stmt|;
name|CleanupStack
operator|::
name|PushL
argument_list|(
name|activeScheduler
argument_list|)
expr_stmt|;
name|CActiveScheduler
operator|::
name|Install
argument_list|(
name|activeScheduler
argument_list|)
expr_stmt|;
name|CActiveScheduler
operator|::
name|Add
argument_list|(
name|this
argument_list|)
expr_stmt|;
comment|// These aren't deleted in the destructor so leaving the to CS is ok
name|iCertStore
operator|=
name|CUnifiedCertStore
operator|::
name|NewLC
argument_list|(
name|qt_s60GetRFs
argument_list|()
argument_list|,
name|EFalse
argument_list|)
expr_stmt|;
name|iCertFilter
operator|=
name|CCertAttributeFilter
operator|::
name|NewLC
argument_list|()
expr_stmt|;
comment|// only interested in CA certs
name|iCertFilter
operator|->
name|SetOwnerType
argument_list|(
name|ECACertificate
argument_list|)
expr_stmt|;
comment|// only interested in X.509 format (we don't support WAP formats)
name|iCertFilter
operator|->
name|SetFormat
argument_list|(
name|EX509Certificate
argument_list|)
expr_stmt|;
comment|// Kick off the sequence by initializing the cert store
name|iState
operator|=
name|Initializing
expr_stmt|;
name|iCertStore
operator|->
name|Initialize
argument_list|(
name|iStatus
argument_list|)
expr_stmt|;
name|SetActive
argument_list|()
expr_stmt|;
name|CActiveScheduler
operator|::
name|Start
argument_list|()
expr_stmt|;
comment|// Sequence complete, clean up
comment|// These MUST be cleaned up before the installed CActiveScheduler is destroyed and can't be left to the
comment|// destructor of CSymbianCertificateRetriever. Otherwise the destructor of CActiveScheduler will get
comment|// stuck.
name|iCertInfos
operator|.
name|Close
argument_list|()
expr_stmt|;
name|CleanupStack
operator|::
name|PopAndDestroy
argument_list|(
literal|3
argument_list|)
expr_stmt|;
comment|// activeScheduler, iCertStore, iCertFilter
block|}
end_function
begin_function
DECL|function|ThreadEntryPoint
name|TInt
name|CSymbianCertificateRetriever
operator|::
name|ThreadEntryPoint
parameter_list|(
name|TAny
modifier|*
name|aParams
parameter_list|)
block|{
name|User
operator|::
name|SetCritical
argument_list|(
name|User
operator|::
name|EProcessCritical
argument_list|)
expr_stmt|;
name|CTrapCleanup
modifier|*
name|cleanupStack
init|=
name|CTrapCleanup
operator|::
name|New
argument_list|()
decl_stmt|;
name|CSymbianCertificateRetriever
modifier|*
name|self
init|=
operator|(
name|CSymbianCertificateRetriever
operator|*
operator|)
name|aParams
decl_stmt|;
name|TRAPD
argument_list|(
name|err
argument_list|,
name|self
operator|->
name|doThreadEntryL
argument_list|()
argument_list|)
expr_stmt|;
operator|delete
name|cleanupStack
expr_stmt|;
comment|// doThreadEntryL() can leave only before the retrieval sequence is started
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
else|else
return|return
name|self
operator|->
name|iSequenceError
return|;
comment|// return any error that occurred during the retrieval
block|}
end_function
begin_function
DECL|function|ConstructL
name|void
name|CSymbianCertificateRetriever
operator|::
name|ConstructL
parameter_list|()
block|{
name|TInt
name|err
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|QString
name|name
argument_list|(
name|QLatin1String
argument_list|(
literal|"CertWorkerThread-%1"
argument_list|)
argument_list|)
decl_stmt|;
comment|//recently closed thread names remain in use for a while until all handles have been closed
comment|//including users of RUndertaker
do|do
block|{
name|err
operator|=
name|iThread
operator|.
name|Create
argument_list|(
name|qt_QString2TPtrC
argument_list|(
name|name
operator|.
name|arg
argument_list|(
name|i
operator|++
argument_list|)
argument_list|)
argument_list|,
name|CSymbianCertificateRetriever
operator|::
name|ThreadEntryPoint
argument_list|,
literal|16384
argument_list|,
name|NULL
argument_list|,
name|this
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|err
operator|==
name|KErrAlreadyExists
condition|)
do|;
name|User
operator|::
name|LeaveIfError
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|DoCancel
name|void
name|CSymbianCertificateRetriever
operator|::
name|DoCancel
parameter_list|()
block|{
switch|switch
condition|(
name|iState
condition|)
block|{
case|case
name|Initializing
case|:
name|iCertStore
operator|->
name|CancelInitialize
argument_list|()
expr_stmt|;
break|break;
case|case
name|Listing
case|:
name|iCertStore
operator|->
name|CancelList
argument_list|()
expr_stmt|;
break|break;
case|case
name|RetrievingCertificates
case|:
name|iCertStore
operator|->
name|CancelGetCert
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
end_function
begin_function
DECL|function|RunError
name|TInt
name|CSymbianCertificateRetriever
operator|::
name|RunError
parameter_list|(
name|TInt
name|aError
parameter_list|)
block|{
comment|// If something goes wrong in the sequence, abort the sequence
name|iSequenceError
operator|=
name|aError
expr_stmt|;
comment|// this gets reported to the client in the TRequestStatus
name|CActiveScheduler
operator|::
name|Stop
argument_list|()
expr_stmt|;
return|return
name|KErrNone
return|;
block|}
end_function
begin_function
DECL|function|GetCertificateL
name|void
name|CSymbianCertificateRetriever
operator|::
name|GetCertificateL
parameter_list|()
block|{
if|if
condition|(
name|iCurrentCertIndex
operator|<
name|iCertInfos
operator|.
name|Count
argument_list|()
condition|)
block|{
name|CCTCertInfo
modifier|*
name|certInfo
init|=
name|iCertInfos
index|[
name|iCurrentCertIndex
operator|++
index|]
decl_stmt|;
name|iCertificateData
operator|=
name|QByteArray
argument_list|()
expr_stmt|;
name|QT_TRYCATCH_LEAVING
argument_list|(
name|iCertificateData
operator|.
name|resize
argument_list|(
name|certInfo
operator|->
name|Size
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|iCertificatePtr
operator|.
name|Set
argument_list|(
operator|(
name|TUint8
operator|*
operator|)
name|iCertificateData
operator|.
name|data
argument_list|()
argument_list|,
literal|0
argument_list|,
name|iCertificateData
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QSSLSOCKET_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"getting "
operator|<<
name|qt_TDesC2QString
argument_list|(
name|certInfo
operator|->
name|Label
argument_list|()
argument_list|)
operator|<<
literal|" size="
operator|<<
name|certInfo
operator|->
name|Size
argument_list|()
expr_stmt|;
name|qDebug
argument_list|()
operator|<<
literal|"format="
operator|<<
name|certInfo
operator|->
name|CertificateFormat
argument_list|()
expr_stmt|;
name|qDebug
argument_list|()
operator|<<
literal|"ownertype="
operator|<<
name|certInfo
operator|->
name|CertificateOwnerType
argument_list|()
expr_stmt|;
name|qDebug
argument_list|()
operator|<<
literal|"type="
operator|<<
name|hex
operator|<<
name|certInfo
operator|->
name|Type
argument_list|()
operator|.
name|iUid
expr_stmt|;
endif|#
directive|endif
name|iCertStore
operator|->
name|Retrieve
argument_list|(
operator|*
name|certInfo
argument_list|,
name|iCertificatePtr
argument_list|,
name|iStatus
argument_list|)
expr_stmt|;
name|iState
operator|=
name|RetrievingCertificates
expr_stmt|;
name|SetActive
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|//reached end of list
name|CActiveScheduler
operator|::
name|Stop
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|RunL
name|void
name|CSymbianCertificateRetriever
operator|::
name|RunL
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|QSSLSOCKET_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"CSymbianCertificateRetriever::RunL status "
operator|<<
name|iStatus
operator|.
name|Int
argument_list|()
operator|<<
literal|" count "
operator|<<
name|iCertInfos
operator|.
name|Count
argument_list|()
operator|<<
literal|" index "
operator|<<
name|iCurrentCertIndex
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|iState
condition|)
block|{
case|case
name|Initializing
case|:
name|User
operator|::
name|LeaveIfError
argument_list|(
name|iStatus
operator|.
name|Int
argument_list|()
argument_list|)
expr_stmt|;
comment|// initialise fail means pointless to continue
name|iState
operator|=
name|Listing
expr_stmt|;
name|iCertStore
operator|->
name|List
argument_list|(
name|iCertInfos
argument_list|,
operator|*
name|iCertFilter
argument_list|,
name|iStatus
argument_list|)
expr_stmt|;
name|SetActive
argument_list|()
expr_stmt|;
break|break;
case|case
name|Listing
case|:
name|User
operator|::
name|LeaveIfError
argument_list|(
name|iStatus
operator|.
name|Int
argument_list|()
argument_list|)
expr_stmt|;
comment|// listing fail means pointless to continue
name|iCurrentCertIndex
operator|=
literal|0
expr_stmt|;
name|GetCertificateL
argument_list|()
expr_stmt|;
break|break;
case|case
name|RetrievingCertificates
case|:
if|if
condition|(
name|iStatus
operator|.
name|Int
argument_list|()
operator|==
name|KErrNone
condition|)
name|iCertificates
operator|->
name|append
argument_list|(
name|iCertificateData
argument_list|)
expr_stmt|;
else|else
name|qWarning
argument_list|()
operator|<<
literal|"CSymbianCertificateRetriever: failed to retrieve a certificate, error "
operator|<<
name|iStatus
operator|.
name|Int
argument_list|()
expr_stmt|;
name|GetCertificateL
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// defined(Q_OS_SYMBIAN)
end_comment
begin_function
DECL|function|systemCaCertificates
name|QList
argument_list|<
name|QSslCertificate
argument_list|>
name|QSslSocketPrivate
operator|::
name|systemCaCertificates
parameter_list|()
block|{
name|ensureInitialized
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|QSSLSOCKET_DEBUG
name|QElapsedTimer
name|timer
decl_stmt|;
name|timer
operator|.
name|start
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|QList
argument_list|<
name|QSslCertificate
argument_list|>
name|systemCerts
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_MAC
argument_list|)
name|CFArrayRef
name|cfCerts
decl_stmt|;
name|OSStatus
name|status
init|=
literal|1
decl_stmt|;
name|OSStatus
name|SecCertificateGetData
argument_list|(
name|SecCertificateRef
name|certificate
argument_list|,
name|CSSM_DATA_PTR
name|data
argument_list|)
decl_stmt|;
if|if
condition|(
name|ptrSecCertificateGetData
condition|)
block|{
if|if
condition|(
name|ptrSecTrustSettingsCopyCertificates
condition|)
name|status
operator|=
name|ptrSecTrustSettingsCopyCertificates
argument_list|(
name|kSecTrustSettingsDomainSystem
argument_list|,
operator|&
name|cfCerts
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ptrSecTrustCopyAnchorCertificates
condition|)
name|status
operator|=
name|ptrSecTrustCopyAnchorCertificates
argument_list|(
operator|&
name|cfCerts
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|status
condition|)
block|{
name|CFIndex
name|size
init|=
name|CFArrayGetCount
argument_list|(
name|cfCerts
argument_list|)
decl_stmt|;
for|for
control|(
name|CFIndex
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
operator|++
name|i
control|)
block|{
name|SecCertificateRef
name|cfCert
init|=
operator|(
name|SecCertificateRef
operator|)
name|CFArrayGetValueAtIndex
argument_list|(
name|cfCerts
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|CSSM_DATA
name|data
decl_stmt|;
name|CSSM_DATA_PTR
name|dataPtr
init|=
operator|&
name|data
decl_stmt|;
if|if
condition|(
name|ptrSecCertificateGetData
argument_list|(
name|cfCert
argument_list|,
name|dataPtr
argument_list|)
condition|)
block|{
name|qWarning
argument_list|(
literal|"error retrieving a CA certificate from the system store"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|len
init|=
name|data
operator|.
name|Length
decl_stmt|;
name|char
modifier|*
name|rawData
init|=
cast|reinterpret_cast
argument_list|<
name|char
operator|*
argument_list|>
argument_list|(
name|data
operator|.
name|Data
argument_list|)
decl_stmt|;
name|QByteArray
name|rawCert
argument_list|(
name|rawData
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|systemCerts
operator|.
name|append
argument_list|(
name|QSslCertificate
operator|::
name|fromData
argument_list|(
name|rawCert
argument_list|,
name|QSsl
operator|::
name|Der
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|CFRelease
argument_list|(
name|cfCerts
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// no detailed error handling here
name|qWarning
argument_list|(
literal|"could not retrieve system CA certificates"
argument_list|)
expr_stmt|;
block|}
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
if|if
condition|(
name|ptrCertOpenSystemStoreW
operator|&&
name|ptrCertFindCertificateInStore
operator|&&
name|ptrCertCloseStore
condition|)
block|{
name|HCERTSTORE
name|hSystemStore
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
name|hSystemStore
operator|=
name|ptrCertOpenSystemStoreW
argument_list|(
name|CERT_STORE_PROV_SYSTEM_W
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|CERT_STORE_NO_CRYPT_RELEASE_FLAG
operator||
name|CERT_SYSTEM_STORE_CURRENT_USER
argument_list|,
literal|L"ROOT"
argument_list|)
expr_stmt|;
else|#
directive|else
name|hSystemStore
operator|=
name|ptrCertOpenSystemStoreW
argument_list|(
literal|0
argument_list|,
literal|L"ROOT"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|hSystemStore
condition|)
block|{
name|PCCERT_CONTEXT
name|pc
init|=
name|NULL
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|pc
operator|=
name|ptrCertFindCertificateInStore
argument_list|(
name|hSystemStore
argument_list|,
name|X509_ASN_ENCODING
argument_list|,
literal|0
argument_list|,
name|CERT_FIND_ANY
argument_list|,
name|NULL
argument_list|,
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pc
condition|)
break|break;
name|QByteArray
name|der
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
operator|(
name|pc
operator|->
name|pbCertEncoded
operator|)
argument_list|,
cast|static_cast
argument_list|<
name|int
argument_list|>
argument_list|(
name|pc
operator|->
name|cbCertEncoded
argument_list|)
argument_list|)
decl_stmt|;
name|QSslCertificate
name|cert
argument_list|(
name|der
argument_list|,
name|QSsl
operator|::
name|Der
argument_list|)
decl_stmt|;
name|systemCerts
operator|.
name|append
argument_list|(
name|cert
argument_list|)
expr_stmt|;
block|}
name|ptrCertCloseStore
argument_list|(
name|hSystemStore
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_UNIX
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|Q_OS_SYMBIAN
argument_list|)
name|QSet
argument_list|<
name|QString
argument_list|>
name|certFiles
decl_stmt|;
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|directories
init|=
name|unixRootCertDirectories
argument_list|()
decl_stmt|;
name|QDir
name|currentDir
decl_stmt|;
name|QStringList
name|nameFilters
decl_stmt|;
name|nameFilters
operator|<<
name|QLatin1String
argument_list|(
literal|"*.pem"
argument_list|)
operator|<<
name|QLatin1String
argument_list|(
literal|"*.crt"
argument_list|)
expr_stmt|;
name|currentDir
operator|.
name|setNameFilters
argument_list|(
name|nameFilters
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|a
init|=
literal|0
init|;
name|a
operator|<
name|directories
operator|.
name|count
argument_list|()
condition|;
name|a
operator|++
control|)
block|{
name|currentDir
operator|.
name|setPath
argument_list|(
name|QLatin1String
argument_list|(
name|directories
operator|.
name|at
argument_list|(
name|a
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|QDirIterator
name|it
argument_list|(
name|currentDir
argument_list|)
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|it
operator|.
name|next
argument_list|()
expr_stmt|;
comment|// use canonical path here to not load the same certificate twice if symlinked
name|certFiles
operator|.
name|insert
argument_list|(
name|it
operator|.
name|fileInfo
argument_list|()
operator|.
name|canonicalFilePath
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|QSetIterator
argument_list|<
name|QString
argument_list|>
name|it
argument_list|(
name|certFiles
argument_list|)
decl_stmt|;
while|while
condition|(
name|it
operator|.
name|hasNext
argument_list|()
condition|)
block|{
name|systemCerts
operator|.
name|append
argument_list|(
name|QSslCertificate
operator|::
name|fromPath
argument_list|(
name|it
operator|.
name|next
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|systemCerts
operator|.
name|append
argument_list|(
name|QSslCertificate
operator|::
name|fromPath
argument_list|(
name|QLatin1String
argument_list|(
literal|"/etc/pki/tls/certs/ca-bundle.crt"
argument_list|)
argument_list|,
name|QSsl
operator|::
name|Pem
argument_list|)
argument_list|)
expr_stmt|;
comment|// Fedora, Mandriva
name|systemCerts
operator|.
name|append
argument_list|(
name|QSslCertificate
operator|::
name|fromPath
argument_list|(
name|QLatin1String
argument_list|(
literal|"/usr/local/share/certs/ca-root-nss.crt"
argument_list|)
argument_list|,
name|QSsl
operator|::
name|Pem
argument_list|)
argument_list|)
expr_stmt|;
comment|// FreeBSD's ca_root_nss
elif|#
directive|elif
name|defined
argument_list|(
name|Q_OS_SYMBIAN
argument_list|)
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|certs
decl_stmt|;
name|QScopedPointer
argument_list|<
name|CSymbianCertificateRetriever
argument_list|>
name|retriever
argument_list|(
name|CSymbianCertificateRetriever
operator|::
name|NewL
argument_list|()
argument_list|)
decl_stmt|;
name|retriever
operator|->
name|GetCertificates
argument_list|(
name|certs
argument_list|)
expr_stmt|;
foreach|foreach
control|(
specifier|const
name|QByteArray
modifier|&
name|encodedCert
decl|,
name|certs
control|)
block|{
name|QSslCertificate
name|cert
argument_list|(
name|encodedCert
argument_list|,
name|QSsl
operator|::
name|Der
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|cert
operator|.
name|isNull
argument_list|()
condition|)
block|{
ifdef|#
directive|ifdef
name|QSSLSOCKET_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"imported certificate: "
operator|<<
name|cert
operator|.
name|issuerInfo
argument_list|(
name|QSslCertificate
operator|::
name|CommonName
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|systemCerts
operator|.
name|append
argument_list|(
name|cert
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|QSSLSOCKET_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"systemCaCertificates retrieval time "
operator|<<
name|timer
operator|.
name|elapsed
argument_list|()
operator|<<
literal|"ms"
expr_stmt|;
name|qDebug
argument_list|()
operator|<<
literal|"imported "
operator|<<
name|systemCerts
operator|.
name|count
argument_list|()
operator|<<
literal|" certificates"
expr_stmt|;
endif|#
directive|endif
return|return
name|systemCerts
return|;
block|}
end_function
begin_function
DECL|function|startClientEncryption
name|void
name|QSslSocketBackendPrivate
operator|::
name|startClientEncryption
parameter_list|()
block|{
if|if
condition|(
operator|!
name|initSslContext
argument_list|()
condition|)
block|{
comment|// ### report error: internal OpenSSL failure
return|return;
block|}
comment|// Start connecting. This will place outgoing data in the BIO, so we
comment|// follow up with calling transmit().
name|startHandshake
argument_list|()
expr_stmt|;
name|transmit
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|startServerEncryption
name|void
name|QSslSocketBackendPrivate
operator|::
name|startServerEncryption
parameter_list|()
block|{
if|if
condition|(
operator|!
name|initSslContext
argument_list|()
condition|)
block|{
comment|// ### report error: internal OpenSSL failure
return|return;
block|}
comment|// Start connecting. This will place outgoing data in the BIO, so we
comment|// follow up with calling transmit().
name|startHandshake
argument_list|()
expr_stmt|;
name|transmit
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \internal      Transmits encrypted data between the BIOs and the socket. */
end_comment
begin_function
DECL|function|transmit
name|void
name|QSslSocketBackendPrivate
operator|::
name|transmit
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QSslSocket
argument_list|)
expr_stmt|;
comment|// If we don't have any SSL context, don't bother transmitting.
if|if
condition|(
operator|!
name|ssl
condition|)
return|return;
name|bool
name|transmitting
decl_stmt|;
do|do
block|{
name|transmitting
operator|=
literal|false
expr_stmt|;
comment|// If the connection is secure, we can transfer data from the write
comment|// buffer (in plain text) to the write BIO through SSL_write.
if|if
condition|(
name|connectionEncrypted
operator|&&
operator|!
name|writeBuffer
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|qint64
name|totalBytesWritten
init|=
literal|0
decl_stmt|;
name|int
name|nextDataBlockSize
decl_stmt|;
while|while
condition|(
operator|(
name|nextDataBlockSize
operator|=
name|writeBuffer
operator|.
name|nextDataBlockSize
argument_list|()
operator|)
operator|>
literal|0
condition|)
block|{
name|int
name|writtenBytes
init|=
name|q_SSL_write
argument_list|(
name|ssl
argument_list|,
name|writeBuffer
operator|.
name|readPointer
argument_list|()
argument_list|,
name|nextDataBlockSize
argument_list|)
decl_stmt|;
if|if
condition|(
name|writtenBytes
operator|<=
literal|0
condition|)
block|{
comment|// ### Better error handling.
name|q
operator|->
name|setErrorString
argument_list|(
name|QSslSocket
operator|::
name|tr
argument_list|(
literal|"Unable to write data: %1"
argument_list|)
operator|.
name|arg
argument_list|(
name|getErrorsFromOpenSsl
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|->
name|setSocketError
argument_list|(
name|QAbstractSocket
operator|::
name|UnknownSocketError
argument_list|)
expr_stmt|;
emit|emit
name|q
operator|->
name|error
argument_list|(
name|QAbstractSocket
operator|::
name|UnknownSocketError
argument_list|)
emit|;
return|return;
block|}
ifdef|#
directive|ifdef
name|QSSLSOCKET_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QSslSocketBackendPrivate::transmit: encrypted"
operator|<<
name|writtenBytes
operator|<<
literal|"bytes"
expr_stmt|;
endif|#
directive|endif
name|writeBuffer
operator|.
name|free
argument_list|(
name|writtenBytes
argument_list|)
expr_stmt|;
name|totalBytesWritten
operator|+=
name|writtenBytes
expr_stmt|;
if|if
condition|(
name|writtenBytes
operator|<
name|nextDataBlockSize
condition|)
block|{
comment|// break out of the writing loop and try again after we had read
name|transmitting
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|totalBytesWritten
operator|>
literal|0
condition|)
block|{
comment|// Don't emit bytesWritten() recursively.
if|if
condition|(
operator|!
name|emittedBytesWritten
condition|)
block|{
name|emittedBytesWritten
operator|=
literal|true
expr_stmt|;
emit|emit
name|q
operator|->
name|bytesWritten
argument_list|(
name|totalBytesWritten
argument_list|)
emit|;
name|emittedBytesWritten
operator|=
literal|false
expr_stmt|;
block|}
block|}
block|}
comment|// Check if we've got any data to be written to the socket.
name|QVarLengthArray
argument_list|<
name|char
argument_list|,
literal|4096
argument_list|>
name|data
decl_stmt|;
name|int
name|pendingBytes
decl_stmt|;
while|while
condition|(
name|plainSocket
operator|->
name|isValid
argument_list|()
operator|&&
operator|(
name|pendingBytes
operator|=
name|q_BIO_pending
argument_list|(
name|writeBio
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
comment|// Read encrypted data from the write BIO into a buffer.
name|data
operator|.
name|resize
argument_list|(
name|pendingBytes
argument_list|)
expr_stmt|;
name|int
name|encryptedBytesRead
init|=
name|q_BIO_read
argument_list|(
name|writeBio
argument_list|,
name|data
operator|.
name|data
argument_list|()
argument_list|,
name|pendingBytes
argument_list|)
decl_stmt|;
comment|// Write encrypted data from the buffer to the socket.
name|plainSocket
operator|->
name|write
argument_list|(
name|data
operator|.
name|constData
argument_list|()
argument_list|,
name|encryptedBytesRead
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QSSLSOCKET_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QSslSocketBackendPrivate::transmit: wrote"
operator|<<
name|encryptedBytesRead
operator|<<
literal|"encrypted bytes to the socket"
expr_stmt|;
endif|#
directive|endif
name|transmitting
operator|=
literal|true
expr_stmt|;
block|}
comment|// Check if we've got any data to be read from the socket.
if|if
condition|(
operator|!
name|connectionEncrypted
operator|||
operator|!
name|readBufferMaxSize
operator|||
name|readBuffer
operator|.
name|size
argument_list|()
operator|<
name|readBufferMaxSize
condition|)
while|while
condition|(
operator|(
name|pendingBytes
operator|=
name|plainSocket
operator|->
name|bytesAvailable
argument_list|()
operator|)
operator|>
literal|0
condition|)
block|{
comment|// Read encrypted data from the socket into a buffer.
name|data
operator|.
name|resize
argument_list|(
name|pendingBytes
argument_list|)
expr_stmt|;
comment|// just peek() here because q_BIO_write could write less data than expected
name|int
name|encryptedBytesRead
init|=
name|plainSocket
operator|->
name|peek
argument_list|(
name|data
operator|.
name|data
argument_list|()
argument_list|,
name|pendingBytes
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|QSSLSOCKET_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QSslSocketBackendPrivate::transmit: read"
operator|<<
name|encryptedBytesRead
operator|<<
literal|"encrypted bytes from the socket"
expr_stmt|;
endif|#
directive|endif
comment|// Write encrypted data from the buffer into the read BIO.
name|int
name|writtenToBio
init|=
name|q_BIO_write
argument_list|(
name|readBio
argument_list|,
name|data
operator|.
name|constData
argument_list|()
argument_list|,
name|encryptedBytesRead
argument_list|)
decl_stmt|;
comment|// do the actual read() here and throw away the results.
if|if
condition|(
name|writtenToBio
operator|>
literal|0
condition|)
block|{
comment|// ### TODO: make this cheaper by not making it memcpy. E.g. make it work with data=0x0 or make it work with seek
name|plainSocket
operator|->
name|read
argument_list|(
name|data
operator|.
name|data
argument_list|()
argument_list|,
name|writtenToBio
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// ### Better error handling.
name|q
operator|->
name|setErrorString
argument_list|(
name|QSslSocket
operator|::
name|tr
argument_list|(
literal|"Unable to decrypt data: %1"
argument_list|)
operator|.
name|arg
argument_list|(
name|getErrorsFromOpenSsl
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|->
name|setSocketError
argument_list|(
name|QAbstractSocket
operator|::
name|UnknownSocketError
argument_list|)
expr_stmt|;
emit|emit
name|q
operator|->
name|error
argument_list|(
name|QAbstractSocket
operator|::
name|UnknownSocketError
argument_list|)
emit|;
return|return;
block|}
name|transmitting
operator|=
literal|true
expr_stmt|;
block|}
comment|// If the connection isn't secured yet, this is the time to retry the
comment|// connect / accept.
if|if
condition|(
operator|!
name|connectionEncrypted
condition|)
block|{
ifdef|#
directive|ifdef
name|QSSLSOCKET_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QSslSocketBackendPrivate::transmit: testing encryption"
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|startHandshake
argument_list|()
condition|)
block|{
ifdef|#
directive|ifdef
name|QSSLSOCKET_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QSslSocketBackendPrivate::transmit: encryption established"
expr_stmt|;
endif|#
directive|endif
name|connectionEncrypted
operator|=
literal|true
expr_stmt|;
name|transmitting
operator|=
literal|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|plainSocket
operator|->
name|state
argument_list|()
operator|!=
name|QAbstractSocket
operator|::
name|ConnectedState
condition|)
block|{
ifdef|#
directive|ifdef
name|QSSLSOCKET_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QSslSocketBackendPrivate::transmit: connection lost"
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|QSSLSOCKET_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QSslSocketBackendPrivate::transmit: encryption not done yet"
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|// If the request is small and the remote host closes the transmission
comment|// after sending, there's a chance that startHandshake() will already
comment|// have triggered a shutdown.
if|if
condition|(
operator|!
name|ssl
condition|)
continue|continue;
comment|// We always read everything from the SSL decryption buffers, even if
comment|// we have a readBufferMaxSize. There's no point in leaving data there
comment|// just so that readBuffer.size() == readBufferMaxSize.
name|int
name|readBytes
init|=
literal|0
decl_stmt|;
name|data
operator|.
name|resize
argument_list|(
literal|4096
argument_list|)
expr_stmt|;
operator|::
name|memset
argument_list|(
name|data
operator|.
name|data
argument_list|()
argument_list|,
literal|0
argument_list|,
name|data
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
do|do
block|{
comment|// Don't use SSL_pending(). It's very unreliable.
if|if
condition|(
operator|(
name|readBytes
operator|=
name|q_SSL_read
argument_list|(
name|ssl
argument_list|,
name|data
operator|.
name|data
argument_list|()
argument_list|,
name|data
operator|.
name|size
argument_list|()
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|QSSLSOCKET_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QSslSocketBackendPrivate::transmit: decrypted"
operator|<<
name|readBytes
operator|<<
literal|"bytes"
expr_stmt|;
endif|#
directive|endif
name|char
modifier|*
name|ptr
init|=
name|readBuffer
operator|.
name|reserve
argument_list|(
name|readBytes
argument_list|)
decl_stmt|;
operator|::
name|memcpy
argument_list|(
name|ptr
argument_list|,
name|data
operator|.
name|data
argument_list|()
argument_list|,
name|readBytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|readyReadEmittedPointer
condition|)
operator|*
name|readyReadEmittedPointer
operator|=
literal|true
expr_stmt|;
emit|emit
name|q
operator|->
name|readyRead
argument_list|()
emit|;
name|transmitting
operator|=
literal|true
expr_stmt|;
continue|continue;
block|}
comment|// Error.
switch|switch
condition|(
name|q_SSL_get_error
argument_list|(
name|ssl
argument_list|,
name|readBytes
argument_list|)
condition|)
block|{
case|case
name|SSL_ERROR_WANT_READ
case|:
case|case
name|SSL_ERROR_WANT_WRITE
case|:
comment|// Out of data.
break|break;
case|case
name|SSL_ERROR_ZERO_RETURN
case|:
comment|// The remote host closed the connection.
ifdef|#
directive|ifdef
name|QSSLSOCKET_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QSslSocketBackendPrivate::transmit: remote disconnect"
expr_stmt|;
endif|#
directive|endif
name|plainSocket
operator|->
name|disconnectFromHost
argument_list|()
expr_stmt|;
break|break;
case|case
name|SSL_ERROR_SYSCALL
case|:
comment|// some IO error
case|case
name|SSL_ERROR_SSL
case|:
comment|// error in the SSL library
comment|// we do not know exactly what the error is, nor whether we can recover from it,
comment|// so just return to prevent an endless loop in the outer "while" statement
name|q
operator|->
name|setErrorString
argument_list|(
name|QSslSocket
operator|::
name|tr
argument_list|(
literal|"Error while reading: %1"
argument_list|)
operator|.
name|arg
argument_list|(
name|getErrorsFromOpenSsl
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|->
name|setSocketError
argument_list|(
name|QAbstractSocket
operator|::
name|UnknownSocketError
argument_list|)
expr_stmt|;
emit|emit
name|q
operator|->
name|error
argument_list|(
name|QAbstractSocket
operator|::
name|UnknownSocketError
argument_list|)
emit|;
return|return;
default|default:
comment|// SSL_ERROR_WANT_CONNECT, SSL_ERROR_WANT_ACCEPT: can only happen with a
comment|// BIO_s_connect() or BIO_s_accept(), which we do not call.
comment|// SSL_ERROR_WANT_X509_LOOKUP: can only happen with a
comment|// SSL_CTX_set_client_cert_cb(), which we do not call.
comment|// So this default case should never be triggered.
name|q
operator|->
name|setErrorString
argument_list|(
name|QSslSocket
operator|::
name|tr
argument_list|(
literal|"Error while reading: %1"
argument_list|)
operator|.
name|arg
argument_list|(
name|getErrorsFromOpenSsl
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|->
name|setSocketError
argument_list|(
name|QAbstractSocket
operator|::
name|UnknownSocketError
argument_list|)
expr_stmt|;
emit|emit
name|q
operator|->
name|error
argument_list|(
name|QAbstractSocket
operator|::
name|UnknownSocketError
argument_list|)
emit|;
break|break;
block|}
block|}
do|while
condition|(
name|ssl
operator|&&
name|readBytes
operator|>
literal|0
condition|)
do|;
block|}
do|while
condition|(
name|ssl
operator|&&
name|ctx
operator|&&
name|transmitting
condition|)
do|;
block|}
end_function
begin_function
DECL|function|_q_OpenSSL_to_QSslError
specifier|static
name|QSslError
name|_q_OpenSSL_to_QSslError
parameter_list|(
name|int
name|errorCode
parameter_list|,
specifier|const
name|QSslCertificate
modifier|&
name|cert
parameter_list|)
block|{
name|QSslError
name|error
decl_stmt|;
switch|switch
condition|(
name|errorCode
condition|)
block|{
case|case
name|X509_V_OK
case|:
comment|// X509_V_OK is also reported if the peer had no certificate.
break|break;
case|case
name|X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT
case|:
name|error
operator|=
name|QSslError
argument_list|(
name|QSslError
operator|::
name|UnableToGetIssuerCertificate
argument_list|,
name|cert
argument_list|)
expr_stmt|;
break|break;
case|case
name|X509_V_ERR_UNABLE_TO_DECRYPT_CERT_SIGNATURE
case|:
name|error
operator|=
name|QSslError
argument_list|(
name|QSslError
operator|::
name|UnableToDecryptCertificateSignature
argument_list|,
name|cert
argument_list|)
expr_stmt|;
break|break;
case|case
name|X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY
case|:
name|error
operator|=
name|QSslError
argument_list|(
name|QSslError
operator|::
name|UnableToDecodeIssuerPublicKey
argument_list|,
name|cert
argument_list|)
expr_stmt|;
break|break;
case|case
name|X509_V_ERR_CERT_SIGNATURE_FAILURE
case|:
name|error
operator|=
name|QSslError
argument_list|(
name|QSslError
operator|::
name|CertificateSignatureFailed
argument_list|,
name|cert
argument_list|)
expr_stmt|;
break|break;
case|case
name|X509_V_ERR_CERT_NOT_YET_VALID
case|:
name|error
operator|=
name|QSslError
argument_list|(
name|QSslError
operator|::
name|CertificateNotYetValid
argument_list|,
name|cert
argument_list|)
expr_stmt|;
break|break;
case|case
name|X509_V_ERR_CERT_HAS_EXPIRED
case|:
name|error
operator|=
name|QSslError
argument_list|(
name|QSslError
operator|::
name|CertificateExpired
argument_list|,
name|cert
argument_list|)
expr_stmt|;
break|break;
case|case
name|X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD
case|:
name|error
operator|=
name|QSslError
argument_list|(
name|QSslError
operator|::
name|InvalidNotBeforeField
argument_list|,
name|cert
argument_list|)
expr_stmt|;
break|break;
case|case
name|X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD
case|:
name|error
operator|=
name|QSslError
argument_list|(
name|QSslError
operator|::
name|InvalidNotAfterField
argument_list|,
name|cert
argument_list|)
expr_stmt|;
break|break;
case|case
name|X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT
case|:
name|error
operator|=
name|QSslError
argument_list|(
name|QSslError
operator|::
name|SelfSignedCertificate
argument_list|,
name|cert
argument_list|)
expr_stmt|;
break|break;
case|case
name|X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN
case|:
name|error
operator|=
name|QSslError
argument_list|(
name|QSslError
operator|::
name|SelfSignedCertificateInChain
argument_list|,
name|cert
argument_list|)
expr_stmt|;
break|break;
case|case
name|X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY
case|:
name|error
operator|=
name|QSslError
argument_list|(
name|QSslError
operator|::
name|UnableToGetLocalIssuerCertificate
argument_list|,
name|cert
argument_list|)
expr_stmt|;
break|break;
case|case
name|X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE
case|:
name|error
operator|=
name|QSslError
argument_list|(
name|QSslError
operator|::
name|UnableToVerifyFirstCertificate
argument_list|,
name|cert
argument_list|)
expr_stmt|;
break|break;
case|case
name|X509_V_ERR_CERT_REVOKED
case|:
name|error
operator|=
name|QSslError
argument_list|(
name|QSslError
operator|::
name|CertificateRevoked
argument_list|,
name|cert
argument_list|)
expr_stmt|;
break|break;
case|case
name|X509_V_ERR_INVALID_CA
case|:
name|error
operator|=
name|QSslError
argument_list|(
name|QSslError
operator|::
name|InvalidCaCertificate
argument_list|,
name|cert
argument_list|)
expr_stmt|;
break|break;
case|case
name|X509_V_ERR_PATH_LENGTH_EXCEEDED
case|:
name|error
operator|=
name|QSslError
argument_list|(
name|QSslError
operator|::
name|PathLengthExceeded
argument_list|,
name|cert
argument_list|)
expr_stmt|;
break|break;
case|case
name|X509_V_ERR_INVALID_PURPOSE
case|:
name|error
operator|=
name|QSslError
argument_list|(
name|QSslError
operator|::
name|InvalidPurpose
argument_list|,
name|cert
argument_list|)
expr_stmt|;
break|break;
case|case
name|X509_V_ERR_CERT_UNTRUSTED
case|:
name|error
operator|=
name|QSslError
argument_list|(
name|QSslError
operator|::
name|CertificateUntrusted
argument_list|,
name|cert
argument_list|)
expr_stmt|;
break|break;
case|case
name|X509_V_ERR_CERT_REJECTED
case|:
name|error
operator|=
name|QSslError
argument_list|(
name|QSslError
operator|::
name|CertificateRejected
argument_list|,
name|cert
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|QSslError
argument_list|(
name|QSslError
operator|::
name|UnspecifiedError
argument_list|,
name|cert
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|error
return|;
block|}
end_function
begin_function
DECL|function|startHandshake
name|bool
name|QSslSocketBackendPrivate
operator|::
name|startHandshake
parameter_list|()
block|{
name|Q_Q
argument_list|(
name|QSslSocket
argument_list|)
expr_stmt|;
comment|// Check if the connection has been established. Get all errors from the
comment|// verification stage.
name|_q_sslErrorList
argument_list|()
operator|->
name|mutex
operator|.
name|lock
argument_list|()
expr_stmt|;
name|_q_sslErrorList
argument_list|()
operator|->
name|errors
operator|.
name|clear
argument_list|()
expr_stmt|;
name|int
name|result
init|=
operator|(
name|mode
operator|==
name|QSslSocket
operator|::
name|SslClientMode
operator|)
condition|?
name|q_SSL_connect
argument_list|(
name|ssl
argument_list|)
else|:
name|q_SSL_accept
argument_list|(
name|ssl
argument_list|)
decl_stmt|;
specifier|const
name|QList
argument_list|<
name|QPair
argument_list|<
name|int
argument_list|,
name|int
argument_list|>
argument_list|>
modifier|&
name|lastErrors
init|=
name|_q_sslErrorList
argument_list|()
operator|->
name|errors
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|lastErrors
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QPair
argument_list|<
name|int
argument_list|,
name|int
argument_list|>
modifier|&
name|currentError
init|=
name|lastErrors
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|// Initialize the peer certificate chain in order to find which certificate caused this error
if|if
condition|(
name|configuration
operator|.
name|peerCertificateChain
operator|.
name|isEmpty
argument_list|()
condition|)
name|configuration
operator|.
name|peerCertificateChain
operator|=
name|STACKOFX509_to_QSslCertificates
argument_list|(
name|q_SSL_get_peer_cert_chain
argument_list|(
name|ssl
argument_list|)
argument_list|)
expr_stmt|;
emit|emit
name|q
operator|->
name|peerVerifyError
argument_list|(
name|_q_OpenSSL_to_QSslError
argument_list|(
name|currentError
operator|.
name|first
argument_list|,
name|configuration
operator|.
name|peerCertificateChain
operator|.
name|value
argument_list|(
name|currentError
operator|.
name|second
argument_list|)
argument_list|)
argument_list|)
emit|;
if|if
condition|(
name|q
operator|->
name|state
argument_list|()
operator|!=
name|QAbstractSocket
operator|::
name|ConnectedState
condition|)
break|break;
block|}
name|errorList
operator|<<
name|lastErrors
expr_stmt|;
name|_q_sslErrorList
argument_list|()
operator|->
name|mutex
operator|.
name|unlock
argument_list|()
expr_stmt|;
comment|// Connection aborted during handshake phase.
if|if
condition|(
name|q
operator|->
name|state
argument_list|()
operator|!=
name|QAbstractSocket
operator|::
name|ConnectedState
condition|)
return|return
literal|false
return|;
comment|// Check if we're encrypted or not.
if|if
condition|(
name|result
operator|<=
literal|0
condition|)
block|{
switch|switch
condition|(
name|q_SSL_get_error
argument_list|(
name|ssl
argument_list|,
name|result
argument_list|)
condition|)
block|{
case|case
name|SSL_ERROR_WANT_READ
case|:
case|case
name|SSL_ERROR_WANT_WRITE
case|:
comment|// The handshake is not yet complete.
break|break;
default|default:
name|q
operator|->
name|setErrorString
argument_list|(
name|QSslSocket
operator|::
name|tr
argument_list|(
literal|"Error during SSL handshake: %1"
argument_list|)
operator|.
name|arg
argument_list|(
name|getErrorsFromOpenSsl
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|->
name|setSocketError
argument_list|(
name|QAbstractSocket
operator|::
name|SslHandshakeFailedError
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|QSSLSOCKET_DEBUG
name|qDebug
argument_list|()
operator|<<
literal|"QSslSocketBackendPrivate::startHandshake: error!"
operator|<<
name|q
operator|->
name|errorString
argument_list|()
expr_stmt|;
endif|#
directive|endif
emit|emit
name|q
operator|->
name|error
argument_list|(
name|QAbstractSocket
operator|::
name|SslHandshakeFailedError
argument_list|)
emit|;
name|q
operator|->
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
literal|false
return|;
block|}
comment|// Store the peer certificate and chain. For clients, the peer certificate
comment|// chain includes the peer certificate; for servers, it doesn't. Both the
comment|// peer certificate and the chain may be empty if the peer didn't present
comment|// any certificate.
if|if
condition|(
name|configuration
operator|.
name|peerCertificateChain
operator|.
name|isEmpty
argument_list|()
condition|)
name|configuration
operator|.
name|peerCertificateChain
operator|=
name|STACKOFX509_to_QSslCertificates
argument_list|(
name|q_SSL_get_peer_cert_chain
argument_list|(
name|ssl
argument_list|)
argument_list|)
expr_stmt|;
name|X509
modifier|*
name|x509
init|=
name|q_SSL_get_peer_certificate
argument_list|(
name|ssl
argument_list|)
decl_stmt|;
name|configuration
operator|.
name|peerCertificate
operator|=
name|QSslCertificatePrivate
operator|::
name|QSslCertificate_from_X509
argument_list|(
name|x509
argument_list|)
expr_stmt|;
name|q_X509_free
argument_list|(
name|x509
argument_list|)
expr_stmt|;
comment|// Start translating errors.
name|QList
argument_list|<
name|QSslError
argument_list|>
name|errors
decl_stmt|;
if|if
condition|(
name|QSslCertificatePrivate
operator|::
name|isBlacklisted
argument_list|(
name|configuration
operator|.
name|peerCertificate
argument_list|)
condition|)
block|{
name|QSslError
name|error
argument_list|(
name|QSslError
operator|::
name|CertificateBlacklisted
argument_list|,
name|configuration
operator|.
name|peerCertificate
argument_list|)
decl_stmt|;
name|errors
operator|<<
name|error
expr_stmt|;
emit|emit
name|q
operator|->
name|peerVerifyError
argument_list|(
name|error
argument_list|)
emit|;
if|if
condition|(
name|q
operator|->
name|state
argument_list|()
operator|!=
name|QAbstractSocket
operator|::
name|ConnectedState
condition|)
return|return
literal|false
return|;
block|}
name|bool
name|doVerifyPeer
init|=
name|configuration
operator|.
name|peerVerifyMode
operator|==
name|QSslSocket
operator|::
name|VerifyPeer
operator|||
operator|(
name|configuration
operator|.
name|peerVerifyMode
operator|==
name|QSslSocket
operator|::
name|AutoVerifyPeer
operator|&&
name|mode
operator|==
name|QSslSocket
operator|::
name|SslClientMode
operator|)
decl_stmt|;
comment|// Check the peer certificate itself. First try the subject's common name
comment|// (CN) as a wildcard, then try all alternate subject name DNS entries the
comment|// same way.
if|if
condition|(
operator|!
name|configuration
operator|.
name|peerCertificate
operator|.
name|isNull
argument_list|()
condition|)
block|{
comment|// but only if we're a client connecting to a server
comment|// if we're the server, don't check CN
if|if
condition|(
name|mode
operator|==
name|QSslSocket
operator|::
name|SslClientMode
condition|)
block|{
name|QString
name|peerName
init|=
operator|(
name|verificationPeerName
operator|.
name|isEmpty
argument_list|()
condition|?
name|q
operator|->
name|peerName
argument_list|()
else|:
name|verificationPeerName
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|isMatchingHostname
argument_list|(
name|configuration
operator|.
name|peerCertificate
argument_list|,
name|peerName
argument_list|)
condition|)
block|{
comment|// No matches in common names or alternate names.
name|QSslError
name|error
argument_list|(
name|QSslError
operator|::
name|HostNameMismatch
argument_list|,
name|configuration
operator|.
name|peerCertificate
argument_list|)
decl_stmt|;
name|errors
operator|<<
name|error
expr_stmt|;
emit|emit
name|q
operator|->
name|peerVerifyError
argument_list|(
name|error
argument_list|)
emit|;
if|if
condition|(
name|q
operator|->
name|state
argument_list|()
operator|!=
name|QAbstractSocket
operator|::
name|ConnectedState
condition|)
return|return
literal|false
return|;
block|}
block|}
block|}
else|else
block|{
comment|// No peer certificate presented. Report as error if the socket
comment|// expected one.
if|if
condition|(
name|doVerifyPeer
condition|)
block|{
name|QSslError
name|error
argument_list|(
name|QSslError
operator|::
name|NoPeerCertificate
argument_list|)
decl_stmt|;
name|errors
operator|<<
name|error
expr_stmt|;
emit|emit
name|q
operator|->
name|peerVerifyError
argument_list|(
name|error
argument_list|)
emit|;
if|if
condition|(
name|q
operator|->
name|state
argument_list|()
operator|!=
name|QAbstractSocket
operator|::
name|ConnectedState
condition|)
return|return
literal|false
return|;
block|}
block|}
comment|// Translate errors from the error list into QSslErrors.
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|errorList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QPair
argument_list|<
name|int
argument_list|,
name|int
argument_list|>
modifier|&
name|errorAndDepth
init|=
name|errorList
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|int
name|err
init|=
name|errorAndDepth
operator|.
name|first
decl_stmt|;
name|int
name|depth
init|=
name|errorAndDepth
operator|.
name|second
decl_stmt|;
name|errors
operator|<<
name|_q_OpenSSL_to_QSslError
argument_list|(
name|err
argument_list|,
name|configuration
operator|.
name|peerCertificateChain
operator|.
name|value
argument_list|(
name|depth
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|errors
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|sslErrors
operator|=
name|errors
expr_stmt|;
emit|emit
name|q
operator|->
name|sslErrors
argument_list|(
name|errors
argument_list|)
emit|;
name|bool
name|doEmitSslError
decl_stmt|;
if|if
condition|(
operator|!
name|ignoreErrorsList
operator|.
name|empty
argument_list|()
condition|)
block|{
comment|// check whether the errors we got are all in the list of expected errors
comment|// (applies only if the method QSslSocket::ignoreSslErrors(const QList<QSslError>&errors)
comment|// was called)
name|doEmitSslError
operator|=
literal|false
expr_stmt|;
for|for
control|(
name|int
name|a
init|=
literal|0
init|;
name|a
operator|<
name|errors
operator|.
name|count
argument_list|()
condition|;
name|a
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|ignoreErrorsList
operator|.
name|contains
argument_list|(
name|errors
operator|.
name|at
argument_list|(
name|a
argument_list|)
argument_list|)
condition|)
block|{
name|doEmitSslError
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
comment|// if QSslSocket::ignoreSslErrors(const QList<QSslError>&errors) was not called and
comment|// we get an SSL error, emit a signal unless we ignored all errors (by calling
comment|// QSslSocket::ignoreSslErrors() )
name|doEmitSslError
operator|=
operator|!
name|ignoreAllSslErrors
expr_stmt|;
block|}
comment|// check whether we need to emit an SSL handshake error
if|if
condition|(
name|doVerifyPeer
operator|&&
name|doEmitSslError
condition|)
block|{
name|q
operator|->
name|setErrorString
argument_list|(
name|sslErrors
operator|.
name|first
argument_list|()
operator|.
name|errorString
argument_list|()
argument_list|)
expr_stmt|;
name|q
operator|->
name|setSocketError
argument_list|(
name|QAbstractSocket
operator|::
name|SslHandshakeFailedError
argument_list|)
expr_stmt|;
emit|emit
name|q
operator|->
name|error
argument_list|(
name|QAbstractSocket
operator|::
name|SslHandshakeFailedError
argument_list|)
emit|;
name|plainSocket
operator|->
name|disconnectFromHost
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
block|}
else|else
block|{
name|sslErrors
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
comment|// if we have a max read buffer size, reset the plain socket's to 1k
if|if
condition|(
name|readBufferMaxSize
condition|)
name|plainSocket
operator|->
name|setReadBufferSize
argument_list|(
literal|1024
argument_list|)
expr_stmt|;
name|connectionEncrypted
operator|=
literal|true
expr_stmt|;
emit|emit
name|q
operator|->
name|encrypted
argument_list|()
emit|;
if|if
condition|(
name|autoStartHandshake
operator|&&
name|pendingClose
condition|)
block|{
name|pendingClose
operator|=
literal|false
expr_stmt|;
name|q
operator|->
name|disconnectFromHost
argument_list|()
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|disconnectFromHost
name|void
name|QSslSocketBackendPrivate
operator|::
name|disconnectFromHost
parameter_list|()
block|{
if|if
condition|(
name|ssl
condition|)
block|{
name|q_SSL_shutdown
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
name|transmit
argument_list|()
expr_stmt|;
block|}
name|plainSocket
operator|->
name|disconnectFromHost
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|disconnected
name|void
name|QSslSocketBackendPrivate
operator|::
name|disconnected
parameter_list|()
block|{
if|if
condition|(
name|ssl
condition|)
block|{
name|q_SSL_free
argument_list|(
name|ssl
argument_list|)
expr_stmt|;
name|ssl
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ctx
condition|)
block|{
name|q_SSL_CTX_free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|ctx
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|pkey
condition|)
block|{
name|q_EVP_PKEY_free
argument_list|(
name|pkey
argument_list|)
expr_stmt|;
name|pkey
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|sessionCipher
name|QSslCipher
name|QSslSocketBackendPrivate
operator|::
name|sessionCipher
parameter_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|ssl
operator|||
operator|!
name|ctx
condition|)
return|return
name|QSslCipher
argument_list|()
return|;
if|#
directive|if
name|OPENSSL_VERSION_NUMBER
operator|>=
literal|0x10000000L
comment|// FIXME This is fairly evil, but needed to keep source level compatibility
comment|// with the OpenSSL 0.9.x implementation at maximum -- some other functions
comment|// don't take a const SSL_CIPHER* when they should
name|SSL_CIPHER
modifier|*
name|sessionCipher
init|=
cast|const_cast
argument_list|<
name|SSL_CIPHER
operator|*
argument_list|>
argument_list|(
name|q_SSL_get_current_cipher
argument_list|(
name|ssl
argument_list|)
argument_list|)
decl_stmt|;
else|#
directive|else
name|SSL_CIPHER
modifier|*
name|sessionCipher
init|=
name|q_SSL_get_current_cipher
argument_list|(
name|ssl
argument_list|)
decl_stmt|;
endif|#
directive|endif
return|return
name|sessionCipher
condition|?
name|QSslCipher_from_SSL_CIPHER
argument_list|(
name|sessionCipher
argument_list|)
else|:
name|QSslCipher
argument_list|()
return|;
block|}
end_function
begin_decl_stmt
name|QList
argument_list|<
name|QSslCertificate
argument_list|>
name|QSslSocketBackendPrivate
operator|::
name|STACKOFX509_to_QSslCertificates
argument_list|(
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
name|x509
argument_list|)
argument_list|{
name|ensureInitialized
argument_list|()
argument_list|;
name|QList
argument_list|<
name|QSslCertificate
argument_list|>
name|certificates
argument_list|;     for
operator|(
name|int
name|i
operator|=
literal|0
expr|;
name|i
operator|<
name|q_sk_X509_num
argument_list|(
name|x509
argument_list|)
expr|;
operator|++
name|i
operator|)
block|{
if|if
condition|(
name|X509
modifier|*
name|entry
type|=
name|q_sk_X509_value
type|(
name|x509
condition|,
name|i
condition|))             certificates<< QSslCertificatePrivate::QSslCertificate_from_X509(entry)
empty_stmt|;
block|}
return|return
name|certificates
return|;
end_decl_stmt
begin_macro
unit|}  QString
DECL|function|getErrorsFromOpenSsl
name|QSslSocketBackendPrivate
end_macro
begin_expr_stmt
DECL|function|getErrorsFromOpenSsl
operator|::
name|getErrorsFromOpenSsl
operator|(
operator|)
block|{
name|QString
name|errorString
block|;
name|unsigned
name|long
name|errNum
block|;
while|while
condition|(
operator|(
name|errNum
operator|=
name|q_ERR_get_error
argument_list|()
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|errorString
operator|.
name|isEmpty
argument_list|()
condition|)
name|errorString
operator|.
name|append
argument_list|(
name|QLatin1String
argument_list|(
literal|", "
argument_list|)
argument_list|)
expr_stmt|;
specifier|const
name|char
modifier|*
name|error
init|=
name|q_ERR_error_string
argument_list|(
name|errNum
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|errorString
operator|.
name|append
argument_list|(
name|QString
operator|::
name|fromAscii
argument_list|(
name|error
argument_list|)
argument_list|)
expr_stmt|;
comment|// error is ascii according to man ERR_error_string
block|}
end_expr_stmt
begin_return
return|return
name|errorString
return|;
end_return
begin_macro
unit|}  bool
DECL|function|isMatchingHostname
name|QSslSocketBackendPrivate
end_macro
begin_expr_stmt
DECL|function|isMatchingHostname
operator|::
name|isMatchingHostname
operator|(
specifier|const
name|QSslCertificate
operator|&
name|cert
operator|,
specifier|const
name|QString
operator|&
name|peerName
operator|)
block|{
name|QStringList
name|commonNameList
operator|=
name|cert
operator|.
name|subjectInfo
argument_list|(
name|QSslCertificate
operator|::
name|CommonName
argument_list|)
block|;
foreach|foreach
control|(
specifier|const
name|QString
modifier|&
name|commonName
decl|,
name|commonNameList
control|)
block|{
if|if
condition|(
name|isMatchingHostname
argument_list|(
name|commonName
operator|.
name|toLower
argument_list|()
argument_list|,
name|peerName
operator|.
name|toLower
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
end_expr_stmt
begin_expr_stmt
unit|}      foreach
operator|(
specifier|const
name|QString
operator|&
name|altName
operator|,
name|cert
operator|.
name|subjectAlternativeNames
argument_list|()
operator|.
name|values
argument_list|(
name|QSsl
operator|::
name|DnsEntry
argument_list|)
operator|)
block|{
if|if
condition|(
name|isMatchingHostname
argument_list|(
name|altName
operator|.
name|toLower
argument_list|()
argument_list|,
name|peerName
operator|.
name|toLower
argument_list|()
argument_list|)
condition|)
block|{
return|return
literal|true
return|;
block|}
end_expr_stmt
begin_expr_stmt
unit|}      return
literal|false
expr_stmt|;
end_expr_stmt
begin_macro
unit|}  bool
DECL|function|isMatchingHostname
name|QSslSocketBackendPrivate
end_macro
begin_expr_stmt
DECL|function|isMatchingHostname
operator|::
name|isMatchingHostname
operator|(
specifier|const
name|QString
operator|&
name|cn
operator|,
specifier|const
name|QString
operator|&
name|hostname
operator|)
block|{
name|int
name|wildcard
operator|=
name|cn
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'*'
argument_list|)
argument_list|)
block|;
comment|// Check this is a wildcard cert, if not then just compare the strings
if|if
condition|(
name|wildcard
operator|<
literal|0
condition|)
return|return
name|cn
operator|==
name|hostname
return|;
name|int
name|firstCnDot
operator|=
name|cn
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt
begin_decl_stmt
name|int
name|secondCnDot
init|=
name|cn
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
argument_list|,
name|firstCnDot
operator|+
literal|1
argument_list|)
decl_stmt|;
end_decl_stmt
begin_comment
comment|// Check at least 3 components
end_comment
begin_if
if|if
condition|(
operator|(
operator|-
literal|1
operator|==
name|secondCnDot
operator|)
operator|||
operator|(
name|secondCnDot
operator|+
literal|1
operator|>=
name|cn
operator|.
name|length
argument_list|()
operator|)
condition|)
return|return
literal|false
return|;
end_if
begin_comment
comment|// Check * is last character of 1st component (ie. there's a following .)
end_comment
begin_if
if|if
condition|(
name|wildcard
operator|+
literal|1
operator|!=
name|firstCnDot
condition|)
return|return
literal|false
return|;
end_if
begin_comment
comment|// Check only one star
end_comment
begin_if
if|if
condition|(
name|cn
operator|.
name|lastIndexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'*'
argument_list|)
argument_list|)
operator|!=
name|wildcard
condition|)
return|return
literal|false
return|;
end_if
begin_comment
comment|// Check characters preceding * (if any) match
end_comment
begin_if
if|if
condition|(
name|wildcard
operator|&&
operator|(
name|hostname
operator|.
name|leftRef
argument_list|(
name|wildcard
argument_list|)
operator|!=
name|cn
operator|.
name|leftRef
argument_list|(
name|wildcard
argument_list|)
operator|)
condition|)
return|return
literal|false
return|;
end_if
begin_comment
comment|// Check characters following first . match
end_comment
begin_if
if|if
condition|(
name|hostname
operator|.
name|midRef
argument_list|(
name|hostname
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|cn
operator|.
name|midRef
argument_list|(
name|firstCnDot
argument_list|)
condition|)
return|return
literal|false
return|;
end_if
begin_comment
comment|// Check if the hostname is an IP address, if so then wildcards are not allowed
end_comment
begin_function_decl
name|QHostAddress
name|addr
parameter_list|(
name|hostname
parameter_list|)
function_decl|;
end_function_decl
begin_if
if|if
condition|(
operator|!
name|addr
operator|.
name|isNull
argument_list|()
condition|)
return|return
literal|false
return|;
end_if
begin_comment
comment|// Ok, I guess this was a wildcard CN and the hostname matches.
end_comment
begin_return
return|return
literal|true
return|;
end_return
begin_expr_stmt
unit|}  QList
DECL|function|verify
operator|<
name|QSslError
operator|>
name|QSslSocketBackendPrivate
operator|::
name|verify
operator|(
name|QList
argument_list|<
name|QSslCertificate
argument_list|>
name|certificateChain
operator|,
specifier|const
name|QString
operator|&
name|hostName
operator|)
block|{
name|QList
argument_list|<
name|QSslError
argument_list|>
name|errors
block|;
if|if
condition|(
name|certificateChain
operator|.
name|count
argument_list|()
operator|<=
literal|0
condition|)
block|{
name|errors
operator|<<
name|QSslError
argument_list|(
name|QSslError
operator|::
name|UnspecifiedError
argument_list|)
expr_stmt|;
return|return
name|errors
return|;
block|}
comment|// Setup the store with the default CA certificates
name|X509_STORE
operator|*
name|certStore
operator|=
name|q_X509_STORE_new
argument_list|()
expr_stmt|;
end_expr_stmt
begin_if
if|if
condition|(
operator|!
name|certStore
condition|)
block|{
name|qWarning
argument_list|()
operator|<<
literal|"Unable to create certificate store"
expr_stmt|;
name|errors
operator|<<
name|QSslError
argument_list|(
name|QSslError
operator|::
name|UnspecifiedError
argument_list|)
expr_stmt|;
return|return
name|errors
return|;
block|}
end_if
begin_decl_stmt
name|QList
argument_list|<
name|QSslCertificate
argument_list|>
name|expiredCerts
decl_stmt|;
end_decl_stmt
begin_foreach
foreach|foreach
control|(
specifier|const
name|QSslCertificate
modifier|&
name|caCertificate
decl|,
name|QSslSocket
operator|::
name|defaultCaCertificates
argument_list|()
control|)
block|{
comment|// add expired certs later, so that the
comment|// valid ones are used before the expired ones
if|if
condition|(
operator|!
name|caCertificate
operator|.
name|isValid
argument_list|()
condition|)
block|{
name|expiredCerts
operator|.
name|append
argument_list|(
name|caCertificate
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|q_X509_STORE_add_cert
argument_list|(
name|certStore
argument_list|,
operator|(
name|X509
operator|*
operator|)
name|caCertificate
operator|.
name|handle
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_foreach
begin_decl_stmt
name|bool
name|addExpiredCerts
init|=
literal|true
decl_stmt|;
end_decl_stmt
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_MAC
argument_list|)
operator|&&
operator|(
name|MAC_OS_X_VERSION_MAX_ALLOWED
operator|==
name|MAC_OS_X_VERSION_10_5
operator|)
end_if
begin_comment
comment|//On Leopard SSL does not work if we add the expired certificates.
end_comment
begin_if
if|if
condition|(
name|QSysInfo
operator|::
name|MacintoshVersion
operator|==
name|QSysInfo
operator|::
name|MV_10_5
condition|)
name|addExpiredCerts
operator|=
literal|false
expr_stmt|;
end_if
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// now add the expired certs
end_comment
begin_if
if|if
condition|(
name|addExpiredCerts
condition|)
block|{
foreach|foreach
control|(
specifier|const
name|QSslCertificate
modifier|&
name|caCertificate
decl|,
name|expiredCerts
control|)
block|{
name|q_X509_STORE_add_cert
argument_list|(
name|certStore
argument_list|,
operator|(
name|X509
operator|*
operator|)
name|caCertificate
operator|.
name|handle
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_if
begin_decl_stmt
name|QMutexLocker
name|sslErrorListMutexLocker
argument_list|(
operator|&
name|_q_sslErrorList
argument_list|()
operator|->
name|mutex
argument_list|)
decl_stmt|;
end_decl_stmt
begin_comment
comment|// Register a custom callback to get all verification errors.
end_comment
begin_expr_stmt
name|X509_STORE_set_verify_cb_func
argument_list|(
name|certStore
argument_list|,
name|q_X509Callback
argument_list|)
expr_stmt|;
end_expr_stmt
begin_comment
comment|// Build the chain of intermediate certificates
end_comment
begin_expr_stmt
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
name|intermediates
operator|=
literal|0
expr_stmt|;
end_expr_stmt
begin_if
if|if
condition|(
name|certificateChain
operator|.
name|length
argument_list|()
operator|>
literal|1
condition|)
block|{
name|intermediates
operator|=
operator|(
name|STACK_OF
argument_list|(
name|X509
argument_list|)
operator|*
operator|)
name|q_sk_new_null
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|intermediates
condition|)
block|{
name|q_X509_STORE_free
argument_list|(
name|certStore
argument_list|)
expr_stmt|;
name|errors
operator|<<
name|QSslError
argument_list|(
name|QSslError
operator|::
name|UnspecifiedError
argument_list|)
expr_stmt|;
return|return
name|errors
return|;
block|}
name|bool
name|first
init|=
literal|true
decl_stmt|;
foreach|foreach
control|(
specifier|const
name|QSslCertificate
modifier|&
name|cert
decl|,
name|certificateChain
control|)
block|{
if|if
condition|(
name|first
condition|)
block|{
name|first
operator|=
literal|false
expr_stmt|;
continue|continue;
block|}
if|#
directive|if
name|OPENSSL_VERSION_NUMBER
operator|>=
literal|0x10000000L
name|q_sk_push
argument_list|(
operator|(
name|_STACK
operator|*
operator|)
name|intermediates
argument_list|,
operator|(
name|X509
operator|*
operator|)
name|cert
operator|.
name|handle
argument_list|()
argument_list|)
expr_stmt|;
else|#
directive|else
name|q_sk_push
argument_list|(
operator|(
name|STACK
operator|*
operator|)
name|intermediates
argument_list|,
operator|(
name|X509
operator|*
operator|)
name|cert
operator|.
name|handle
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_if
begin_decl_stmt
name|X509_STORE_CTX
modifier|*
name|storeContext
init|=
name|q_X509_STORE_CTX_new
argument_list|()
decl_stmt|;
end_decl_stmt
begin_if
if|if
condition|(
operator|!
name|storeContext
condition|)
block|{
name|q_X509_STORE_free
argument_list|(
name|certStore
argument_list|)
expr_stmt|;
name|errors
operator|<<
name|QSslError
argument_list|(
name|QSslError
operator|::
name|UnspecifiedError
argument_list|)
expr_stmt|;
return|return
name|errors
return|;
block|}
end_if
begin_if
if|if
condition|(
operator|!
name|q_X509_STORE_CTX_init
argument_list|(
name|storeContext
argument_list|,
name|certStore
argument_list|,
operator|(
name|X509
operator|*
operator|)
name|certificateChain
index|[
literal|0
index|]
operator|.
name|handle
argument_list|()
argument_list|,
name|intermediates
argument_list|)
condition|)
block|{
name|q_X509_STORE_CTX_free
argument_list|(
name|storeContext
argument_list|)
expr_stmt|;
name|q_X509_STORE_free
argument_list|(
name|certStore
argument_list|)
expr_stmt|;
name|errors
operator|<<
name|QSslError
argument_list|(
name|QSslError
operator|::
name|UnspecifiedError
argument_list|)
expr_stmt|;
return|return
name|errors
return|;
block|}
end_if
begin_comment
comment|// Now we can actually perform the verification of the chain we have built.
end_comment
begin_comment
comment|// We ignore the result of this function since we process errors via the
end_comment
begin_comment
comment|// callback.
end_comment
begin_expr_stmt
operator|(
name|void
operator|)
name|q_X509_verify_cert
argument_list|(
name|storeContext
argument_list|)
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|q_X509_STORE_CTX_free
argument_list|(
name|storeContext
argument_list|)
expr_stmt|;
end_expr_stmt
begin_if
if|#
directive|if
name|OPENSSL_VERSION_NUMBER
operator|>=
literal|0x10000000L
end_if
begin_expr_stmt
name|q_sk_free
argument_list|(
operator|(
name|_STACK
operator|*
operator|)
name|intermediates
argument_list|)
expr_stmt|;
end_expr_stmt
begin_else
else|#
directive|else
end_else
begin_expr_stmt
name|q_sk_free
argument_list|(
operator|(
name|STACK
operator|*
operator|)
name|intermediates
argument_list|)
expr_stmt|;
end_expr_stmt
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// Now process the errors
end_comment
begin_decl_stmt
specifier|const
name|QList
argument_list|<
name|QPair
argument_list|<
name|int
argument_list|,
name|int
argument_list|>
argument_list|>
name|errorList
init|=
name|_q_sslErrorList
argument_list|()
operator|->
name|errors
decl_stmt|;
end_decl_stmt
begin_expr_stmt
name|_q_sslErrorList
argument_list|()
operator|->
name|errors
operator|.
name|clear
argument_list|()
expr_stmt|;
end_expr_stmt
begin_expr_stmt
name|sslErrorListMutexLocker
operator|.
name|unlock
argument_list|()
expr_stmt|;
end_expr_stmt
begin_comment
comment|// Translate the errors
end_comment
begin_if
if|if
condition|(
name|QSslCertificatePrivate
operator|::
name|isBlacklisted
argument_list|(
name|certificateChain
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|QSslError
name|error
parameter_list|(
name|QSslError
operator|::
name|CertificateBlacklisted
parameter_list|,
name|certificateChain
index|[
literal|0
index|]
parameter_list|)
function_decl|;
name|errors
operator|<<
name|error
expr_stmt|;
block|}
end_if
begin_comment
comment|// Check the certificate name against the hostname if one was specified
end_comment
begin_if
if|if
condition|(
operator|(
operator|!
name|hostName
operator|.
name|isEmpty
argument_list|()
operator|)
operator|&&
operator|(
operator|!
name|isMatchingHostname
argument_list|(
name|certificateChain
index|[
literal|0
index|]
argument_list|,
name|hostName
argument_list|)
operator|)
condition|)
block|{
comment|// No matches in common names or alternate names.
name|QSslError
name|error
parameter_list|(
name|QSslError
operator|::
name|HostNameMismatch
parameter_list|,
name|certificateChain
index|[
literal|0
index|]
parameter_list|)
function_decl|;
name|errors
operator|<<
name|error
expr_stmt|;
block|}
end_if
begin_comment
comment|// Translate errors from the error list into QSslErrors.
end_comment
begin_for
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|errorList
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QPair
argument_list|<
name|int
argument_list|,
name|int
argument_list|>
modifier|&
name|errorAndDepth
init|=
name|errorList
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|int
name|err
init|=
name|errorAndDepth
operator|.
name|first
decl_stmt|;
name|int
name|depth
init|=
name|errorAndDepth
operator|.
name|second
decl_stmt|;
name|errors
operator|<<
name|_q_OpenSSL_to_QSslError
argument_list|(
name|err
argument_list|,
name|certificateChain
operator|.
name|value
argument_list|(
name|depth
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_for
begin_expr_stmt
name|q_X509_STORE_free
argument_list|(
name|certStore
argument_list|)
expr_stmt|;
end_expr_stmt
begin_return
return|return
name|errors
return|;
end_return
unit|}  QT_END_NAMESPACE
end_unit
