begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2010 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: Nokia Corporation (qt-info@nokia.com) ** ** This file is part of the QtNetwork module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** No Commercial Usage ** This file contains pre-release code and may not be distributed. ** You may use this file in accordance with the terms and conditions ** contained in the Technology Preview License Agreement accompanying ** this package. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights.  These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** If you have questions regarding the use of this file, please contact ** Nokia at qt-info@nokia.com. ** ** ** ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_comment
comment|//#define QHOSTINFO_DEBUG
end_comment
begin_comment
comment|// Qt Headers
end_comment
begin_include
include|#
directive|include
file|<QByteArray>
end_include
begin_include
include|#
directive|include
file|<QUrl>
end_include
begin_include
include|#
directive|include
file|<QList>
end_include
begin_include
include|#
directive|include
file|"qplatformdefs.h"
end_include
begin_include
include|#
directive|include
file|"qhostinfo_p.h"
end_include
begin_include
include|#
directive|include
file|<private/qcore_symbian_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qsystemerror_p.h>
end_include
begin_include
include|#
directive|include
file|<private/qnetworksession_p.h>
end_include
begin_comment
comment|// Header does not exist in the S60 5.0 SDK
end_comment
begin_comment
comment|//#include<networking/dnd_err.h>
end_comment
begin_decl_stmt
DECL|variable|KErrDndNameNotFound
specifier|const
name|TInt
name|KErrDndNameNotFound
init|=
operator|-
literal|5120
decl_stmt|;
end_decl_stmt
begin_comment
DECL|variable|KErrDndNameNotFound
comment|// Returned when no data found for GetByName
end_comment
begin_decl_stmt
DECL|variable|KErrDndAddrNotFound
specifier|const
name|TInt
name|KErrDndAddrNotFound
init|=
operator|-
literal|5121
decl_stmt|;
end_decl_stmt
begin_comment
DECL|variable|KErrDndAddrNotFound
comment|// Returned when no data found for GetByAddr
end_comment
begin_function
name|QT_BEGIN_NAMESPACE
DECL|function|setError_helper
specifier|static
name|void
name|setError_helper
parameter_list|(
name|QHostInfo
modifier|&
name|info
parameter_list|,
name|TInt
name|symbianError
parameter_list|)
block|{
switch|switch
condition|(
name|symbianError
condition|)
block|{
case|case
name|KErrDndNameNotFound
case|:
case|case
name|KErrDndAddrNotFound
case|:
case|case
name|KErrNotFound
case|:
case|case
name|KErrEof
case|:
comment|// various "no more results" error codes
name|info
operator|.
name|setError
argument_list|(
name|QHostInfo
operator|::
name|HostNotFound
argument_list|)
expr_stmt|;
name|info
operator|.
name|setErrorString
argument_list|(
name|QObject
operator|::
name|tr
argument_list|(
literal|"Host not found"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|// Unknown error
name|info
operator|.
name|setError
argument_list|(
name|QHostInfo
operator|::
name|UnknownError
argument_list|)
expr_stmt|;
name|info
operator|.
name|setErrorString
argument_list|(
name|QSystemError
argument_list|(
name|symbianError
argument_list|,
name|QSystemError
operator|::
name|NativeError
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function
begin_function
DECL|function|fromName
name|QHostInfo
name|QHostInfoAgent
operator|::
name|fromName
parameter_list|(
specifier|const
name|QString
modifier|&
name|hostName
parameter_list|,
name|QSharedPointer
argument_list|<
name|QNetworkSession
argument_list|>
name|networkSession
parameter_list|)
block|{
name|QHostInfo
name|results
decl_stmt|;
comment|// Connect to ESOCK
name|RSocketServ
name|socketServ
argument_list|(
name|qt_symbianGetSocketServer
argument_list|()
argument_list|)
decl_stmt|;
name|RHostResolver
name|hostResolver
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|networkSession
condition|)
name|err
operator|=
name|QNetworkSessionPrivate
operator|::
name|nativeOpenHostResolver
argument_list|(
operator|*
name|networkSession
argument_list|,
name|hostResolver
argument_list|,
name|KAfInet
argument_list|,
name|KProtocolInetUdp
argument_list|)
expr_stmt|;
else|else
name|err
operator|=
name|hostResolver
operator|.
name|Open
argument_list|(
name|socketServ
argument_list|,
name|KAfInet
argument_list|,
name|KProtocolInetUdp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|setError_helper
argument_list|(
name|results
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
name|results
return|;
block|}
name|TNameEntry
name|nameResult
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QHOSTINFO_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QHostInfoAgent::fromName(%s) looking up..."
argument_list|,
name|hostName
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|QHostAddress
name|address
decl_stmt|;
if|if
condition|(
name|address
operator|.
name|setAddress
argument_list|(
name|hostName
argument_list|)
condition|)
block|{
comment|// Reverse lookup
if|#
directive|if
name|defined
argument_list|(
name|QHOSTINFO_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"(reverse lookup)"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|TInetAddr
name|IpAdd
decl_stmt|;
name|IpAdd
operator|.
name|Input
argument_list|(
name|qt_QString2TPtrC
argument_list|(
name|hostName
argument_list|)
argument_list|)
expr_stmt|;
comment|// Synchronous request. nameResult returns Host Name.
name|err
operator|=
name|hostResolver
operator|.
name|GetByAddress
argument_list|(
name|IpAdd
argument_list|,
name|nameResult
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
comment|//for behavioural compatibility with Qt 4.7 and unix/windows
comment|//backends: don't report error, return ip address as host name
name|results
operator|.
name|setHostName
argument_list|(
name|address
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|results
operator|.
name|setHostName
argument_list|(
name|qt_TDesC2QString
argument_list|(
name|nameResult
argument_list|()
operator|.
name|iName
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|results
operator|.
name|setAddresses
argument_list|(
name|QList
argument_list|<
name|QHostAddress
argument_list|>
argument_list|()
operator|<<
name|address
argument_list|)
expr_stmt|;
return|return
name|results
return|;
block|}
comment|// IDN support
name|QByteArray
name|aceHostname
init|=
name|QUrl
operator|::
name|toAce
argument_list|(
name|hostName
argument_list|)
decl_stmt|;
name|results
operator|.
name|setHostName
argument_list|(
name|hostName
argument_list|)
expr_stmt|;
if|if
condition|(
name|aceHostname
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|results
operator|.
name|setError
argument_list|(
name|QHostInfo
operator|::
name|HostNotFound
argument_list|)
expr_stmt|;
name|results
operator|.
name|setErrorString
argument_list|(
name|hostName
operator|.
name|isEmpty
argument_list|()
condition|?
name|QCoreApplication
operator|::
name|translate
argument_list|(
literal|"QHostInfoAgent"
argument_list|,
literal|"No host name given"
argument_list|)
else|:
name|QCoreApplication
operator|::
name|translate
argument_list|(
literal|"QHostInfoAgent"
argument_list|,
literal|"Invalid hostname"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|results
return|;
block|}
comment|// Call RHostResolver::GetByAddress, and place all IPv4 addresses at the start and
comment|// the IPv6 addresses at the end of the address list in results.
comment|// Synchronous request.
name|err
operator|=
name|hostResolver
operator|.
name|GetByName
argument_list|(
name|qt_QString2TPtrC
argument_list|(
name|QString
operator|::
name|fromLatin1
argument_list|(
name|aceHostname
argument_list|)
argument_list|)
argument_list|,
name|nameResult
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|setError_helper
argument_list|(
name|results
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
name|results
return|;
block|}
name|QList
argument_list|<
name|QHostAddress
argument_list|>
name|hostAddresses
decl_stmt|;
name|TInetAddr
name|hostAdd
init|=
name|nameResult
argument_list|()
operator|.
name|iAddr
decl_stmt|;
comment|// 39 is the maximum length of an IPv6 address.
name|TBuf
argument_list|<
literal|39
argument_list|>
name|ipAddr
decl_stmt|;
comment|// Fill ipAddr with the IP address from hostAdd
name|hostAdd
operator|.
name|Output
argument_list|(
name|ipAddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipAddr
operator|.
name|Length
argument_list|()
operator|>
literal|0
condition|)
name|hostAddresses
operator|.
name|append
argument_list|(
name|QHostAddress
argument_list|(
name|qt_TDesC2QString
argument_list|(
name|ipAddr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|// Check if there's more than one IP address linkd to this name
while|while
condition|(
name|hostResolver
operator|.
name|Next
argument_list|(
name|nameResult
argument_list|)
operator|==
name|KErrNone
condition|)
block|{
name|hostAdd
operator|=
name|nameResult
argument_list|()
operator|.
name|iAddr
expr_stmt|;
name|hostAdd
operator|.
name|Output
argument_list|(
name|ipAddr
argument_list|)
expr_stmt|;
comment|// Ensure that record is valid (not an alias and with length greater than 0)
if|if
condition|(
operator|!
operator|(
name|nameResult
argument_list|()
operator|.
name|iFlags
operator|&
name|TNameRecord
operator|::
name|EAlias
operator|)
operator|&&
operator|!
operator|(
name|hostAdd
operator|.
name|IsUnspecified
argument_list|()
operator|)
condition|)
block|{
name|hostAddresses
operator|.
name|append
argument_list|(
name|QHostAddress
argument_list|(
name|qt_TDesC2QString
argument_list|(
name|ipAddr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|hostResolver
operator|.
name|Close
argument_list|()
expr_stmt|;
name|results
operator|.
name|setAddresses
argument_list|(
name|hostAddresses
argument_list|)
expr_stmt|;
return|return
name|results
return|;
block|}
end_function
begin_function
DECL|function|fromName
name|QHostInfo
name|QHostInfoAgent
operator|::
name|fromName
parameter_list|(
specifier|const
name|QString
modifier|&
name|hostName
parameter_list|)
block|{
comment|// null shared pointer
name|QSharedPointer
argument_list|<
name|QNetworkSession
argument_list|>
name|networkSession
decl_stmt|;
return|return
name|fromName
argument_list|(
name|hostName
argument_list|,
name|networkSession
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|localHostName
name|QString
name|QHostInfo
operator|::
name|localHostName
parameter_list|()
block|{
comment|// Connect to ESOCK
name|RSocketServ
name|socketServ
argument_list|(
name|qt_symbianGetSocketServer
argument_list|()
argument_list|)
decl_stmt|;
name|RHostResolver
name|hostResolver
decl_stmt|;
comment|// RConnection not required to get the host name
name|int
name|err
init|=
name|hostResolver
operator|.
name|Open
argument_list|(
name|socketServ
argument_list|,
name|KAfInet
argument_list|,
name|KProtocolInetUdp
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|QString
argument_list|()
return|;
name|THostName
name|hostName
decl_stmt|;
name|err
operator|=
name|hostResolver
operator|.
name|GetHostName
argument_list|(
name|hostName
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|QString
argument_list|()
return|;
name|hostResolver
operator|.
name|Close
argument_list|()
expr_stmt|;
return|return
name|qt_TDesC2QString
argument_list|(
name|hostName
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|localDomainName
name|QString
name|QHostInfo
operator|::
name|localDomainName
parameter_list|()
block|{
comment|// This concept does not exist on Symbian OS because the device can be on
comment|// multiple networks with multiple "local domain" names.
comment|// For now, return a null string.
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_constructor
DECL|function|QSymbianHostResolver
name|QSymbianHostResolver
operator|::
name|QSymbianHostResolver
parameter_list|(
specifier|const
name|QString
modifier|&
name|hostName
parameter_list|,
name|int
name|identifier
parameter_list|,
name|QSharedPointer
argument_list|<
name|QNetworkSession
argument_list|>
name|networkSession
parameter_list|)
member_init_list|:
name|CActive
argument_list|(
name|CActive
operator|::
name|EPriorityStandard
argument_list|)
member_init_list|,
name|iHostName
argument_list|(
name|hostName
argument_list|)
member_init_list|,
name|iSocketServ
argument_list|(
name|qt_symbianGetSocketServer
argument_list|()
argument_list|)
member_init_list|,
name|iNetworkSession
argument_list|(
name|networkSession
argument_list|)
member_init_list|,
name|iResults
argument_list|(
name|identifier
argument_list|)
block|{
name|CActiveScheduler
operator|::
name|Add
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QSymbianHostResolver
name|QSymbianHostResolver
operator|::
name|~
name|QSymbianHostResolver
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|QHOSTINFO_DEBUG
argument_list|)
name|qDebug
argument_list|()
operator|<<
literal|"QSymbianHostInfoLookupManager::~QSymbianHostResolver"
operator|<<
name|id
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|Cancel
argument_list|()
expr_stmt|;
name|iHostResolver
operator|.
name|Close
argument_list|()
expr_stmt|;
block|}
end_destructor
begin_comment
comment|// Async equivalent to QHostInfoAgent::fromName()
end_comment
begin_function
DECL|function|requestHostLookup
name|void
name|QSymbianHostResolver
operator|::
name|requestHostLookup
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|QHOSTINFO_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"QSymbianHostResolver::requestHostLookup(%s) looking up... (id = %d)"
argument_list|,
name|iHostName
operator|.
name|toLatin1
argument_list|()
operator|.
name|constData
argument_list|()
argument_list|,
name|id
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|QSymbianHostInfoLookupManager
modifier|*
name|manager
init|=
name|QSymbianHostInfoLookupManager
operator|::
name|globalInstance
argument_list|()
decl_stmt|;
if|if
condition|(
name|manager
operator|->
name|cache
operator|.
name|isEnabled
argument_list|()
condition|)
block|{
comment|//check if name has been put in the cache while this request was queued
name|bool
name|valid
decl_stmt|;
name|QHostInfo
name|cachedResult
init|=
name|manager
operator|->
name|cache
operator|.
name|get
argument_list|(
name|iHostName
argument_list|,
operator|&
name|valid
argument_list|)
decl_stmt|;
if|if
condition|(
name|valid
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|QHOSTINFO_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"...found in cache"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|iResults
operator|=
name|cachedResult
expr_stmt|;
name|iState
operator|=
name|ECompleteFromCache
expr_stmt|;
name|SetActive
argument_list|()
expr_stmt|;
name|TRequestStatus
modifier|*
name|stat
init|=
operator|&
name|iStatus
decl_stmt|;
name|User
operator|::
name|RequestComplete
argument_list|(
name|stat
argument_list|,
name|KErrNone
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|int
name|err
decl_stmt|;
if|if
condition|(
name|iNetworkSession
condition|)
block|{
name|err
operator|=
name|QNetworkSessionPrivate
operator|::
name|nativeOpenHostResolver
argument_list|(
operator|*
name|iNetworkSession
argument_list|,
name|iHostResolver
argument_list|,
name|KAfInet
argument_list|,
name|KProtocolInetUdp
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QHOSTINFO_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"using resolver from session (err = %d)"
argument_list|,
name|err
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|err
operator|=
name|iHostResolver
operator|.
name|Open
argument_list|(
name|iSocketServ
argument_list|,
name|KAfInet
argument_list|,
name|KProtocolInetUdp
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QHOSTINFO_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|"using default resolver (err = %d)"
argument_list|,
name|err
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|err
condition|)
block|{
name|setError_helper
argument_list|(
name|iResults
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|iAddress
operator|.
name|setAddress
argument_list|(
name|iHostName
argument_list|)
condition|)
block|{
comment|// Reverse lookup
name|IpAdd
operator|.
name|Input
argument_list|(
name|qt_QString2TPtrC
argument_list|(
name|iHostName
argument_list|)
argument_list|)
expr_stmt|;
comment|// Asynchronous request.
name|iHostResolver
operator|.
name|GetByAddress
argument_list|(
name|IpAdd
argument_list|,
name|iNameResult
argument_list|,
name|iStatus
argument_list|)
expr_stmt|;
comment|//<---- ASYNC
name|iState
operator|=
name|EGetByAddress
expr_stmt|;
block|}
else|else
block|{
comment|// IDN support
name|QByteArray
name|aceHostname
init|=
name|QUrl
operator|::
name|toAce
argument_list|(
name|iHostName
argument_list|)
decl_stmt|;
name|iResults
operator|.
name|setHostName
argument_list|(
name|iHostName
argument_list|)
expr_stmt|;
if|if
condition|(
name|aceHostname
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|iResults
operator|.
name|setError
argument_list|(
name|QHostInfo
operator|::
name|HostNotFound
argument_list|)
expr_stmt|;
name|iResults
operator|.
name|setErrorString
argument_list|(
name|iHostName
operator|.
name|isEmpty
argument_list|()
condition|?
name|QCoreApplication
operator|::
name|translate
argument_list|(
literal|"QHostInfoAgent"
argument_list|,
literal|"No host name given"
argument_list|)
else|:
name|QCoreApplication
operator|::
name|translate
argument_list|(
literal|"QHostInfoAgent"
argument_list|,
literal|"Invalid hostname"
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|KErrArgument
expr_stmt|;
block|}
else|else
block|{
name|iEncodedHostName
operator|=
name|QString
operator|::
name|fromLatin1
argument_list|(
name|aceHostname
argument_list|)
expr_stmt|;
name|iHostNamePtr
operator|.
name|Set
argument_list|(
name|qt_QString2TPtrC
argument_list|(
name|iEncodedHostName
argument_list|)
argument_list|)
expr_stmt|;
comment|// Asynchronous request.
name|iHostResolver
operator|.
name|GetByName
argument_list|(
name|iHostNamePtr
argument_list|,
name|iNameResult
argument_list|,
name|iStatus
argument_list|)
expr_stmt|;
name|iState
operator|=
name|EGetByName
expr_stmt|;
block|}
block|}
block|}
name|SetActive
argument_list|()
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|iHostResolver
operator|.
name|Close
argument_list|()
expr_stmt|;
comment|//self complete so that RunL can inform manager without causing recursion
name|iState
operator|=
name|EError
expr_stmt|;
name|TRequestStatus
modifier|*
name|stat
init|=
operator|&
name|iStatus
decl_stmt|;
name|User
operator|::
name|RequestComplete
argument_list|(
name|stat
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|abortHostLookup
name|void
name|QSymbianHostResolver
operator|::
name|abortHostLookup
parameter_list|()
block|{
if|if
condition|(
name|resultEmitter
operator|.
name|thread
argument_list|()
operator|==
name|QThread
operator|::
name|currentThread
argument_list|()
condition|)
block|{
ifdef|#
directive|ifdef
name|QHOSTINFO_DEBUG
name|qDebug
argument_list|(
literal|"QSymbianHostResolver::abortHostLookup - deleting %d"
argument_list|,
name|id
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|//normal case, abort from same thread it was started
operator|delete
name|this
expr_stmt|;
comment|//will cancel outstanding request
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|QHOSTINFO_DEBUG
name|qDebug
argument_list|(
literal|"QSymbianHostResolver::abortHostLookup - detaching %d"
argument_list|,
name|id
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|//abort from different thread, carry on but don't report the results
name|resultEmitter
operator|.
name|disconnect
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|DoCancel
name|void
name|QSymbianHostResolver
operator|::
name|DoCancel
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|QHOSTINFO_DEBUG
argument_list|)
name|qDebug
argument_list|()
operator|<<
literal|"QSymbianHostResolver::DoCancel"
operator|<<
name|QThread
operator|::
name|currentThreadId
argument_list|()
operator|<<
name|id
argument_list|()
operator|<<
operator|(
name|int
operator|)
name|iState
operator|<<
name|this
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|iState
operator|==
name|EGetByAddress
operator|||
name|iState
operator|==
name|EGetByName
condition|)
block|{
comment|//these states have made an async request to host resolver
name|iHostResolver
operator|.
name|Cancel
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|//for the self completing states there is nothing to cancel
name|Q_ASSERT
argument_list|(
name|iState
operator|==
name|EError
operator|||
name|iState
operator|==
name|ECompleteFromCache
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|RunL
name|void
name|QSymbianHostResolver
operator|::
name|RunL
parameter_list|()
block|{
name|QT_TRYCATCH_LEAVING
argument_list|(
name|run
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|run
name|void
name|QSymbianHostResolver
operator|::
name|run
parameter_list|()
block|{
switch|switch
condition|(
name|iState
condition|)
block|{
case|case
name|EGetByName
case|:
name|processNameResult
argument_list|()
expr_stmt|;
break|break;
case|case
name|EGetByAddress
case|:
name|processAddressResult
argument_list|()
expr_stmt|;
break|break;
case|case
name|ECompleteFromCache
case|:
case|case
name|EError
case|:
name|returnResults
argument_list|()
expr_stmt|;
break|break;
default|default:
name|qWarning
argument_list|(
literal|"QSymbianHostResolver internal error, bad state in run()"
argument_list|)
expr_stmt|;
name|iResults
operator|.
name|setError
argument_list|(
name|QHostInfo
operator|::
name|UnknownError
argument_list|)
expr_stmt|;
name|iResults
operator|.
name|setErrorString
argument_list|(
name|QSystemError
argument_list|(
name|KErrCorrupt
argument_list|,
name|QSystemError
operator|::
name|NativeError
argument_list|)
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
name|returnResults
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|returnResults
name|void
name|QSymbianHostResolver
operator|::
name|returnResults
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|QHOSTINFO_DEBUG
argument_list|)
name|qDebug
argument_list|()
operator|<<
literal|"QSymbianHostResolver::returnResults"
operator|<<
name|iResults
operator|.
name|error
argument_list|()
operator|<<
name|iResults
operator|.
name|errorString
argument_list|()
expr_stmt|;
foreach|foreach
control|(
name|QHostAddress
name|addr
decl|,
name|iResults
operator|.
name|addresses
argument_list|()
control|)
name|qDebug
argument_list|()
operator|<<
name|addr
expr_stmt|;
endif|#
directive|endif
name|iState
operator|=
name|EIdle
expr_stmt|;
name|QSymbianHostInfoLookupManager
modifier|*
name|manager
init|=
name|QSymbianHostInfoLookupManager
operator|::
name|globalInstance
argument_list|()
decl_stmt|;
if|if
condition|(
name|manager
operator|->
name|cache
operator|.
name|isEnabled
argument_list|()
condition|)
block|{
name|manager
operator|->
name|cache
operator|.
name|put
argument_list|(
name|iHostName
argument_list|,
name|iResults
argument_list|)
expr_stmt|;
block|}
name|manager
operator|->
name|lookupFinished
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|resultEmitter
operator|.
name|emitResultsReady
argument_list|(
name|iResults
argument_list|)
expr_stmt|;
operator|delete
name|this
expr_stmt|;
block|}
end_function
begin_function
DECL|function|RunError
name|TInt
name|QSymbianHostResolver
operator|::
name|RunError
parameter_list|(
name|TInt
name|aError
parameter_list|)
block|{
name|QT_TRY
block|{
name|iState
operator|=
name|EIdle
expr_stmt|;
name|QSymbianHostInfoLookupManager
modifier|*
name|manager
init|=
name|QSymbianHostInfoLookupManager
operator|::
name|globalInstance
argument_list|()
decl_stmt|;
name|manager
operator|->
name|lookupFinished
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|setError_helper
argument_list|(
name|iResults
argument_list|,
name|aError
argument_list|)
expr_stmt|;
name|resultEmitter
operator|.
name|emitResultsReady
argument_list|(
name|iResults
argument_list|)
expr_stmt|;
block|}
name|QT_CATCH
argument_list|(
argument|...
argument_list|)
block|{}
operator|delete
name|this
expr_stmt|;
return|return
name|KErrNone
return|;
block|}
end_function
begin_function
DECL|function|processNameResult
name|void
name|QSymbianHostResolver
operator|::
name|processNameResult
parameter_list|()
block|{
if|if
condition|(
name|iStatus
operator|.
name|Int
argument_list|()
operator|==
name|KErrNone
condition|)
block|{
name|TInetAddr
name|hostAdd
init|=
name|iNameResult
argument_list|()
operator|.
name|iAddr
decl_stmt|;
comment|// 39 is the maximum length of an IPv6 address.
name|TBuf
argument_list|<
literal|39
argument_list|>
name|ipAddr
decl_stmt|;
name|hostAdd
operator|.
name|Output
argument_list|(
name|ipAddr
argument_list|)
expr_stmt|;
comment|// Ensure that record is valid (not an alias and with length greater than 0)
if|if
condition|(
operator|!
operator|(
name|iNameResult
argument_list|()
operator|.
name|iFlags
operator|&
name|TNameRecord
operator|::
name|EAlias
operator|)
operator|&&
operator|!
operator|(
name|hostAdd
operator|.
name|IsUnspecified
argument_list|()
operator|)
condition|)
block|{
name|iHostAddresses
operator|.
name|append
argument_list|(
name|QHostAddress
argument_list|(
name|qt_TDesC2QString
argument_list|(
name|ipAddr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|iState
operator|=
name|EGetByName
expr_stmt|;
name|iHostResolver
operator|.
name|Next
argument_list|(
name|iNameResult
argument_list|,
name|iStatus
argument_list|)
expr_stmt|;
name|SetActive
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|// No more addresses, so return the results (or an error if there aren't any).
if|#
directive|if
name|defined
argument_list|(
name|QHOSTINFO_DEBUG
argument_list|)
name|qDebug
argument_list|()
operator|<<
literal|"QSymbianHostResolver::processNameResult with err="
operator|<<
name|iStatus
operator|.
name|Int
argument_list|()
operator|<<
literal|"count="
operator|<<
name|iHostAddresses
operator|.
name|count
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|iHostAddresses
operator|.
name|count
argument_list|()
operator|>
literal|0
condition|)
block|{
name|iResults
operator|.
name|setAddresses
argument_list|(
name|iHostAddresses
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|iState
operator|=
name|EError
expr_stmt|;
name|setError_helper
argument_list|(
name|iResults
argument_list|,
name|iStatus
operator|.
name|Int
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|returnResults
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|processAddressResult
name|void
name|QSymbianHostResolver
operator|::
name|processAddressResult
parameter_list|()
block|{
name|TInt
name|err
init|=
name|iStatus
operator|.
name|Int
argument_list|()
decl_stmt|;
if|if
condition|(
name|err
operator|<
literal|0
condition|)
block|{
comment|//For behavioural compatibility with Qt 4.7, don't report errors on reverse lookup,
comment|//return the address as a string (same as unix/windows backends)
name|iResults
operator|.
name|setHostName
argument_list|(
name|iAddress
operator|.
name|toString
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|iResults
operator|.
name|setHostName
argument_list|(
name|qt_TDesC2QString
argument_list|(
name|iNameResult
argument_list|()
operator|.
name|iName
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|iResults
operator|.
name|setAddresses
argument_list|(
name|QList
argument_list|<
name|QHostAddress
argument_list|>
argument_list|()
operator|<<
name|iAddress
argument_list|)
expr_stmt|;
name|returnResults
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|id
name|int
name|QSymbianHostResolver
operator|::
name|id
parameter_list|()
block|{
return|return
name|iResults
operator|.
name|lookupId
argument_list|()
return|;
block|}
end_function
begin_constructor
DECL|function|QSymbianHostInfoLookupManager
name|QSymbianHostInfoLookupManager
operator|::
name|QSymbianHostInfoLookupManager
parameter_list|()
block|{ }
end_constructor
begin_destructor
DECL|function|~QSymbianHostInfoLookupManager
name|QSymbianHostInfoLookupManager
operator|::
name|~
name|QSymbianHostInfoLookupManager
parameter_list|()
block|{ }
end_destructor
begin_function
DECL|function|clear
name|void
name|QSymbianHostInfoLookupManager
operator|::
name|clear
parameter_list|()
block|{
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|mutex
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QHOSTINFO_DEBUG
argument_list|)
name|qDebug
argument_list|()
operator|<<
literal|"QSymbianHostInfoLookupManager::clear"
operator|<<
name|QThread
operator|::
name|currentThreadId
argument_list|()
expr_stmt|;
endif|#
directive|endif
foreach|foreach
control|(
name|QSymbianHostResolver
modifier|*
name|hr
decl|,
name|iCurrentLookups
control|)
name|hr
operator|->
name|abortHostLookup
argument_list|()
expr_stmt|;
name|iCurrentLookups
operator|.
name|clear
argument_list|()
expr_stmt|;
name|qDeleteAll
argument_list|(
name|iScheduledLookups
argument_list|)
expr_stmt|;
name|cache
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|lookupFinished
name|void
name|QSymbianHostInfoLookupManager
operator|::
name|lookupFinished
parameter_list|(
name|QSymbianHostResolver
modifier|*
name|r
parameter_list|)
block|{
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|mutex
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QHOSTINFO_DEBUG
argument_list|)
name|qDebug
argument_list|()
operator|<<
literal|"QSymbianHostInfoLookupManager::lookupFinished"
operator|<<
name|QThread
operator|::
name|currentThreadId
argument_list|()
operator|<<
name|r
operator|->
name|id
argument_list|()
operator|<<
literal|"current"
operator|<<
name|iCurrentLookups
operator|.
name|count
argument_list|()
operator|<<
literal|"queued"
operator|<<
name|iScheduledLookups
operator|.
name|count
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|// remove finished lookup from array and destroy
name|TInt
name|count
init|=
name|iCurrentLookups
operator|.
name|count
argument_list|()
decl_stmt|;
for|for
control|(
name|TInt
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|iCurrentLookups
index|[
name|i
index|]
operator|->
name|id
argument_list|()
operator|==
name|r
operator|->
name|id
argument_list|()
condition|)
block|{
name|iCurrentLookups
operator|.
name|removeAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|runNextLookup
argument_list|()
expr_stmt|;
block|}
end_function
begin_function
DECL|function|runNextLookup
name|void
name|QSymbianHostInfoLookupManager
operator|::
name|runNextLookup
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|QHOSTINFO_DEBUG
argument_list|)
name|qDebug
argument_list|()
operator|<<
literal|"QSymbianHostInfoLookupManager::runNextLookup"
operator|<<
name|QThread
operator|::
name|currentThreadId
argument_list|()
operator|<<
literal|"current"
operator|<<
name|iCurrentLookups
operator|.
name|count
argument_list|()
operator|<<
literal|"queued"
operator|<<
name|iScheduledLookups
operator|.
name|count
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|// check to see if there are any scheduled lookups
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|iScheduledLookups
operator|.
name|count
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|QSymbianHostResolver
modifier|*
name|hostResolver
init|=
name|iScheduledLookups
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|hostResolver
operator|->
name|resultEmitter
operator|.
name|thread
argument_list|()
operator|==
name|QThread
operator|::
name|currentThread
argument_list|()
condition|)
block|{
comment|// if so, move one to the current lookups and run it
name|iCurrentLookups
operator|.
name|append
argument_list|(
name|hostResolver
argument_list|)
expr_stmt|;
name|iScheduledLookups
operator|.
name|removeAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|hostResolver
operator|->
name|requestHostLookup
argument_list|()
expr_stmt|;
comment|// if spare capacity, try to start another one
if|if
condition|(
name|iCurrentLookups
operator|.
name|count
argument_list|()
operator|>=
name|KMaxConcurrentLookups
condition|)
break|break;
name|i
operator|--
expr_stmt|;
comment|//compensate for removeAt
block|}
block|}
block|}
end_function
begin_comment
comment|// called from QHostInfo
end_comment
begin_function
DECL|function|scheduleLookup
name|void
name|QSymbianHostInfoLookupManager
operator|::
name|scheduleLookup
parameter_list|(
name|QSymbianHostResolver
modifier|*
name|r
parameter_list|)
block|{
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|mutex
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QHOSTINFO_DEBUG
argument_list|)
name|qDebug
argument_list|()
operator|<<
literal|"QSymbianHostInfoLookupManager::scheduleLookup"
operator|<<
name|QThread
operator|::
name|currentThreadId
argument_list|()
operator|<<
name|r
operator|->
name|id
argument_list|()
operator|<<
literal|"current"
operator|<<
name|iCurrentLookups
operator|.
name|count
argument_list|()
operator|<<
literal|"queued"
operator|<<
name|iScheduledLookups
operator|.
name|count
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|// Check to see if we have space on the current lookups pool.
name|bool
name|defer
init|=
literal|false
decl_stmt|;
if|if
condition|(
name|iCurrentLookups
operator|.
name|count
argument_list|()
operator|>=
name|KMaxConcurrentLookups
condition|)
block|{
comment|// busy, defer unless there are no request in this thread
comment|// at least one active request per thread with queued requests is needed
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|iCurrentLookups
operator|.
name|count
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|iCurrentLookups
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|->
name|resultEmitter
operator|.
name|thread
argument_list|()
operator|==
name|QThread
operator|::
name|currentThread
argument_list|()
condition|)
block|{
name|defer
operator|=
literal|true
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|defer
condition|)
block|{
comment|// If no, schedule for later.
name|iScheduledLookups
operator|.
name|append
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QHOSTINFO_DEBUG
argument_list|)
name|qDebug
argument_list|(
literal|" - scheduled"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
else|else
block|{
comment|// If yes, add it to the current lookups.
name|iCurrentLookups
operator|.
name|append
argument_list|(
name|r
argument_list|)
expr_stmt|;
comment|// ... and trigger the async call.
name|r
operator|->
name|requestHostLookup
argument_list|()
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|abortLookup
name|void
name|QSymbianHostInfoLookupManager
operator|::
name|abortLookup
parameter_list|(
name|int
name|id
parameter_list|)
block|{
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|mutex
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|QHOSTINFO_DEBUG
argument_list|)
name|qDebug
argument_list|()
operator|<<
literal|"QSymbianHostInfoLookupManager::abortLookup"
operator|<<
name|QThread
operator|::
name|currentThreadId
argument_list|()
operator|<<
name|id
operator|<<
literal|"current"
operator|<<
name|iCurrentLookups
operator|.
name|count
argument_list|()
operator|<<
literal|"queued"
operator|<<
name|iScheduledLookups
operator|.
name|count
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|int
name|i
init|=
literal|0
decl_stmt|;
comment|// Find the aborted lookup by ID.
comment|// First in the current lookups.
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|iCurrentLookups
operator|.
name|count
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|id
operator|==
name|iCurrentLookups
index|[
name|i
index|]
operator|->
name|id
argument_list|()
condition|)
block|{
name|QSymbianHostResolver
modifier|*
name|r
init|=
name|iCurrentLookups
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|iCurrentLookups
operator|.
name|removeAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|r
operator|->
name|abortHostLookup
argument_list|()
expr_stmt|;
name|runNextLookup
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
comment|// Then in the scheduled lookups.
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|iScheduledLookups
operator|.
name|count
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|id
operator|==
name|iScheduledLookups
index|[
name|i
index|]
operator|->
name|id
argument_list|()
condition|)
block|{
name|QSymbianHostResolver
modifier|*
name|r
init|=
name|iScheduledLookups
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|iScheduledLookups
operator|.
name|removeAt
argument_list|(
name|i
argument_list|)
expr_stmt|;
operator|delete
name|r
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function
begin_function
DECL|function|globalInstance
name|QSymbianHostInfoLookupManager
modifier|*
name|QSymbianHostInfoLookupManager
operator|::
name|globalInstance
parameter_list|()
block|{
return|return
cast|static_cast
argument_list|<
name|QSymbianHostInfoLookupManager
operator|*
argument_list|>
argument_list|(
name|QAbstractHostInfoLookupManager
operator|::
name|globalInstance
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
