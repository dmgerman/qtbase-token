begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2016 The Qt Company Ltd. ** Copyright (C) 2016 Intel Corporation. ** Contact: https://www.qt.io/licensing/ ** ** This file is part of the QtNetwork module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and The Qt Company. For licensing terms ** and conditions see https://www.qt.io/terms-conditions. For further ** information use the contact form at https://www.qt.io/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 3 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL3 included in the ** packaging of this file. Please review the following information to ** ensure the GNU Lesser General Public License version 3 requirements ** will be met: https://www.gnu.org/licenses/lgpl-3.0.html. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 2.0 or (at your option) the GNU General ** Public license version 3 or any later version approved by the KDE Free ** Qt Foundation. The licenses are as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3 ** included in the packaging of this file. Please review the following ** information to ensure the GNU General Public License requirements will ** be met: https://www.gnu.org/licenses/gpl-2.0.html and ** https://www.gnu.org/licenses/gpl-3.0.html. ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qnetworkinterface.h"
end_include
begin_include
include|#
directive|include
file|"qnetworkinterface_p.h"
end_include
begin_include
include|#
directive|include
file|"qdebug.h"
end_include
begin_include
include|#
directive|include
file|"qendian.h"
end_include
begin_include
include|#
directive|include
file|"private/qtools_p.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_NETWORKINTERFACE
end_ifndef
begin_function
name|QT_BEGIN_NAMESPACE
DECL|function|postProcess
specifier|static
name|QList
argument_list|<
name|QNetworkInterfacePrivate
modifier|*
argument_list|>
name|postProcess
parameter_list|(
name|QList
argument_list|<
name|QNetworkInterfacePrivate
modifier|*
argument_list|>
name|list
parameter_list|)
block|{
comment|// Some platforms report a netmask but don't report a broadcast address
comment|// Go through all available addresses and calculate the broadcast address
comment|// from the IP and the netmask
comment|//
comment|// This is an IPv4-only thing -- IPv6 has no concept of broadcasts
comment|// The math is:
comment|//    broadcast = IP | ~netmask
name|QList
argument_list|<
name|QNetworkInterfacePrivate
modifier|*
argument_list|>
operator|::
name|Iterator
name|it
init|=
name|list
operator|.
name|begin
argument_list|()
decl_stmt|;
specifier|const
name|QList
argument_list|<
name|QNetworkInterfacePrivate
modifier|*
argument_list|>
operator|::
name|Iterator
name|end
init|=
name|list
operator|.
name|end
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|end
condition|;
operator|++
name|it
control|)
block|{
name|QList
argument_list|<
name|QNetworkAddressEntry
argument_list|>
operator|::
name|Iterator
name|addr_it
init|=
operator|(
operator|*
name|it
operator|)
operator|->
name|addressEntries
operator|.
name|begin
argument_list|()
decl_stmt|;
specifier|const
name|QList
argument_list|<
name|QNetworkAddressEntry
argument_list|>
operator|::
name|Iterator
name|addr_end
init|=
operator|(
operator|*
name|it
operator|)
operator|->
name|addressEntries
operator|.
name|end
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|addr_it
operator|!=
name|addr_end
condition|;
operator|++
name|addr_it
control|)
block|{
if|if
condition|(
name|addr_it
operator|->
name|ip
argument_list|()
operator|.
name|protocol
argument_list|()
operator|!=
name|QAbstractSocket
operator|::
name|IPv4Protocol
condition|)
continue|continue;
if|if
condition|(
operator|!
name|addr_it
operator|->
name|netmask
argument_list|()
operator|.
name|isNull
argument_list|()
operator|&&
name|addr_it
operator|->
name|broadcast
argument_list|()
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|QHostAddress
name|bcast
init|=
name|addr_it
operator|->
name|ip
argument_list|()
decl_stmt|;
name|bcast
operator|=
name|QHostAddress
argument_list|(
name|bcast
operator|.
name|toIPv4Address
argument_list|()
operator||
operator|~
name|addr_it
operator|->
name|netmask
argument_list|()
operator|.
name|toIPv4Address
argument_list|()
argument_list|)
expr_stmt|;
name|addr_it
operator|->
name|setBroadcast
argument_list|(
name|bcast
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|list
return|;
block|}
end_function
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|QNetworkInterfaceManager
argument_list|,
argument|manager
argument_list|)
end_macro
begin_constructor
DECL|function|QNetworkInterfaceManager
name|QNetworkInterfaceManager
operator|::
name|QNetworkInterfaceManager
parameter_list|()
block|{ }
end_constructor
begin_destructor
DECL|function|~QNetworkInterfaceManager
name|QNetworkInterfaceManager
operator|::
name|~
name|QNetworkInterfaceManager
parameter_list|()
block|{ }
end_destructor
begin_function
DECL|function|interfaceFromName
name|QSharedDataPointer
argument_list|<
name|QNetworkInterfacePrivate
argument_list|>
name|QNetworkInterfaceManager
operator|::
name|interfaceFromName
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
name|QList
argument_list|<
name|QSharedDataPointer
argument_list|<
name|QNetworkInterfacePrivate
argument_list|>
argument_list|>
name|interfaceList
init|=
name|allInterfaces
argument_list|()
decl_stmt|;
name|QList
argument_list|<
name|QSharedDataPointer
argument_list|<
name|QNetworkInterfacePrivate
argument_list|>
argument_list|>
operator|::
name|ConstIterator
name|it
init|=
name|interfaceList
operator|.
name|constBegin
argument_list|()
decl_stmt|;
name|bool
name|ok
decl_stmt|;
name|uint
name|index
init|=
name|name
operator|.
name|toUInt
argument_list|(
operator|&
name|ok
argument_list|)
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|interfaceList
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
if|if
condition|(
name|ok
operator|&&
operator|(
operator|*
name|it
operator|)
operator|->
name|index
operator|==
name|int
argument_list|(
name|index
argument_list|)
condition|)
return|return
operator|*
name|it
return|;
elseif|else
if|if
condition|(
operator|(
operator|*
name|it
operator|)
operator|->
name|name
operator|==
name|name
condition|)
return|return
operator|*
name|it
return|;
block|}
return|return
name|empty
return|;
block|}
end_function
begin_function
DECL|function|interfaceFromIndex
name|QSharedDataPointer
argument_list|<
name|QNetworkInterfacePrivate
argument_list|>
name|QNetworkInterfaceManager
operator|::
name|interfaceFromIndex
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|QList
argument_list|<
name|QSharedDataPointer
argument_list|<
name|QNetworkInterfacePrivate
argument_list|>
argument_list|>
name|interfaceList
init|=
name|allInterfaces
argument_list|()
decl_stmt|;
name|QList
argument_list|<
name|QSharedDataPointer
argument_list|<
name|QNetworkInterfacePrivate
argument_list|>
argument_list|>
operator|::
name|ConstIterator
name|it
init|=
name|interfaceList
operator|.
name|constBegin
argument_list|()
decl_stmt|;
for|for
control|(
init|;
name|it
operator|!=
name|interfaceList
operator|.
name|constEnd
argument_list|()
condition|;
operator|++
name|it
control|)
if|if
condition|(
operator|(
operator|*
name|it
operator|)
operator|->
name|index
operator|==
name|index
condition|)
return|return
operator|*
name|it
return|;
return|return
name|empty
return|;
block|}
end_function
begin_function
DECL|function|allInterfaces
name|QList
argument_list|<
name|QSharedDataPointer
argument_list|<
name|QNetworkInterfacePrivate
argument_list|>
argument_list|>
name|QNetworkInterfaceManager
operator|::
name|allInterfaces
parameter_list|()
block|{
specifier|const
name|QList
argument_list|<
name|QNetworkInterfacePrivate
modifier|*
argument_list|>
name|list
init|=
name|postProcess
argument_list|(
name|scan
argument_list|()
argument_list|)
decl_stmt|;
name|QList
argument_list|<
name|QSharedDataPointer
argument_list|<
name|QNetworkInterfacePrivate
argument_list|>
argument_list|>
name|result
decl_stmt|;
name|result
operator|.
name|reserve
argument_list|(
name|list
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|QNetworkInterfacePrivate
modifier|*
name|ptr
range|:
name|list
control|)
name|result
operator|<<
name|QSharedDataPointer
argument_list|<
name|QNetworkInterfacePrivate
argument_list|>
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_function
DECL|function|makeHwAddress
name|QString
name|QNetworkInterfacePrivate
operator|::
name|makeHwAddress
parameter_list|(
name|int
name|len
parameter_list|,
name|uchar
modifier|*
name|data
parameter_list|)
block|{
specifier|const
name|int
name|outLen
init|=
name|qMax
argument_list|(
name|len
operator|*
literal|2
operator|+
operator|(
name|len
operator|-
literal|1
operator|)
operator|*
literal|1
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|QString
name|result
argument_list|(
name|outLen
argument_list|,
name|Qt
operator|::
name|Uninitialized
argument_list|)
decl_stmt|;
name|QChar
modifier|*
name|out
init|=
name|result
operator|.
name|data
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
condition|)
operator|*
name|out
operator|++
operator|=
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
expr_stmt|;
operator|*
name|out
operator|++
operator|=
name|QLatin1Char
argument_list|(
name|QtMiscUtils
operator|::
name|toHexUpper
argument_list|(
name|data
index|[
name|i
index|]
operator|/
literal|16
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|out
operator|++
operator|=
name|QLatin1Char
argument_list|(
name|QtMiscUtils
operator|::
name|toHexUpper
argument_list|(
name|data
index|[
name|i
index|]
operator|%
literal|16
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!     \class QNetworkAddressEntry     \brief The QNetworkAddressEntry class stores one IP address     supported by a network interface, along with its associated     netmask and broadcast address.      \since 4.2     \reentrant     \ingroup network     \ingroup shared     \inmodule QtNetwork      Each network interface can contain zero or more IP addresses, which     in turn can be associated with a netmask and/or a broadcast     address (depending on support from the operating system).      This class represents one such group. */
end_comment
begin_comment
comment|/*!     Constructs an empty QNetworkAddressEntry object. */
end_comment
begin_constructor
DECL|function|QNetworkAddressEntry
name|QNetworkAddressEntry
operator|::
name|QNetworkAddressEntry
parameter_list|()
member_init_list|:
name|d
argument_list|(
operator|new
name|QNetworkAddressEntryPrivate
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Constructs a QNetworkAddressEntry object that is a copy of the     object \a other. */
end_comment
begin_constructor
DECL|function|QNetworkAddressEntry
name|QNetworkAddressEntry
operator|::
name|QNetworkAddressEntry
parameter_list|(
specifier|const
name|QNetworkAddressEntry
modifier|&
name|other
parameter_list|)
member_init_list|:
name|d
argument_list|(
operator|new
name|QNetworkAddressEntryPrivate
argument_list|(
operator|*
name|other
operator|.
name|d
operator|.
name|data
argument_list|()
argument_list|)
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Makes a copy of the QNetworkAddressEntry object \a other. */
end_comment
begin_function
DECL|function|operator =
name|QNetworkAddressEntry
modifier|&
name|QNetworkAddressEntry
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QNetworkAddressEntry
modifier|&
name|other
parameter_list|)
block|{
operator|*
name|d
operator|.
name|data
argument_list|()
operator|=
operator|*
name|other
operator|.
name|d
operator|.
name|data
argument_list|()
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QNetworkAddressEntry::swap(QNetworkAddressEntry&other)     \since 5.0      Swaps this network address entry instance with \a other. This     function is very fast and never fails. */
end_comment
begin_comment
comment|/*!     Destroys this QNetworkAddressEntry object. */
end_comment
begin_destructor
DECL|function|~QNetworkAddressEntry
name|QNetworkAddressEntry
operator|::
name|~
name|QNetworkAddressEntry
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     Returns \c true if this network address entry is the same as \a     other. */
end_comment
begin_function
DECL|function|operator ==
name|bool
name|QNetworkAddressEntry
operator|::
name|operator
name|==
parameter_list|(
specifier|const
name|QNetworkAddressEntry
modifier|&
name|other
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|d
operator|==
name|other
operator|.
name|d
condition|)
return|return
literal|true
return|;
if|if
condition|(
operator|!
name|d
operator|||
operator|!
name|other
operator|.
name|d
condition|)
return|return
literal|false
return|;
return|return
name|d
operator|->
name|address
operator|==
name|other
operator|.
name|d
operator|->
name|address
operator|&&
name|d
operator|->
name|netmask
operator|==
name|other
operator|.
name|d
operator|->
name|netmask
operator|&&
name|d
operator|->
name|broadcast
operator|==
name|other
operator|.
name|d
operator|->
name|broadcast
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QNetworkAddressEntry::operator!=(const QNetworkAddressEntry&other) const      Returns \c true if this network address entry is different from \a     other. */
end_comment
begin_comment
comment|/*!     This function returns one IPv4 or IPv6 address found, that was     found in a network interface. */
end_comment
begin_function
DECL|function|ip
name|QHostAddress
name|QNetworkAddressEntry
operator|::
name|ip
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|address
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the IP address the QNetworkAddressEntry object contains to \a     newIp. */
end_comment
begin_function
DECL|function|setIp
name|void
name|QNetworkAddressEntry
operator|::
name|setIp
parameter_list|(
specifier|const
name|QHostAddress
modifier|&
name|newIp
parameter_list|)
block|{
name|d
operator|->
name|address
operator|=
name|newIp
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the netmask associated with the IP address. The     netmask is expressed in the form of an IP address, such as     255.255.0.0.      For IPv6 addresses, the prefix length is converted to an address     where the number of bits set to 1 is equal to the prefix     length. For a prefix length of 64 bits (the most common value),     the netmask will be expressed as a QHostAddress holding the     address FFFF:FFFF:FFFF:FFFF::      \sa prefixLength() */
end_comment
begin_function
DECL|function|netmask
name|QHostAddress
name|QNetworkAddressEntry
operator|::
name|netmask
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|netmask
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the netmask that this QNetworkAddressEntry object contains to     \a newNetmask. Setting the netmask also sets the prefix length to     match the new netmask.      \sa setPrefixLength() */
end_comment
begin_function
DECL|function|setNetmask
name|void
name|QNetworkAddressEntry
operator|::
name|setNetmask
parameter_list|(
specifier|const
name|QHostAddress
modifier|&
name|newNetmask
parameter_list|)
block|{
if|if
condition|(
name|newNetmask
operator|.
name|protocol
argument_list|()
operator|!=
name|ip
argument_list|()
operator|.
name|protocol
argument_list|()
condition|)
block|{
name|d
operator|->
name|netmask
operator|=
name|QNetmaskAddress
argument_list|()
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|netmask
operator|.
name|setAddress
argument_list|(
name|newNetmask
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5     Returns the prefix length of this IP address. The prefix length     matches the number of bits set to 1 in the netmask (see     netmask()). For IPv4 addresses, the value is between 0 and 32. For     IPv6 addresses, it's contained between 0 and 128 and is the     preferred form of representing addresses.      This function returns -1 if the prefix length could not be     determined (i.e., netmask() returns a null QHostAddress()).      \sa netmask() */
end_comment
begin_function
DECL|function|prefixLength
name|int
name|QNetworkAddressEntry
operator|::
name|prefixLength
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|netmask
operator|.
name|prefixLength
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5     Sets the prefix length of this IP address to \a length. The value     of \a length must be valid for this type of IP address: between 0     and 32 for IPv4 addresses, between 0 and 128 for IPv6     addresses. Setting to any invalid value is equivalent to setting     to -1, which means "no prefix length".      Setting the prefix length also sets the netmask (see netmask()).      \sa setNetmask() */
end_comment
begin_function
DECL|function|setPrefixLength
name|void
name|QNetworkAddressEntry
operator|::
name|setPrefixLength
parameter_list|(
name|int
name|length
parameter_list|)
block|{
name|d
operator|->
name|netmask
operator|.
name|setPrefixLength
argument_list|(
name|d
operator|->
name|address
operator|.
name|protocol
argument_list|()
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the broadcast address associated with the IPv4     address and netmask. It can usually be derived from those two by     setting to 1 the bits of the IP address where the netmask contains     a 0. (In other words, by bitwise-OR'ing the IP address with the     inverse of the netmask)      This member is always empty for IPv6 addresses, since the concept     of broadcast has been abandoned in that system in favor of     multicast. In particular, the group of hosts corresponding to all     the nodes in the local network can be reached by the "all-nodes"     special multicast group (address FF02::1). */
end_comment
begin_function
DECL|function|broadcast
name|QHostAddress
name|QNetworkAddressEntry
operator|::
name|broadcast
parameter_list|()
specifier|const
block|{
return|return
name|d
operator|->
name|broadcast
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the broadcast IP address of this QNetworkAddressEntry object     to \a newBroadcast. */
end_comment
begin_function
DECL|function|setBroadcast
name|void
name|QNetworkAddressEntry
operator|::
name|setBroadcast
parameter_list|(
specifier|const
name|QHostAddress
modifier|&
name|newBroadcast
parameter_list|)
block|{
name|d
operator|->
name|broadcast
operator|=
name|newBroadcast
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \class QNetworkInterface     \brief The QNetworkInterface class provides a listing of the host's IP     addresses and network interfaces.      \since 4.2     \reentrant     \ingroup network     \ingroup shared     \inmodule QtNetwork      QNetworkInterface represents one network interface attached to the     host where the program is being run. Each network interface may     contain zero or more IP addresses, each of which is optionally     associated with a netmask and/or a broadcast address. The list of     such trios can be obtained with addressEntries(). Alternatively,     when the netmask or the broadcast addresses aren't necessary, use     the allAddresses() convenience function to obtain just the IP     addresses.      QNetworkInterface also reports the interface's hardware address with     hardwareAddress().      Not all operating systems support reporting all features. Only the     IPv4 addresses are guaranteed to be listed by this class in all     platforms. In particular, IPv6 address listing is only supported     on Windows, Linux, OS X and the BSDs.      \sa QNetworkAddressEntry */
end_comment
begin_comment
comment|/*!     \enum QNetworkInterface::InterfaceFlag     Specifies the flags associated with this network interface. The     possible values are:      \value IsUp                 the network interface is active     \value IsRunning            the network interface has resources                                 allocated     \value CanBroadcast         the network interface works in                                 broadcast mode     \value IsLoopBack           the network interface is a loopback                                 interface: that is, it's a virtual                                 interface whose destination is the                                 host computer itself     \value IsPointToPoint       the network interface is a                                 point-to-point interface: that is,                                 there is one, single other address                                 that can be directly reached by it.     \value CanMulticast         the network interface supports                                 multicasting      Note that one network interface cannot be both broadcast-based and     point-to-point. */
end_comment
begin_comment
comment|/*!     Constructs an empty network interface object. */
end_comment
begin_constructor
DECL|function|QNetworkInterface
name|QNetworkInterface
operator|::
name|QNetworkInterface
parameter_list|()
member_init_list|:
name|d
argument_list|(
literal|0
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Frees the resources associated with the QNetworkInterface object. */
end_comment
begin_destructor
DECL|function|~QNetworkInterface
name|QNetworkInterface
operator|::
name|~
name|QNetworkInterface
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     Creates a copy of the QNetworkInterface object contained in \a     other. */
end_comment
begin_constructor
DECL|function|QNetworkInterface
name|QNetworkInterface
operator|::
name|QNetworkInterface
parameter_list|(
specifier|const
name|QNetworkInterface
modifier|&
name|other
parameter_list|)
member_init_list|:
name|d
argument_list|(
name|other
operator|.
name|d
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Copies the contents of the QNetworkInterface object contained in \a     other into this one. */
end_comment
begin_function
DECL|function|operator =
name|QNetworkInterface
modifier|&
name|QNetworkInterface
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QNetworkInterface
modifier|&
name|other
parameter_list|)
block|{
name|d
operator|=
name|other
operator|.
name|d
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QNetworkInterface::swap(QNetworkInterface&other)     \since 5.0      Swaps this network interface instance with \a other. This function     is very fast and never fails. */
end_comment
begin_comment
comment|/*!     Returns \c true if this QNetworkInterface object contains valid     information about a network interface. */
end_comment
begin_function
DECL|function|isValid
name|bool
name|QNetworkInterface
operator|::
name|isValid
parameter_list|()
specifier|const
block|{
return|return
operator|!
name|name
argument_list|()
operator|.
name|isEmpty
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5     Returns the interface system index, if known. This is an integer     assigned by the operating system to identify this interface and it     generally doesn't change. It matches the scope ID field in IPv6     addresses.      If the index isn't known, this function returns 0. */
end_comment
begin_function
DECL|function|index
name|int
name|QNetworkInterface
operator|::
name|index
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|d
operator|->
name|index
else|:
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the name of this network interface. On Unix systems, this     is a string containing the type of the interface and optionally a     sequence number, such as "eth0", "lo" or "pcn0". On Windows, it's     an internal ID that cannot be changed by the user. */
end_comment
begin_function
DECL|function|name
name|QString
name|QNetworkInterface
operator|::
name|name
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|d
operator|->
name|name
else|:
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5      Returns the human-readable name of this network interface on     Windows, such as "Local Area Connection", if the name could be     determined. If it couldn't, this function returns the same as     name(). The human-readable name is a name that the user can modify     in the Windows Control Panel, so it may change during the     execution of the program.      On Unix, this function currently always returns the same as     name(), since Unix systems don't store a configuration for     human-readable names. */
end_comment
begin_function
DECL|function|humanReadableName
name|QString
name|QNetworkInterface
operator|::
name|humanReadableName
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
operator|!
name|d
operator|->
name|friendlyName
operator|.
name|isEmpty
argument_list|()
condition|?
name|d
operator|->
name|friendlyName
else|:
name|name
argument_list|()
else|:
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the flags associated with this network interface. */
end_comment
begin_function
DECL|function|flags
name|QNetworkInterface
operator|::
name|InterfaceFlags
name|QNetworkInterface
operator|::
name|flags
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|d
operator|->
name|flags
else|:
name|InterfaceFlags
argument_list|(
literal|0
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the low-level hardware address for this interface. On     Ethernet interfaces, this will be a MAC address in string     representation, separated by colons.      Other interface types may have other types of hardware     addresses. Implementations should not depend on this function     returning a valid MAC address. */
end_comment
begin_function
DECL|function|hardwareAddress
name|QString
name|QNetworkInterface
operator|::
name|hardwareAddress
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|d
operator|->
name|hardwareAddress
else|:
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the list of IP addresses that this interface possesses     along with their associated netmasks and broadcast addresses.      If the netmask or broadcast address information is not necessary,     you can call the allAddresses() function to obtain just the IP     addresses. */
end_comment
begin_function
DECL|function|addressEntries
name|QList
argument_list|<
name|QNetworkAddressEntry
argument_list|>
name|QNetworkInterface
operator|::
name|addressEntries
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|d
operator|->
name|addressEntries
else|:
name|QList
argument_list|<
name|QNetworkAddressEntry
argument_list|>
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 5.7      Returns the index of the interface whose name is \a name or 0 if there is     no interface with that name. This function should produce the same result     as the following code, but will probably execute faster.      \code         QNetworkInterface::interfaceFromName(name).index()     \endcode      \sa interfaceFromName(), interfaceNameFromIndex() */
end_comment
begin_function
DECL|function|interfaceIndexFromName
name|int
name|QNetworkInterface
operator|::
name|interfaceIndexFromName
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
if|if
condition|(
name|name
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|0
return|;
name|bool
name|ok
decl_stmt|;
name|uint
name|id
init|=
name|name
operator|.
name|toUInt
argument_list|(
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
name|id
operator|=
name|QNetworkInterfaceManager
operator|::
name|interfaceIndexFromName
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|int
argument_list|(
name|id
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a QNetworkInterface object for the interface named \a     name. If no such interface exists, this function returns an     invalid QNetworkInterface object.      The string \a name may be either an actual interface name (such as "eth0"     or "en1") or an interface index in string form ("1", "2", etc.).      \sa name(), isValid() */
end_comment
begin_function
DECL|function|interfaceFromName
name|QNetworkInterface
name|QNetworkInterface
operator|::
name|interfaceFromName
parameter_list|(
specifier|const
name|QString
modifier|&
name|name
parameter_list|)
block|{
name|QNetworkInterface
name|result
decl_stmt|;
name|result
operator|.
name|d
operator|=
name|manager
argument_list|()
operator|->
name|interfaceFromName
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a QNetworkInterface object for the interface whose internal     ID is \a index. Network interfaces have a unique identifier called     the "interface index" to distinguish it from other interfaces on     the system. Often, this value is assigned progressively and     interfaces being removed and then added again get a different     value every time.      This index is also found in the IPv6 address' scope ID field. */
end_comment
begin_function
DECL|function|interfaceFromIndex
name|QNetworkInterface
name|QNetworkInterface
operator|::
name|interfaceFromIndex
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|QNetworkInterface
name|result
decl_stmt|;
name|result
operator|.
name|d
operator|=
name|manager
argument_list|()
operator|->
name|interfaceFromIndex
argument_list|(
name|index
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!     \since 5.7      Returns the name of the interface whose index is \a index or an empty     string if there is no interface with that index. This function should     produce the same result as the following code, but will probably execute     faster.      \code         QNetworkInterface::interfaceFromIndex(index).name()     \endcode      \sa interfaceFromIndex(), interfaceIndexFromName() */
end_comment
begin_function
DECL|function|interfaceNameFromIndex
name|QString
name|QNetworkInterface
operator|::
name|interfaceNameFromIndex
parameter_list|(
name|int
name|index
parameter_list|)
block|{
if|if
condition|(
operator|!
name|index
condition|)
return|return
name|QString
argument_list|()
return|;
return|return
name|QNetworkInterfaceManager
operator|::
name|interfaceNameFromIndex
argument_list|(
name|index
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns a listing of all the network interfaces found on the host     machine.  In case of failure it returns a list with zero elements. */
end_comment
begin_function
DECL|function|allInterfaces
name|QList
argument_list|<
name|QNetworkInterface
argument_list|>
name|QNetworkInterface
operator|::
name|allInterfaces
parameter_list|()
block|{
specifier|const
name|QList
argument_list|<
name|QSharedDataPointer
argument_list|<
name|QNetworkInterfacePrivate
argument_list|>
argument_list|>
name|privs
init|=
name|manager
argument_list|()
operator|->
name|allInterfaces
argument_list|()
decl_stmt|;
name|QList
argument_list|<
name|QNetworkInterface
argument_list|>
name|result
decl_stmt|;
name|result
operator|.
name|reserve
argument_list|(
name|privs
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
specifier|const
specifier|auto
modifier|&
name|p
range|:
name|privs
control|)
block|{
name|QNetworkInterface
name|item
decl_stmt|;
name|item
operator|.
name|d
operator|=
name|p
expr_stmt|;
name|result
operator|<<
name|item
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|/*!     This convenience function returns all IP addresses found on the     host machine. It is equivalent to calling addressEntries() on all the     objects returned by allInterfaces() to obtain lists of QHostAddress     objects then calling QHostAddress::ip() on each of these. */
end_comment
begin_function
DECL|function|allAddresses
name|QList
argument_list|<
name|QHostAddress
argument_list|>
name|QNetworkInterface
operator|::
name|allAddresses
parameter_list|()
block|{
specifier|const
name|QList
argument_list|<
name|QSharedDataPointer
argument_list|<
name|QNetworkInterfacePrivate
argument_list|>
argument_list|>
name|privs
init|=
name|manager
argument_list|()
operator|->
name|allInterfaces
argument_list|()
decl_stmt|;
name|QList
argument_list|<
name|QHostAddress
argument_list|>
name|result
decl_stmt|;
for|for
control|(
specifier|const
specifier|auto
modifier|&
name|p
range|:
name|privs
control|)
block|{
for|for
control|(
specifier|const
name|QNetworkAddressEntry
modifier|&
name|entry
range|:
name|qAsConst
argument_list|(
name|p
operator|->
name|addressEntries
argument_list|)
control|)
name|result
operator|+=
name|entry
operator|.
name|ip
argument_list|()
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DEBUG_STREAM
end_ifndef
begin_function
DECL|function|flagsDebug
specifier|static
specifier|inline
name|QDebug
name|flagsDebug
parameter_list|(
name|QDebug
name|debug
parameter_list|,
name|QNetworkInterface
operator|::
name|InterfaceFlags
name|flags
parameter_list|)
block|{
if|if
condition|(
name|flags
operator|&
name|QNetworkInterface
operator|::
name|IsUp
condition|)
name|debug
operator|<<
literal|"IsUp "
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|QNetworkInterface
operator|::
name|IsRunning
condition|)
name|debug
operator|<<
literal|"IsRunning "
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|QNetworkInterface
operator|::
name|CanBroadcast
condition|)
name|debug
operator|<<
literal|"CanBroadcast "
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|QNetworkInterface
operator|::
name|IsLoopBack
condition|)
name|debug
operator|<<
literal|"IsLoopBack "
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|QNetworkInterface
operator|::
name|IsPointToPoint
condition|)
name|debug
operator|<<
literal|"IsPointToPoint "
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|QNetworkInterface
operator|::
name|CanMulticast
condition|)
name|debug
operator|<<
literal|"CanMulticast "
expr_stmt|;
return|return
name|debug
return|;
block|}
end_function
begin_function
DECL|function|operator <<
specifier|static
specifier|inline
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|debug
parameter_list|,
specifier|const
name|QNetworkAddressEntry
modifier|&
name|entry
parameter_list|)
block|{
name|debug
operator|<<
literal|"(address = "
operator|<<
name|entry
operator|.
name|ip
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|entry
operator|.
name|netmask
argument_list|()
operator|.
name|isNull
argument_list|()
condition|)
name|debug
operator|<<
literal|", netmask = "
operator|<<
name|entry
operator|.
name|netmask
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|entry
operator|.
name|broadcast
argument_list|()
operator|.
name|isNull
argument_list|()
condition|)
name|debug
operator|<<
literal|", broadcast = "
operator|<<
name|entry
operator|.
name|broadcast
argument_list|()
expr_stmt|;
name|debug
operator|<<
literal|')'
expr_stmt|;
return|return
name|debug
return|;
block|}
end_function
begin_function
DECL|function|operator <<
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|debug
parameter_list|,
specifier|const
name|QNetworkInterface
modifier|&
name|networkInterface
parameter_list|)
block|{
name|QDebugStateSaver
name|saver
argument_list|(
name|debug
argument_list|)
decl_stmt|;
name|debug
operator|.
name|resetFormat
argument_list|()
operator|.
name|nospace
argument_list|()
expr_stmt|;
name|debug
operator|<<
literal|"QNetworkInterface(name = "
operator|<<
name|networkInterface
operator|.
name|name
argument_list|()
operator|<<
literal|", hardware address = "
operator|<<
name|networkInterface
operator|.
name|hardwareAddress
argument_list|()
operator|<<
literal|", flags = "
expr_stmt|;
name|flagsDebug
argument_list|(
name|debug
argument_list|,
name|networkInterface
operator|.
name|flags
argument_list|()
argument_list|)
expr_stmt|;
name|debug
operator|<<
literal|", entries = "
operator|<<
name|networkInterface
operator|.
name|addressEntries
argument_list|()
operator|<<
literal|")\n"
expr_stmt|;
return|return
name|debug
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_NETWORKINTERFACE
end_comment
end_unit
