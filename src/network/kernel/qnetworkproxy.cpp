begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtNetwork module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_comment
comment|/*!     \class QNetworkProxy      \since 4.1      \brief The QNetworkProxy class provides a network layer proxy.      \reentrant     \ingroup network     \ingroup shared     \inmodule QtNetwork      QNetworkProxy provides the method for configuring network layer     proxy support to the Qt network classes. The currently supported     classes are QAbstractSocket, QTcpSocket, QUdpSocket, QTcpServer     and QNetworkAccessManager. The proxy support is designed to     be as transparent as possible. This means that existing     network-enabled applications that you have written should     automatically support network proxy using the following code.      \snippet code/src_network_kernel_qnetworkproxy.cpp 0      An alternative to setting an application wide proxy is to specify     the proxy for individual sockets using QAbstractSocket::setProxy()     and QTcpServer::setProxy(). In this way, it is possible to disable     the use of a proxy for specific sockets using the following code:      \snippet code/src_network_kernel_qnetworkproxy.cpp 1      Network proxy is not used if the address used in \l     {QAbstractSocket::connectToHost()}{connectToHost()}, \l     {QUdpSocket::bind()}{bind()} or \l     {QTcpServer::listen()}{listen()} is equivalent to     QHostAddress::LocalHost or QHostAddress::LocalHostIPv6.      Each type of proxy support has certain restrictions associated with it.     You should read the \l{ProxyType} documentation carefully before     selecting a proxy type to use.      \note Changes made to currently connected sockets do not take effect.     If you need to change a connected socket, you should reconnect it.      \section1 SOCKS5      The SOCKS5 support in Qt 4 is based on \l{http://www.rfc-editor.org/rfc/rfc1928.txt}{RFC 1928} and \l{http://www.rfc-editor.org/rfc/rfc1929.txt}{RFC 1929}.     The supported authentication methods are no authentication and     username/password authentication.  Both IPv4 and IPv6 are     supported. Domain names are resolved through the SOCKS5 server if     the QNetworkProxy::HostNameLookupCapability is enabled, otherwise     they are resolved locally and the IP address is sent to the     server. There are several things to remember when using SOCKS5     with QUdpSocket and QTcpServer:      With QUdpSocket, a call to \l {QUdpSocket::bind()}{bind()} may fail     with a timeout error. If a port number other than 0 is passed to     \l {QUdpSocket::bind()}{bind()}, it is not guaranteed that it is the     specified port that will be used.     Use \l{QUdpSocket::localPort()}{localPort()} and     \l{QUdpSocket::localAddress()}{localAddress()} to get the actual     address and port number in use. Because proxied UDP goes through     two UDP connections, it is more likely that packets will be dropped.      With QTcpServer a call to \l{QTcpServer::listen()}{listen()} may     fail with a timeout error. If a port number other than 0 is passed     to \l{QTcpServer::listen()}{listen()}, then it is not guaranteed     that it is the specified port that will be used.     Use \l{QTcpServer::serverPort()}{serverPort()} and     \l{QTcpServer::serverAddress()}{serverAddress()} to get the actual     address and port used to listen for connections. SOCKS5 only supports     one accepted connection per call to \l{QTcpServer::listen()}{listen()},     and each call is likely to result in a different     \l{QTcpServer::serverPort()}{serverPort()} being used.      \sa QAbstractSocket, QTcpServer */
end_comment
begin_comment
comment|/*!     \enum QNetworkProxy::ProxyType      This enum describes the types of network proxying provided in Qt.      There are two types of proxies that Qt understands:     transparent proxies and caching proxies. The first group consists     of proxies that can handle any arbitrary data transfer, while the     second can only handle specific requests. The caching proxies only     make sense for the specific classes where they can be used.      \value NoProxy No proxying is used     \value DefaultProxy Proxy is determined based on the application proxy set using setApplicationProxy()     \value Socks5Proxy \l Socks5 proxying is used     \value HttpProxy HTTP transparent proxying is used     \value HttpCachingProxy Proxying for HTTP requests only     \value FtpCachingProxy Proxying for FTP requests only      The table below lists different proxy types and their     capabilities. Since each proxy type has different capabilities, it     is important to understand them before choosing a proxy type.      \table     \header         \li Proxy type         \li Description         \li Default capabilities      \row         \li SOCKS 5         \li Generic proxy for any kind of connection. Supports TCP,            UDP, binding to a port (incoming connections) and            authentication.         \li TunnelingCapability, ListeningCapability,            UdpTunnelingCapability, HostNameLookupCapability      \row         \li HTTP         \li Implemented using the "CONNECT" command, supports only            outgoing TCP connections; supports authentication.         \li TunnelingCapability, CachingCapability, HostNameLookupCapability      \row         \li Caching-only HTTP         \li Implemented using normal HTTP commands, it is useful only            in the context of HTTP requests (see QNetworkAccessManager)         \li CachingCapability, HostNameLookupCapability      \row         \li Caching FTP         \li Implemented using an FTP proxy, it is useful only in the            context of FTP requests (see QNetworkAccessManager)         \li CachingCapability, HostNameLookupCapability      \endtable      Also note that you shouldn't set the application default proxy     (setApplicationProxy()) to a proxy that doesn't have the     TunnelingCapability capability. If you do, QTcpSocket will not     know how to open connections.      \sa setType(), type(), capabilities(), setCapabilities() */
end_comment
begin_comment
comment|/*!     \enum QNetworkProxy::Capability     \since 4.5      These flags indicate the capabilities that a given proxy server     supports.      QNetworkProxy sets different capabilities by default when the     object is created (see QNetworkProxy::ProxyType for a list of the     defaults). However, it is possible to change the capabitilies     after the object has been created with setCapabilities().      The capabilities that QNetworkProxy supports are:      \value TunnelingCapability Ability to open transparent, tunneled     TCP connections to a remote host. The proxy server relays the     transmission verbatim from one side to the other and does no     caching.      \value ListeningCapability Ability to create a listening socket     and wait for an incoming TCP connection from a remote host.      \value UdpTunnelingCapability Ability to relay UDP datagrams via     the proxy server to and from a remote host.      \value CachingCapability Ability to cache the contents of the     transfer. This capability is specific to each protocol and proxy     type. For example, HTTP proxies can cache the contents of web data     transferred with "GET" commands.      \value HostNameLookupCapability Ability to connect to perform the     lookup on a remote host name and connect to it, as opposed to     requiring the application to perform the name lookup and request     connection to IP addresses only. */
end_comment
begin_include
include|#
directive|include
file|"qnetworkproxy.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_NETWORKPROXY
end_ifndef
begin_include
include|#
directive|include
file|"private/qnetworkproxy_p.h"
end_include
begin_include
include|#
directive|include
file|"private/qnetworkrequest_p.h"
end_include
begin_include
include|#
directive|include
file|"private/qsocks5socketengine_p.h"
end_include
begin_include
include|#
directive|include
file|"private/qhttpsocketengine_p.h"
end_include
begin_include
include|#
directive|include
file|"qauthenticator.h"
end_include
begin_include
include|#
directive|include
file|"qdebug.h"
end_include
begin_include
include|#
directive|include
file|"qhash.h"
end_include
begin_include
include|#
directive|include
file|"qmutex.h"
end_include
begin_include
include|#
directive|include
file|"qstringlist.h"
end_include
begin_include
include|#
directive|include
file|"qurl.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_BEARERMANAGEMENT
end_ifndef
begin_include
include|#
directive|include
file|<QtNetwork/QNetworkConfiguration>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_class_decl
class_decl|class
name|QSocks5SocketEngineHandler
class_decl|;
end_class_decl
begin_class_decl
class_decl|class
name|QHttpSocketEngineHandler
class_decl|;
end_class_decl
begin_class
DECL|class|QGlobalNetworkProxy
class|class
name|QGlobalNetworkProxy
block|{
public|public:
DECL|function|QGlobalNetworkProxy
name|QGlobalNetworkProxy
parameter_list|()
member_init_list|:
name|mutex
argument_list|(
name|QMutex
operator|::
name|Recursive
argument_list|)
member_init_list|,
name|applicationLevelProxy
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|applicationLevelProxyFactory
argument_list|(
literal|0
argument_list|)
ifndef|#
directive|ifndef
name|QT_NO_SOCKS5
member_init_list|,
name|socks5SocketEngineHandler
argument_list|(
literal|0
argument_list|)
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_HTTP
member_init_list|,
name|httpSocketEngineHandler
argument_list|(
literal|0
argument_list|)
endif|#
directive|endif
block|{
ifdef|#
directive|ifdef
name|QT_USE_SYSTEM_PROXIES
name|setApplicationProxyFactory
argument_list|(
operator|new
name|QSystemConfigurationProxyFactory
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_SOCKS5
name|socks5SocketEngineHandler
operator|=
operator|new
name|QSocks5SocketEngineHandler
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_HTTP
name|httpSocketEngineHandler
operator|=
operator|new
name|QHttpSocketEngineHandler
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
DECL|function|~QGlobalNetworkProxy
name|~
name|QGlobalNetworkProxy
parameter_list|()
block|{
operator|delete
name|applicationLevelProxy
expr_stmt|;
operator|delete
name|applicationLevelProxyFactory
expr_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_SOCKS5
operator|delete
name|socks5SocketEngineHandler
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_HTTP
operator|delete
name|httpSocketEngineHandler
expr_stmt|;
endif|#
directive|endif
block|}
DECL|function|setApplicationProxy
name|void
name|setApplicationProxy
parameter_list|(
specifier|const
name|QNetworkProxy
modifier|&
name|proxy
parameter_list|)
block|{
name|QMutexLocker
name|lock
argument_list|(
operator|&
name|mutex
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|applicationLevelProxy
condition|)
name|applicationLevelProxy
operator|=
operator|new
name|QNetworkProxy
expr_stmt|;
operator|*
name|applicationLevelProxy
operator|=
name|proxy
expr_stmt|;
operator|delete
name|applicationLevelProxyFactory
expr_stmt|;
name|applicationLevelProxyFactory
operator|=
literal|0
expr_stmt|;
block|}
DECL|function|setApplicationProxyFactory
name|void
name|setApplicationProxyFactory
parameter_list|(
name|QNetworkProxyFactory
modifier|*
name|factory
parameter_list|)
block|{
name|QMutexLocker
name|lock
argument_list|(
operator|&
name|mutex
argument_list|)
decl_stmt|;
if|if
condition|(
name|factory
operator|==
name|applicationLevelProxyFactory
condition|)
return|return;
if|if
condition|(
name|applicationLevelProxy
condition|)
operator|*
name|applicationLevelProxy
operator|=
name|QNetworkProxy
argument_list|()
expr_stmt|;
operator|delete
name|applicationLevelProxyFactory
expr_stmt|;
name|applicationLevelProxyFactory
operator|=
name|factory
expr_stmt|;
block|}
DECL|function|applicationProxy
name|QNetworkProxy
name|applicationProxy
parameter_list|()
block|{
return|return
name|proxyForQuery
argument_list|(
name|QNetworkProxyQuery
argument_list|()
argument_list|)
operator|.
name|first
argument_list|()
return|;
block|}
name|QList
argument_list|<
name|QNetworkProxy
argument_list|>
name|proxyForQuery
parameter_list|(
specifier|const
name|QNetworkProxyQuery
modifier|&
name|query
parameter_list|)
function_decl|;
private|private:
DECL|member|mutex
name|QMutex
name|mutex
decl_stmt|;
DECL|member|applicationLevelProxy
name|QNetworkProxy
modifier|*
name|applicationLevelProxy
decl_stmt|;
DECL|member|applicationLevelProxyFactory
name|QNetworkProxyFactory
modifier|*
name|applicationLevelProxyFactory
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_SOCKS5
DECL|member|socks5SocketEngineHandler
name|QSocks5SocketEngineHandler
modifier|*
name|socks5SocketEngineHandler
decl_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|QT_NO_HTTP
DECL|member|httpSocketEngineHandler
name|QHttpSocketEngineHandler
modifier|*
name|httpSocketEngineHandler
decl_stmt|;
endif|#
directive|endif
block|}
class|;
end_class
begin_function
DECL|function|proxyForQuery
name|QList
argument_list|<
name|QNetworkProxy
argument_list|>
name|QGlobalNetworkProxy
operator|::
name|proxyForQuery
parameter_list|(
specifier|const
name|QNetworkProxyQuery
modifier|&
name|query
parameter_list|)
block|{
name|QMutexLocker
name|locker
argument_list|(
operator|&
name|mutex
argument_list|)
decl_stmt|;
name|QList
argument_list|<
name|QNetworkProxy
argument_list|>
name|result
decl_stmt|;
comment|// don't look for proxies for a local connection
name|QHostAddress
name|parsed
decl_stmt|;
name|QString
name|hostname
init|=
name|query
operator|.
name|url
argument_list|()
operator|.
name|host
argument_list|()
decl_stmt|;
if|if
condition|(
name|hostname
operator|==
name|QLatin1String
argument_list|(
literal|"localhost"
argument_list|)
operator|||
name|hostname
operator|.
name|startsWith
argument_list|(
name|QLatin1String
argument_list|(
literal|"localhost."
argument_list|)
argument_list|)
operator|||
operator|(
name|parsed
operator|.
name|setAddress
argument_list|(
name|hostname
argument_list|)
operator|&&
operator|(
name|parsed
operator|.
name|isLoopback
argument_list|()
operator|)
operator|)
condition|)
block|{
name|result
operator|<<
name|QNetworkProxy
argument_list|(
name|QNetworkProxy
operator|::
name|NoProxy
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
if|if
condition|(
operator|!
name|applicationLevelProxyFactory
condition|)
block|{
if|if
condition|(
name|applicationLevelProxy
operator|&&
name|applicationLevelProxy
operator|->
name|type
argument_list|()
operator|!=
name|QNetworkProxy
operator|::
name|DefaultProxy
condition|)
name|result
operator|<<
operator|*
name|applicationLevelProxy
expr_stmt|;
else|else
name|result
operator|<<
name|QNetworkProxy
argument_list|(
name|QNetworkProxy
operator|::
name|NoProxy
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
comment|// we have a factory
name|result
operator|=
name|applicationLevelProxyFactory
operator|->
name|queryProxy
argument_list|(
name|query
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|qWarning
argument_list|(
literal|"QNetworkProxyFactory: factory %p has returned an empty result set"
argument_list|,
name|applicationLevelProxyFactory
argument_list|)
expr_stmt|;
name|result
operator|<<
name|QNetworkProxy
argument_list|(
name|QNetworkProxy
operator|::
name|NoProxy
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function
begin_macro
name|Q_GLOBAL_STATIC
argument_list|(
argument|QGlobalNetworkProxy
argument_list|,
argument|globalNetworkProxy
argument_list|)
end_macro
begin_namespace
namespace|namespace
block|{
template|template
parameter_list|<
name|bool
parameter_list|>
struct_decl|struct
name|StaticAssertTest
struct_decl|;
DECL|struct|StaticAssertTest
DECL|enumerator|Value
template|template
parameter_list|<>
struct|struct
name|StaticAssertTest
argument_list|<
literal|true
argument_list|>
block|{
enum|enum
block|{
name|Value
init|=
literal|1
block|}
enum|;
block|}
struct|;
block|}
end_namespace
begin_function
DECL|function|qt_noop_with_arg
specifier|static
specifier|inline
name|void
name|qt_noop_with_arg
parameter_list|(
name|int
parameter_list|)
block|{}
end_function
begin_define
DECL|macro|q_static_assert
define|#
directive|define
name|q_static_assert
parameter_list|(
name|expr
parameter_list|)
value|qt_noop_with_arg(sizeof(StaticAssertTest< expr>::Value))
end_define
begin_function
DECL|function|defaultCapabilitiesForType
specifier|static
name|QNetworkProxy
operator|::
name|Capabilities
name|defaultCapabilitiesForType
parameter_list|(
name|QNetworkProxy
operator|::
name|ProxyType
name|type
parameter_list|)
block|{
name|q_static_assert
argument_list|(
name|int
argument_list|(
name|QNetworkProxy
operator|::
name|DefaultProxy
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|q_static_assert
argument_list|(
name|int
argument_list|(
name|QNetworkProxy
operator|::
name|FtpCachingProxy
argument_list|)
operator|==
literal|5
argument_list|)
expr_stmt|;
specifier|static
specifier|const
name|int
name|defaults
index|[]
init|=
block|{
comment|/* [QNetworkProxy::DefaultProxy] = */
operator|(
name|int
argument_list|(
name|QNetworkProxy
operator|::
name|ListeningCapability
argument_list|)
operator||
name|int
argument_list|(
name|QNetworkProxy
operator|::
name|TunnelingCapability
argument_list|)
operator||
name|int
argument_list|(
name|QNetworkProxy
operator|::
name|UdpTunnelingCapability
argument_list|)
operator|)
block|,
comment|/* [QNetworkProxy::Socks5Proxy] = */
operator|(
name|int
argument_list|(
name|QNetworkProxy
operator|::
name|TunnelingCapability
argument_list|)
operator||
name|int
argument_list|(
name|QNetworkProxy
operator|::
name|ListeningCapability
argument_list|)
operator||
name|int
argument_list|(
name|QNetworkProxy
operator|::
name|UdpTunnelingCapability
argument_list|)
operator||
name|int
argument_list|(
name|QNetworkProxy
operator|::
name|HostNameLookupCapability
argument_list|)
operator|)
block|,
comment|// it's weird to talk about the proxy capabilities of a "not proxy"...
comment|/* [QNetworkProxy::NoProxy] = */
operator|(
name|int
argument_list|(
name|QNetworkProxy
operator|::
name|ListeningCapability
argument_list|)
operator||
name|int
argument_list|(
name|QNetworkProxy
operator|::
name|TunnelingCapability
argument_list|)
operator||
name|int
argument_list|(
name|QNetworkProxy
operator|::
name|UdpTunnelingCapability
argument_list|)
operator|)
block|,
comment|/* [QNetworkProxy::HttpProxy] = */
operator|(
name|int
argument_list|(
name|QNetworkProxy
operator|::
name|TunnelingCapability
argument_list|)
operator||
name|int
argument_list|(
name|QNetworkProxy
operator|::
name|CachingCapability
argument_list|)
operator||
name|int
argument_list|(
name|QNetworkProxy
operator|::
name|HostNameLookupCapability
argument_list|)
operator|)
block|,
comment|/* [QNetworkProxy::HttpCachingProxy] = */
operator|(
name|int
argument_list|(
name|QNetworkProxy
operator|::
name|CachingCapability
argument_list|)
operator||
name|int
argument_list|(
name|QNetworkProxy
operator|::
name|HostNameLookupCapability
argument_list|)
operator|)
block|,
comment|/* [QNetworkProxy::FtpCachingProxy] = */
operator|(
name|int
argument_list|(
name|QNetworkProxy
operator|::
name|CachingCapability
argument_list|)
operator||
name|int
argument_list|(
name|QNetworkProxy
operator|::
name|HostNameLookupCapability
argument_list|)
operator|)
block|,     }
decl_stmt|;
if|if
condition|(
name|int
argument_list|(
name|type
argument_list|)
operator|<
literal|0
operator|||
name|int
argument_list|(
name|type
argument_list|)
operator|>
name|int
argument_list|(
name|QNetworkProxy
operator|::
name|FtpCachingProxy
argument_list|)
condition|)
name|type
operator|=
name|QNetworkProxy
operator|::
name|DefaultProxy
expr_stmt|;
return|return
name|QNetworkProxy
operator|::
name|Capabilities
argument_list|(
name|defaults
index|[
name|int
argument_list|(
name|type
argument_list|)
index|]
argument_list|)
return|;
block|}
end_function
begin_class
DECL|class|QNetworkProxyPrivate
class|class
name|QNetworkProxyPrivate
super|:
specifier|public
name|QSharedData
block|{
public|public:
DECL|member|hostName
name|QString
name|hostName
decl_stmt|;
DECL|member|user
name|QString
name|user
decl_stmt|;
DECL|member|password
name|QString
name|password
decl_stmt|;
DECL|member|capabilities
name|QNetworkProxy
operator|::
name|Capabilities
name|capabilities
decl_stmt|;
DECL|member|port
name|quint16
name|port
decl_stmt|;
DECL|member|type
name|QNetworkProxy
operator|::
name|ProxyType
name|type
decl_stmt|;
DECL|member|capabilitiesSet
name|bool
name|capabilitiesSet
decl_stmt|;
DECL|member|headers
name|QNetworkHeadersPrivate
name|headers
decl_stmt|;
DECL|function|QNetworkProxyPrivate
specifier|inline
name|QNetworkProxyPrivate
parameter_list|(
name|QNetworkProxy
operator|::
name|ProxyType
name|t
init|=
name|QNetworkProxy
operator|::
name|DefaultProxy
parameter_list|,
specifier|const
name|QString
modifier|&
name|h
init|=
name|QString
argument_list|()
parameter_list|,
name|quint16
name|p
init|=
literal|0
parameter_list|,
specifier|const
name|QString
modifier|&
name|u
init|=
name|QString
argument_list|()
parameter_list|,
specifier|const
name|QString
modifier|&
name|pw
init|=
name|QString
argument_list|()
parameter_list|)
member_init_list|:
name|hostName
argument_list|(
name|h
argument_list|)
member_init_list|,
name|user
argument_list|(
name|u
argument_list|)
member_init_list|,
name|password
argument_list|(
name|pw
argument_list|)
member_init_list|,
name|capabilities
argument_list|(
name|defaultCapabilitiesForType
argument_list|(
name|t
argument_list|)
argument_list|)
member_init_list|,
name|port
argument_list|(
name|p
argument_list|)
member_init_list|,
name|type
argument_list|(
name|t
argument_list|)
member_init_list|,
name|capabilitiesSet
argument_list|(
literal|false
argument_list|)
block|{ }
DECL|function|operator ==
specifier|inline
name|bool
name|operator
name|==
parameter_list|(
specifier|const
name|QNetworkProxyPrivate
modifier|&
name|other
parameter_list|)
specifier|const
block|{
return|return
name|type
operator|==
name|other
operator|.
name|type
operator|&&
name|port
operator|==
name|other
operator|.
name|port
operator|&&
name|hostName
operator|==
name|other
operator|.
name|hostName
operator|&&
name|user
operator|==
name|other
operator|.
name|user
operator|&&
name|password
operator|==
name|other
operator|.
name|password
operator|&&
name|capabilities
operator|==
name|other
operator|.
name|capabilities
return|;
block|}
block|}
class|;
end_class
begin_function
DECL|function|detach
template|template
parameter_list|<>
name|void
name|QSharedDataPointer
argument_list|<
name|QNetworkProxyPrivate
argument_list|>
operator|::
name|detach
parameter_list|()
block|{
if|if
condition|(
name|d
operator|&&
name|d
operator|->
name|ref
operator|.
name|load
argument_list|()
operator|==
literal|1
condition|)
return|return;
name|QNetworkProxyPrivate
modifier|*
name|x
init|=
operator|(
name|d
condition|?
operator|new
name|QNetworkProxyPrivate
argument_list|(
operator|*
name|d
argument_list|)
else|:
operator|new
name|QNetworkProxyPrivate
operator|)
decl_stmt|;
name|x
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
if|if
condition|(
name|d
operator|&&
operator|!
name|d
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
operator|delete
name|d
expr_stmt|;
name|d
operator|=
name|x
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Constructs a QNetworkProxy with DefaultProxy type; the proxy type is     determined by applicationProxy(), which defaults to NoProxy.      \sa setType(), setApplicationProxy() */
end_comment
begin_constructor
DECL|function|QNetworkProxy
name|QNetworkProxy
operator|::
name|QNetworkProxy
parameter_list|()
member_init_list|:
name|d
argument_list|(
literal|0
argument_list|)
block|{
comment|// make sure we have QGlobalNetworkProxy singleton created, otherwise
comment|// you don't have any socket engine handler created when directly setting
comment|// a proxy to a socket
name|globalNetworkProxy
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a QNetworkProxy with \a type, \a hostName, \a port,     \a user and \a password.      The default capabilities for proxy type \a type are set automatically.      \sa capabilities() */
end_comment
begin_constructor
DECL|function|QNetworkProxy
name|QNetworkProxy
operator|::
name|QNetworkProxy
parameter_list|(
name|ProxyType
name|type
parameter_list|,
specifier|const
name|QString
modifier|&
name|hostName
parameter_list|,
name|quint16
name|port
parameter_list|,
specifier|const
name|QString
modifier|&
name|user
parameter_list|,
specifier|const
name|QString
modifier|&
name|password
parameter_list|)
member_init_list|:
name|d
argument_list|(
operator|new
name|QNetworkProxyPrivate
argument_list|(
name|type
argument_list|,
name|hostName
argument_list|,
name|port
argument_list|,
name|user
argument_list|,
name|password
argument_list|)
argument_list|)
block|{
comment|// make sure we have QGlobalNetworkProxy singleton created, otherwise
comment|// you don't have any socket engine handler created when directly setting
comment|// a proxy to a socket
name|globalNetworkProxy
argument_list|()
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a copy of \a other. */
end_comment
begin_constructor
DECL|function|QNetworkProxy
name|QNetworkProxy
operator|::
name|QNetworkProxy
parameter_list|(
specifier|const
name|QNetworkProxy
modifier|&
name|other
parameter_list|)
member_init_list|:
name|d
argument_list|(
name|other
operator|.
name|d
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Destroys the QNetworkProxy object. */
end_comment
begin_destructor
DECL|function|~QNetworkProxy
name|QNetworkProxy
operator|::
name|~
name|QNetworkProxy
parameter_list|()
block|{
comment|// QSharedDataPointer takes care of deleting for us
block|}
end_destructor
begin_comment
comment|/*!     \since 4.4      Compares the value of this network proxy to \a other and returns true     if they are equal (same proxy type, server as well as username and password) */
end_comment
begin_function
DECL|function|operator ==
name|bool
name|QNetworkProxy
operator|::
name|operator
name|==
parameter_list|(
specifier|const
name|QNetworkProxy
modifier|&
name|other
parameter_list|)
specifier|const
block|{
return|return
name|d
operator|==
name|other
operator|.
name|d
operator|||
operator|(
name|d
operator|&&
name|other
operator|.
name|d
operator|&&
operator|*
name|d
operator|==
operator|*
name|other
operator|.
name|d
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QNetworkProxy::operator!=(const QNetworkProxy&other) const     \since 4.4      Compares the value of this network proxy to \a other and returns true     if they differ. \*/
end_comment
begin_comment
comment|/*!     \since 4.2      Assigns the value of the network proxy \a other to this network proxy. */
end_comment
begin_function
DECL|function|operator =
name|QNetworkProxy
modifier|&
name|QNetworkProxy
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QNetworkProxy
modifier|&
name|other
parameter_list|)
block|{
name|d
operator|=
name|other
operator|.
name|d
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QNetworkProxy::swap(QNetworkProxy&other)     \since 5.0      Swaps this network proxy instance with \a other. This function is     very fast and never fails. */
end_comment
begin_comment
comment|/*!     Sets the proxy type for this instance to be \a type.      Note that changing the type of a proxy does not change     the set of capabilities this QNetworkProxy object holds if any     capabilities have been set with setCapabilities().      \sa type(), setCapabilities() */
end_comment
begin_function
DECL|function|setType
name|void
name|QNetworkProxy
operator|::
name|setType
parameter_list|(
name|QNetworkProxy
operator|::
name|ProxyType
name|type
parameter_list|)
block|{
name|d
operator|->
name|type
operator|=
name|type
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|capabilitiesSet
condition|)
name|d
operator|->
name|capabilities
operator|=
name|defaultCapabilitiesForType
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the proxy type for this instance.      \sa setType() */
end_comment
begin_function
DECL|function|type
name|QNetworkProxy
operator|::
name|ProxyType
name|QNetworkProxy
operator|::
name|type
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|d
operator|->
name|type
else|:
name|DefaultProxy
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5      Sets the capabilities of this proxy to \a capabilities.      \sa setType(), capabilities() */
end_comment
begin_function
DECL|function|setCapabilities
name|void
name|QNetworkProxy
operator|::
name|setCapabilities
parameter_list|(
name|Capabilities
name|capabilities
parameter_list|)
block|{
name|d
operator|->
name|capabilities
operator|=
name|capabilities
expr_stmt|;
name|d
operator|->
name|capabilitiesSet
operator|=
literal|true
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5      Returns the capabilities of this proxy server.      \sa setCapabilities(), type() */
end_comment
begin_function
DECL|function|capabilities
name|QNetworkProxy
operator|::
name|Capabilities
name|QNetworkProxy
operator|::
name|capabilities
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|d
operator|->
name|capabilities
else|:
name|defaultCapabilitiesForType
argument_list|(
name|DefaultProxy
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Returns true if this proxy supports the     QNetworkProxy::CachingCapability capability.      In Qt 4.4, the capability was tied to the proxy type, but since Qt     4.5 it is possible to remove the capability of caching from a     proxy by calling setCapabilities().      \sa capabilities(), type(), isTransparentProxy() */
end_comment
begin_function
DECL|function|isCachingProxy
name|bool
name|QNetworkProxy
operator|::
name|isCachingProxy
parameter_list|()
specifier|const
block|{
return|return
name|capabilities
argument_list|()
operator|&
name|CachingCapability
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.4      Returns true if this proxy supports transparent tunneling of TCP     connections. This matches the QNetworkProxy::TunnelingCapability     capability.      In Qt 4.4, the capability was tied to the proxy type, but since Qt     4.5 it is possible to remove the capability of caching from a     proxy by calling setCapabilities().      \sa capabilities(), type(), isCachingProxy() */
end_comment
begin_function
DECL|function|isTransparentProxy
name|bool
name|QNetworkProxy
operator|::
name|isTransparentProxy
parameter_list|()
specifier|const
block|{
return|return
name|capabilities
argument_list|()
operator|&
name|TunnelingCapability
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the user name for proxy authentication to be \a user.      \sa user(), setPassword(), password() */
end_comment
begin_function
DECL|function|setUser
name|void
name|QNetworkProxy
operator|::
name|setUser
parameter_list|(
specifier|const
name|QString
modifier|&
name|user
parameter_list|)
block|{
name|d
operator|->
name|user
operator|=
name|user
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the user name used for authentication.      \sa setUser(), setPassword(), password() */
end_comment
begin_function
DECL|function|user
name|QString
name|QNetworkProxy
operator|::
name|user
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|d
operator|->
name|user
else|:
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the password for proxy authentication to be \a password.      \sa user(), setUser(), password() */
end_comment
begin_function
DECL|function|setPassword
name|void
name|QNetworkProxy
operator|::
name|setPassword
parameter_list|(
specifier|const
name|QString
modifier|&
name|password
parameter_list|)
block|{
name|d
operator|->
name|password
operator|=
name|password
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the password used for authentication.      \sa user(), setPassword(), setUser() */
end_comment
begin_function
DECL|function|password
name|QString
name|QNetworkProxy
operator|::
name|password
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|d
operator|->
name|password
else|:
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the host name of the proxy host to be \a hostName.      \sa hostName(), setPort(), port() */
end_comment
begin_function
DECL|function|setHostName
name|void
name|QNetworkProxy
operator|::
name|setHostName
parameter_list|(
specifier|const
name|QString
modifier|&
name|hostName
parameter_list|)
block|{
name|d
operator|->
name|hostName
operator|=
name|hostName
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the host name of the proxy host.      \sa setHostName(), setPort(), port() */
end_comment
begin_function
DECL|function|hostName
name|QString
name|QNetworkProxy
operator|::
name|hostName
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|d
operator|->
name|hostName
else|:
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the port of the proxy host to be \a port.      \sa hostName(), setHostName(), port() */
end_comment
begin_function
DECL|function|setPort
name|void
name|QNetworkProxy
operator|::
name|setPort
parameter_list|(
name|quint16
name|port
parameter_list|)
block|{
name|d
operator|->
name|port
operator|=
name|port
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the port of the proxy host.      \sa setHostName(), setPort(), hostName() */
end_comment
begin_function
DECL|function|port
name|quint16
name|QNetworkProxy
operator|::
name|port
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|d
operator|->
name|port
else|:
literal|0
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the application level network proxying to be \a networkProxy.      If a QAbstractSocket or QTcpSocket has the     QNetworkProxy::DefaultProxy type, then the QNetworkProxy set with     this function is used. If you want more flexibility in determining     which proxy is used, use the QNetworkProxyFactory class.      Setting a default proxy value with this function will override the     application proxy factory set with     QNetworkProxyFactory::setApplicationProxyFactory.      \sa QNetworkProxyFactory, applicationProxy(), QAbstractSocket::setProxy(), QTcpServer::setProxy() */
end_comment
begin_function
DECL|function|setApplicationProxy
name|void
name|QNetworkProxy
operator|::
name|setApplicationProxy
parameter_list|(
specifier|const
name|QNetworkProxy
modifier|&
name|networkProxy
parameter_list|)
block|{
if|if
condition|(
name|globalNetworkProxy
argument_list|()
condition|)
block|{
comment|// don't accept setting the proxy to DefaultProxy
if|if
condition|(
name|networkProxy
operator|.
name|type
argument_list|()
operator|==
name|DefaultProxy
condition|)
name|globalNetworkProxy
argument_list|()
operator|->
name|setApplicationProxy
argument_list|(
name|QNetworkProxy
operator|::
name|NoProxy
argument_list|)
expr_stmt|;
else|else
name|globalNetworkProxy
argument_list|()
operator|->
name|setApplicationProxy
argument_list|(
name|networkProxy
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Returns the application level network proxying.      If a QAbstractSocket or QTcpSocket has the     QNetworkProxy::DefaultProxy type, then the QNetworkProxy returned     by this function is used.      \sa QNetworkProxyFactory, setApplicationProxy(), QAbstractSocket::proxy(), QTcpServer::proxy() */
end_comment
begin_function
DECL|function|applicationProxy
name|QNetworkProxy
name|QNetworkProxy
operator|::
name|applicationProxy
parameter_list|()
block|{
if|if
condition|(
name|globalNetworkProxy
argument_list|()
condition|)
return|return
name|globalNetworkProxy
argument_list|()
operator|->
name|applicationProxy
argument_list|()
return|;
return|return
name|QNetworkProxy
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 5.0     Returns the value of the known network header \a header if it is     in use for this proxy. If it is not present, returns QVariant()     (i.e., an invalid variant).      \sa QNetworkRequest::KnownHeaders, rawHeader(), setHeader() */
end_comment
begin_function
DECL|function|header
name|QVariant
name|QNetworkProxy
operator|::
name|header
parameter_list|(
name|QNetworkRequest
operator|::
name|KnownHeaders
name|header
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|d
operator|->
name|type
operator|!=
name|HttpProxy
operator|&&
name|d
operator|->
name|type
operator|!=
name|HttpCachingProxy
condition|)
return|return
name|QVariant
argument_list|()
return|;
return|return
name|d
operator|->
name|headers
operator|.
name|cookedHeaders
operator|.
name|value
argument_list|(
name|header
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 5.0     Sets the value of the known header \a header to be \a value,     overriding any previously set headers. This operation also sets     the equivalent raw HTTP header.      If the proxy is not of type HttpProxy or HttpCachingProxy this has no     effect.      \sa QNetworkRequest::KnownHeaders, setRawHeader(), header() */
end_comment
begin_function
DECL|function|setHeader
name|void
name|QNetworkProxy
operator|::
name|setHeader
parameter_list|(
name|QNetworkRequest
operator|::
name|KnownHeaders
name|header
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|value
parameter_list|)
block|{
if|if
condition|(
name|d
operator|->
name|type
operator|==
name|HttpProxy
operator|||
name|d
operator|->
name|type
operator|==
name|HttpCachingProxy
condition|)
name|d
operator|->
name|headers
operator|.
name|setCookedHeader
argument_list|(
name|header
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \since 5.0     Returns true if the raw header \a headerName is in use for this     proxy. Returns false if the proxy is not of type HttpProxy or     HttpCachingProxy.      \sa rawHeader(), setRawHeader() */
end_comment
begin_function
DECL|function|hasRawHeader
name|bool
name|QNetworkProxy
operator|::
name|hasRawHeader
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|headerName
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|d
operator|->
name|type
operator|!=
name|HttpProxy
operator|&&
name|d
operator|->
name|type
operator|!=
name|HttpCachingProxy
condition|)
return|return
literal|false
return|;
return|return
name|d
operator|->
name|headers
operator|.
name|findRawHeader
argument_list|(
name|headerName
argument_list|)
operator|!=
name|d
operator|->
name|headers
operator|.
name|rawHeaders
operator|.
name|constEnd
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 5.0     Returns the raw form of header \a headerName. If no such header is     present or the proxy is not of type HttpProxy or HttpCachingProxy,     an empty QByteArray is returned, which may be indistinguishable     from a header that is present but has no content (use hasRawHeader()     to find out if the header exists or not).      Raw headers can be set with setRawHeader() or with setHeader().      \sa header(), setRawHeader() */
end_comment
begin_function
DECL|function|rawHeader
name|QByteArray
name|QNetworkProxy
operator|::
name|rawHeader
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|headerName
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|d
operator|->
name|type
operator|!=
name|HttpProxy
operator|&&
name|d
operator|->
name|type
operator|!=
name|HttpCachingProxy
condition|)
return|return
name|QByteArray
argument_list|()
return|;
name|QNetworkHeadersPrivate
operator|::
name|RawHeadersList
operator|::
name|ConstIterator
name|it
init|=
name|d
operator|->
name|headers
operator|.
name|findRawHeader
argument_list|(
name|headerName
argument_list|)
decl_stmt|;
if|if
condition|(
name|it
operator|!=
name|d
operator|->
name|headers
operator|.
name|rawHeaders
operator|.
name|constEnd
argument_list|()
condition|)
return|return
name|it
operator|->
name|second
return|;
return|return
name|QByteArray
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 5.0     Returns a list of all raw headers that are set in this network     proxy. The list is in the order that the headers were set.      If the proxy is not of type HttpProxy or HttpCachingProxy an empty     QList is returned.      \sa hasRawHeader(), rawHeader() */
end_comment
begin_function
DECL|function|rawHeaderList
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|QNetworkProxy
operator|::
name|rawHeaderList
parameter_list|()
specifier|const
block|{
if|if
condition|(
name|d
operator|->
name|type
operator|!=
name|HttpProxy
operator|&&
name|d
operator|->
name|type
operator|!=
name|HttpCachingProxy
condition|)
return|return
name|QList
argument_list|<
name|QByteArray
argument_list|>
argument_list|()
return|;
return|return
name|d
operator|->
name|headers
operator|.
name|rawHeadersKeys
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 5.0     Sets the header \a headerName to be of value \a headerValue. If \a     headerName corresponds to a known header (see     QNetworkRequest::KnownHeaders), the raw format will be parsed and     the corresponding "cooked" header will be set as well.      For example:     \snippet code/src_network_access_qnetworkrequest.cpp 0      will also set the known header LastModifiedHeader to be the     QDateTime object of the parsed date.      Note: setting the same header twice overrides the previous     setting. To accomplish the behaviour of multiple HTTP headers of     the same name, you should concatenate the two values, separating     them with a comma (",") and set one single raw header.      If the proxy is not of type HttpProxy or HttpCachingProxy this has no     effect.      \sa QNetworkRequest::KnownHeaders, setHeader(), hasRawHeader(), rawHeader() */
end_comment
begin_function
DECL|function|setRawHeader
name|void
name|QNetworkProxy
operator|::
name|setRawHeader
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|headerName
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|headerValue
parameter_list|)
block|{
if|if
condition|(
name|d
operator|->
name|type
operator|==
name|HttpProxy
operator|||
name|d
operator|->
name|type
operator|==
name|HttpCachingProxy
condition|)
name|d
operator|->
name|headers
operator|.
name|setRawHeader
argument_list|(
name|headerName
argument_list|,
name|headerValue
argument_list|)
expr_stmt|;
block|}
end_function
begin_class
DECL|class|QNetworkProxyQueryPrivate
class|class
name|QNetworkProxyQueryPrivate
super|:
specifier|public
name|QSharedData
block|{
public|public:
DECL|function|QNetworkProxyQueryPrivate
specifier|inline
name|QNetworkProxyQueryPrivate
parameter_list|()
member_init_list|:
name|localPort
argument_list|(
operator|-
literal|1
argument_list|)
member_init_list|,
name|type
argument_list|(
name|QNetworkProxyQuery
operator|::
name|TcpSocket
argument_list|)
block|{ }
DECL|function|operator ==
name|bool
name|operator
name|==
parameter_list|(
specifier|const
name|QNetworkProxyQueryPrivate
modifier|&
name|other
parameter_list|)
specifier|const
block|{
return|return
name|type
operator|==
name|other
operator|.
name|type
operator|&&
name|localPort
operator|==
name|other
operator|.
name|localPort
operator|&&
name|remote
operator|==
name|other
operator|.
name|remote
return|;
block|}
DECL|member|remote
name|QUrl
name|remote
decl_stmt|;
DECL|member|localPort
name|int
name|localPort
decl_stmt|;
DECL|member|type
name|QNetworkProxyQuery
operator|::
name|QueryType
name|type
decl_stmt|;
ifndef|#
directive|ifndef
name|QT_NO_BEARERMANAGEMENT
DECL|member|config
name|QNetworkConfiguration
name|config
decl_stmt|;
endif|#
directive|endif
block|}
class|;
end_class
begin_function
DECL|function|detach
template|template
parameter_list|<>
name|void
name|QSharedDataPointer
argument_list|<
name|QNetworkProxyQueryPrivate
argument_list|>
operator|::
name|detach
parameter_list|()
block|{
if|if
condition|(
name|d
operator|&&
name|d
operator|->
name|ref
operator|.
name|load
argument_list|()
operator|==
literal|1
condition|)
return|return;
name|QNetworkProxyQueryPrivate
modifier|*
name|x
init|=
operator|(
name|d
condition|?
operator|new
name|QNetworkProxyQueryPrivate
argument_list|(
operator|*
name|d
argument_list|)
else|:
operator|new
name|QNetworkProxyQueryPrivate
operator|)
decl_stmt|;
name|x
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
if|if
condition|(
name|d
operator|&&
operator|!
name|d
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
operator|delete
name|d
expr_stmt|;
name|d
operator|=
name|x
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \class QNetworkProxyQuery     \since 4.5     \ingroup shared     \inmodule QtNetwork     \brief The QNetworkProxyQuery class is used to query the proxy     settings for a socket.      QNetworkProxyQuery holds the details of a socket being created or     request being made. It is used by QNetworkProxy and     QNetworkProxyFactory to allow applications to have a more     fine-grained control over which proxy servers are used, depending     on the details of the query. This allows an application to apply     different settings, according to the protocol or destination     hostname, for instance.      QNetworkProxyQuery supports the following criteria for selecting     the proxy:      \list       \li the type of query       \li the local port number to use       \li the destination host name       \li the destination port number       \li the protocol name, such as "http" or "ftp"       \li the URL being requested     \endlist      The destination host name is the host in the connection in the     case of outgoing connection sockets. It is the \c hostName     parameter passed to QTcpSocket::connectToHost() or the host     component of a URL requested with QNetworkRequest.      The destination port number is the requested port to connect to in     the case of outgoing sockets, while the local port number is the     port the socket wishes to use locally before attempting the     external connection. In most cases, the local port number is used     by listening sockets only (QTcpSocket) or by datagram sockets     (QUdpSocket).      The protocol name is an arbitrary string that indicates the type     of connection being attempted. For example, it can match the     scheme of a URL, like "http", "https" and "ftp". In most cases,     the proxy selection will not change depending on the protocol, but     this information is provided in case a better choice can be made,     like choosing an caching HTTP proxy for HTTP-based connections,     but a more powerful SOCKSv5 proxy for all others.      The network configuration specifies which configuration to use,     when bearer management is used. For example on a mobile phone     the proxy settings are likely to be different for the cellular     network vs WLAN.      Some of the criteria may not make sense in all of the types of     query. The following table lists the criteria that are most     commonly used, according to the type of query.      \table     \header       \li Query type       \li Description      \row       \li TcpSocket       \li Normal sockets requesting a connection to a remote server,          like QTcpSocket. The peer hostname and peer port match the          values passed to QTcpSocket::connectToHost(). The local port          is usually -1, indicating the socket has no preference in          which port should be used. The URL component is not used.      \row       \li UdpSocket       \li Datagram-based sockets, which can both send and          receive. The local port, remote host or remote port fields          can all be used or be left unused, depending on the          characteristics of the socket. The URL component is not used.      \row       \li TcpServer       \li Passive server sockets that listen on a port and await          incoming connections from the network. Normally, only the          local port is used, but the remote address could be used in          specific circumstances, for example to indicate which remote          host a connection is expected from. The URL component is not used.      \row       \li UrlRequest       \li A more high-level request, such as those coming from          QNetworkAccessManager. These requests will inevitably use an          outgoing TCP socket, but the this query type is provided to          indicate that more detailed information is present in the URL          component. For ease of implementation, the URL's host and          port are set as the destination address.     \endtable      It should be noted that any of the criteria may be missing or     unknown (an empty QString for the hostname or protocol name, -1     for the port numbers). If that happens, the functions executing     the query should make their best guess or apply some     implementation-defined default values.      \sa QNetworkProxy, QNetworkProxyFactory, QNetworkAccessManager,         QAbstractSocket::setProxy() */
end_comment
begin_comment
comment|/*!     \enum QNetworkProxyQuery::QueryType      Describes the type of one QNetworkProxyQuery query.      \value TcpSocket    a normal, outgoing TCP socket     \value UdpSocket    a datagram-based UDP socket, which could send                         to multiple destinations     \value TcpServer    a TCP server that listens for incoming                         connections from the network     \value UrlRequest   a more complex request which involves loading                         of a URL      \sa queryType(), setQueryType() */
end_comment
begin_comment
comment|/*!     Constructs a default QNetworkProxyQuery object. By default, the     query type will be QNetworkProxyQuery::TcpSocket. */
end_comment
begin_constructor
DECL|function|QNetworkProxyQuery
name|QNetworkProxyQuery
operator|::
name|QNetworkProxyQuery
parameter_list|()
block|{ }
end_constructor
begin_comment
comment|/*!     Constructs a QNetworkProxyQuery with the URL \a requestUrl and     sets the query type to \a queryType.      \sa protocolTag(), peerHostName(), peerPort() */
end_comment
begin_constructor
DECL|function|QNetworkProxyQuery
name|QNetworkProxyQuery
operator|::
name|QNetworkProxyQuery
parameter_list|(
specifier|const
name|QUrl
modifier|&
name|requestUrl
parameter_list|,
name|QueryType
name|queryType
parameter_list|)
block|{
name|d
operator|->
name|remote
operator|=
name|requestUrl
expr_stmt|;
name|d
operator|->
name|type
operator|=
name|queryType
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a QNetworkProxyQuery of type \a queryType and sets the     protocol tag to be \a protocolTag. This constructor is suitable     for QNetworkProxyQuery::TcpSocket queries, because it sets the     peer hostname to \a hostname and the peer's port number to \a     port. */
end_comment
begin_constructor
DECL|function|QNetworkProxyQuery
name|QNetworkProxyQuery
operator|::
name|QNetworkProxyQuery
parameter_list|(
specifier|const
name|QString
modifier|&
name|hostname
parameter_list|,
name|int
name|port
parameter_list|,
specifier|const
name|QString
modifier|&
name|protocolTag
parameter_list|,
name|QueryType
name|queryType
parameter_list|)
block|{
name|d
operator|->
name|remote
operator|.
name|setScheme
argument_list|(
name|protocolTag
argument_list|)
expr_stmt|;
name|d
operator|->
name|remote
operator|.
name|setHost
argument_list|(
name|hostname
argument_list|)
expr_stmt|;
name|d
operator|->
name|remote
operator|.
name|setPort
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|d
operator|->
name|type
operator|=
name|queryType
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a QNetworkProxyQuery of type \a queryType and sets the     protocol tag to be \a protocolTag. This constructor is suitable     for QNetworkProxyQuery::TcpSocket queries because it sets the     local port number to \a bindPort.      Note that \a bindPort is of type quint16 to indicate the exact     port number that is requested. The value of -1 (unknown) is not     allowed in this context.      \sa localPort() */
end_comment
begin_constructor
DECL|function|QNetworkProxyQuery
name|QNetworkProxyQuery
operator|::
name|QNetworkProxyQuery
parameter_list|(
name|quint16
name|bindPort
parameter_list|,
specifier|const
name|QString
modifier|&
name|protocolTag
parameter_list|,
name|QueryType
name|queryType
parameter_list|)
block|{
name|d
operator|->
name|remote
operator|.
name|setScheme
argument_list|(
name|protocolTag
argument_list|)
expr_stmt|;
name|d
operator|->
name|localPort
operator|=
name|bindPort
expr_stmt|;
name|d
operator|->
name|type
operator|=
name|queryType
expr_stmt|;
block|}
end_constructor
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_BEARERMANAGEMENT
end_ifndef
begin_comment
comment|/*!     Constructs a QNetworkProxyQuery with the URL \a requestUrl and     sets the query type to \a queryType. The specified \a networkConfiguration     is used to resolve the proxy settings.      \sa protocolTag(), peerHostName(), peerPort(), networkConfiguration() */
end_comment
begin_constructor
DECL|function|QNetworkProxyQuery
name|QNetworkProxyQuery
operator|::
name|QNetworkProxyQuery
parameter_list|(
specifier|const
name|QNetworkConfiguration
modifier|&
name|networkConfiguration
parameter_list|,
specifier|const
name|QUrl
modifier|&
name|requestUrl
parameter_list|,
name|QueryType
name|queryType
parameter_list|)
block|{
name|d
operator|->
name|config
operator|=
name|networkConfiguration
expr_stmt|;
name|d
operator|->
name|remote
operator|=
name|requestUrl
expr_stmt|;
name|d
operator|->
name|type
operator|=
name|queryType
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a QNetworkProxyQuery of type \a queryType and sets the     protocol tag to be \a protocolTag. This constructor is suitable     for QNetworkProxyQuery::TcpSocket queries, because it sets the     peer hostname to \a hostname and the peer's port number to \a     port. The specified \a networkConfiguration     is used to resolve the proxy settings.      \sa networkConfiguration() */
end_comment
begin_constructor
DECL|function|QNetworkProxyQuery
name|QNetworkProxyQuery
operator|::
name|QNetworkProxyQuery
parameter_list|(
specifier|const
name|QNetworkConfiguration
modifier|&
name|networkConfiguration
parameter_list|,
specifier|const
name|QString
modifier|&
name|hostname
parameter_list|,
name|int
name|port
parameter_list|,
specifier|const
name|QString
modifier|&
name|protocolTag
parameter_list|,
name|QueryType
name|queryType
parameter_list|)
block|{
name|d
operator|->
name|config
operator|=
name|networkConfiguration
expr_stmt|;
name|d
operator|->
name|remote
operator|.
name|setScheme
argument_list|(
name|protocolTag
argument_list|)
expr_stmt|;
name|d
operator|->
name|remote
operator|.
name|setHost
argument_list|(
name|hostname
argument_list|)
expr_stmt|;
name|d
operator|->
name|remote
operator|.
name|setPort
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|d
operator|->
name|type
operator|=
name|queryType
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a QNetworkProxyQuery of type \a queryType and sets the     protocol tag to be \a protocolTag. This constructor is suitable     for QNetworkProxyQuery::TcpSocket queries because it sets the     local port number to \a bindPort. The specified \a networkConfiguration     is used to resolve the proxy settings.      Note that \a bindPort is of type quint16 to indicate the exact     port number that is requested. The value of -1 (unknown) is not     allowed in this context.      \sa localPort(), networkConfiguration() */
end_comment
begin_constructor
DECL|function|QNetworkProxyQuery
name|QNetworkProxyQuery
operator|::
name|QNetworkProxyQuery
parameter_list|(
specifier|const
name|QNetworkConfiguration
modifier|&
name|networkConfiguration
parameter_list|,
name|quint16
name|bindPort
parameter_list|,
specifier|const
name|QString
modifier|&
name|protocolTag
parameter_list|,
name|QueryType
name|queryType
parameter_list|)
block|{
name|d
operator|->
name|config
operator|=
name|networkConfiguration
expr_stmt|;
name|d
operator|->
name|remote
operator|.
name|setScheme
argument_list|(
name|protocolTag
argument_list|)
expr_stmt|;
name|d
operator|->
name|localPort
operator|=
name|bindPort
expr_stmt|;
name|d
operator|->
name|type
operator|=
name|queryType
expr_stmt|;
block|}
end_constructor
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     Constructs a QNetworkProxyQuery object that is a copy of \a other. */
end_comment
begin_constructor
DECL|function|QNetworkProxyQuery
name|QNetworkProxyQuery
operator|::
name|QNetworkProxyQuery
parameter_list|(
specifier|const
name|QNetworkProxyQuery
modifier|&
name|other
parameter_list|)
member_init_list|:
name|d
argument_list|(
name|other
operator|.
name|d
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Destroys this QNetworkProxyQuery object. */
end_comment
begin_destructor
DECL|function|~QNetworkProxyQuery
name|QNetworkProxyQuery
operator|::
name|~
name|QNetworkProxyQuery
parameter_list|()
block|{
comment|// QSharedDataPointer automatically deletes
block|}
end_destructor
begin_comment
comment|/*!     Copies the contents of \a other. */
end_comment
begin_function
DECL|function|operator =
name|QNetworkProxyQuery
modifier|&
name|QNetworkProxyQuery
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QNetworkProxyQuery
modifier|&
name|other
parameter_list|)
block|{
name|d
operator|=
name|other
operator|.
name|d
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QNetworkProxyQuery::swap(QNetworkProxyQuery&other)     \since 5.0      Swaps this network proxy query instance with \a other. This     function is very fast and never fails. */
end_comment
begin_comment
comment|/*!     Returns true if this QNetworkProxyQuery object contains the same     data as \a other. */
end_comment
begin_function
DECL|function|operator ==
name|bool
name|QNetworkProxyQuery
operator|::
name|operator
name|==
parameter_list|(
specifier|const
name|QNetworkProxyQuery
modifier|&
name|other
parameter_list|)
specifier|const
block|{
return|return
name|d
operator|==
name|other
operator|.
name|d
operator|||
operator|(
name|d
operator|&&
name|other
operator|.
name|d
operator|&&
operator|*
name|d
operator|==
operator|*
name|other
operator|.
name|d
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QNetworkProxyQuery::operator!=(const QNetworkProxyQuery&other) const      Returns true if this QNetworkProxyQuery object does not contain     the same data as \a other. */
end_comment
begin_comment
comment|/*!     Returns the query type. */
end_comment
begin_function
DECL|function|queryType
name|QNetworkProxyQuery
operator|::
name|QueryType
name|QNetworkProxyQuery
operator|::
name|queryType
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|d
operator|->
name|type
else|:
name|TcpSocket
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the query type of this object to be \a type. */
end_comment
begin_function
DECL|function|setQueryType
name|void
name|QNetworkProxyQuery
operator|::
name|setQueryType
parameter_list|(
name|QueryType
name|type
parameter_list|)
block|{
name|d
operator|->
name|type
operator|=
name|type
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the port number for the outgoing request or -1 if the port     number is not known.      If the query type is QNetworkProxyQuery::UrlRequest, this function     returns the port number of the URL being requested. In general,     frameworks will fill in the port number from their default values.      \sa peerHostName(), localPort(), setPeerPort() */
end_comment
begin_function
DECL|function|peerPort
name|int
name|QNetworkProxyQuery
operator|::
name|peerPort
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|d
operator|->
name|remote
operator|.
name|port
argument_list|()
else|:
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the requested port number for the outgoing connection to be     \a port. Valid values are 1 to 65535, or -1 to indicate that the     remote port number is unknown.      The peer port number can also be used to indicate the expected     port number of an incoming connection in the case of     QNetworkProxyQuery::UdpSocket or QNetworkProxyQuery::TcpServer     query types.      \sa peerPort(), setPeerHostName(), setLocalPort() */
end_comment
begin_function
DECL|function|setPeerPort
name|void
name|QNetworkProxyQuery
operator|::
name|setPeerPort
parameter_list|(
name|int
name|port
parameter_list|)
block|{
name|d
operator|->
name|remote
operator|.
name|setPort
argument_list|(
name|port
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the host name or IP address being of the outgoing     connection being requested, or an empty string if the remote     hostname is not known.      If the query type is QNetworkProxyQuery::UrlRequest, this function     returns the host component of the URL being requested.      \sa peerPort(), localPort(), setPeerHostName() */
end_comment
begin_function
DECL|function|peerHostName
name|QString
name|QNetworkProxyQuery
operator|::
name|peerHostName
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|d
operator|->
name|remote
operator|.
name|host
argument_list|()
else|:
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the hostname of the outgoing connection being requested to \a     hostname.  An empty hostname can be used to indicate that the     remote host is unknown.      The peer host name can also be used to indicate the expected     source address of an incoming connection in the case of     QNetworkProxyQuery::UdpSocket or QNetworkProxyQuery::TcpServer     query types.      \sa peerHostName(), setPeerPort(), setLocalPort() */
end_comment
begin_function
DECL|function|setPeerHostName
name|void
name|QNetworkProxyQuery
operator|::
name|setPeerHostName
parameter_list|(
specifier|const
name|QString
modifier|&
name|hostname
parameter_list|)
block|{
name|d
operator|->
name|remote
operator|.
name|setHost
argument_list|(
name|hostname
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the port number of the socket that will accept incoming     packets from remote servers or -1 if the port is not known.      \sa peerPort(), peerHostName(), setLocalPort() */
end_comment
begin_function
DECL|function|localPort
name|int
name|QNetworkProxyQuery
operator|::
name|localPort
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|d
operator|->
name|localPort
else|:
operator|-
literal|1
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the port number that the socket wishes to use locally to     accept incoming packets from remote servers to \a port. The local     port is most often used with the QNetworkProxyQuery::TcpServer     and QNetworkProxyQuery::UdpSocket query types.      Valid values are 0 to 65535 (with 0 indicating that any port     number will be acceptable) or -1, which means the local port     number is unknown or not applicable.      In some circumstances, for special protocols, it's the local port     number can also be used with a query of type     QNetworkProxyQuery::TcpSocket. When that happens, the socket is     indicating it wishes to use the port number \a port when     connecting to a remote host.      \sa localPort(), setPeerPort(), setPeerHostName() */
end_comment
begin_function
DECL|function|setLocalPort
name|void
name|QNetworkProxyQuery
operator|::
name|setLocalPort
parameter_list|(
name|int
name|port
parameter_list|)
block|{
name|d
operator|->
name|localPort
operator|=
name|port
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the protocol tag for this QNetworkProxyQuery object, or an     empty QString in case the protocol tag is unknown.      In the case of queries of type QNetworkProxyQuery::UrlRequest,     this function returns the value of the scheme component of the     URL.      \sa setProtocolTag(), url() */
end_comment
begin_function
DECL|function|protocolTag
name|QString
name|QNetworkProxyQuery
operator|::
name|protocolTag
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|d
operator|->
name|remote
operator|.
name|scheme
argument_list|()
else|:
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the protocol tag for this QNetworkProxyQuery object to be \a     protocolTag.      The protocol tag is an arbitrary string that indicates which     protocol is being talked over the socket, such as "http", "xmpp",     "telnet", etc. The protocol tag is used by the backend to     return a request that is more specific to the protocol in     question: for example, a HTTP connection could be use a caching     HTTP proxy server, while all other connections use a more powerful     SOCKSv5 proxy server.      \sa protocolTag() */
end_comment
begin_function
DECL|function|setProtocolTag
name|void
name|QNetworkProxyQuery
operator|::
name|setProtocolTag
parameter_list|(
specifier|const
name|QString
modifier|&
name|protocolTag
parameter_list|)
block|{
name|d
operator|->
name|remote
operator|.
name|setScheme
argument_list|(
name|protocolTag
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the URL component of this QNetworkProxyQuery object in     case of a query of type QNetworkProxyQuery::UrlRequest.      \sa setUrl() */
end_comment
begin_function
DECL|function|url
name|QUrl
name|QNetworkProxyQuery
operator|::
name|url
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|d
operator|->
name|remote
else|:
name|QUrl
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the URL component of this QNetworkProxyQuery object to be \a     url. Setting the URL will also set the protocol tag, the remote     host name and port number. This is done so as to facilitate the     implementation of the code that determines the proxy server to be     used.      \sa url(), peerHostName(), peerPort() */
end_comment
begin_function
DECL|function|setUrl
name|void
name|QNetworkProxyQuery
operator|::
name|setUrl
parameter_list|(
specifier|const
name|QUrl
modifier|&
name|url
parameter_list|)
block|{
name|d
operator|->
name|remote
operator|=
name|url
expr_stmt|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_BEARERMANAGEMENT
end_ifndef
begin_comment
comment|/*!     Returns the network configuration component of the query.      \sa setNetworkConfiguration() */
end_comment
begin_function
DECL|function|networkConfiguration
name|QNetworkConfiguration
name|QNetworkProxyQuery
operator|::
name|networkConfiguration
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|d
operator|->
name|config
else|:
name|QNetworkConfiguration
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     Sets the network configuration component of this QNetworkProxyQuery     object to be \a networkConfiguration. The network configuration can     be used to return different proxy settings based on the network in     use, for example WLAN vs cellular networks on a mobile phone.      In the case of "user choice" or "service network" configurations,     you should first start the QNetworkSession and obtain the active     configuration from its properties.      \sa networkConfiguration() */
end_comment
begin_function
DECL|function|setNetworkConfiguration
name|void
name|QNetworkProxyQuery
operator|::
name|setNetworkConfiguration
parameter_list|(
specifier|const
name|QNetworkConfiguration
modifier|&
name|networkConfiguration
parameter_list|)
block|{
name|d
operator|->
name|config
operator|=
name|networkConfiguration
expr_stmt|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!     \class QNetworkProxyFactory     \brief The QNetworkProxyFactory class provides fine-grained proxy selection.     \since 4.5      \ingroup network     \inmodule QtNetwork      QNetworkProxyFactory is an extension to QNetworkProxy, allowing     applications to have a more fine-grained control over which proxy     servers are used, depending on the socket requesting the     proxy. This allows an application to apply different settings,     according to the protocol or destination hostname, for instance.      QNetworkProxyFactory can be set globally for an application, in     which case it will override any global proxies set with     QNetworkProxy::setApplicationProxy(). If set globally, any sockets     created with Qt will query the factory to determine the proxy to     be used.      A factory can also be set in certain frameworks that support     multiple connections, such as QNetworkAccessManager. When set on     such object, the factory will be queried for sockets created by     that framework only.      \section1 System Proxies      You can configure a factory to use the system proxy's settings.     Call the setUseSystemConfiguration() function with true to enable     this behavior, or false to disable it.      Similarly, you can use a factory to make queries directly to the     system proxy by calling its systemProxyForQuery() function.      \warning Depending on the configuration of the user's system, the     use of system proxy features on certain platforms may be subject     to limitations. The systemProxyForQuery() documentation contains a     list of these limitations for those platforms that are affected. */
end_comment
begin_comment
comment|/*!     Creates a QNetworkProxyFactory object.      Since QNetworkProxyFactory is an abstract class, you cannot create     objects of type QNetworkProxyFactory directly. */
end_comment
begin_constructor
DECL|function|QNetworkProxyFactory
name|QNetworkProxyFactory
operator|::
name|QNetworkProxyFactory
parameter_list|()
block|{ }
end_constructor
begin_comment
comment|/*!     Destroys the QNetworkProxyFactory object. */
end_comment
begin_destructor
DECL|function|~QNetworkProxyFactory
name|QNetworkProxyFactory
operator|::
name|~
name|QNetworkProxyFactory
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     \since 4.6      Enables the use of the platform-specific proxy settings, and only those.     See systemProxyForQuery() for more information.      Internally, this method (when called with \a enable set to true)     sets an application-wide proxy factory. For this reason, this method     is mutually exclusive with setApplicationProxyFactory(): calling     setApplicationProxyFactory() overrides the use of the system-wide proxy,     and calling setUseSystemConfiguration() overrides any     application proxy or proxy factory that was previously set.      \note See the systemProxyForQuery() documentation for a list of     limitations related to the use of system proxies. */
end_comment
begin_function
DECL|function|setUseSystemConfiguration
name|void
name|QNetworkProxyFactory
operator|::
name|setUseSystemConfiguration
parameter_list|(
name|bool
name|enable
parameter_list|)
block|{
if|if
condition|(
name|enable
condition|)
block|{
name|setApplicationProxyFactory
argument_list|(
operator|new
name|QSystemConfigurationProxyFactory
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|setApplicationProxyFactory
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     Sets the application-wide proxy factory to be \a factory. This     function will take ownership of that object and will delete it     when necessary.      The application-wide proxy is used as a last-resort when all other     proxy selection requests returned QNetworkProxy::DefaultProxy. For     example, QTcpSocket objects can have a proxy set with     QTcpSocket::setProxy, but if none is set, the proxy factory class     set with this function will be queried.      If you set a proxy factory with this function, any application     level proxies set with QNetworkProxy::setApplicationProxy will be     overridden.      \sa QNetworkProxy::setApplicationProxy(),         QAbstractSocket::proxy(), QAbstractSocket::setProxy() */
end_comment
begin_function
DECL|function|setApplicationProxyFactory
name|void
name|QNetworkProxyFactory
operator|::
name|setApplicationProxyFactory
parameter_list|(
name|QNetworkProxyFactory
modifier|*
name|factory
parameter_list|)
block|{
if|if
condition|(
name|globalNetworkProxy
argument_list|()
condition|)
name|globalNetworkProxy
argument_list|()
operator|->
name|setApplicationProxyFactory
argument_list|(
name|factory
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \fn QList<QNetworkProxy> QNetworkProxyFactory::queryProxy(const QNetworkProxyQuery&query)      This function takes the query request, \a query,     examines the details of the type of socket or request and returns     a list of QNetworkProxy objects that indicate the proxy servers to     be used, in order of preference.      When reimplementing this class, take care to return at least one     element.      If you cannot determine a better proxy alternative, use     QNetworkProxy::DefaultProxy, which tells the code querying for a     proxy to use a higher alternative. For example, if this factory is     set to a QNetworkAccessManager object, DefaultProxy will tell it     to query the application-level proxy settings.      If this factory is set as the application proxy factory,     DefaultProxy and NoProxy will have the same meaning. */
end_comment
begin_comment
comment|/*!     \fn QList<QNetworkProxy> QNetworkProxyFactory::systemProxyForQuery(const QNetworkProxyQuery&query)      This function takes the query request, \a query,     examines the details of the type of socket or request and returns     a list of QNetworkProxy objects that indicate the proxy servers to     be used, in order of preference.      This function can be used to determine the platform-specific proxy     settings. This function will use the libraries provided by the     operating system to determine the proxy for a given connection, if     such libraries exist. If they don't, this function will just return a     QNetworkProxy of type QNetworkProxy::NoProxy.      On Windows, this function will use the WinHTTP DLL functions. Despite     its name, Microsoft suggests using it for all applications that     require network connections, not just HTTP. This will respect the     proxy settings set on the registry with the proxycfg.exe tool. If     those settings are not found, this function will attempt to obtain     Internet Explorer's settings and use them.      On MacOS X, this function will obtain the proxy settings using the     SystemConfiguration framework from Apple. It will apply the FTP,     HTTP and HTTPS proxy configurations for queries that contain the     protocol tag "ftp", "http" and "https", respectively. If the SOCKS     proxy is enabled in that configuration, this function will use the     SOCKS server for all queries. If SOCKS isn't enabled, it will use     the HTTPS proxy for all TcpSocket and UrlRequest queries.      On BlackBerry, this function obtains proxy settings for the default     configuration using system configuration. The type will be set based on     protocol tag "http", "https", "ftp", respectively. By default, it     assumes http type. Proxy username and password are also set during     the query using system configuration.      On other systems, this function will pick up proxy settings from     the "http_proxy" environment variable. This variable must be a URL     using one of the following schemes: "http", "socks5" or "socks5h".      \section1 Limitations      These are the limitations for the current version of this     function. Future versions of Qt may lift some of the limitations     listed here.      \list     \li On MacOS X, this function will ignore the Proxy Auto Configuration     settings, since it cannot execute the associated ECMAScript code.      \li On Windows platforms, this function may take several seconds to     execute depending on the configuration of the user's system.      \li On BlackBerry, only UrlRequest queries are supported. SOCKS is     not supported. The proxy credentials are only retrieved for the     default configuration.     \endlist */
end_comment
begin_comment
comment|/*!     This function takes the query request, \a query,     examines the details of the type of socket or request and returns     a list of QNetworkProxy objects that indicate the proxy servers to     be used, in order of preference. */
end_comment
begin_function
DECL|function|proxyForQuery
name|QList
argument_list|<
name|QNetworkProxy
argument_list|>
name|QNetworkProxyFactory
operator|::
name|proxyForQuery
parameter_list|(
specifier|const
name|QNetworkProxyQuery
modifier|&
name|query
parameter_list|)
block|{
if|if
condition|(
operator|!
name|globalNetworkProxy
argument_list|()
condition|)
return|return
name|QList
argument_list|<
name|QNetworkProxy
argument_list|>
argument_list|()
operator|<<
name|QNetworkProxy
argument_list|(
name|QNetworkProxy
operator|::
name|NoProxy
argument_list|)
return|;
return|return
name|globalNetworkProxy
argument_list|()
operator|->
name|proxyForQuery
argument_list|(
name|query
argument_list|)
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DEBUG_STREAM
end_ifndef
begin_comment
comment|/*!     \since 5.0     Outputs a QNetworkProxy details to a debug stream */
end_comment
begin_function
DECL|function|operator <<
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|debug
parameter_list|,
specifier|const
name|QNetworkProxy
modifier|&
name|proxy
parameter_list|)
block|{
name|QNetworkProxy
operator|::
name|ProxyType
name|type
init|=
name|proxy
operator|.
name|type
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|QNetworkProxy
operator|::
name|NoProxy
case|:
name|debug
operator|<<
literal|"NoProxy "
expr_stmt|;
break|break;
case|case
name|QNetworkProxy
operator|::
name|DefaultProxy
case|:
name|debug
operator|<<
literal|"DefaultProxy "
expr_stmt|;
break|break;
case|case
name|QNetworkProxy
operator|::
name|Socks5Proxy
case|:
name|debug
operator|<<
literal|"Socks5Proxy "
expr_stmt|;
break|break;
case|case
name|QNetworkProxy
operator|::
name|HttpProxy
case|:
name|debug
operator|<<
literal|"HttpProxy "
expr_stmt|;
break|break;
case|case
name|QNetworkProxy
operator|::
name|HttpCachingProxy
case|:
name|debug
operator|<<
literal|"HttpCachingProxy "
expr_stmt|;
break|break;
case|case
name|QNetworkProxy
operator|::
name|FtpCachingProxy
case|:
name|debug
operator|<<
literal|"FtpCachingProxy "
expr_stmt|;
break|break;
default|default:
name|debug
operator|<<
literal|"Unknown proxy "
operator|<<
name|int
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
block|}
name|debug
operator|<<
literal|"\""
operator|<<
name|proxy
operator|.
name|hostName
argument_list|()
operator|<<
literal|":"
operator|<<
name|proxy
operator|.
name|port
argument_list|()
operator|<<
literal|"\" "
expr_stmt|;
name|QNetworkProxy
operator|::
name|Capabilities
name|caps
init|=
name|proxy
operator|.
name|capabilities
argument_list|()
decl_stmt|;
name|QStringList
name|scaps
decl_stmt|;
if|if
condition|(
name|caps
operator|&
name|QNetworkProxy
operator|::
name|TunnelingCapability
condition|)
name|scaps
operator|<<
name|QStringLiteral
argument_list|(
literal|"Tunnel"
argument_list|)
expr_stmt|;
if|if
condition|(
name|caps
operator|&
name|QNetworkProxy
operator|::
name|ListeningCapability
condition|)
name|scaps
operator|<<
name|QStringLiteral
argument_list|(
literal|"Listen"
argument_list|)
expr_stmt|;
if|if
condition|(
name|caps
operator|&
name|QNetworkProxy
operator|::
name|UdpTunnelingCapability
condition|)
name|scaps
operator|<<
name|QStringLiteral
argument_list|(
literal|"UDP"
argument_list|)
expr_stmt|;
if|if
condition|(
name|caps
operator|&
name|QNetworkProxy
operator|::
name|CachingCapability
condition|)
name|scaps
operator|<<
name|QStringLiteral
argument_list|(
literal|"Caching"
argument_list|)
expr_stmt|;
if|if
condition|(
name|caps
operator|&
name|QNetworkProxy
operator|::
name|HostNameLookupCapability
condition|)
name|scaps
operator|<<
name|QStringLiteral
argument_list|(
literal|"NameLookup"
argument_list|)
expr_stmt|;
name|debug
operator|<<
literal|"["
operator|<<
name|scaps
operator|.
name|join
argument_list|(
name|QLatin1Char
argument_list|(
literal|' '
argument_list|)
argument_list|)
operator|<<
literal|"]"
expr_stmt|;
return|return
name|debug
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_macro
name|QT_END_NAMESPACE
end_macro
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// QT_NO_NETWORKPROXY
end_comment
end_unit
