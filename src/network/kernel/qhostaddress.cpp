begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtNetwork module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|"qhostaddress.h"
end_include
begin_include
include|#
directive|include
file|"qhostaddress_p.h"
end_include
begin_include
include|#
directive|include
file|"private/qipaddress_p.h"
end_include
begin_include
include|#
directive|include
file|"qdebug.h"
end_include
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WIN
argument_list|)
end_if
begin_include
include|#
directive|include
file|<winsock2.h>
end_include
begin_else
else|#
directive|else
end_else
begin_include
include|#
directive|include
file|<netinet/in.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_include
include|#
directive|include
file|"qplatformdefs.h"
end_include
begin_include
include|#
directive|include
file|"qstringlist.h"
end_include
begin_include
include|#
directive|include
file|"qendian.h"
end_include
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATASTREAM
end_ifndef
begin_include
include|#
directive|include
file|<qdatastream.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_ifdef
ifdef|#
directive|ifdef
name|QT_LINUXBASE
end_ifdef
begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_macro
name|QT_BEGIN_NAMESPACE
end_macro
begin_define
DECL|macro|QT_ENSURE_PARSED
define|#
directive|define
name|QT_ENSURE_PARSED
parameter_list|(
name|a
parameter_list|)
define|\
value|do { \         if (!(a)->d->isParsed) \             (a)->d->parse(); \     } while (0)
end_define
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_WIN
end_ifdef
begin_comment
comment|// sockaddr_in6 size changed between old and new SDK
end_comment
begin_comment
comment|// Only the new version is the correct one, so always
end_comment
begin_comment
comment|// use this structure.
end_comment
begin_if
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
end_if
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|u_char
argument_list|)
end_if
begin_define
DECL|macro|u_char
define|#
directive|define
name|u_char
value|unsigned char
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|u_short
argument_list|)
end_if
begin_define
DECL|macro|u_short
define|#
directive|define
name|u_short
value|unsigned short
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|u_long
argument_list|)
end_if
begin_define
DECL|macro|u_long
define|#
directive|define
name|u_long
value|unsigned long
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_endif
endif|#
directive|endif
end_endif
begin_struct
DECL|struct|qt_in6_addr
struct|struct
name|qt_in6_addr
block|{
DECL|member|qt_s6_addr
name|u_char
name|qt_s6_addr
index|[
literal|16
index|]
decl_stmt|;
block|}
struct|;
end_struct
begin_typedef
typedef|typedef
struct|struct
block|{
DECL|member|sin6_family
name|short
name|sin6_family
decl_stmt|;
comment|/* AF_INET6 */
DECL|member|sin6_port
name|u_short
name|sin6_port
decl_stmt|;
comment|/* Transport level port number */
DECL|member|sin6_flowinfo
name|u_long
name|sin6_flowinfo
decl_stmt|;
comment|/* IPv6 flow information */
DECL|member|sin6_addr
name|struct
name|qt_in6_addr
name|sin6_addr
decl_stmt|;
comment|/* IPv6 address */
DECL|member|sin6_scope_id
name|u_long
name|sin6_scope_id
decl_stmt|;
comment|/* set of interfaces for a scope */
block|}
DECL|typedef|qt_sockaddr_in6
name|qt_sockaddr_in6
typedef|;
end_typedef
begin_else
else|#
directive|else
end_else
begin_define
define|#
directive|define
name|qt_sockaddr_in6
value|sockaddr_in6
end_define
begin_define
define|#
directive|define
name|qt_s6_addr
value|s6_addr
end_define
begin_endif
endif|#
directive|endif
end_endif
begin_class
DECL|class|QHostAddressPrivate
class|class
name|QHostAddressPrivate
block|{
public|public:
name|QHostAddressPrivate
parameter_list|()
constructor_decl|;
name|void
name|setAddress
parameter_list|(
name|quint32
name|a_
init|=
literal|0
parameter_list|)
function_decl|;
name|void
name|setAddress
parameter_list|(
specifier|const
name|quint8
modifier|*
name|a_
parameter_list|)
function_decl|;
name|void
name|setAddress
parameter_list|(
specifier|const
name|Q_IPV6ADDR
modifier|&
name|a_
parameter_list|)
function_decl|;
name|bool
name|parse
parameter_list|()
function_decl|;
name|void
name|clear
parameter_list|()
function_decl|;
DECL|member|ipString
name|QString
name|ipString
decl_stmt|;
DECL|member|scopeId
name|QString
name|scopeId
decl_stmt|;
DECL|member|a
name|quint32
name|a
decl_stmt|;
comment|// IPv4 address
DECL|member|a6
name|Q_IPV6ADDR
name|a6
decl_stmt|;
comment|// IPv6 address
DECL|member|protocol
name|QAbstractSocket
operator|::
name|NetworkLayerProtocol
name|protocol
decl_stmt|;
DECL|member|isParsed
name|bool
name|isParsed
decl_stmt|;
friend|friend
class_decl|class
name|QHostAddress
class_decl|;
block|}
class|;
end_class
begin_constructor
DECL|function|QHostAddressPrivate
name|QHostAddressPrivate
operator|::
name|QHostAddressPrivate
parameter_list|()
member_init_list|:
name|a
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|protocol
argument_list|(
name|QAbstractSocket
operator|::
name|UnknownNetworkLayerProtocol
argument_list|)
member_init_list|,
name|isParsed
argument_list|(
literal|true
argument_list|)
block|{
name|memset
argument_list|(
operator|&
name|a6
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|a6
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_function
DECL|function|setAddress
name|void
name|QHostAddressPrivate
operator|::
name|setAddress
parameter_list|(
name|quint32
name|a_
parameter_list|)
block|{
name|a
operator|=
name|a_
expr_stmt|;
comment|//create mapped address
name|memset
argument_list|(
operator|&
name|a6
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|a6
argument_list|)
argument_list|)
expr_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|15
init|;
name|a_
operator|!=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|a6
index|[
name|i
index|]
operator|=
name|a_
operator|&
literal|0xFF
expr_stmt|;
name|a_
operator|>>=
literal|8
expr_stmt|;
block|}
name|Q_ASSERT
argument_list|(
name|i
operator|>=
literal|11
argument_list|)
expr_stmt|;
name|a6
index|[
literal|11
index|]
operator|=
literal|0xFF
expr_stmt|;
name|a6
index|[
literal|10
index|]
operator|=
literal|0xFF
expr_stmt|;
name|protocol
operator|=
name|QAbstractSocket
operator|::
name|IPv4Protocol
expr_stmt|;
name|isParsed
operator|=
literal|true
expr_stmt|;
block|}
end_function
begin_function
DECL|function|parseMappedAddress
specifier|static
name|bool
name|parseMappedAddress
parameter_list|(
name|quint32
modifier|&
name|a
parameter_list|,
specifier|const
name|Q_IPV6ADDR
modifier|&
name|a6
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|a6
index|[
name|i
index|]
condition|)
return|return
literal|false
return|;
for|for
control|(
init|;
name|i
operator|<
literal|12
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|a6
index|[
name|i
index|]
operator|!=
literal|0xFF
condition|)
return|return
literal|false
return|;
name|a
operator|=
operator|(
name|a6
index|[
literal|12
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|a6
index|[
literal|13
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|a6
index|[
literal|14
index|]
operator|<<
literal|8
operator|)
operator||
name|a6
index|[
literal|15
index|]
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|setAddress
name|void
name|QHostAddressPrivate
operator|::
name|setAddress
parameter_list|(
specifier|const
name|quint8
modifier|*
name|a_
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
name|a6
index|[
name|i
index|]
operator|=
name|a_
index|[
name|i
index|]
expr_stmt|;
name|a
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|parseMappedAddress
argument_list|(
name|a
argument_list|,
name|a6
argument_list|)
condition|)
name|protocol
operator|=
name|QAbstractSocket
operator|::
name|IPv4Protocol
expr_stmt|;
else|else
name|protocol
operator|=
name|QAbstractSocket
operator|::
name|IPv6Protocol
expr_stmt|;
name|isParsed
operator|=
literal|true
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setAddress
name|void
name|QHostAddressPrivate
operator|::
name|setAddress
parameter_list|(
specifier|const
name|Q_IPV6ADDR
modifier|&
name|a_
parameter_list|)
block|{
name|a6
operator|=
name|a_
expr_stmt|;
name|a
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|parseMappedAddress
argument_list|(
name|a
argument_list|,
name|a6
argument_list|)
condition|)
name|protocol
operator|=
name|QAbstractSocket
operator|::
name|IPv4Protocol
expr_stmt|;
else|else
name|protocol
operator|=
name|QAbstractSocket
operator|::
name|IPv6Protocol
expr_stmt|;
name|isParsed
operator|=
literal|true
expr_stmt|;
block|}
end_function
begin_function
DECL|function|parseIp6
specifier|static
name|bool
name|parseIp6
parameter_list|(
specifier|const
name|QString
modifier|&
name|address
parameter_list|,
name|QIPAddressUtils
operator|::
name|IPv6Address
modifier|&
name|addr
parameter_list|,
name|QString
modifier|*
name|scopeId
parameter_list|)
block|{
name|QString
name|tmp
init|=
name|address
decl_stmt|;
name|int
name|scopeIdPos
init|=
name|tmp
operator|.
name|lastIndexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'%'
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|scopeIdPos
operator|!=
operator|-
literal|1
condition|)
block|{
operator|*
name|scopeId
operator|=
name|tmp
operator|.
name|mid
argument_list|(
name|scopeIdPos
operator|+
literal|1
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|chop
argument_list|(
name|tmp
operator|.
name|size
argument_list|()
operator|-
name|scopeIdPos
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|scopeId
operator|->
name|clear
argument_list|()
expr_stmt|;
block|}
return|return
name|QIPAddressUtils
operator|::
name|parseIp6
argument_list|(
name|addr
argument_list|,
name|tmp
operator|.
name|constBegin
argument_list|()
argument_list|,
name|tmp
operator|.
name|constEnd
argument_list|()
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|parse
name|bool
name|QHostAddressPrivate
operator|::
name|parse
parameter_list|()
block|{
name|isParsed
operator|=
literal|true
expr_stmt|;
name|protocol
operator|=
name|QAbstractSocket
operator|::
name|UnknownNetworkLayerProtocol
expr_stmt|;
name|QString
name|a
init|=
name|ipString
operator|.
name|simplified
argument_list|()
decl_stmt|;
if|if
condition|(
name|a
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
literal|false
return|;
comment|// All IPv6 addresses contain a ':', and may contain a '.'.
if|if
condition|(
name|a
operator|.
name|contains
argument_list|(
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
argument_list|)
condition|)
block|{
name|quint8
name|maybeIp6
index|[
literal|16
index|]
decl_stmt|;
if|if
condition|(
name|parseIp6
argument_list|(
name|a
argument_list|,
name|maybeIp6
argument_list|,
operator|&
name|scopeId
argument_list|)
condition|)
block|{
name|setAddress
argument_list|(
name|maybeIp6
argument_list|)
expr_stmt|;
name|protocol
operator|=
name|QAbstractSocket
operator|::
name|IPv6Protocol
expr_stmt|;
return|return
literal|true
return|;
block|}
block|}
name|quint32
name|maybeIp4
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|QIPAddressUtils
operator|::
name|parseIp4
argument_list|(
name|maybeIp4
argument_list|,
name|a
operator|.
name|constBegin
argument_list|()
argument_list|,
name|a
operator|.
name|constEnd
argument_list|()
argument_list|)
condition|)
block|{
name|setAddress
argument_list|(
name|maybeIp4
argument_list|)
expr_stmt|;
name|protocol
operator|=
name|QAbstractSocket
operator|::
name|IPv4Protocol
expr_stmt|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_function
DECL|function|clear
name|void
name|QHostAddressPrivate
operator|::
name|clear
parameter_list|()
block|{
name|a
operator|=
literal|0
expr_stmt|;
name|protocol
operator|=
name|QAbstractSocket
operator|::
name|UnknownNetworkLayerProtocol
expr_stmt|;
name|isParsed
operator|=
literal|true
expr_stmt|;
name|memset
argument_list|(
operator|&
name|a6
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|a6
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|setAddress
name|bool
name|QNetmaskAddress
operator|::
name|setAddress
parameter_list|(
specifier|const
name|QString
modifier|&
name|address
parameter_list|)
block|{
name|length
operator|=
operator|-
literal|1
expr_stmt|;
name|QHostAddress
name|other
decl_stmt|;
return|return
name|other
operator|.
name|setAddress
argument_list|(
name|address
argument_list|)
operator|&&
name|setAddress
argument_list|(
name|other
argument_list|)
return|;
block|}
end_function
begin_function
DECL|function|setAddress
name|bool
name|QNetmaskAddress
operator|::
name|setAddress
parameter_list|(
specifier|const
name|QHostAddress
modifier|&
name|address
parameter_list|)
block|{
specifier|static
specifier|const
name|quint8
name|zeroes
index|[
literal|16
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
union|union
block|{
name|quint32
name|v4
decl_stmt|;
name|quint8
name|v6
index|[
literal|16
index|]
decl_stmt|;
block|}
name|ip
union|;
name|int
name|netmask
init|=
literal|0
decl_stmt|;
name|quint8
modifier|*
name|ptr
init|=
name|ip
operator|.
name|v6
decl_stmt|;
name|quint8
modifier|*
name|end
decl_stmt|;
name|length
operator|=
operator|-
literal|1
expr_stmt|;
name|QHostAddress
operator|::
name|operator
name|=
parameter_list|(
name|address
parameter_list|)
function_decl|;
if|if
condition|(
name|d
operator|->
name|protocol
operator|==
name|QAbstractSocket
operator|::
name|IPv4Protocol
condition|)
block|{
name|ip
operator|.
name|v4
operator|=
name|qToBigEndian
argument_list|(
name|d
operator|->
name|a
argument_list|)
expr_stmt|;
name|end
operator|=
name|ptr
operator|+
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|protocol
operator|==
name|QAbstractSocket
operator|::
name|IPv6Protocol
condition|)
block|{
name|memcpy
argument_list|(
name|ip
operator|.
name|v6
argument_list|,
name|d
operator|->
name|a6
operator|.
name|c
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|end
operator|=
name|ptr
operator|+
literal|16
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|clear
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
while|while
condition|(
name|ptr
operator|<
name|end
condition|)
block|{
switch|switch
condition|(
operator|*
name|ptr
condition|)
block|{
case|case
literal|255
case|:
name|netmask
operator|+=
literal|8
expr_stmt|;
operator|++
name|ptr
expr_stmt|;
continue|continue;
default|default:
name|d
operator|->
name|clear
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
comment|// invalid IP-style netmask
comment|// the rest always falls through
case|case
literal|254
case|:
operator|++
name|netmask
expr_stmt|;
case|case
literal|252
case|:
operator|++
name|netmask
expr_stmt|;
case|case
literal|248
case|:
operator|++
name|netmask
expr_stmt|;
case|case
literal|240
case|:
operator|++
name|netmask
expr_stmt|;
case|case
literal|224
case|:
operator|++
name|netmask
expr_stmt|;
case|case
literal|192
case|:
operator|++
name|netmask
expr_stmt|;
case|case
literal|128
case|:
operator|++
name|netmask
expr_stmt|;
case|case
literal|0
case|:
break|break;
block|}
break|break;
block|}
comment|// confirm that the rest is only zeroes
if|if
condition|(
name|ptr
operator|<
name|end
operator|&&
name|memcmp
argument_list|(
name|ptr
operator|+
literal|1
argument_list|,
name|zeroes
argument_list|,
name|end
operator|-
name|ptr
operator|-
literal|1
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|d
operator|->
name|clear
argument_list|()
expr_stmt|;
return|return
literal|false
return|;
block|}
name|length
operator|=
name|netmask
expr_stmt|;
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|clearBits
specifier|static
name|void
name|clearBits
parameter_list|(
name|quint8
modifier|*
name|where
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|end
operator|==
literal|32
operator|||
name|end
operator|==
literal|128
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
operator|==
name|end
condition|)
return|return;
comment|// for the byte where 'start' is, clear the lower bits only
name|quint8
name|bytemask
init|=
literal|256
operator|-
operator|(
literal|1
operator|<<
operator|(
literal|8
operator|-
operator|(
name|start
operator|&
literal|7
operator|)
operator|)
operator|)
decl_stmt|;
name|where
index|[
name|start
operator|/
literal|8
index|]
operator|&=
name|bytemask
expr_stmt|;
comment|// for the tail part, clear everything
name|memset
argument_list|(
name|where
operator|+
operator|(
name|start
operator|+
literal|7
operator|)
operator|/
literal|8
argument_list|,
literal|0
argument_list|,
name|end
operator|/
literal|8
operator|-
operator|(
name|start
operator|+
literal|7
operator|)
operator|/
literal|8
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|prefixLength
name|int
name|QNetmaskAddress
operator|::
name|prefixLength
parameter_list|()
specifier|const
block|{
return|return
name|length
return|;
block|}
end_function
begin_function
DECL|function|setPrefixLength
name|void
name|QNetmaskAddress
operator|::
name|setPrefixLength
parameter_list|(
name|QAbstractSocket
operator|::
name|NetworkLayerProtocol
name|proto
parameter_list|,
name|int
name|newLength
parameter_list|)
block|{
name|length
operator|=
name|newLength
expr_stmt|;
if|if
condition|(
name|length
argument_list|<
literal|0
operator|||
name|length
argument_list|>
argument_list|(
name|proto
operator|==
name|QAbstractSocket
operator|::
name|IPv4Protocol
condition|?
literal|32
else|:
name|proto
operator|==
name|QAbstractSocket
operator|::
name|IPv6Protocol
condition|?
literal|128
else|:
operator|-
literal|1
argument_list|)
condition|)
block|{
comment|// invalid information, reject
name|d
operator|->
name|protocol
operator|=
name|QAbstractSocket
operator|::
name|UnknownNetworkLayerProtocol
expr_stmt|;
name|length
operator|=
operator|-
literal|1
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|protocol
operator|=
name|proto
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|protocol
operator|==
name|QAbstractSocket
operator|::
name|IPv4Protocol
condition|)
block|{
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
name|d
operator|->
name|a
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|length
operator|==
literal|32
condition|)
block|{
name|d
operator|->
name|a
operator|=
name|quint32
argument_list|(
literal|0xffffffff
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|a
operator|=
name|quint32
argument_list|(
literal|0xffffffff
argument_list|)
operator|>>
operator|(
literal|32
operator|-
name|length
operator|)
operator|<<
operator|(
literal|32
operator|-
name|length
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|memset
argument_list|(
name|d
operator|->
name|a6
operator|.
name|c
argument_list|,
literal|0xFF
argument_list|,
sizeof|sizeof
argument_list|(
name|d
operator|->
name|a6
argument_list|)
argument_list|)
expr_stmt|;
name|clearBits
argument_list|(
name|d
operator|->
name|a6
operator|.
name|c
argument_list|,
name|length
argument_list|,
literal|128
argument_list|)
expr_stmt|;
block|}
block|}
end_function
begin_comment
comment|/*!     \class QHostAddress     \brief The QHostAddress class provides an IP address.     \ingroup network     \inmodule QtNetwork      This class holds an IPv4 or IPv6 address in a platform- and     protocol-independent manner.      QHostAddress is normally used with the QTcpSocket, QTcpServer,     and QUdpSocket to connect to a host or to set up a server.      A host address is set with setAddress(), and retrieved with     toIPv4Address(), toIPv6Address(), or toString(). You can check the     type with protocol().      \note Please note that QHostAddress does not do DNS lookups.     QHostInfo is needed for that.      The class also supports common predefined addresses: \l Null, \l     LocalHost, \l LocalHostIPv6, \l Broadcast, and \l Any.      \sa QHostInfo, QTcpSocket, QTcpServer, QUdpSocket */
end_comment
begin_comment
comment|/*! \enum QHostAddress::SpecialAddress      \value Null The null address object. Equivalent to QHostAddress().     \value LocalHost The IPv4 localhost address. Equivalent to QHostAddress("127.0.0.1").     \value LocalHostIPv6 The IPv6 localhost address. Equivalent to QHostAddress("::1").     \value Broadcast The IPv4 broadcast address. Equivalent to QHostAddress("255.255.255.255").     \value AnyIPv4 The IPv4 any-address. Equivalent to QHostAddress("0.0.0.0"). A socket bound with this address will listen only on IPv4 interaces.     \value AnyIPv6 The IPv6 any-address. Equivalent to QHostAddress("::"). A socket bound with this address will listen only on IPv6 interaces.     \value Any The dual stack any-address. A socket bound with this address will listen on both IPv4 and IPv6 interfaces. */
end_comment
begin_comment
comment|/*!  Constructs a host address object with the IP address 0.0.0.0.      \sa clear() */
end_comment
begin_constructor
DECL|function|QHostAddress
name|QHostAddress
operator|::
name|QHostAddress
parameter_list|()
member_init_list|:
name|d
argument_list|(
operator|new
name|QHostAddressPrivate
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Constructs a host address object with the IPv4 address \a ip4Addr. */
end_comment
begin_constructor
DECL|function|QHostAddress
name|QHostAddress
operator|::
name|QHostAddress
parameter_list|(
name|quint32
name|ip4Addr
parameter_list|)
member_init_list|:
name|d
argument_list|(
operator|new
name|QHostAddressPrivate
argument_list|)
block|{
name|setAddress
argument_list|(
name|ip4Addr
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a host address object with the IPv6 address \a ip6Addr.      \a ip6Addr must be a 16-byte array in network byte order (big     endian). */
end_comment
begin_constructor
DECL|function|QHostAddress
name|QHostAddress
operator|::
name|QHostAddress
parameter_list|(
name|quint8
modifier|*
name|ip6Addr
parameter_list|)
member_init_list|:
name|d
argument_list|(
operator|new
name|QHostAddressPrivate
argument_list|)
block|{
name|setAddress
argument_list|(
name|ip6Addr
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a host address object with the IPv6 address \a ip6Addr. */
end_comment
begin_constructor
DECL|function|QHostAddress
name|QHostAddress
operator|::
name|QHostAddress
parameter_list|(
specifier|const
name|Q_IPV6ADDR
modifier|&
name|ip6Addr
parameter_list|)
member_init_list|:
name|d
argument_list|(
operator|new
name|QHostAddressPrivate
argument_list|)
block|{
name|setAddress
argument_list|(
name|ip6Addr
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs an IPv4 or IPv6 address based on the string \a address     (e.g., "127.0.0.1").      \sa setAddress() */
end_comment
begin_constructor
DECL|function|QHostAddress
name|QHostAddress
operator|::
name|QHostAddress
parameter_list|(
specifier|const
name|QString
modifier|&
name|address
parameter_list|)
member_init_list|:
name|d
argument_list|(
operator|new
name|QHostAddressPrivate
argument_list|)
block|{
name|d
operator|->
name|ipString
operator|=
name|address
expr_stmt|;
name|d
operator|->
name|isParsed
operator|=
literal|false
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     \fn QHostAddress::QHostAddress(const sockaddr *sockaddr)      Constructs an IPv4 or IPv6 address using the address specified by     the native structure \a sockaddr.      \sa setAddress() */
end_comment
begin_constructor
DECL|function|QHostAddress
name|QHostAddress
operator|::
name|QHostAddress
parameter_list|(
specifier|const
name|struct
name|sockaddr
modifier|*
name|sockaddr
parameter_list|)
member_init_list|:
name|d
argument_list|(
operator|new
name|QHostAddressPrivate
argument_list|)
block|{
if|if
condition|(
name|sockaddr
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
name|setAddress
argument_list|(
name|htonl
argument_list|(
operator|(
operator|(
name|sockaddr_in
operator|*
operator|)
name|sockaddr
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sockaddr
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
name|setAddress
argument_list|(
operator|(
operator|(
name|qt_sockaddr_in6
operator|*
operator|)
name|sockaddr
operator|)
operator|->
name|sin6_addr
operator|.
name|qt_s6_addr
argument_list|)
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Constructs a copy of the given \a address. */
end_comment
begin_constructor
DECL|function|QHostAddress
name|QHostAddress
operator|::
name|QHostAddress
parameter_list|(
specifier|const
name|QHostAddress
modifier|&
name|address
parameter_list|)
member_init_list|:
name|d
argument_list|(
operator|new
name|QHostAddressPrivate
argument_list|(
operator|*
name|address
operator|.
name|d
operator|.
name|data
argument_list|()
argument_list|)
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!     Constructs a QHostAddress object for \a address. */
end_comment
begin_constructor
DECL|function|QHostAddress
name|QHostAddress
operator|::
name|QHostAddress
parameter_list|(
name|SpecialAddress
name|address
parameter_list|)
member_init_list|:
name|d
argument_list|(
operator|new
name|QHostAddressPrivate
argument_list|)
block|{
name|Q_IPV6ADDR
name|ip6
decl_stmt|;
name|memset
argument_list|(
operator|&
name|ip6
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|ip6
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|address
condition|)
block|{
case|case
name|Null
case|:
break|break;
case|case
name|Broadcast
case|:
name|d
operator|->
name|setAddress
argument_list|(
name|quint32
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LocalHost
case|:
name|d
operator|->
name|setAddress
argument_list|(
literal|0x7f000001
argument_list|)
expr_stmt|;
break|break;
case|case
name|LocalHostIPv6
case|:
name|ip6
index|[
literal|15
index|]
operator|=
literal|1
expr_stmt|;
name|d
operator|->
name|setAddress
argument_list|(
name|ip6
argument_list|)
expr_stmt|;
break|break;
case|case
name|AnyIPv4
case|:
name|setAddress
argument_list|(
literal|0u
argument_list|)
expr_stmt|;
break|break;
case|case
name|AnyIPv6
case|:
name|d
operator|->
name|setAddress
argument_list|(
name|ip6
argument_list|)
expr_stmt|;
break|break;
case|case
name|Any
case|:
name|d
operator|->
name|clear
argument_list|()
expr_stmt|;
name|d
operator|->
name|protocol
operator|=
name|QAbstractSocket
operator|::
name|AnyIPProtocol
expr_stmt|;
break|break;
block|}
block|}
end_constructor
begin_comment
comment|/*!     Destroys the host address object. */
end_comment
begin_destructor
DECL|function|~QHostAddress
name|QHostAddress
operator|::
name|~
name|QHostAddress
parameter_list|()
block|{ }
end_destructor
begin_comment
comment|/*!     Assigns another host \a address to this object, and returns a reference     to this object. */
end_comment
begin_function
DECL|function|operator =
name|QHostAddress
modifier|&
name|QHostAddress
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QHostAddress
modifier|&
name|address
parameter_list|)
block|{
operator|*
name|d
operator|.
name|data
argument_list|()
operator|=
operator|*
name|address
operator|.
name|d
operator|.
name|data
argument_list|()
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     Assigns the host address \a address to this object, and returns a     reference to this object.      \sa setAddress() */
end_comment
begin_function
DECL|function|operator =
name|QHostAddress
modifier|&
name|QHostAddress
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QString
modifier|&
name|address
parameter_list|)
block|{
name|setAddress
argument_list|(
name|address
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QHostAddress::operator!=(const QHostAddress&other) const     \since 4.2      Returns true if this host address is not the same as the \a other     address given; otherwise returns false. */
end_comment
begin_comment
comment|/*!     \fn bool QHostAddress::operator!=(SpecialAddress other) const      Returns true if this host address is not the same as the \a other     address given; otherwise returns false. */
end_comment
begin_comment
comment|/*!     Sets the host address to 0.0.0.0. */
end_comment
begin_function
DECL|function|clear
name|void
name|QHostAddress
operator|::
name|clear
parameter_list|()
block|{
name|d
operator|->
name|clear
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Set the IPv4 address specified by \a ip4Addr. */
end_comment
begin_function
DECL|function|setAddress
name|void
name|QHostAddress
operator|::
name|setAddress
parameter_list|(
name|quint32
name|ip4Addr
parameter_list|)
block|{
name|d
operator|->
name|setAddress
argument_list|(
name|ip4Addr
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Set the IPv6 address specified by \a ip6Addr.      \a ip6Addr must be an array of 16 bytes in network byte order     (high-order byte first). */
end_comment
begin_function
DECL|function|setAddress
name|void
name|QHostAddress
operator|::
name|setAddress
parameter_list|(
name|quint8
modifier|*
name|ip6Addr
parameter_list|)
block|{
name|d
operator|->
name|setAddress
argument_list|(
name|ip6Addr
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Set the IPv6 address specified by \a ip6Addr. */
end_comment
begin_function
DECL|function|setAddress
name|void
name|QHostAddress
operator|::
name|setAddress
parameter_list|(
specifier|const
name|Q_IPV6ADDR
modifier|&
name|ip6Addr
parameter_list|)
block|{
name|d
operator|->
name|setAddress
argument_list|(
name|ip6Addr
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     \overload      Sets the IPv4 or IPv6 address specified by the string     representation specified by \a address (e.g. "127.0.0.1").     Returns true and sets the address if the address was successfully     parsed; otherwise returns false. */
end_comment
begin_function
DECL|function|setAddress
name|bool
name|QHostAddress
operator|::
name|setAddress
parameter_list|(
specifier|const
name|QString
modifier|&
name|address
parameter_list|)
block|{
name|d
operator|->
name|ipString
operator|=
name|address
expr_stmt|;
return|return
name|d
operator|->
name|parse
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \fn void QHostAddress::setAddress(const sockaddr *sockaddr)     \overload      Sets the IPv4 or IPv6 address specified by the native structure \a     sockaddr.  Returns true and sets the address if the address was     successfully parsed; otherwise returns false. */
end_comment
begin_function
DECL|function|setAddress
name|void
name|QHostAddress
operator|::
name|setAddress
parameter_list|(
specifier|const
name|struct
name|sockaddr
modifier|*
name|sockaddr
parameter_list|)
block|{
name|clear
argument_list|()
expr_stmt|;
if|if
condition|(
name|sockaddr
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
name|setAddress
argument_list|(
name|htonl
argument_list|(
operator|(
operator|(
name|sockaddr_in
operator|*
operator|)
name|sockaddr
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sockaddr
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
name|setAddress
argument_list|(
operator|(
operator|(
name|qt_sockaddr_in6
operator|*
operator|)
name|sockaddr
operator|)
operator|->
name|sin6_addr
operator|.
name|qt_s6_addr
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns the IPv4 address as a number.      For example, if the address is 127.0.0.1, the returned value is     2130706433 (i.e. 0x7f000001).      This value is valid if the protocol() is     \l{QAbstractSocket::}{IPv4Protocol},     or if the protocol is     \l{QAbstractSocket::}{IPv6Protocol},     and the IPv6 address is an IPv4 mapped address. (RFC4291)      \sa toString() */
end_comment
begin_function
DECL|function|toIPv4Address
name|quint32
name|QHostAddress
operator|::
name|toIPv4Address
parameter_list|()
specifier|const
block|{
name|QT_ENSURE_PARSED
argument_list|(
name|this
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|a
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the network layer protocol of the host address. */
end_comment
begin_function
DECL|function|protocol
name|QAbstractSocket
operator|::
name|NetworkLayerProtocol
name|QHostAddress
operator|::
name|protocol
parameter_list|()
specifier|const
block|{
name|QT_ENSURE_PARSED
argument_list|(
name|this
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|protocol
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the IPv6 address as a Q_IPV6ADDR structure. The structure     consists of 16 unsigned characters.      \snippet code/src_network_kernel_qhostaddress.cpp 0      This value is valid if the protocol() is     \l{QAbstractSocket::}{IPv6Protocol}.     If the protocol is     \l{QAbstractSocket::}{IPv4Protocol},     then the address is returned an an IPv4 mapped IPv6 address. (RFC4291)      \sa toString() */
end_comment
begin_function
DECL|function|toIPv6Address
name|Q_IPV6ADDR
name|QHostAddress
operator|::
name|toIPv6Address
parameter_list|()
specifier|const
block|{
name|QT_ENSURE_PARSED
argument_list|(
name|this
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|a6
return|;
block|}
end_function
begin_comment
comment|/*!     Returns the address as a string.      For example, if the address is the IPv4 address 127.0.0.1, the     returned string is "127.0.0.1". For IPv6 the string format will     follow the RFC5952 recommendation.     For QHostAddress::Any, its IPv4 address will be returned ("0.0.0.0")      \sa toIPv4Address() */
end_comment
begin_function
DECL|function|toString
name|QString
name|QHostAddress
operator|::
name|toString
parameter_list|()
specifier|const
block|{
name|QT_ENSURE_PARSED
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|protocol
operator|==
name|QAbstractSocket
operator|::
name|IPv4Protocol
operator|||
name|d
operator|->
name|protocol
operator|==
name|QAbstractSocket
operator|::
name|AnyIPProtocol
condition|)
block|{
name|quint32
name|i
init|=
name|toIPv4Address
argument_list|()
decl_stmt|;
name|QString
name|s
decl_stmt|;
name|QIPAddressUtils
operator|::
name|toString
argument_list|(
name|s
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
if|if
condition|(
name|d
operator|->
name|protocol
operator|==
name|QAbstractSocket
operator|::
name|IPv6Protocol
condition|)
block|{
name|QString
name|s
decl_stmt|;
name|QIPAddressUtils
operator|::
name|toString
argument_list|(
name|s
argument_list|,
name|d
operator|->
name|a6
operator|.
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|d
operator|->
name|scopeId
operator|.
name|isEmpty
argument_list|()
condition|)
name|s
operator|.
name|append
argument_list|(
name|QLatin1Char
argument_list|(
literal|'%'
argument_list|)
operator|+
name|d
operator|->
name|scopeId
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
return|return
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.1      Returns the scope ID of an IPv6 address. For IPv4 addresses, or if the     address does not contain a scope ID, an empty QString is returned.      The IPv6 scope ID specifies the scope of \e reachability for non-global     IPv6 addresses, limiting the area in which the address can be used. All     IPv6 addresses are associated with such a reachability scope. The scope ID     is used to disambiguate addresses that are not guaranteed to be globally     unique.      IPv6 specifies the following four levels of reachability:      \list      \li Node-local: Addresses that are only used for communicating with     services on the same interface (e.g., the loopback interface "::1").      \li Link-local: Addresses that are local to the network interface     (\e{link}). There is always one link-local address for each IPv6 interface     on your host. Link-local addresses ("fe80...") are generated from the MAC     address of the local network adaptor, and are not guaranteed to be unique.      \li Site-local: Addresses that are local to the site / private network     (e.g., the company intranet). Site-local addresses ("fec0...")  are     usually distributed by the site router, and are not guaranteed to be     unique outside of the local site.      \li Global: For globally routable addresses, such as public servers on the     Internet.      \endlist      When using a link-local or site-local address for IPv6 connections, you     must specify the scope ID. The scope ID for a link-local address is     usually the same as the interface name (e.g., "eth0", "en1") or number     (e.g., "1", "2").      \sa setScopeId() */
end_comment
begin_function
DECL|function|scopeId
name|QString
name|QHostAddress
operator|::
name|scopeId
parameter_list|()
specifier|const
block|{
name|QT_ENSURE_PARSED
argument_list|(
name|this
argument_list|)
expr_stmt|;
return|return
operator|(
name|d
operator|->
name|protocol
operator|==
name|QAbstractSocket
operator|::
name|IPv6Protocol
operator|)
condition|?
name|d
operator|->
name|scopeId
else|:
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.1      Sets the IPv6 scope ID of the address to \a id. If the address     protocol is not IPv6, this function does nothing. */
end_comment
begin_function
DECL|function|setScopeId
name|void
name|QHostAddress
operator|::
name|setScopeId
parameter_list|(
specifier|const
name|QString
modifier|&
name|id
parameter_list|)
block|{
name|QT_ENSURE_PARSED
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|protocol
operator|==
name|QAbstractSocket
operator|::
name|IPv6Protocol
condition|)
name|d
operator|->
name|scopeId
operator|=
name|id
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns true if this host address is the same as the \a other address     given; otherwise returns false. */
end_comment
begin_function
DECL|function|operator ==
name|bool
name|QHostAddress
operator|::
name|operator
name|==
parameter_list|(
specifier|const
name|QHostAddress
modifier|&
name|other
parameter_list|)
specifier|const
block|{
name|QT_ENSURE_PARSED
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|QT_ENSURE_PARSED
argument_list|(
operator|&
name|other
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|protocol
operator|==
name|QAbstractSocket
operator|::
name|IPv4Protocol
condition|)
return|return
name|other
operator|.
name|d
operator|->
name|protocol
operator|==
name|QAbstractSocket
operator|::
name|IPv4Protocol
operator|&&
name|d
operator|->
name|a
operator|==
name|other
operator|.
name|d
operator|->
name|a
return|;
if|if
condition|(
name|d
operator|->
name|protocol
operator|==
name|QAbstractSocket
operator|::
name|IPv6Protocol
condition|)
block|{
return|return
name|other
operator|.
name|d
operator|->
name|protocol
operator|==
name|QAbstractSocket
operator|::
name|IPv6Protocol
operator|&&
name|memcmp
argument_list|(
operator|&
name|d
operator|->
name|a6
argument_list|,
operator|&
name|other
operator|.
name|d
operator|->
name|a6
argument_list|,
sizeof|sizeof
argument_list|(
name|Q_IPV6ADDR
argument_list|)
argument_list|)
operator|==
literal|0
return|;
block|}
return|return
name|d
operator|->
name|protocol
operator|==
name|other
operator|.
name|d
operator|->
name|protocol
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if this host address is the same as the \a other     address given; otherwise returns false. */
end_comment
begin_function
DECL|function|operator ==
name|bool
name|QHostAddress
operator|::
name|operator
name|==
parameter_list|(
name|SpecialAddress
name|other
parameter_list|)
specifier|const
block|{
name|QT_ENSURE_PARSED
argument_list|(
name|this
argument_list|)
expr_stmt|;
name|QHostAddress
name|otherAddress
argument_list|(
name|other
argument_list|)
decl_stmt|;
name|QT_ENSURE_PARSED
argument_list|(
operator|&
name|otherAddress
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|protocol
operator|==
name|QAbstractSocket
operator|::
name|IPv4Protocol
condition|)
return|return
name|otherAddress
operator|.
name|d
operator|->
name|protocol
operator|==
name|QAbstractSocket
operator|::
name|IPv4Protocol
operator|&&
name|d
operator|->
name|a
operator|==
name|otherAddress
operator|.
name|d
operator|->
name|a
return|;
if|if
condition|(
name|d
operator|->
name|protocol
operator|==
name|QAbstractSocket
operator|::
name|IPv6Protocol
condition|)
block|{
return|return
name|otherAddress
operator|.
name|d
operator|->
name|protocol
operator|==
name|QAbstractSocket
operator|::
name|IPv6Protocol
operator|&&
name|memcmp
argument_list|(
operator|&
name|d
operator|->
name|a6
argument_list|,
operator|&
name|otherAddress
operator|.
name|d
operator|->
name|a6
argument_list|,
sizeof|sizeof
argument_list|(
name|Q_IPV6ADDR
argument_list|)
argument_list|)
operator|==
literal|0
return|;
block|}
if|if
condition|(
name|d
operator|->
name|protocol
operator|==
name|QAbstractSocket
operator|::
name|AnyIPProtocol
condition|)
return|return
name|other
operator|==
name|QHostAddress
operator|::
name|Any
return|;
return|return
name|int
argument_list|(
name|other
argument_list|)
operator|==
name|int
argument_list|(
name|Null
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if this host address is null (INADDR_ANY or in6addr_any).     The default constructor creates a null address, and that address is     not valid for any host or interface. */
end_comment
begin_function
DECL|function|isNull
name|bool
name|QHostAddress
operator|::
name|isNull
parameter_list|()
specifier|const
block|{
name|QT_ENSURE_PARSED
argument_list|(
name|this
argument_list|)
expr_stmt|;
return|return
name|d
operator|->
name|protocol
operator|==
name|QAbstractSocket
operator|::
name|UnknownNetworkLayerProtocol
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5      Returns true if this IP is in the subnet described by the network     prefix \a subnet and netmask \a netmask.      An IP is considered to belong to a subnet if it is contained     between the lowest and the highest address in that subnet. In the     case of IP version 4, the lowest address is the network address,     while the highest address is the broadcast address.      The \a subnet argument does not have to be the actual network     address (the lowest address in the subnet). It can be any valid IP     belonging to that subnet. In particular, if it is equal to the IP     address held by this object, this function will always return true     (provided the netmask is a valid value).      \sa parseSubnet() */
end_comment
begin_function
DECL|function|isInSubnet
name|bool
name|QHostAddress
operator|::
name|isInSubnet
parameter_list|(
specifier|const
name|QHostAddress
modifier|&
name|subnet
parameter_list|,
name|int
name|netmask
parameter_list|)
specifier|const
block|{
name|QT_ENSURE_PARSED
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
name|subnet
operator|.
name|protocol
argument_list|()
operator|!=
name|d
operator|->
name|protocol
operator|||
name|netmask
operator|<
literal|0
condition|)
return|return
literal|false
return|;
union|union
block|{
name|quint32
name|ip
decl_stmt|;
name|quint8
name|data
index|[
literal|4
index|]
decl_stmt|;
block|}
name|ip4
union|,
name|net4
union|;
specifier|const
name|quint8
modifier|*
name|ip
decl_stmt|;
specifier|const
name|quint8
modifier|*
name|net
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|protocol
operator|==
name|QAbstractSocket
operator|::
name|IPv4Protocol
condition|)
block|{
if|if
condition|(
name|netmask
operator|>
literal|32
condition|)
name|netmask
operator|=
literal|32
expr_stmt|;
name|ip4
operator|.
name|ip
operator|=
name|qToBigEndian
argument_list|(
name|d
operator|->
name|a
argument_list|)
expr_stmt|;
name|net4
operator|.
name|ip
operator|=
name|qToBigEndian
argument_list|(
name|subnet
operator|.
name|d
operator|->
name|a
argument_list|)
expr_stmt|;
name|ip
operator|=
name|ip4
operator|.
name|data
expr_stmt|;
name|net
operator|=
name|net4
operator|.
name|data
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|protocol
operator|==
name|QAbstractSocket
operator|::
name|IPv6Protocol
condition|)
block|{
if|if
condition|(
name|netmask
operator|>
literal|128
condition|)
name|netmask
operator|=
literal|128
expr_stmt|;
name|ip
operator|=
name|d
operator|->
name|a6
operator|.
name|c
expr_stmt|;
name|net
operator|=
name|subnet
operator|.
name|d
operator|->
name|a6
operator|.
name|c
expr_stmt|;
block|}
else|else
block|{
return|return
literal|false
return|;
block|}
if|if
condition|(
name|netmask
operator|>=
literal|8
operator|&&
name|memcmp
argument_list|(
name|ip
argument_list|,
name|net
argument_list|,
name|netmask
operator|/
literal|8
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|false
return|;
if|if
condition|(
operator|(
name|netmask
operator|&
literal|7
operator|)
operator|==
literal|0
condition|)
return|return
literal|true
return|;
comment|// compare the last octet now
name|quint8
name|bytemask
init|=
literal|256
operator|-
operator|(
literal|1
operator|<<
operator|(
literal|8
operator|-
operator|(
name|netmask
operator|&
literal|7
operator|)
operator|)
operator|)
decl_stmt|;
name|quint8
name|ipbyte
init|=
name|ip
index|[
name|netmask
operator|/
literal|8
index|]
decl_stmt|;
name|quint8
name|netbyte
init|=
name|net
index|[
name|netmask
operator|/
literal|8
index|]
decl_stmt|;
return|return
operator|(
name|ipbyte
operator|&
name|bytemask
operator|)
operator|==
operator|(
name|netbyte
operator|&
name|bytemask
operator|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5     \overload      Returns true if this IP is in the subnet described by \a     subnet. The QHostAddress member of \a subnet contains the network     prefix and the int (second) member contains the netmask (prefix     length). */
end_comment
begin_function
DECL|function|isInSubnet
name|bool
name|QHostAddress
operator|::
name|isInSubnet
parameter_list|(
specifier|const
name|QPair
argument_list|<
name|QHostAddress
argument_list|,
name|int
argument_list|>
modifier|&
name|subnet
parameter_list|)
specifier|const
block|{
return|return
name|isInSubnet
argument_list|(
name|subnet
operator|.
name|first
argument_list|,
name|subnet
operator|.
name|second
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.5      Parses the IP and subnet information contained in \a subnet and     returns the network prefix for that network and its prefix length.      The IP address and the netmask must be separated by a slash     (/).      This function supports arguments in the form:     \list       \li 123.123.123.123/n  where n is any value between 0 and 32       \li 123.123.123.123/255.255.255.255       \li<ipv6-address>/n  where n is any value between 0 and 128     \endlist      For IP version 4, this function accepts as well missing trailing     components (i.e., less than 4 octets, like "192.168.1"), followed     or not by a dot. If the netmask is also missing in that case, it     is set to the number of octets actually passed (in the example     above, it would be 24, for 3 octets).      \sa isInSubnet() */
end_comment
begin_function
DECL|function|parseSubnet
name|QPair
argument_list|<
name|QHostAddress
argument_list|,
name|int
argument_list|>
name|QHostAddress
operator|::
name|parseSubnet
parameter_list|(
specifier|const
name|QString
modifier|&
name|subnet
parameter_list|)
block|{
comment|// We support subnets in the form:
comment|//   ddd.ddd.ddd.ddd/nn
comment|//   ddd.ddd.ddd/nn
comment|//   ddd.ddd/nn
comment|//   ddd/nn
comment|//   ddd.ddd.ddd.
comment|//   ddd.ddd.ddd
comment|//   ddd.ddd.
comment|//   ddd.ddd
comment|//   ddd.
comment|//   ddd
comment|//<ipv6-address>/nn
comment|//
comment|//  where nn can be an IPv4-style netmask for the IPv4 forms
specifier|const
name|QPair
argument_list|<
name|QHostAddress
argument_list|,
name|int
argument_list|>
name|invalid
init|=
name|qMakePair
argument_list|(
name|QHostAddress
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|subnet
operator|.
name|isEmpty
argument_list|()
condition|)
return|return
name|invalid
return|;
name|int
name|slash
init|=
name|subnet
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'/'
argument_list|)
argument_list|)
decl_stmt|;
name|QString
name|netStr
init|=
name|subnet
decl_stmt|;
if|if
condition|(
name|slash
operator|!=
operator|-
literal|1
condition|)
name|netStr
operator|.
name|truncate
argument_list|(
name|slash
argument_list|)
expr_stmt|;
name|int
name|netmask
init|=
operator|-
literal|1
decl_stmt|;
name|bool
name|isIpv6
init|=
name|netStr
operator|.
name|contains
argument_list|(
name|QLatin1Char
argument_list|(
literal|':'
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|slash
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// is the netmask given in IP-form or in bit-count form?
if|if
condition|(
operator|!
name|isIpv6
operator|&&
name|subnet
operator|.
name|indexOf
argument_list|(
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
argument_list|,
name|slash
operator|+
literal|1
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
comment|// IP-style, convert it to bit-count form
name|QNetmaskAddress
name|parser
decl_stmt|;
if|if
condition|(
operator|!
name|parser
operator|.
name|setAddress
argument_list|(
name|subnet
operator|.
name|mid
argument_list|(
name|slash
operator|+
literal|1
argument_list|)
argument_list|)
condition|)
return|return
name|invalid
return|;
name|netmask
operator|=
name|parser
operator|.
name|prefixLength
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|bool
name|ok
decl_stmt|;
name|netmask
operator|=
name|subnet
operator|.
name|mid
argument_list|(
name|slash
operator|+
literal|1
argument_list|)
operator|.
name|toUInt
argument_list|(
operator|&
name|ok
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
condition|)
return|return
name|invalid
return|;
comment|// failed to parse the subnet
block|}
block|}
if|if
condition|(
name|isIpv6
condition|)
block|{
comment|// looks like it's an IPv6 address
if|if
condition|(
name|netmask
operator|>
literal|128
condition|)
return|return
name|invalid
return|;
comment|// invalid netmask
if|if
condition|(
name|netmask
operator|<
literal|0
condition|)
name|netmask
operator|=
literal|128
expr_stmt|;
name|QHostAddress
name|net
decl_stmt|;
if|if
condition|(
operator|!
name|net
operator|.
name|setAddress
argument_list|(
name|netStr
argument_list|)
condition|)
return|return
name|invalid
return|;
comment|// failed to parse the IP
name|clearBits
argument_list|(
name|net
operator|.
name|d
operator|->
name|a6
operator|.
name|c
argument_list|,
name|netmask
argument_list|,
literal|128
argument_list|)
expr_stmt|;
return|return
name|qMakePair
argument_list|(
name|net
argument_list|,
name|netmask
argument_list|)
return|;
block|}
if|if
condition|(
name|netmask
operator|>
literal|32
condition|)
return|return
name|invalid
return|;
comment|// invalid netmask
comment|// parse the address manually
name|QStringList
name|parts
init|=
name|netStr
operator|.
name|split
argument_list|(
name|QLatin1Char
argument_list|(
literal|'.'
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|parts
operator|.
name|isEmpty
argument_list|()
operator|||
name|parts
operator|.
name|count
argument_list|()
operator|>
literal|4
condition|)
return|return
name|invalid
return|;
comment|// invalid IPv4 address
if|if
condition|(
name|parts
operator|.
name|last
argument_list|()
operator|.
name|isEmpty
argument_list|()
condition|)
name|parts
operator|.
name|removeLast
argument_list|()
expr_stmt|;
name|quint32
name|addr
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|parts
operator|.
name|count
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|bool
name|ok
decl_stmt|;
name|uint
name|byteValue
init|=
name|parts
operator|.
name|at
argument_list|(
name|i
argument_list|)
operator|.
name|toUInt
argument_list|(
operator|&
name|ok
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ok
operator|||
name|byteValue
operator|>
literal|255
condition|)
return|return
name|invalid
return|;
comment|// invalid IPv4 address
name|addr
operator|<<=
literal|8
expr_stmt|;
name|addr
operator|+=
name|byteValue
expr_stmt|;
block|}
name|addr
operator|<<=
literal|8
operator|*
operator|(
literal|4
operator|-
name|parts
operator|.
name|count
argument_list|()
operator|)
expr_stmt|;
if|if
condition|(
name|netmask
operator|==
operator|-
literal|1
condition|)
block|{
name|netmask
operator|=
literal|8
operator|*
name|parts
operator|.
name|count
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|netmask
operator|==
literal|0
condition|)
block|{
comment|// special case here
comment|// x86's instructions "shr" and "shl" do not operate when
comment|// their argument is 32, so the code below doesn't work as expected
name|addr
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|netmask
operator|!=
literal|32
condition|)
block|{
comment|// clear remaining bits
name|quint32
name|mask
init|=
name|quint32
argument_list|(
literal|0xffffffff
argument_list|)
operator|>>
operator|(
literal|32
operator|-
name|netmask
operator|)
operator|<<
operator|(
literal|32
operator|-
name|netmask
operator|)
decl_stmt|;
name|addr
operator|&=
name|mask
expr_stmt|;
block|}
return|return
name|qMakePair
argument_list|(
name|QHostAddress
argument_list|(
name|addr
argument_list|)
argument_list|,
name|netmask
argument_list|)
return|;
block|}
end_function
begin_comment
comment|/*!     \since 5.0      returns true if the address is the IPv6 loopback address, or any     of the IPv4 loopback addresses. */
end_comment
begin_function
DECL|function|isLoopback
name|bool
name|QHostAddress
operator|::
name|isLoopback
parameter_list|()
specifier|const
block|{
name|QT_ENSURE_PARSED
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|->
name|a
operator|&
literal|0xFF000000
operator|)
operator|==
literal|0x7F000000
condition|)
return|return
literal|true
return|;
comment|// v4 range (including IPv6 wrapped IPv4 addresses)
if|if
condition|(
name|d
operator|->
name|protocol
operator|==
name|QAbstractSocket
operator|::
name|IPv6Protocol
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|a6
operator|.
name|c
index|[
literal|15
index|]
operator|!=
literal|1
condition|)
return|return
literal|false
return|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|15
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|d
operator|->
name|a6
index|[
name|i
index|]
operator|!=
literal|0
condition|)
return|return
literal|false
return|;
return|return
literal|true
return|;
block|}
return|return
literal|false
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DEBUG_STREAM
end_ifndef
begin_function
DECL|function|operator <<
name|QDebug
name|operator
name|<<
parameter_list|(
name|QDebug
name|d
parameter_list|,
specifier|const
name|QHostAddress
modifier|&
name|address
parameter_list|)
block|{
name|d
operator|.
name|maybeSpace
argument_list|()
operator|<<
literal|"QHostAddress("
operator|<<
name|address
operator|.
name|toString
argument_list|()
operator|<<
literal|')'
expr_stmt|;
return|return
name|d
operator|.
name|space
argument_list|()
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_function
DECL|function|qHash
name|uint
name|qHash
parameter_list|(
specifier|const
name|QHostAddress
modifier|&
name|key
parameter_list|,
name|uint
name|seed
parameter_list|)
block|{
comment|// both lines might throw
name|QT_ENSURE_PARSED
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
return|return
name|qHash
argument_list|(
name|QByteArray
operator|::
name|fromRawData
argument_list|(
cast|reinterpret_cast
argument_list|<
specifier|const
name|char
operator|*
argument_list|>
argument_list|(
name|key
operator|.
name|d
operator|->
name|a6
operator|.
name|c
argument_list|)
argument_list|,
literal|16
argument_list|)
argument_list|,
name|seed
argument_list|)
return|;
block|}
end_function
begin_ifndef
ifndef|#
directive|ifndef
name|QT_NO_DATASTREAM
end_ifndef
begin_comment
comment|/*! \relates QHostAddress      Writes host address \a address to the stream \a out and returns a reference     to the stream.      \sa {Serializing Qt Data Types} */
end_comment
begin_function
DECL|function|operator <<
name|QDataStream
modifier|&
name|operator
name|<<
parameter_list|(
name|QDataStream
modifier|&
name|out
parameter_list|,
specifier|const
name|QHostAddress
modifier|&
name|address
parameter_list|)
block|{
name|qint8
name|prot
decl_stmt|;
name|prot
operator|=
name|qint8
argument_list|(
name|address
operator|.
name|protocol
argument_list|()
argument_list|)
expr_stmt|;
name|out
operator|<<
name|prot
expr_stmt|;
switch|switch
condition|(
name|address
operator|.
name|protocol
argument_list|()
condition|)
block|{
case|case
name|QAbstractSocket
operator|::
name|UnknownNetworkLayerProtocol
case|:
case|case
name|QAbstractSocket
operator|::
name|AnyIPProtocol
case|:
break|break;
case|case
name|QAbstractSocket
operator|::
name|IPv4Protocol
case|:
name|out
operator|<<
name|address
operator|.
name|toIPv4Address
argument_list|()
expr_stmt|;
break|break;
case|case
name|QAbstractSocket
operator|::
name|IPv6Protocol
case|:
block|{
name|Q_IPV6ADDR
name|ipv6
init|=
name|address
operator|.
name|toIPv6Address
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
name|out
operator|<<
name|ipv6
index|[
name|i
index|]
expr_stmt|;
name|out
operator|<<
name|address
operator|.
name|scopeId
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
return|return
name|out
return|;
block|}
end_function
begin_comment
comment|/*! \relates QHostAddress      Reads a host address into \a address from the stream \a in and returns a     reference to the stream.      \sa {Serializing Qt Data Types} */
end_comment
begin_function
DECL|function|operator >>
name|QDataStream
modifier|&
name|operator
name|>>
parameter_list|(
name|QDataStream
modifier|&
name|in
parameter_list|,
name|QHostAddress
modifier|&
name|address
parameter_list|)
block|{
name|qint8
name|prot
decl_stmt|;
name|in
operator|>>
name|prot
expr_stmt|;
switch|switch
condition|(
name|QAbstractSocket
operator|::
name|NetworkLayerProtocol
argument_list|(
name|prot
argument_list|)
condition|)
block|{
case|case
name|QAbstractSocket
operator|::
name|UnknownNetworkLayerProtocol
case|:
name|address
operator|.
name|clear
argument_list|()
expr_stmt|;
break|break;
case|case
name|QAbstractSocket
operator|::
name|IPv4Protocol
case|:
block|{
name|quint32
name|ipv4
decl_stmt|;
name|in
operator|>>
name|ipv4
expr_stmt|;
name|address
operator|.
name|setAddress
argument_list|(
name|ipv4
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|QAbstractSocket
operator|::
name|IPv6Protocol
case|:
block|{
name|Q_IPV6ADDR
name|ipv6
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
operator|++
name|i
control|)
name|in
operator|>>
name|ipv6
index|[
name|i
index|]
expr_stmt|;
name|address
operator|.
name|setAddress
argument_list|(
name|ipv6
argument_list|)
expr_stmt|;
name|QString
name|scope
decl_stmt|;
name|in
operator|>>
name|scope
expr_stmt|;
name|address
operator|.
name|setScopeId
argument_list|(
name|scope
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|QAbstractSocket
operator|::
name|AnyIPProtocol
case|:
name|address
operator|=
name|QHostAddress
operator|::
name|Any
expr_stmt|;
break|break;
default|default:
name|address
operator|.
name|clear
argument_list|()
expr_stmt|;
name|in
operator|.
name|setStatus
argument_list|(
name|QDataStream
operator|::
name|ReadCorruptData
argument_list|)
expr_stmt|;
block|}
return|return
name|in
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//QT_NO_DATASTREAM
end_comment
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
