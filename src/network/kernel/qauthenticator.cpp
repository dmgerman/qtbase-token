begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2012 Nokia Corporation and/or its subsidiary(-ies). ** All rights reserved. ** Contact: http://www.qt-project.org/ ** ** This file is part of the QtNetwork module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** GNU Lesser General Public License Usage ** This file may be used under the terms of the GNU Lesser General Public ** License version 2.1 as published by the Free Software Foundation and ** appearing in the file LICENSE.LGPL included in the packaging of this ** file. Please review the following information to ensure the GNU Lesser ** General Public License version 2.1 requirements will be met: ** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Nokia gives you certain additional ** rights. These rights are described in the Nokia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU General ** Public License version 3.0 as published by the Free Software Foundation ** and appearing in the file LICENSE.GPL included in the packaging of this ** file. Please review the following information to ensure the GNU General ** Public License version 3.0 requirements will be met: ** http://www.gnu.org/copyleft/gpl.html. ** ** Other Usage ** Alternatively, this file may be used in accordance with the terms and ** conditions contained in a signed written agreement between you and Nokia. ** ** ** ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<qauthenticator.h>
end_include
begin_include
include|#
directive|include
file|<qauthenticator_p.h>
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_include
include|#
directive|include
file|<qhash.h>
end_include
begin_include
include|#
directive|include
file|<qbytearray.h>
end_include
begin_include
include|#
directive|include
file|<qcryptographichash.h>
end_include
begin_include
include|#
directive|include
file|<qiodevice.h>
end_include
begin_include
include|#
directive|include
file|<qdatastream.h>
end_include
begin_include
include|#
directive|include
file|<qendian.h>
end_include
begin_include
include|#
directive|include
file|<qstring.h>
end_include
begin_include
include|#
directive|include
file|<qdatetime.h>
end_include
begin_comment
comment|//#define NTLMV1_CLIENT
end_comment
begin_function_decl
name|QT_BEGIN_NAMESPACE
ifdef|#
directive|ifdef
name|NTLMV1_CLIENT
include|#
directive|include
file|"../../3rdparty/des/des.cpp"
endif|#
directive|endif
specifier|static
name|QByteArray
name|qNtlmPhase1
parameter_list|()
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|QByteArray
name|qNtlmPhase3
parameter_list|(
name|QAuthenticatorPrivate
modifier|*
name|ctx
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|phase2data
parameter_list|)
function_decl|;
end_function_decl
begin_comment
comment|/*!   \class QAuthenticator   \brief The QAuthenticator class provides an authentication object.   \since 4.3    \reentrant   \ingroup network   \inmodule QtNetwork    The QAuthenticator class is usually used in the   \l{QNetworkAccessManager::}{authenticationRequired()} and   \l{QNetworkAccessManager::}{proxyAuthenticationRequired()} signals of QNetworkAccessManager and   QAbstractSocket. The class provides a way to pass back the required   authentication information to the socket when accessing services that   require authentication.    QAuthenticator supports the following authentication methods:   \list     \o Basic     \o NTLM version 1     \o Digest-MD5   \endlist    Note that, in particular, NTLM version 2 is not supported.    \section1 Options    In addition to the username and password required for authentication, a   QAuthenticator object can also contain additional options. The   options() function can be used to query incoming options sent by   the server; the setOption() function can   be used to set outgoing options, to be processed by the authenticator   calculation. The options accepted and provided depend on the authentication   type (see method()).    The following tables list known incoming options as well as accepted   outgoing options. The list of incoming options is not exhaustive, since   servers may include additional information at any time. The list of   outgoing options is exhaustive, however, and no unknown options will be   treated or sent back to the server.    \section2 Basic    \table     \header \o Option \o Direction \o Description     \row \o \tt{realm} \o Incoming \o Contains the realm of the authentication, the same as realm()   \endtable    The Basic authentication mechanism supports no outgoing options.    \section2 NTLM version 1    The NTLM authentication mechanism currently supports no incoming or outgoing options.    \section2 Digest-MD5    \table     \header \o Option \o Direction \o Description     \row \o \tt{realm} \o Incoming \o Contains the realm of the authentication, the same as realm()   \endtable    The Digest-MD5 authentication mechanism supports no outgoing options.    \sa QSslSocket */
end_comment
begin_comment
comment|/*!   Constructs an empty authentication object */
end_comment
begin_constructor
DECL|function|QAuthenticator
name|QAuthenticator
operator|::
name|QAuthenticator
parameter_list|()
member_init_list|:
name|d
argument_list|(
literal|0
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!   Destructs the object */
end_comment
begin_destructor
DECL|function|~QAuthenticator
name|QAuthenticator
operator|::
name|~
name|QAuthenticator
parameter_list|()
block|{
if|if
condition|(
name|d
operator|&&
operator|!
name|d
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
operator|delete
name|d
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     Constructs a copy of \a other. */
end_comment
begin_constructor
DECL|function|QAuthenticator
name|QAuthenticator
operator|::
name|QAuthenticator
parameter_list|(
specifier|const
name|QAuthenticator
modifier|&
name|other
parameter_list|)
member_init_list|:
name|d
argument_list|(
name|other
operator|.
name|d
argument_list|)
block|{
if|if
condition|(
name|d
condition|)
name|d
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
block|}
end_constructor
begin_comment
comment|/*!     Assigns the contents of \a other to this authenticator. */
end_comment
begin_function
DECL|function|operator =
name|QAuthenticator
modifier|&
name|QAuthenticator
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QAuthenticator
modifier|&
name|other
parameter_list|)
block|{
if|if
condition|(
name|d
operator|==
name|other
operator|.
name|d
condition|)
return|return
operator|*
name|this
return|;
if|if
condition|(
name|d
operator|&&
operator|!
name|d
operator|->
name|ref
operator|.
name|deref
argument_list|()
condition|)
operator|delete
name|d
expr_stmt|;
name|d
operator|=
name|other
operator|.
name|d
expr_stmt|;
if|if
condition|(
name|d
condition|)
name|d
operator|->
name|ref
operator|.
name|ref
parameter_list|()
constructor_decl|;
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if this authenticator is identical to \a other; otherwise     returns false. */
end_comment
begin_function
DECL|function|operator ==
name|bool
name|QAuthenticator
operator|::
name|operator
name|==
parameter_list|(
specifier|const
name|QAuthenticator
modifier|&
name|other
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|d
operator|==
name|other
operator|.
name|d
condition|)
return|return
literal|true
return|;
return|return
name|d
operator|->
name|user
operator|==
name|other
operator|.
name|d
operator|->
name|user
operator|&&
name|d
operator|->
name|password
operator|==
name|other
operator|.
name|d
operator|->
name|password
operator|&&
name|d
operator|->
name|realm
operator|==
name|other
operator|.
name|d
operator|->
name|realm
operator|&&
name|d
operator|->
name|method
operator|==
name|other
operator|.
name|d
operator|->
name|method
operator|&&
name|d
operator|->
name|options
operator|==
name|other
operator|.
name|d
operator|->
name|options
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QAuthenticator::operator!=(const QAuthenticator&other) const      Returns true if this authenticator is different from \a other; otherwise     returns false. */
end_comment
begin_comment
comment|/*!   returns the user used for authentication. */
end_comment
begin_function
DECL|function|user
name|QString
name|QAuthenticator
operator|::
name|user
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|d
operator|->
name|user
else|:
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!   Sets the \a user used for authentication.    \sa QNetworkAccessManager::authenticationRequired() */
end_comment
begin_function
DECL|function|setUser
name|void
name|QAuthenticator
operator|::
name|setUser
parameter_list|(
specifier|const
name|QString
modifier|&
name|user
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|int
name|separatorPosn
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|d
operator|->
name|method
condition|)
block|{
case|case
name|QAuthenticatorPrivate
operator|::
name|Ntlm
case|:
if|if
condition|(
operator|(
name|separatorPosn
operator|=
name|user
operator|.
name|indexOf
argument_list|(
name|QLatin1String
argument_list|(
literal|"\\"
argument_list|)
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
comment|//domain name is present
name|d
operator|->
name|realm
operator|.
name|clear
argument_list|()
expr_stmt|;
name|d
operator|->
name|userDomain
operator|=
name|user
operator|.
name|left
argument_list|(
name|separatorPosn
argument_list|)
expr_stmt|;
name|d
operator|->
name|extractedUser
operator|=
name|user
operator|.
name|mid
argument_list|(
name|separatorPosn
operator|+
literal|1
argument_list|)
expr_stmt|;
name|d
operator|->
name|user
operator|=
name|user
expr_stmt|;
block|}
else|else
block|{
name|d
operator|->
name|extractedUser
operator|=
name|user
expr_stmt|;
name|d
operator|->
name|user
operator|=
name|user
expr_stmt|;
name|d
operator|->
name|realm
operator|.
name|clear
argument_list|()
expr_stmt|;
name|d
operator|->
name|userDomain
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
break|break;
default|default:
name|d
operator|->
name|user
operator|=
name|user
expr_stmt|;
name|d
operator|->
name|userDomain
operator|.
name|clear
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
end_function
begin_comment
comment|/*!   returns the password used for authentication. */
end_comment
begin_function
DECL|function|password
name|QString
name|QAuthenticator
operator|::
name|password
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|d
operator|->
name|password
else|:
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!   Sets the \a password used for authentication.    \sa QNetworkAccessManager::authenticationRequired() */
end_comment
begin_function
DECL|function|setPassword
name|void
name|QAuthenticator
operator|::
name|setPassword
parameter_list|(
specifier|const
name|QString
modifier|&
name|password
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|password
operator|=
name|password
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \internal */
end_comment
begin_function
DECL|function|detach
name|void
name|QAuthenticator
operator|::
name|detach
parameter_list|()
block|{
if|if
condition|(
operator|!
name|d
condition|)
block|{
name|d
operator|=
operator|new
name|QAuthenticatorPrivate
expr_stmt|;
name|d
operator|->
name|ref
operator|.
name|store
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|qAtomicDetach
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|phase
operator|=
name|QAuthenticatorPrivate
operator|::
name|Start
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   returns the realm requiring authentication. */
end_comment
begin_function
DECL|function|realm
name|QString
name|QAuthenticator
operator|::
name|realm
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|d
operator|->
name|realm
else|:
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.7     Returns the value related to option \a opt if it was set by the server.     See \l{QAuthenticator#Options} for more information on incoming options.     If option \a opt isn't found, an invalid QVariant will be returned.      \sa options(), QAuthenticator#Options */
end_comment
begin_function
DECL|function|option
name|QVariant
name|QAuthenticator
operator|::
name|option
parameter_list|(
specifier|const
name|QString
modifier|&
name|opt
parameter_list|)
specifier|const
block|{
return|return
name|d
condition|?
name|d
operator|->
name|options
operator|.
name|value
argument_list|(
name|opt
argument_list|)
else|:
name|QVariant
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.7     Returns all incoming options set in this QAuthenticator object by parsing     the server reply. See \l{QAuthenticator#Options} for more information     on incoming options.      \sa option(), QAuthenticator#Options */
end_comment
begin_function
DECL|function|options
name|QVariantHash
name|QAuthenticator
operator|::
name|options
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|d
operator|->
name|options
else|:
name|QVariantHash
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.7      Sets the outgoing option \a opt to value \a value.     See \l{QAuthenticator#Options} for more information on outgoing options.      \sa options(), option(), QAuthenticator#Options */
end_comment
begin_function
DECL|function|setOption
name|void
name|QAuthenticator
operator|::
name|setOption
parameter_list|(
specifier|const
name|QString
modifier|&
name|opt
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|value
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|options
operator|.
name|insert
argument_list|(
name|opt
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the authenticator is null. */
end_comment
begin_function
DECL|function|isNull
name|bool
name|QAuthenticator
operator|::
name|isNull
parameter_list|()
specifier|const
block|{
return|return
operator|!
name|d
return|;
block|}
end_function
begin_constructor
DECL|function|QAuthenticatorPrivate
name|QAuthenticatorPrivate
operator|::
name|QAuthenticatorPrivate
parameter_list|()
member_init_list|:
name|ref
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|method
argument_list|(
name|None
argument_list|)
member_init_list|,
name|hasFailed
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|phase
argument_list|(
name|Start
argument_list|)
member_init_list|,
name|nonceCount
argument_list|(
literal|0
argument_list|)
block|{
name|cnonce
operator|=
name|QCryptographicHash
operator|::
name|hash
argument_list|(
name|QByteArray
operator|::
name|number
argument_list|(
name|qrand
argument_list|()
argument_list|,
literal|16
argument_list|)
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|qrand
argument_list|()
argument_list|,
literal|16
argument_list|)
argument_list|,
name|QCryptographicHash
operator|::
name|Md5
argument_list|)
operator|.
name|toHex
argument_list|()
expr_stmt|;
name|nonceCount
operator|=
literal|0
expr_stmt|;
block|}
end_constructor
begin_function
DECL|function|parseHttpResponse
name|void
name|QAuthenticatorPrivate
operator|::
name|parseHttpResponse
parameter_list|(
specifier|const
name|QList
argument_list|<
name|QPair
argument_list|<
name|QByteArray
argument_list|,
name|QByteArray
argument_list|>
argument_list|>
modifier|&
name|values
parameter_list|,
name|bool
name|isProxy
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|search
init|=
name|isProxy
condition|?
literal|"proxy-authenticate"
else|:
literal|"www-authenticate"
decl_stmt|;
name|method
operator|=
name|None
expr_stmt|;
comment|/*       Fun from the HTTP 1.1 specs, that we currently ignore:        User agents are advised to take special care in parsing the WWW-       Authenticate field value as it might contain more than one challenge,       or if more than one WWW-Authenticate header field is provided, the       contents of a challenge itself can contain a comma-separated list of       authentication parameters.     */
name|QByteArray
name|headerVal
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|values
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QPair
argument_list|<
name|QByteArray
argument_list|,
name|QByteArray
argument_list|>
modifier|&
name|current
init|=
name|values
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|current
operator|.
name|first
operator|.
name|toLower
argument_list|()
operator|!=
name|search
condition|)
continue|continue;
name|QByteArray
name|str
init|=
name|current
operator|.
name|second
operator|.
name|toLower
argument_list|()
decl_stmt|;
if|if
condition|(
name|method
operator|<
name|Basic
operator|&&
name|str
operator|.
name|startsWith
argument_list|(
literal|"basic"
argument_list|)
condition|)
block|{
name|method
operator|=
name|Basic
expr_stmt|;
name|headerVal
operator|=
name|current
operator|.
name|second
operator|.
name|mid
argument_list|(
literal|6
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|method
operator|<
name|Ntlm
operator|&&
name|str
operator|.
name|startsWith
argument_list|(
literal|"ntlm"
argument_list|)
condition|)
block|{
name|method
operator|=
name|Ntlm
expr_stmt|;
name|headerVal
operator|=
name|current
operator|.
name|second
operator|.
name|mid
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|method
operator|<
name|DigestMd5
operator|&&
name|str
operator|.
name|startsWith
argument_list|(
literal|"digest"
argument_list|)
condition|)
block|{
name|method
operator|=
name|DigestMd5
expr_stmt|;
name|headerVal
operator|=
name|current
operator|.
name|second
operator|.
name|mid
argument_list|(
literal|7
argument_list|)
expr_stmt|;
block|}
block|}
name|challenge
operator|=
name|headerVal
operator|.
name|trimmed
argument_list|()
expr_stmt|;
name|QHash
argument_list|<
name|QByteArray
argument_list|,
name|QByteArray
argument_list|>
name|options
init|=
name|parseDigestAuthenticationChallenge
argument_list|(
name|challenge
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|method
condition|)
block|{
case|case
name|Basic
case|:
name|this
operator|->
name|options
index|[
name|QLatin1String
argument_list|(
literal|"realm"
argument_list|)
index|]
operator|=
name|realm
operator|=
name|QString
operator|::
name|fromLatin1
argument_list|(
name|options
operator|.
name|value
argument_list|(
literal|"realm"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|user
operator|.
name|isEmpty
argument_list|()
operator|&&
name|password
operator|.
name|isEmpty
argument_list|()
condition|)
name|phase
operator|=
name|Done
expr_stmt|;
break|break;
case|case
name|Ntlm
case|:
comment|// #### extract from header
break|break;
case|case
name|DigestMd5
case|:
block|{
name|this
operator|->
name|options
index|[
name|QLatin1String
argument_list|(
literal|"realm"
argument_list|)
index|]
operator|=
name|realm
operator|=
name|QString
operator|::
name|fromLatin1
argument_list|(
name|options
operator|.
name|value
argument_list|(
literal|"realm"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|options
operator|.
name|value
argument_list|(
literal|"stale"
argument_list|)
operator|.
name|toLower
argument_list|()
operator|==
literal|"true"
condition|)
name|phase
operator|=
name|Start
expr_stmt|;
if|if
condition|(
name|user
operator|.
name|isEmpty
argument_list|()
operator|&&
name|password
operator|.
name|isEmpty
argument_list|()
condition|)
name|phase
operator|=
name|Done
expr_stmt|;
break|break;
block|}
default|default:
name|realm
operator|.
name|clear
argument_list|()
expr_stmt|;
name|challenge
operator|=
name|QByteArray
argument_list|()
expr_stmt|;
name|phase
operator|=
name|Invalid
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|calculateResponse
name|QByteArray
name|QAuthenticatorPrivate
operator|::
name|calculateResponse
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|requestMethod
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|path
parameter_list|)
block|{
name|QByteArray
name|response
decl_stmt|;
specifier|const
name|char
modifier|*
name|methodString
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|method
condition|)
block|{
case|case
name|QAuthenticatorPrivate
operator|::
name|None
case|:
name|methodString
operator|=
literal|""
expr_stmt|;
name|phase
operator|=
name|Done
expr_stmt|;
break|break;
case|case
name|QAuthenticatorPrivate
operator|::
name|Plain
case|:
name|response
operator|=
literal|'\0'
operator|+
name|user
operator|.
name|toUtf8
argument_list|()
operator|+
literal|'\0'
operator|+
name|password
operator|.
name|toUtf8
argument_list|()
expr_stmt|;
name|phase
operator|=
name|Done
expr_stmt|;
break|break;
case|case
name|QAuthenticatorPrivate
operator|::
name|Basic
case|:
name|methodString
operator|=
literal|"Basic "
expr_stmt|;
name|response
operator|=
name|user
operator|.
name|toLatin1
argument_list|()
operator|+
literal|':'
operator|+
name|password
operator|.
name|toLatin1
argument_list|()
expr_stmt|;
name|response
operator|=
name|response
operator|.
name|toBase64
argument_list|()
expr_stmt|;
name|phase
operator|=
name|Done
expr_stmt|;
break|break;
case|case
name|QAuthenticatorPrivate
operator|::
name|Login
case|:
if|if
condition|(
name|challenge
operator|.
name|contains
argument_list|(
literal|"VXNlciBOYW1lAA=="
argument_list|)
condition|)
block|{
name|response
operator|=
name|user
operator|.
name|toUtf8
argument_list|()
operator|.
name|toBase64
argument_list|()
expr_stmt|;
name|phase
operator|=
name|Phase2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|challenge
operator|.
name|contains
argument_list|(
literal|"UGFzc3dvcmQA"
argument_list|)
condition|)
block|{
name|response
operator|=
name|password
operator|.
name|toUtf8
argument_list|()
operator|.
name|toBase64
argument_list|()
expr_stmt|;
name|phase
operator|=
name|Done
expr_stmt|;
block|}
break|break;
case|case
name|QAuthenticatorPrivate
operator|::
name|CramMd5
case|:
break|break;
case|case
name|QAuthenticatorPrivate
operator|::
name|DigestMd5
case|:
name|methodString
operator|=
literal|"Digest "
expr_stmt|;
name|response
operator|=
name|digestMd5Response
argument_list|(
name|challenge
argument_list|,
name|requestMethod
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|phase
operator|=
name|Done
expr_stmt|;
break|break;
case|case
name|QAuthenticatorPrivate
operator|::
name|Ntlm
case|:
name|methodString
operator|=
literal|"NTLM "
expr_stmt|;
if|if
condition|(
name|challenge
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|response
operator|=
name|qNtlmPhase1
argument_list|()
operator|.
name|toBase64
argument_list|()
expr_stmt|;
if|if
condition|(
name|user
operator|.
name|isEmpty
argument_list|()
condition|)
name|phase
operator|=
name|Done
expr_stmt|;
else|else
name|phase
operator|=
name|Phase2
expr_stmt|;
block|}
else|else
block|{
name|response
operator|=
name|qNtlmPhase3
argument_list|(
name|this
argument_list|,
name|QByteArray
operator|::
name|fromBase64
argument_list|(
name|challenge
argument_list|)
argument_list|)
operator|.
name|toBase64
argument_list|()
expr_stmt|;
name|phase
operator|=
name|Done
expr_stmt|;
block|}
break|break;
block|}
return|return
name|QByteArray
argument_list|(
name|methodString
argument_list|)
operator|+
name|response
return|;
block|}
end_function
begin_comment
comment|// ---------------------------- Digest Md5 code ----------------------------------------
end_comment
begin_function
DECL|function|parseDigestAuthenticationChallenge
name|QHash
argument_list|<
name|QByteArray
argument_list|,
name|QByteArray
argument_list|>
name|QAuthenticatorPrivate
operator|::
name|parseDigestAuthenticationChallenge
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|challenge
parameter_list|)
block|{
name|QHash
argument_list|<
name|QByteArray
argument_list|,
name|QByteArray
argument_list|>
name|options
decl_stmt|;
comment|// parse the challenge
specifier|const
name|char
modifier|*
name|d
init|=
name|challenge
operator|.
name|constData
argument_list|()
decl_stmt|;
specifier|const
name|char
modifier|*
name|end
init|=
name|d
operator|+
name|challenge
operator|.
name|length
argument_list|()
decl_stmt|;
while|while
condition|(
name|d
operator|<
name|end
condition|)
block|{
while|while
condition|(
name|d
operator|<
name|end
operator|&&
operator|(
operator|*
name|d
operator|==
literal|' '
operator|||
operator|*
name|d
operator|==
literal|'\n'
operator|||
operator|*
name|d
operator|==
literal|'\r'
operator|)
condition|)
operator|++
name|d
expr_stmt|;
specifier|const
name|char
modifier|*
name|start
init|=
name|d
decl_stmt|;
while|while
condition|(
name|d
operator|<
name|end
operator|&&
operator|*
name|d
operator|!=
literal|'='
condition|)
operator|++
name|d
expr_stmt|;
name|QByteArray
name|key
init|=
name|QByteArray
argument_list|(
name|start
argument_list|,
name|d
operator|-
name|start
argument_list|)
decl_stmt|;
operator|++
name|d
expr_stmt|;
if|if
condition|(
name|d
operator|>=
name|end
condition|)
break|break;
name|bool
name|quote
init|=
operator|(
operator|*
name|d
operator|==
literal|'"'
operator|)
decl_stmt|;
if|if
condition|(
name|quote
condition|)
operator|++
name|d
expr_stmt|;
if|if
condition|(
name|d
operator|>=
name|end
condition|)
break|break;
name|start
operator|=
name|d
expr_stmt|;
name|QByteArray
name|value
decl_stmt|;
while|while
condition|(
name|d
operator|<
name|end
condition|)
block|{
name|bool
name|backslash
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|*
name|d
operator|==
literal|'\\'
operator|&&
name|d
operator|<
name|end
operator|-
literal|1
condition|)
block|{
operator|++
name|d
expr_stmt|;
name|backslash
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|backslash
condition|)
block|{
if|if
condition|(
name|quote
condition|)
block|{
if|if
condition|(
operator|*
name|d
operator|==
literal|'"'
condition|)
break|break;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|d
operator|==
literal|','
condition|)
break|break;
block|}
block|}
name|value
operator|+=
operator|*
name|d
expr_stmt|;
operator|++
name|d
expr_stmt|;
block|}
while|while
condition|(
name|d
operator|<
name|end
operator|&&
operator|*
name|d
operator|!=
literal|','
condition|)
operator|++
name|d
expr_stmt|;
operator|++
name|d
expr_stmt|;
name|options
index|[
name|key
index|]
operator|=
name|value
expr_stmt|;
block|}
name|QByteArray
name|qop
init|=
name|options
operator|.
name|value
argument_list|(
literal|"qop"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|qop
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|qopoptions
init|=
name|qop
operator|.
name|split
argument_list|(
literal|','
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|qopoptions
operator|.
name|contains
argument_list|(
literal|"auth"
argument_list|)
condition|)
return|return
name|QHash
argument_list|<
name|QByteArray
argument_list|,
name|QByteArray
argument_list|>
argument_list|()
return|;
comment|// #### can't do auth-int currently
comment|//         if (qop.contains("auth-int"))
comment|//             qop = "auth-int";
comment|//         else if (qop.contains("auth"))
comment|//             qop = "auth";
comment|//         else
comment|//             qop = QByteArray();
name|options
index|[
literal|"qop"
index|]
operator|=
literal|"auth"
expr_stmt|;
block|}
return|return
name|options
return|;
block|}
end_function
begin_comment
comment|/*   Digest MD5 implementation    Code taken from RFC 2617    Currently we don't support the full SASL authentication mechanism (which includes cyphers) */
end_comment
begin_comment
comment|/* calculate request-digest/response-digest as per HTTP Digest spec */
end_comment
begin_function
DECL|function|digestMd5ResponseHelper
specifier|static
name|QByteArray
name|digestMd5ResponseHelper
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|alg
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|userName
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|realm
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|password
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|nonce
parameter_list|,
comment|/* nonce from server */
specifier|const
name|QByteArray
modifier|&
name|nonceCount
parameter_list|,
comment|/* 8 hex digits */
specifier|const
name|QByteArray
modifier|&
name|cNonce
parameter_list|,
comment|/* client nonce */
specifier|const
name|QByteArray
modifier|&
name|qop
parameter_list|,
comment|/* qop-value: "", "auth", "auth-int" */
specifier|const
name|QByteArray
modifier|&
name|method
parameter_list|,
comment|/* method from the request */
specifier|const
name|QByteArray
modifier|&
name|digestUri
parameter_list|,
comment|/* requested URL */
specifier|const
name|QByteArray
modifier|&
name|hEntity
comment|/* H(entity body) if qop="auth-int" */
parameter_list|)
block|{
name|QCryptographicHash
name|hash
argument_list|(
name|QCryptographicHash
operator|::
name|Md5
argument_list|)
decl_stmt|;
name|hash
operator|.
name|addData
argument_list|(
name|userName
argument_list|)
expr_stmt|;
name|hash
operator|.
name|addData
argument_list|(
literal|":"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hash
operator|.
name|addData
argument_list|(
name|realm
argument_list|)
expr_stmt|;
name|hash
operator|.
name|addData
argument_list|(
literal|":"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hash
operator|.
name|addData
argument_list|(
name|password
argument_list|)
expr_stmt|;
name|QByteArray
name|ha1
init|=
name|hash
operator|.
name|result
argument_list|()
decl_stmt|;
if|if
condition|(
name|alg
operator|.
name|toLower
argument_list|()
operator|==
literal|"md5-sess"
condition|)
block|{
name|hash
operator|.
name|reset
argument_list|()
expr_stmt|;
comment|// RFC 2617 contains an error, it was:
comment|// hash.addData(ha1);
comment|// but according to the errata page at http://www.rfc-editor.org/errata_list.php, ID 1649, it
comment|// must be the following line:
name|hash
operator|.
name|addData
argument_list|(
name|ha1
operator|.
name|toHex
argument_list|()
argument_list|)
expr_stmt|;
name|hash
operator|.
name|addData
argument_list|(
literal|":"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hash
operator|.
name|addData
argument_list|(
name|nonce
argument_list|)
expr_stmt|;
name|hash
operator|.
name|addData
argument_list|(
literal|":"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hash
operator|.
name|addData
argument_list|(
name|cNonce
argument_list|)
expr_stmt|;
name|ha1
operator|=
name|hash
operator|.
name|result
argument_list|()
expr_stmt|;
block|}
empty_stmt|;
name|ha1
operator|=
name|ha1
operator|.
name|toHex
argument_list|()
expr_stmt|;
comment|// calculate H(A2)
name|hash
operator|.
name|reset
argument_list|()
expr_stmt|;
name|hash
operator|.
name|addData
argument_list|(
name|method
argument_list|)
expr_stmt|;
name|hash
operator|.
name|addData
argument_list|(
literal|":"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hash
operator|.
name|addData
argument_list|(
name|digestUri
argument_list|)
expr_stmt|;
if|if
condition|(
name|qop
operator|.
name|toLower
argument_list|()
operator|==
literal|"auth-int"
condition|)
block|{
name|hash
operator|.
name|addData
argument_list|(
literal|":"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hash
operator|.
name|addData
argument_list|(
name|hEntity
argument_list|)
expr_stmt|;
block|}
name|QByteArray
name|ha2hex
init|=
name|hash
operator|.
name|result
argument_list|()
operator|.
name|toHex
argument_list|()
decl_stmt|;
comment|// calculate response
name|hash
operator|.
name|reset
argument_list|()
expr_stmt|;
name|hash
operator|.
name|addData
argument_list|(
name|ha1
argument_list|)
expr_stmt|;
name|hash
operator|.
name|addData
argument_list|(
literal|":"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hash
operator|.
name|addData
argument_list|(
name|nonce
argument_list|)
expr_stmt|;
name|hash
operator|.
name|addData
argument_list|(
literal|":"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qop
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|hash
operator|.
name|addData
argument_list|(
name|nonceCount
argument_list|)
expr_stmt|;
name|hash
operator|.
name|addData
argument_list|(
literal|":"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hash
operator|.
name|addData
argument_list|(
name|cNonce
argument_list|)
expr_stmt|;
name|hash
operator|.
name|addData
argument_list|(
literal|":"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hash
operator|.
name|addData
argument_list|(
name|qop
argument_list|)
expr_stmt|;
name|hash
operator|.
name|addData
argument_list|(
literal|":"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|hash
operator|.
name|addData
argument_list|(
name|ha2hex
argument_list|)
expr_stmt|;
return|return
name|hash
operator|.
name|result
argument_list|()
operator|.
name|toHex
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|digestMd5Response
name|QByteArray
name|QAuthenticatorPrivate
operator|::
name|digestMd5Response
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|challenge
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|method
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|path
parameter_list|)
block|{
name|QHash
argument_list|<
name|QByteArray
argument_list|,
name|QByteArray
argument_list|>
name|options
init|=
name|parseDigestAuthenticationChallenge
argument_list|(
name|challenge
argument_list|)
decl_stmt|;
operator|++
name|nonceCount
expr_stmt|;
name|QByteArray
name|nonceCountString
init|=
name|QByteArray
operator|::
name|number
argument_list|(
name|nonceCount
argument_list|,
literal|16
argument_list|)
decl_stmt|;
while|while
condition|(
name|nonceCountString
operator|.
name|length
argument_list|()
operator|<
literal|8
condition|)
name|nonceCountString
operator|.
name|prepend
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
name|QByteArray
name|nonce
init|=
name|options
operator|.
name|value
argument_list|(
literal|"nonce"
argument_list|)
decl_stmt|;
name|QByteArray
name|opaque
init|=
name|options
operator|.
name|value
argument_list|(
literal|"opaque"
argument_list|)
decl_stmt|;
name|QByteArray
name|qop
init|=
name|options
operator|.
name|value
argument_list|(
literal|"qop"
argument_list|)
decl_stmt|;
comment|//    qDebug()<< "calculating digest: method="<< method<< "path="<< path;
name|QByteArray
name|response
init|=
name|digestMd5ResponseHelper
argument_list|(
name|options
operator|.
name|value
argument_list|(
literal|"algorithm"
argument_list|)
argument_list|,
name|user
operator|.
name|toLatin1
argument_list|()
argument_list|,
name|realm
operator|.
name|toLatin1
argument_list|()
argument_list|,
name|password
operator|.
name|toLatin1
argument_list|()
argument_list|,
name|nonce
argument_list|,
name|nonceCountString
argument_list|,
name|cnonce
argument_list|,
name|qop
argument_list|,
name|method
argument_list|,
name|path
argument_list|,
name|QByteArray
argument_list|()
argument_list|)
decl_stmt|;
name|QByteArray
name|credentials
decl_stmt|;
name|credentials
operator|+=
literal|"username=\""
operator|+
name|user
operator|.
name|toLatin1
argument_list|()
operator|+
literal|"\", "
expr_stmt|;
name|credentials
operator|+=
literal|"realm=\""
operator|+
name|realm
operator|.
name|toLatin1
argument_list|()
operator|+
literal|"\", "
expr_stmt|;
name|credentials
operator|+=
literal|"nonce=\""
operator|+
name|nonce
operator|+
literal|"\", "
expr_stmt|;
name|credentials
operator|+=
literal|"uri=\""
operator|+
name|path
operator|+
literal|"\", "
expr_stmt|;
if|if
condition|(
operator|!
name|opaque
operator|.
name|isEmpty
argument_list|()
condition|)
name|credentials
operator|+=
literal|"opaque=\""
operator|+
name|opaque
operator|+
literal|"\", "
expr_stmt|;
name|credentials
operator|+=
literal|"response=\""
operator|+
name|response
operator|+
literal|'\"'
expr_stmt|;
if|if
condition|(
operator|!
name|options
operator|.
name|value
argument_list|(
literal|"algorithm"
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
name|credentials
operator|+=
literal|", algorithm="
operator|+
name|options
operator|.
name|value
argument_list|(
literal|"algorithm"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|options
operator|.
name|value
argument_list|(
literal|"qop"
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|credentials
operator|+=
literal|", qop="
operator|+
name|qop
operator|+
literal|", "
expr_stmt|;
name|credentials
operator|+=
literal|"nc="
operator|+
name|nonceCountString
operator|+
literal|", "
expr_stmt|;
name|credentials
operator|+=
literal|"cnonce=\""
operator|+
name|cnonce
operator|+
literal|'\"'
expr_stmt|;
block|}
return|return
name|credentials
return|;
block|}
end_function
begin_comment
comment|// ---------------------------- Digest Md5 code ----------------------------------------
end_comment
begin_comment
comment|/*  * NTLM message flags.  *  * Copyright (c) 2004 Andrey Panin<pazke@donpac.ru>  *  * This software is released under the MIT license.  */
end_comment
begin_comment
comment|/*  * Indicates that Unicode strings are supported for use in security  * buffer data.  */
end_comment
begin_define
DECL|macro|NTLMSSP_NEGOTIATE_UNICODE
define|#
directive|define
name|NTLMSSP_NEGOTIATE_UNICODE
value|0x00000001
end_define
begin_comment
comment|/*  * Indicates that OEM strings are supported for use in security buffer data.  */
end_comment
begin_define
DECL|macro|NTLMSSP_NEGOTIATE_OEM
define|#
directive|define
name|NTLMSSP_NEGOTIATE_OEM
value|0x00000002
end_define
begin_comment
comment|/*  * Requests that the server's authentication realm be included in the  * Type 2 message.  */
end_comment
begin_define
DECL|macro|NTLMSSP_REQUEST_TARGET
define|#
directive|define
name|NTLMSSP_REQUEST_TARGET
value|0x00000004
end_define
begin_comment
comment|/*  * Specifies that authenticated communication between the client and server  * should carry a digital signature (message integrity).  */
end_comment
begin_define
DECL|macro|NTLMSSP_NEGOTIATE_SIGN
define|#
directive|define
name|NTLMSSP_NEGOTIATE_SIGN
value|0x00000010
end_define
begin_comment
comment|/*  * Specifies that authenticated communication between the client and server  * should be encrypted (message confidentiality).  */
end_comment
begin_define
DECL|macro|NTLMSSP_NEGOTIATE_SEAL
define|#
directive|define
name|NTLMSSP_NEGOTIATE_SEAL
value|0x00000020
end_define
begin_comment
comment|/*  * Indicates that datagram authentication is being used.  */
end_comment
begin_define
DECL|macro|NTLMSSP_NEGOTIATE_DATAGRAM
define|#
directive|define
name|NTLMSSP_NEGOTIATE_DATAGRAM
value|0x00000040
end_define
begin_comment
comment|/*  * Indicates that the LAN Manager session key should be  * used for signing and sealing authenticated communications.  */
end_comment
begin_define
DECL|macro|NTLMSSP_NEGOTIATE_LM_KEY
define|#
directive|define
name|NTLMSSP_NEGOTIATE_LM_KEY
value|0x00000080
end_define
begin_comment
comment|/*  * Indicates that NTLM authentication is being used.  */
end_comment
begin_define
DECL|macro|NTLMSSP_NEGOTIATE_NTLM
define|#
directive|define
name|NTLMSSP_NEGOTIATE_NTLM
value|0x00000200
end_define
begin_comment
comment|/*  * Sent by the client in the Type 1 message to indicate that the name of the  * domain in which the client workstation has membership is included in the  * message. This is used by the server to determine whether the client is  * eligible for local authentication.  */
end_comment
begin_define
DECL|macro|NTLMSSP_NEGOTIATE_DOMAIN_SUPPLIED
define|#
directive|define
name|NTLMSSP_NEGOTIATE_DOMAIN_SUPPLIED
value|0x00001000
end_define
begin_comment
comment|/*  * Sent by the client in the Type 1 message to indicate that the client  * workstation's name is included in the message. This is used by the server  * to determine whether the client is eligible for local authentication.  */
end_comment
begin_define
DECL|macro|NTLMSSP_NEGOTIATE_WORKSTATION_SUPPLIED
define|#
directive|define
name|NTLMSSP_NEGOTIATE_WORKSTATION_SUPPLIED
value|0x00002000
end_define
begin_comment
comment|/*  * Sent by the server to indicate that the server and client are on the same  * machine. Implies that the client may use the established local credentials  * for authentication instead of calculating a response to the challenge.  */
end_comment
begin_define
DECL|macro|NTLMSSP_NEGOTIATE_LOCAL_CALL
define|#
directive|define
name|NTLMSSP_NEGOTIATE_LOCAL_CALL
value|0x00004000
end_define
begin_comment
comment|/*  * Indicates that authenticated communication between the client and server  * should be signed with a "dummy" signature.  */
end_comment
begin_define
DECL|macro|NTLMSSP_NEGOTIATE_ALWAYS_SIGN
define|#
directive|define
name|NTLMSSP_NEGOTIATE_ALWAYS_SIGN
value|0x00008000
end_define
begin_comment
comment|/*  * Sent by the server in the Type 2 message to indicate that the target  * authentication realm is a domain.  */
end_comment
begin_define
DECL|macro|NTLMSSP_TARGET_TYPE_DOMAIN
define|#
directive|define
name|NTLMSSP_TARGET_TYPE_DOMAIN
value|0x00010000
end_define
begin_comment
comment|/*  * Sent by the server in the Type 2 message to indicate that the target  * authentication realm is a server.  */
end_comment
begin_define
DECL|macro|NTLMSSP_TARGET_TYPE_SERVER
define|#
directive|define
name|NTLMSSP_TARGET_TYPE_SERVER
value|0x00020000
end_define
begin_comment
comment|/*  * Sent by the server in the Type 2 message to indicate that the target  * authentication realm is a share. Presumably, this is for share-level  * authentication. Usage is unclear.  */
end_comment
begin_define
DECL|macro|NTLMSSP_TARGET_TYPE_SHARE
define|#
directive|define
name|NTLMSSP_TARGET_TYPE_SHARE
value|0x00040000
end_define
begin_comment
comment|/*  * Indicates that the NTLM2 signing and sealing scheme should be used for  * protecting authenticated communications. Note that this refers to a  * particular session security scheme, and is not related to the use of  * NTLMv2 authentication.  */
end_comment
begin_define
DECL|macro|NTLMSSP_NEGOTIATE_NTLM2
define|#
directive|define
name|NTLMSSP_NEGOTIATE_NTLM2
value|0x00080000
end_define
begin_comment
comment|/*  * Sent by the server in the Type 2 message to indicate that it is including  * a Target Information block in the message. The Target Information block  * is used in the calculation of the NTLMv2 response.  */
end_comment
begin_define
DECL|macro|NTLMSSP_NEGOTIATE_TARGET_INFO
define|#
directive|define
name|NTLMSSP_NEGOTIATE_TARGET_INFO
value|0x00800000
end_define
begin_comment
comment|/*  * Indicates that 128-bit encryption is supported.  */
end_comment
begin_define
DECL|macro|NTLMSSP_NEGOTIATE_128
define|#
directive|define
name|NTLMSSP_NEGOTIATE_128
value|0x20000000
end_define
begin_comment
comment|/*  * Indicates that the client will provide an encrypted master session key in  * the "Session Key" field of the Type 3 message. This is used in signing and  * sealing, and is RC4-encrypted using the previous session key as the  * encryption key.  */
end_comment
begin_define
DECL|macro|NTLMSSP_NEGOTIATE_KEY_EXCHANGE
define|#
directive|define
name|NTLMSSP_NEGOTIATE_KEY_EXCHANGE
value|0x40000000
end_define
begin_comment
comment|/*  * Indicates that 56-bit encryption is supported.  */
end_comment
begin_define
DECL|macro|NTLMSSP_NEGOTIATE_56
define|#
directive|define
name|NTLMSSP_NEGOTIATE_56
value|0x80000000
end_define
begin_comment
comment|/*  * AvId values  */
end_comment
begin_define
DECL|macro|AVTIMESTAMP
define|#
directive|define
name|AVTIMESTAMP
value|7
end_define
begin_comment
comment|//#define NTLMV1_CLIENT
end_comment
begin_comment
comment|//************************Global variables***************************
end_comment
begin_decl_stmt
DECL|variable|blockSize
specifier|const
name|int
name|blockSize
init|=
literal|64
decl_stmt|;
end_decl_stmt
begin_comment
DECL|variable|blockSize
comment|//As per RFC2104 Block-size is 512 bits
end_comment
begin_decl_stmt
DECL|variable|nDigestLen
specifier|const
name|int
name|nDigestLen
init|=
literal|16
decl_stmt|;
end_decl_stmt
begin_comment
DECL|variable|nDigestLen
comment|//Trunctaion Length of the Hmac-Md5 digest
end_comment
begin_decl_stmt
DECL|variable|respversion
specifier|const
name|quint8
name|respversion
init|=
literal|1
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|hirespversion
specifier|const
name|quint8
name|hirespversion
init|=
literal|1
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* usage:    // fill up ctx with what we know.    QByteArray response = qNtlmPhase1(ctx);    // send response (b64 encoded??)    // get response from server (b64 decode?)    Phase2Block pb;    qNtlmDecodePhase2(response, pb);    response = qNtlmPhase3(ctx, pb);    // send response (b64 encoded??) */
end_comment
begin_comment
comment|/*    TODO:     - Fix unicode handling     - add v2 handling */
end_comment
begin_class
DECL|class|QNtlmBuffer
class|class
name|QNtlmBuffer
block|{
public|public:
DECL|function|QNtlmBuffer
name|QNtlmBuffer
parameter_list|()
member_init_list|:
name|len
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|maxLen
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|offset
argument_list|(
literal|0
argument_list|)
block|{}
DECL|member|len
name|quint16
name|len
decl_stmt|;
DECL|member|maxLen
name|quint16
name|maxLen
decl_stmt|;
DECL|member|offset
name|quint32
name|offset
decl_stmt|;
DECL|enumerator|Size
enum|enum
block|{
name|Size
init|=
literal|8
block|}
enum|;
block|}
class|;
end_class
begin_class
DECL|class|QNtlmPhase1BlockBase
class|class
name|QNtlmPhase1BlockBase
block|{
public|public:
DECL|member|magic
name|char
name|magic
index|[
literal|8
index|]
decl_stmt|;
DECL|member|type
name|quint32
name|type
decl_stmt|;
DECL|member|flags
name|quint32
name|flags
decl_stmt|;
DECL|member|domain
name|QNtlmBuffer
name|domain
decl_stmt|;
DECL|member|workstation
name|QNtlmBuffer
name|workstation
decl_stmt|;
DECL|enumerator|Size
enum|enum
block|{
name|Size
init|=
literal|32
block|}
enum|;
block|}
class|;
end_class
begin_comment
comment|// ################# check paddings
end_comment
begin_class
DECL|class|QNtlmPhase2BlockBase
class|class
name|QNtlmPhase2BlockBase
block|{
public|public:
DECL|member|magic
name|char
name|magic
index|[
literal|8
index|]
decl_stmt|;
DECL|member|type
name|quint32
name|type
decl_stmt|;
DECL|member|targetName
name|QNtlmBuffer
name|targetName
decl_stmt|;
DECL|member|flags
name|quint32
name|flags
decl_stmt|;
DECL|member|challenge
name|unsigned
name|char
name|challenge
index|[
literal|8
index|]
decl_stmt|;
DECL|member|context
name|quint32
name|context
index|[
literal|2
index|]
decl_stmt|;
DECL|member|targetInfo
name|QNtlmBuffer
name|targetInfo
decl_stmt|;
DECL|enumerator|Size
enum|enum
block|{
name|Size
init|=
literal|48
block|}
enum|;
block|}
class|;
end_class
begin_class
DECL|class|QNtlmPhase3BlockBase
class|class
name|QNtlmPhase3BlockBase
block|{
public|public:
DECL|member|magic
name|char
name|magic
index|[
literal|8
index|]
decl_stmt|;
DECL|member|type
name|quint32
name|type
decl_stmt|;
DECL|member|lmResponse
name|QNtlmBuffer
name|lmResponse
decl_stmt|;
DECL|member|ntlmResponse
name|QNtlmBuffer
name|ntlmResponse
decl_stmt|;
DECL|member|domain
name|QNtlmBuffer
name|domain
decl_stmt|;
DECL|member|user
name|QNtlmBuffer
name|user
decl_stmt|;
DECL|member|workstation
name|QNtlmBuffer
name|workstation
decl_stmt|;
DECL|member|sessionKey
name|QNtlmBuffer
name|sessionKey
decl_stmt|;
DECL|member|flags
name|quint32
name|flags
decl_stmt|;
DECL|enumerator|Size
enum|enum
block|{
name|Size
init|=
literal|64
block|}
enum|;
block|}
class|;
end_class
begin_function
DECL|function|qStreamNtlmBuffer
specifier|static
name|void
name|qStreamNtlmBuffer
parameter_list|(
name|QDataStream
modifier|&
name|ds
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|s
parameter_list|)
block|{
name|ds
operator|.
name|writeRawData
argument_list|(
name|s
operator|.
name|constData
argument_list|()
argument_list|,
name|s
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|qStreamNtlmString
specifier|static
name|void
name|qStreamNtlmString
parameter_list|(
name|QDataStream
modifier|&
name|ds
parameter_list|,
specifier|const
name|QString
modifier|&
name|s
parameter_list|,
name|bool
name|unicode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|unicode
condition|)
block|{
name|qStreamNtlmBuffer
argument_list|(
name|ds
argument_list|,
name|s
operator|.
name|toLatin1
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|const
name|ushort
modifier|*
name|d
init|=
name|s
operator|.
name|utf16
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|s
operator|.
name|length
argument_list|()
condition|;
operator|++
name|i
control|)
name|ds
operator|<<
name|d
index|[
name|i
index|]
expr_stmt|;
block|}
end_function
begin_function
DECL|function|qEncodeNtlmBuffer
specifier|static
name|int
name|qEncodeNtlmBuffer
parameter_list|(
name|QNtlmBuffer
modifier|&
name|buf
parameter_list|,
name|int
name|offset
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|s
parameter_list|)
block|{
name|buf
operator|.
name|len
operator|=
name|s
operator|.
name|size
argument_list|()
expr_stmt|;
name|buf
operator|.
name|maxLen
operator|=
name|buf
operator|.
name|len
expr_stmt|;
name|buf
operator|.
name|offset
operator|=
operator|(
name|offset
operator|+
literal|1
operator|)
operator|&
operator|~
literal|1
expr_stmt|;
return|return
name|buf
operator|.
name|offset
operator|+
name|buf
operator|.
name|len
return|;
block|}
end_function
begin_function
DECL|function|qEncodeNtlmString
specifier|static
name|int
name|qEncodeNtlmString
parameter_list|(
name|QNtlmBuffer
modifier|&
name|buf
parameter_list|,
name|int
name|offset
parameter_list|,
specifier|const
name|QString
modifier|&
name|s
parameter_list|,
name|bool
name|unicode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|unicode
condition|)
return|return
name|qEncodeNtlmBuffer
argument_list|(
name|buf
argument_list|,
name|offset
argument_list|,
name|s
operator|.
name|toLatin1
argument_list|()
argument_list|)
return|;
name|buf
operator|.
name|len
operator|=
literal|2
operator|*
name|s
operator|.
name|length
argument_list|()
expr_stmt|;
name|buf
operator|.
name|maxLen
operator|=
name|buf
operator|.
name|len
expr_stmt|;
name|buf
operator|.
name|offset
operator|=
operator|(
name|offset
operator|+
literal|1
operator|)
operator|&
operator|~
literal|1
expr_stmt|;
return|return
name|buf
operator|.
name|offset
operator|+
name|buf
operator|.
name|len
return|;
block|}
end_function
begin_function
DECL|function|operator <<
specifier|static
name|QDataStream
modifier|&
name|operator
name|<<
parameter_list|(
name|QDataStream
modifier|&
name|s
parameter_list|,
specifier|const
name|QNtlmBuffer
modifier|&
name|b
parameter_list|)
block|{
name|s
operator|<<
name|b
operator|.
name|len
operator|<<
name|b
operator|.
name|maxLen
operator|<<
name|b
operator|.
name|offset
expr_stmt|;
return|return
name|s
return|;
block|}
end_function
begin_function
DECL|function|operator >>
specifier|static
name|QDataStream
modifier|&
name|operator
name|>>
parameter_list|(
name|QDataStream
modifier|&
name|s
parameter_list|,
name|QNtlmBuffer
modifier|&
name|b
parameter_list|)
block|{
name|s
operator|>>
name|b
operator|.
name|len
operator|>>
name|b
operator|.
name|maxLen
operator|>>
name|b
operator|.
name|offset
expr_stmt|;
return|return
name|s
return|;
block|}
end_function
begin_class
DECL|class|QNtlmPhase1Block
class|class
name|QNtlmPhase1Block
super|:
specifier|public
name|QNtlmPhase1BlockBase
block|{
comment|// request
public|public:
DECL|function|QNtlmPhase1Block
name|QNtlmPhase1Block
parameter_list|()
block|{
name|qstrncpy
argument_list|(
name|magic
argument_list|,
literal|"NTLMSSP"
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|type
operator|=
literal|1
expr_stmt|;
name|flags
operator|=
name|NTLMSSP_NEGOTIATE_UNICODE
operator||
name|NTLMSSP_NEGOTIATE_NTLM
operator||
name|NTLMSSP_REQUEST_TARGET
expr_stmt|;
block|}
comment|// extracted
DECL|member|domainStr
DECL|member|workstationStr
name|QString
name|domainStr
decl_stmt|,
name|workstationStr
decl_stmt|;
block|}
class|;
end_class
begin_class
DECL|class|QNtlmPhase2Block
class|class
name|QNtlmPhase2Block
super|:
specifier|public
name|QNtlmPhase2BlockBase
block|{
comment|// challenge
public|public:
DECL|function|QNtlmPhase2Block
name|QNtlmPhase2Block
parameter_list|()
block|{
name|magic
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|type
operator|=
literal|0xffffffff
expr_stmt|;
block|}
comment|// extracted
DECL|member|targetNameStr
DECL|member|targetInfoStr
name|QString
name|targetNameStr
decl_stmt|,
name|targetInfoStr
decl_stmt|;
DECL|member|targetInfoBuff
name|QByteArray
name|targetInfoBuff
decl_stmt|;
block|}
class|;
end_class
begin_class
DECL|class|QNtlmPhase3Block
class|class
name|QNtlmPhase3Block
super|:
specifier|public
name|QNtlmPhase3BlockBase
block|{
comment|// response
public|public:
DECL|function|QNtlmPhase3Block
name|QNtlmPhase3Block
parameter_list|()
block|{
name|qstrncpy
argument_list|(
name|magic
argument_list|,
literal|"NTLMSSP"
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|type
operator|=
literal|3
expr_stmt|;
name|flags
operator|=
name|NTLMSSP_NEGOTIATE_UNICODE
operator||
name|NTLMSSP_NEGOTIATE_NTLM
operator||
name|NTLMSSP_NEGOTIATE_TARGET_INFO
expr_stmt|;
block|}
comment|// extracted
DECL|member|lmResponseBuf
DECL|member|ntlmResponseBuf
name|QByteArray
name|lmResponseBuf
decl_stmt|,
name|ntlmResponseBuf
decl_stmt|;
DECL|member|domainStr
DECL|member|userStr
DECL|member|workstationStr
DECL|member|sessionKeyStr
name|QString
name|domainStr
decl_stmt|,
name|userStr
decl_stmt|,
name|workstationStr
decl_stmt|,
name|sessionKeyStr
decl_stmt|;
DECL|member|v2Hash
name|QByteArray
name|v2Hash
decl_stmt|;
block|}
class|;
end_class
begin_function
DECL|function|operator <<
specifier|static
name|QDataStream
modifier|&
name|operator
name|<<
parameter_list|(
name|QDataStream
modifier|&
name|s
parameter_list|,
specifier|const
name|QNtlmPhase1Block
modifier|&
name|b
parameter_list|)
block|{
name|bool
name|unicode
init|=
operator|(
name|b
operator|.
name|flags
operator|&
name|NTLMSSP_NEGOTIATE_UNICODE
operator|)
decl_stmt|;
name|s
operator|.
name|writeRawData
argument_list|(
name|b
operator|.
name|magic
argument_list|,
sizeof|sizeof
argument_list|(
name|b
operator|.
name|magic
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|<<
name|b
operator|.
name|type
expr_stmt|;
name|s
operator|<<
name|b
operator|.
name|flags
expr_stmt|;
name|s
operator|<<
name|b
operator|.
name|domain
expr_stmt|;
name|s
operator|<<
name|b
operator|.
name|workstation
expr_stmt|;
if|if
condition|(
operator|!
name|b
operator|.
name|domainStr
operator|.
name|isEmpty
argument_list|()
condition|)
name|qStreamNtlmString
argument_list|(
name|s
argument_list|,
name|b
operator|.
name|domainStr
argument_list|,
name|unicode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|b
operator|.
name|workstationStr
operator|.
name|isEmpty
argument_list|()
condition|)
name|qStreamNtlmString
argument_list|(
name|s
argument_list|,
name|b
operator|.
name|workstationStr
argument_list|,
name|unicode
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function
begin_function
DECL|function|operator <<
specifier|static
name|QDataStream
modifier|&
name|operator
name|<<
parameter_list|(
name|QDataStream
modifier|&
name|s
parameter_list|,
specifier|const
name|QNtlmPhase3Block
modifier|&
name|b
parameter_list|)
block|{
name|bool
name|unicode
init|=
operator|(
name|b
operator|.
name|flags
operator|&
name|NTLMSSP_NEGOTIATE_UNICODE
operator|)
decl_stmt|;
name|s
operator|.
name|writeRawData
argument_list|(
name|b
operator|.
name|magic
argument_list|,
sizeof|sizeof
argument_list|(
name|b
operator|.
name|magic
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|<<
name|b
operator|.
name|type
expr_stmt|;
name|s
operator|<<
name|b
operator|.
name|lmResponse
expr_stmt|;
name|s
operator|<<
name|b
operator|.
name|ntlmResponse
expr_stmt|;
name|s
operator|<<
name|b
operator|.
name|domain
expr_stmt|;
name|s
operator|<<
name|b
operator|.
name|user
expr_stmt|;
name|s
operator|<<
name|b
operator|.
name|workstation
expr_stmt|;
name|s
operator|<<
name|b
operator|.
name|sessionKey
expr_stmt|;
name|s
operator|<<
name|b
operator|.
name|flags
expr_stmt|;
if|if
condition|(
operator|!
name|b
operator|.
name|domainStr
operator|.
name|isEmpty
argument_list|()
condition|)
name|qStreamNtlmString
argument_list|(
name|s
argument_list|,
name|b
operator|.
name|domainStr
argument_list|,
name|unicode
argument_list|)
expr_stmt|;
name|qStreamNtlmString
argument_list|(
name|s
argument_list|,
name|b
operator|.
name|userStr
argument_list|,
name|unicode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|b
operator|.
name|workstationStr
operator|.
name|isEmpty
argument_list|()
condition|)
name|qStreamNtlmString
argument_list|(
name|s
argument_list|,
name|b
operator|.
name|workstationStr
argument_list|,
name|unicode
argument_list|)
expr_stmt|;
comment|// Send auth info
name|qStreamNtlmBuffer
argument_list|(
name|s
argument_list|,
name|b
operator|.
name|lmResponseBuf
argument_list|)
expr_stmt|;
name|qStreamNtlmBuffer
argument_list|(
name|s
argument_list|,
name|b
operator|.
name|ntlmResponseBuf
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function
begin_function
DECL|function|qNtlmPhase1
specifier|static
name|QByteArray
name|qNtlmPhase1
parameter_list|()
block|{
name|QByteArray
name|rc
decl_stmt|;
name|QDataStream
name|ds
argument_list|(
operator|&
name|rc
argument_list|,
name|QIODevice
operator|::
name|WriteOnly
argument_list|)
decl_stmt|;
name|ds
operator|.
name|setByteOrder
argument_list|(
name|QDataStream
operator|::
name|LittleEndian
argument_list|)
expr_stmt|;
name|QNtlmPhase1Block
name|pb
decl_stmt|;
name|ds
operator|<<
name|pb
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function
begin_function
DECL|function|qStringAsUcs2Le
specifier|static
name|QByteArray
name|qStringAsUcs2Le
parameter_list|(
specifier|const
name|QString
modifier|&
name|src
parameter_list|)
block|{
name|QByteArray
name|rc
argument_list|(
literal|2
operator|*
name|src
operator|.
name|length
argument_list|()
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|const
name|unsigned
name|short
modifier|*
name|s
init|=
name|src
operator|.
name|utf16
argument_list|()
decl_stmt|;
name|unsigned
name|short
modifier|*
name|d
init|=
operator|(
name|unsigned
name|short
operator|*
operator|)
name|rc
operator|.
name|data
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|src
operator|.
name|length
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|d
index|[
name|i
index|]
operator|=
name|qToLittleEndian
argument_list|(
name|s
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|rc
return|;
block|}
end_function
begin_function
DECL|function|qStringFromUcs2Le
specifier|static
name|QString
name|qStringFromUcs2Le
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|src
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|src
operator|.
name|size
argument_list|()
operator|%
literal|2
operator|==
literal|0
argument_list|)
expr_stmt|;
name|unsigned
name|short
modifier|*
name|d
init|=
operator|(
name|unsigned
name|short
operator|*
operator|)
name|src
operator|.
name|data
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|src
operator|.
name|length
argument_list|()
operator|/
literal|2
condition|;
operator|++
name|i
control|)
block|{
name|d
index|[
name|i
index|]
operator|=
name|qFromLittleEndian
argument_list|(
name|d
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|QString
argument_list|(
operator|(
specifier|const
name|QChar
operator|*
operator|)
name|src
operator|.
name|data
argument_list|()
argument_list|,
name|src
operator|.
name|size
argument_list|()
operator|/
literal|2
argument_list|)
return|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|NTLMV1_CLIENT
end_ifdef
begin_function
DECL|function|qEncodeNtlmResponse
specifier|static
name|QByteArray
name|qEncodeNtlmResponse
parameter_list|(
specifier|const
name|QAuthenticatorPrivate
modifier|*
name|ctx
parameter_list|,
specifier|const
name|QNtlmPhase2Block
modifier|&
name|ch
parameter_list|)
block|{
name|QCryptographicHash
name|md4
argument_list|(
name|QCryptographicHash
operator|::
name|Md4
argument_list|)
decl_stmt|;
name|QByteArray
name|asUcs2Le
init|=
name|qStringAsUcs2Le
argument_list|(
name|ctx
operator|->
name|password
argument_list|)
decl_stmt|;
name|md4
operator|.
name|addData
argument_list|(
name|asUcs2Le
operator|.
name|data
argument_list|()
argument_list|,
name|asUcs2Le
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|unsigned
name|char
name|md4hash
index|[
literal|22
index|]
decl_stmt|;
name|memset
argument_list|(
name|md4hash
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|md4hash
argument_list|)
argument_list|)
expr_stmt|;
name|QByteArray
name|hash
init|=
name|md4
operator|.
name|result
argument_list|()
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|hash
operator|.
name|size
argument_list|()
operator|==
literal|16
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|md4hash
argument_list|,
name|hash
operator|.
name|constData
argument_list|()
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|QByteArray
name|rc
argument_list|(
literal|24
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|deshash
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|rc
operator|.
name|data
argument_list|()
argument_list|,
name|md4hash
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ch
operator|.
name|challenge
argument_list|)
expr_stmt|;
name|deshash
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|rc
operator|.
name|data
argument_list|()
operator|+
literal|8
argument_list|,
name|md4hash
operator|+
literal|7
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ch
operator|.
name|challenge
argument_list|)
expr_stmt|;
name|deshash
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|rc
operator|.
name|data
argument_list|()
operator|+
literal|16
argument_list|,
name|md4hash
operator|+
literal|14
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ch
operator|.
name|challenge
argument_list|)
expr_stmt|;
name|hash
operator|.
name|fill
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function
begin_function
DECL|function|qEncodeLmResponse
specifier|static
name|QByteArray
name|qEncodeLmResponse
parameter_list|(
specifier|const
name|QAuthenticatorPrivate
modifier|*
name|ctx
parameter_list|,
specifier|const
name|QNtlmPhase2Block
modifier|&
name|ch
parameter_list|)
block|{
name|QByteArray
name|hash
argument_list|(
literal|21
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|QByteArray
name|key
argument_list|(
literal|14
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|qstrncpy
argument_list|(
name|key
operator|.
name|data
argument_list|()
argument_list|,
name|ctx
operator|->
name|password
operator|.
name|toUpper
argument_list|()
operator|.
name|toLatin1
argument_list|()
argument_list|,
literal|14
argument_list|)
expr_stmt|;
specifier|const
name|char
modifier|*
name|block
init|=
literal|"KGS!@#$%"
decl_stmt|;
name|deshash
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|hash
operator|.
name|data
argument_list|()
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|key
operator|.
name|data
argument_list|()
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|block
argument_list|)
expr_stmt|;
name|deshash
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|hash
operator|.
name|data
argument_list|()
operator|+
literal|8
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|key
operator|.
name|data
argument_list|()
operator|+
literal|7
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|block
argument_list|)
expr_stmt|;
name|key
operator|.
name|fill
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|QByteArray
name|rc
argument_list|(
literal|24
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|deshash
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|rc
operator|.
name|data
argument_list|()
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|hash
operator|.
name|data
argument_list|()
argument_list|,
name|ch
operator|.
name|challenge
argument_list|)
expr_stmt|;
name|deshash
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|rc
operator|.
name|data
argument_list|()
operator|+
literal|8
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|hash
operator|.
name|data
argument_list|()
operator|+
literal|7
argument_list|,
name|ch
operator|.
name|challenge
argument_list|)
expr_stmt|;
name|deshash
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|rc
operator|.
name|data
argument_list|()
operator|+
literal|16
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|hash
operator|.
name|data
argument_list|()
operator|+
literal|14
argument_list|,
name|ch
operator|.
name|challenge
argument_list|)
expr_stmt|;
name|hash
operator|.
name|fill
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/********************************************************************* * Function Name: qEncodeHmacMd5 * Params: *    key:   Type - QByteArray *         - It is the Authentication key *    message:   Type - QByteArray *         - This is the actual message which will be encoded *           using HMacMd5 hash algorithm * * Return Value: *    hmacDigest:   Type - QByteArray * * Description: *    This function will be used to encode the input message using *    HMacMd5 hash algorithm. * *    As per the RFC2104 the HMacMd5 algorithm can be specified *        --------------------------------------- *         MD5(K XOR opad, MD5(K XOR ipad, text)) *        --------------------------------------- * *********************************************************************/
end_comment
begin_function
DECL|function|qEncodeHmacMd5
name|QByteArray
name|qEncodeHmacMd5
parameter_list|(
name|QByteArray
modifier|&
name|key
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|message
parameter_list|)
block|{
name|Q_ASSERT_X
argument_list|(
operator|!
operator|(
name|message
operator|.
name|isEmpty
argument_list|()
operator|)
argument_list|,
literal|"qEncodeHmacMd5"
argument_list|,
literal|"Empty message check"
argument_list|)
expr_stmt|;
name|Q_ASSERT_X
argument_list|(
operator|!
operator|(
name|key
operator|.
name|isEmpty
argument_list|()
operator|)
argument_list|,
literal|"qEncodeHmacMd5"
argument_list|,
literal|"Empty key check"
argument_list|)
expr_stmt|;
name|QCryptographicHash
name|hash
argument_list|(
name|QCryptographicHash
operator|::
name|Md5
argument_list|)
decl_stmt|;
name|QByteArray
name|hMsg
decl_stmt|;
name|QByteArray
name|iKeyPad
argument_list|(
name|blockSize
argument_list|,
literal|0x36
argument_list|)
decl_stmt|;
name|QByteArray
name|oKeyPad
argument_list|(
name|blockSize
argument_list|,
literal|0x5c
argument_list|)
decl_stmt|;
name|hash
operator|.
name|reset
argument_list|()
expr_stmt|;
comment|// Adjust the key length to blockSize
if|if
condition|(
name|blockSize
operator|<
name|key
operator|.
name|length
argument_list|()
condition|)
block|{
name|hash
operator|.
name|addData
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|key
operator|=
name|hash
operator|.
name|result
argument_list|()
expr_stmt|;
comment|//MD5 will always return 16 bytes length output
block|}
comment|//Key will be<= 16 or 20 bytes as hash function (MD5 or SHA hash algorithms)
comment|//key size can be max of Block size only
name|key
operator|=
name|key
operator|.
name|leftJustified
argument_list|(
name|blockSize
argument_list|,
literal|0
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|//iKeyPad, oKeyPad and key are all of same size "blockSize"
comment|//xor of iKeyPad with Key and store the result into iKeyPad
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|key
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|iKeyPad
index|[
name|i
index|]
operator|=
name|key
index|[
name|i
index|]
operator|^
name|iKeyPad
index|[
name|i
index|]
expr_stmt|;
block|}
comment|//xor of oKeyPad with Key and store the result into oKeyPad
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|key
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|oKeyPad
index|[
name|i
index|]
operator|=
name|key
index|[
name|i
index|]
operator|^
name|oKeyPad
index|[
name|i
index|]
expr_stmt|;
block|}
name|iKeyPad
operator|.
name|append
argument_list|(
name|message
argument_list|)
expr_stmt|;
comment|// (K0 xor ipad) || text
name|hash
operator|.
name|reset
argument_list|()
expr_stmt|;
name|hash
operator|.
name|addData
argument_list|(
name|iKeyPad
argument_list|)
expr_stmt|;
name|hMsg
operator|=
name|hash
operator|.
name|result
argument_list|()
expr_stmt|;
comment|//Digest gen after pass-1: H((K0 xor ipad)||text)
name|QByteArray
name|hmacDigest
decl_stmt|;
name|oKeyPad
operator|.
name|append
argument_list|(
name|hMsg
argument_list|)
expr_stmt|;
name|hash
operator|.
name|reset
argument_list|()
expr_stmt|;
name|hash
operator|.
name|addData
argument_list|(
name|oKeyPad
argument_list|)
expr_stmt|;
name|hmacDigest
operator|=
name|hash
operator|.
name|result
argument_list|()
expr_stmt|;
comment|// H((K0 xor opad )|| H((K0 xor ipad) || text))
comment|/*hmacDigest should not be less than half the length of the HMAC output       (to match the birthday attack bound) and not less than 80 bits       (a suitable lower bound on the number of bits that need to be       predicted by an attacker).       Refer RFC 2104 for more details on truncation part */
comment|/*MD5 hash always returns 16 byte digest only and HMAC-MD5 spec       (RFC 2104) also says digest length should be 16 bytes*/
return|return
name|hmacDigest
return|;
block|}
end_function
begin_function
DECL|function|qCreatev2Hash
specifier|static
name|QByteArray
name|qCreatev2Hash
parameter_list|(
specifier|const
name|QAuthenticatorPrivate
modifier|*
name|ctx
parameter_list|,
name|QNtlmPhase3Block
modifier|*
name|phase3
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|phase3
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|// since v2 Hash is need for both NTLMv2 and LMv2 it is calculated
comment|// only once and stored and reused
if|if
condition|(
name|phase3
operator|->
name|v2Hash
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|QCryptographicHash
name|md4
argument_list|(
name|QCryptographicHash
operator|::
name|Md4
argument_list|)
decl_stmt|;
name|QByteArray
name|passUnicode
init|=
name|qStringAsUcs2Le
argument_list|(
name|ctx
operator|->
name|password
argument_list|)
decl_stmt|;
name|md4
operator|.
name|addData
argument_list|(
name|passUnicode
operator|.
name|data
argument_list|()
argument_list|,
name|passUnicode
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|QByteArray
name|hashKey
init|=
name|md4
operator|.
name|result
argument_list|()
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|hashKey
operator|.
name|size
argument_list|()
operator|==
literal|16
argument_list|)
expr_stmt|;
comment|// Assuming the user and domain is always unicode in challenge
name|QByteArray
name|message
init|=
name|qStringAsUcs2Le
argument_list|(
name|ctx
operator|->
name|extractedUser
operator|.
name|toUpper
argument_list|()
argument_list|)
operator|+
name|qStringAsUcs2Le
argument_list|(
name|phase3
operator|->
name|domainStr
argument_list|)
decl_stmt|;
name|phase3
operator|->
name|v2Hash
operator|=
name|qEncodeHmacMd5
argument_list|(
name|hashKey
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
return|return
name|phase3
operator|->
name|v2Hash
return|;
block|}
end_function
begin_function
DECL|function|clientChallenge
specifier|static
name|QByteArray
name|clientChallenge
parameter_list|(
specifier|const
name|QAuthenticatorPrivate
modifier|*
name|ctx
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|ctx
operator|->
name|cnonce
operator|.
name|size
argument_list|()
operator|>=
literal|8
argument_list|)
expr_stmt|;
name|QByteArray
name|clientCh
init|=
name|ctx
operator|->
name|cnonce
operator|.
name|right
argument_list|(
literal|8
argument_list|)
decl_stmt|;
return|return
name|clientCh
return|;
block|}
end_function
begin_comment
comment|// caller has to ensure a valid targetInfoBuff
end_comment
begin_function
DECL|function|qExtractServerTime
specifier|static
name|QByteArray
name|qExtractServerTime
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|targetInfoBuff
parameter_list|)
block|{
name|QByteArray
name|timeArray
decl_stmt|;
name|QDataStream
name|ds
argument_list|(
name|targetInfoBuff
argument_list|)
decl_stmt|;
name|ds
operator|.
name|setByteOrder
argument_list|(
name|QDataStream
operator|::
name|LittleEndian
argument_list|)
expr_stmt|;
name|quint16
name|avId
decl_stmt|;
name|quint16
name|avLen
decl_stmt|;
name|ds
operator|>>
name|avId
expr_stmt|;
name|ds
operator|>>
name|avLen
expr_stmt|;
while|while
condition|(
name|avId
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|avId
operator|==
name|AVTIMESTAMP
condition|)
block|{
name|timeArray
operator|.
name|resize
argument_list|(
name|avLen
argument_list|)
expr_stmt|;
comment|//avLen size of QByteArray is allocated
name|ds
operator|.
name|readRawData
argument_list|(
name|timeArray
operator|.
name|data
argument_list|()
argument_list|,
name|avLen
argument_list|)
expr_stmt|;
break|break;
block|}
name|ds
operator|.
name|skipRawData
argument_list|(
name|avLen
argument_list|)
expr_stmt|;
name|ds
operator|>>
name|avId
expr_stmt|;
name|ds
operator|>>
name|avLen
expr_stmt|;
block|}
return|return
name|timeArray
return|;
block|}
end_function
begin_function
DECL|function|qEncodeNtlmv2Response
specifier|static
name|QByteArray
name|qEncodeNtlmv2Response
parameter_list|(
specifier|const
name|QAuthenticatorPrivate
modifier|*
name|ctx
parameter_list|,
specifier|const
name|QNtlmPhase2Block
modifier|&
name|ch
parameter_list|,
name|QNtlmPhase3Block
modifier|*
name|phase3
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|phase3
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|// return value stored in phase3
name|qCreatev2Hash
argument_list|(
name|ctx
argument_list|,
name|phase3
argument_list|)
expr_stmt|;
name|QByteArray
name|temp
decl_stmt|;
name|QDataStream
name|ds
argument_list|(
operator|&
name|temp
argument_list|,
name|QIODevice
operator|::
name|WriteOnly
argument_list|)
decl_stmt|;
name|ds
operator|.
name|setByteOrder
argument_list|(
name|QDataStream
operator|::
name|LittleEndian
argument_list|)
expr_stmt|;
name|ds
operator|<<
name|respversion
expr_stmt|;
name|ds
operator|<<
name|hirespversion
expr_stmt|;
comment|//Reserved
name|QByteArray
name|reserved1
argument_list|(
literal|6
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|ds
operator|.
name|writeRawData
argument_list|(
name|reserved1
operator|.
name|constData
argument_list|()
argument_list|,
name|reserved1
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|quint64
name|time
init|=
literal|0
decl_stmt|;
name|QByteArray
name|timeArray
decl_stmt|;
if|if
condition|(
name|ch
operator|.
name|targetInfo
operator|.
name|len
condition|)
block|{
name|timeArray
operator|=
name|qExtractServerTime
argument_list|(
name|ch
operator|.
name|targetInfoBuff
argument_list|)
expr_stmt|;
block|}
comment|//if server sends time, use it instead of current time
if|if
condition|(
name|timeArray
operator|.
name|size
argument_list|()
condition|)
block|{
name|ds
operator|.
name|writeRawData
argument_list|(
name|timeArray
operator|.
name|constData
argument_list|()
argument_list|,
name|timeArray
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QDateTime
name|currentTime
argument_list|(
name|QDate
operator|::
name|currentDate
argument_list|()
argument_list|,
name|QTime
operator|::
name|currentTime
argument_list|()
argument_list|,
name|Qt
operator|::
name|UTC
argument_list|)
decl_stmt|;
comment|// number of seconds between 1601 and epoc(1970)
comment|// 369 years, 89 leap years
comment|// ((369 * 365) + 89) * 24 * 3600 = 11644473600
name|time
operator|=
name|Q_UINT64_C
argument_list|(
name|currentTime
operator|.
name|toTime_t
argument_list|()
operator|+
literal|11644473600
argument_list|)
expr_stmt|;
comment|// represented as 100 nano seconds
name|time
operator|=
name|Q_UINT64_C
argument_list|(
name|time
operator|*
literal|10000000
argument_list|)
expr_stmt|;
name|ds
operator|<<
name|time
expr_stmt|;
block|}
comment|//8 byte client challenge
name|QByteArray
name|clientCh
init|=
name|clientChallenge
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
name|ds
operator|.
name|writeRawData
argument_list|(
name|clientCh
operator|.
name|constData
argument_list|()
argument_list|,
name|clientCh
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|//Reserved
name|QByteArray
name|reserved2
argument_list|(
literal|4
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|ds
operator|.
name|writeRawData
argument_list|(
name|reserved2
operator|.
name|constData
argument_list|()
argument_list|,
name|reserved2
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|.
name|targetInfo
operator|.
name|len
operator|>
literal|0
condition|)
block|{
name|ds
operator|.
name|writeRawData
argument_list|(
name|ch
operator|.
name|targetInfoBuff
operator|.
name|constData
argument_list|()
argument_list|,
name|ch
operator|.
name|targetInfoBuff
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|//Reserved
name|QByteArray
name|reserved3
argument_list|(
literal|4
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|ds
operator|.
name|writeRawData
argument_list|(
name|reserved3
operator|.
name|constData
argument_list|()
argument_list|,
name|reserved3
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|QByteArray
name|message
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|ch
operator|.
name|challenge
argument_list|,
sizeof|sizeof
argument_list|(
name|ch
operator|.
name|challenge
argument_list|)
argument_list|)
decl_stmt|;
name|message
operator|.
name|append
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|QByteArray
name|ntChallengeResp
init|=
name|qEncodeHmacMd5
argument_list|(
name|phase3
operator|->
name|v2Hash
argument_list|,
name|message
argument_list|)
decl_stmt|;
name|ntChallengeResp
operator|.
name|append
argument_list|(
name|temp
argument_list|)
expr_stmt|;
return|return
name|ntChallengeResp
return|;
block|}
end_function
begin_function
DECL|function|qEncodeLmv2Response
specifier|static
name|QByteArray
name|qEncodeLmv2Response
parameter_list|(
specifier|const
name|QAuthenticatorPrivate
modifier|*
name|ctx
parameter_list|,
specifier|const
name|QNtlmPhase2Block
modifier|&
name|ch
parameter_list|,
name|QNtlmPhase3Block
modifier|*
name|phase3
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|phase3
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|// return value stored in phase3
name|qCreatev2Hash
argument_list|(
name|ctx
argument_list|,
name|phase3
argument_list|)
expr_stmt|;
name|QByteArray
name|message
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|ch
operator|.
name|challenge
argument_list|,
sizeof|sizeof
argument_list|(
name|ch
operator|.
name|challenge
argument_list|)
argument_list|)
decl_stmt|;
name|QByteArray
name|clientCh
init|=
name|clientChallenge
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
name|message
operator|.
name|append
argument_list|(
name|clientCh
argument_list|)
expr_stmt|;
name|QByteArray
name|lmChallengeResp
init|=
name|qEncodeHmacMd5
argument_list|(
name|phase3
operator|->
name|v2Hash
argument_list|,
name|message
argument_list|)
decl_stmt|;
name|lmChallengeResp
operator|.
name|append
argument_list|(
name|clientCh
argument_list|)
expr_stmt|;
return|return
name|lmChallengeResp
return|;
block|}
end_function
begin_function
DECL|function|qNtlmDecodePhase2
specifier|static
name|bool
name|qNtlmDecodePhase2
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|data
parameter_list|,
name|QNtlmPhase2Block
modifier|&
name|ch
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|QNtlmPhase2BlockBase
operator|::
name|Size
operator|==
sizeof|sizeof
argument_list|(
name|QNtlmPhase2BlockBase
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|.
name|size
argument_list|()
operator|<
name|QNtlmPhase2BlockBase
operator|::
name|Size
condition|)
return|return
literal|false
return|;
name|QDataStream
name|ds
argument_list|(
name|data
argument_list|)
decl_stmt|;
name|ds
operator|.
name|setByteOrder
argument_list|(
name|QDataStream
operator|::
name|LittleEndian
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|.
name|readRawData
argument_list|(
name|ch
operator|.
name|magic
argument_list|,
literal|8
argument_list|)
operator|<
literal|8
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|ch
operator|.
name|magic
argument_list|,
literal|"NTLMSSP"
argument_list|,
literal|8
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|false
return|;
name|ds
operator|>>
name|ch
operator|.
name|type
expr_stmt|;
if|if
condition|(
name|ch
operator|.
name|type
operator|!=
literal|2
condition|)
return|return
literal|false
return|;
name|ds
operator|>>
name|ch
operator|.
name|targetName
expr_stmt|;
name|ds
operator|>>
name|ch
operator|.
name|flags
expr_stmt|;
if|if
condition|(
name|ds
operator|.
name|readRawData
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ch
operator|.
name|challenge
argument_list|,
literal|8
argument_list|)
operator|<
literal|8
condition|)
return|return
literal|false
return|;
name|ds
operator|>>
name|ch
operator|.
name|context
index|[
literal|0
index|]
operator|>>
name|ch
operator|.
name|context
index|[
literal|1
index|]
expr_stmt|;
name|ds
operator|>>
name|ch
operator|.
name|targetInfo
expr_stmt|;
if|if
condition|(
name|ch
operator|.
name|targetName
operator|.
name|len
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|ch
operator|.
name|targetName
operator|.
name|len
operator|+
name|ch
operator|.
name|targetName
operator|.
name|offset
operator|>=
operator|(
name|unsigned
operator|)
name|data
operator|.
name|size
argument_list|()
condition|)
return|return
literal|false
return|;
name|ch
operator|.
name|targetNameStr
operator|=
name|qStringFromUcs2Le
argument_list|(
name|data
operator|.
name|mid
argument_list|(
name|ch
operator|.
name|targetName
operator|.
name|offset
argument_list|,
name|ch
operator|.
name|targetName
operator|.
name|len
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|.
name|targetInfo
operator|.
name|len
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|ch
operator|.
name|targetInfo
operator|.
name|len
operator|+
name|ch
operator|.
name|targetInfo
operator|.
name|offset
operator|>
operator|(
name|unsigned
operator|)
name|data
operator|.
name|size
argument_list|()
condition|)
return|return
literal|false
return|;
name|ch
operator|.
name|targetInfoBuff
operator|=
name|data
operator|.
name|mid
argument_list|(
name|ch
operator|.
name|targetInfo
operator|.
name|offset
argument_list|,
name|ch
operator|.
name|targetInfo
operator|.
name|len
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|qNtlmPhase3
specifier|static
name|QByteArray
name|qNtlmPhase3
parameter_list|(
name|QAuthenticatorPrivate
modifier|*
name|ctx
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|phase2data
parameter_list|)
block|{
name|QNtlmPhase2Block
name|ch
decl_stmt|;
if|if
condition|(
operator|!
name|qNtlmDecodePhase2
argument_list|(
name|phase2data
argument_list|,
name|ch
argument_list|)
condition|)
return|return
name|QByteArray
argument_list|()
return|;
name|QByteArray
name|rc
decl_stmt|;
name|QDataStream
name|ds
argument_list|(
operator|&
name|rc
argument_list|,
name|QIODevice
operator|::
name|WriteOnly
argument_list|)
decl_stmt|;
name|ds
operator|.
name|setByteOrder
argument_list|(
name|QDataStream
operator|::
name|LittleEndian
argument_list|)
expr_stmt|;
name|QNtlmPhase3Block
name|pb
decl_stmt|;
name|bool
name|unicode
init|=
name|ch
operator|.
name|flags
operator|&
name|NTLMSSP_NEGOTIATE_UNICODE
decl_stmt|;
name|pb
operator|.
name|flags
operator|=
name|NTLMSSP_NEGOTIATE_NTLM
expr_stmt|;
if|if
condition|(
name|unicode
condition|)
name|pb
operator|.
name|flags
operator||=
name|NTLMSSP_NEGOTIATE_UNICODE
expr_stmt|;
else|else
name|pb
operator|.
name|flags
operator||=
name|NTLMSSP_NEGOTIATE_OEM
expr_stmt|;
name|int
name|offset
init|=
name|QNtlmPhase3BlockBase
operator|::
name|Size
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|QNtlmPhase3BlockBase
operator|::
name|Size
operator|==
sizeof|sizeof
argument_list|(
name|QNtlmPhase3BlockBase
argument_list|)
argument_list|)
expr_stmt|;
comment|// for kerberos style user@domain logins, NTLM domain string should be left empty
if|if
condition|(
name|ctx
operator|->
name|userDomain
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|ctx
operator|->
name|extractedUser
operator|.
name|contains
argument_list|(
name|QLatin1Char
argument_list|(
literal|'@'
argument_list|)
argument_list|)
condition|)
block|{
name|offset
operator|=
name|qEncodeNtlmString
argument_list|(
name|pb
operator|.
name|domain
argument_list|,
name|offset
argument_list|,
name|ch
operator|.
name|targetNameStr
argument_list|,
name|unicode
argument_list|)
expr_stmt|;
name|pb
operator|.
name|domainStr
operator|=
name|ch
operator|.
name|targetNameStr
expr_stmt|;
block|}
else|else
block|{
name|offset
operator|=
name|qEncodeNtlmString
argument_list|(
name|pb
operator|.
name|domain
argument_list|,
name|offset
argument_list|,
name|ctx
operator|->
name|userDomain
argument_list|,
name|unicode
argument_list|)
expr_stmt|;
name|pb
operator|.
name|domainStr
operator|=
name|ctx
operator|->
name|userDomain
expr_stmt|;
block|}
name|offset
operator|=
name|qEncodeNtlmString
argument_list|(
name|pb
operator|.
name|user
argument_list|,
name|offset
argument_list|,
name|ctx
operator|->
name|extractedUser
argument_list|,
name|unicode
argument_list|)
expr_stmt|;
name|pb
operator|.
name|userStr
operator|=
name|ctx
operator|->
name|extractedUser
expr_stmt|;
name|offset
operator|=
name|qEncodeNtlmString
argument_list|(
name|pb
operator|.
name|workstation
argument_list|,
name|offset
argument_list|,
name|ctx
operator|->
name|workstation
argument_list|,
name|unicode
argument_list|)
expr_stmt|;
name|pb
operator|.
name|workstationStr
operator|=
name|ctx
operator|->
name|workstation
expr_stmt|;
comment|// Get LM response
ifdef|#
directive|ifdef
name|NTLMV1_CLIENT
name|pb
operator|.
name|lmResponseBuf
operator|=
name|qEncodeLmResponse
argument_list|(
name|ctx
argument_list|,
name|ch
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|ch
operator|.
name|targetInfo
operator|.
name|len
operator|>
literal|0
condition|)
block|{
name|pb
operator|.
name|lmResponseBuf
operator|=
name|QByteArray
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|pb
operator|.
name|lmResponseBuf
operator|=
name|qEncodeLmv2Response
argument_list|(
name|ctx
argument_list|,
name|ch
argument_list|,
operator|&
name|pb
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|offset
operator|=
name|qEncodeNtlmBuffer
argument_list|(
name|pb
operator|.
name|lmResponse
argument_list|,
name|offset
argument_list|,
name|pb
operator|.
name|lmResponseBuf
argument_list|)
expr_stmt|;
comment|// Get NTLM response
ifdef|#
directive|ifdef
name|NTLMV1_CLIENT
name|pb
operator|.
name|ntlmResponseBuf
operator|=
name|qEncodeNtlmResponse
argument_list|(
name|ctx
argument_list|,
name|ch
argument_list|)
expr_stmt|;
else|#
directive|else
name|pb
operator|.
name|ntlmResponseBuf
operator|=
name|qEncodeNtlmv2Response
argument_list|(
name|ctx
argument_list|,
name|ch
argument_list|,
operator|&
name|pb
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|offset
operator|=
name|qEncodeNtlmBuffer
argument_list|(
name|pb
operator|.
name|ntlmResponse
argument_list|,
name|offset
argument_list|,
name|pb
operator|.
name|ntlmResponseBuf
argument_list|)
expr_stmt|;
comment|// Encode and send
name|ds
operator|<<
name|pb
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
