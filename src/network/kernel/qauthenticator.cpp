begin_unit
begin_comment
comment|/**************************************************************************** ** ** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies). ** Contact: http://www.qt-project.org/legal ** ** This file is part of the QtNetwork module of the Qt Toolkit. ** ** $QT_BEGIN_LICENSE:LGPL$ ** Commercial License Usage ** Licensees holding valid commercial Qt licenses may use this file in ** accordance with the commercial license agreement provided with the ** Software or, alternatively, in accordance with the terms contained in ** a written agreement between you and Digia.  For licensing terms and ** conditions see http://qt.digia.com/licensing.  For further information ** use the contact form at http://qt.digia.com/contact-us. ** ** GNU Lesser General Public License Usage ** Alternatively, this file may be used under the terms of the GNU Lesser ** General Public License version 2.1 as published by the Free Software ** Foundation and appearing in the file LICENSE.LGPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU Lesser General Public License version 2.1 requirements ** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html. ** ** In addition, as a special exception, Digia gives you certain additional ** rights.  These rights are described in the Digia Qt LGPL Exception ** version 1.1, included in the file LGPL_EXCEPTION.txt in this package. ** ** GNU General Public License Usage ** Alternatively, this file may be used under the terms of the GNU ** General Public License version 3.0 as published by the Free Software ** Foundation and appearing in the file LICENSE.GPL included in the ** packaging of this file.  Please review the following information to ** ensure the GNU General Public License version 3.0 requirements will be ** met: http://www.gnu.org/copyleft/gpl.html. ** ** ** $QT_END_LICENSE$ ** ****************************************************************************/
end_comment
begin_include
include|#
directive|include
file|<qauthenticator.h>
end_include
begin_include
include|#
directive|include
file|<qauthenticator_p.h>
end_include
begin_include
include|#
directive|include
file|<qdebug.h>
end_include
begin_include
include|#
directive|include
file|<qhash.h>
end_include
begin_include
include|#
directive|include
file|<qbytearray.h>
end_include
begin_include
include|#
directive|include
file|<qcryptographichash.h>
end_include
begin_include
include|#
directive|include
file|<qiodevice.h>
end_include
begin_include
include|#
directive|include
file|<qdatastream.h>
end_include
begin_include
include|#
directive|include
file|<qendian.h>
end_include
begin_include
include|#
directive|include
file|<qstring.h>
end_include
begin_include
include|#
directive|include
file|<qdatetime.h>
end_include
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_WIN
end_ifdef
begin_include
include|#
directive|include
file|<qmutex.h>
end_include
begin_include
include|#
directive|include
file|<private/qmutexpool_p.h>
end_include
begin_include
include|#
directive|include
file|<rpc.h>
end_include
begin_define
DECL|macro|SECURITY_WIN32
define|#
directive|define
name|SECURITY_WIN32
value|1
end_define
begin_include
include|#
directive|include
file|<security.h>
end_include
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|//#define NTLMV1_CLIENT
end_comment
begin_function_decl
name|QT_BEGIN_NAMESPACE
ifdef|#
directive|ifdef
name|NTLMV1_CLIENT
include|#
directive|include
file|"../../3rdparty/des/des.cpp"
endif|#
directive|endif
specifier|static
name|QByteArray
name|qNtlmPhase1
parameter_list|()
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|QByteArray
name|qNtlmPhase3
parameter_list|(
name|QAuthenticatorPrivate
modifier|*
name|ctx
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|phase2data
parameter_list|)
function_decl|;
end_function_decl
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_WIN
end_ifdef
begin_function_decl
specifier|static
name|QByteArray
name|qNtlmPhase1_SSPI
parameter_list|(
name|QAuthenticatorPrivate
modifier|*
name|ctx
parameter_list|)
function_decl|;
end_function_decl
begin_function_decl
specifier|static
name|QByteArray
name|qNtlmPhase3_SSPI
parameter_list|(
name|QAuthenticatorPrivate
modifier|*
name|ctx
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|phase2data
parameter_list|)
function_decl|;
end_function_decl
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/*!   \class QAuthenticator   \brief The QAuthenticator class provides an authentication object.   \since 4.3    \reentrant   \ingroup network   \inmodule QtNetwork    The QAuthenticator class is usually used in the   \l{QNetworkAccessManager::}{authenticationRequired()} and   \l{QNetworkAccessManager::}{proxyAuthenticationRequired()} signals of QNetworkAccessManager and   QAbstractSocket. The class provides a way to pass back the required   authentication information to the socket when accessing services that   require authentication.    QAuthenticator supports the following authentication methods:   \list     \li Basic     \li NTLM version 2     \li Digest-MD5   \endlist    \section1 Options    In addition to the username and password required for authentication, a   QAuthenticator object can also contain additional options. The   options() function can be used to query incoming options sent by   the server; the setOption() function can   be used to set outgoing options, to be processed by the authenticator   calculation. The options accepted and provided depend on the authentication   type (see method()).    The following tables list known incoming options as well as accepted   outgoing options. The list of incoming options is not exhaustive, since   servers may include additional information at any time. The list of   outgoing options is exhaustive, however, and no unknown options will be   treated or sent back to the server.    \section2 Basic    \table     \header \li Option \li Direction \li Description     \row \li \tt{realm} \li Incoming \li Contains the realm of the authentication, the same as realm()   \endtable    The Basic authentication mechanism supports no outgoing options.    \section2 NTLM version 2    The NTLM authentication mechanism currently supports no incoming or outgoing options.   On Windows, if no \a user has been set, domain\\user credentials will be searched for on the   local system to enable Single-Sign-On functionality.    \section2 Digest-MD5    \table     \header \li Option \li Direction \li Description     \row \li \tt{realm} \li Incoming \li Contains the realm of the authentication, the same as realm()   \endtable    The Digest-MD5 authentication mechanism supports no outgoing options.    \sa QSslSocket */
end_comment
begin_comment
comment|/*!   Constructs an empty authentication object */
end_comment
begin_constructor
DECL|function|QAuthenticator
name|QAuthenticator
operator|::
name|QAuthenticator
parameter_list|()
member_init_list|:
name|d
argument_list|(
literal|0
argument_list|)
block|{ }
end_constructor
begin_comment
comment|/*!   Destructs the object */
end_comment
begin_destructor
DECL|function|~QAuthenticator
name|QAuthenticator
operator|::
name|~
name|QAuthenticator
parameter_list|()
block|{
if|if
condition|(
name|d
condition|)
operator|delete
name|d
expr_stmt|;
block|}
end_destructor
begin_comment
comment|/*!     Constructs a copy of \a other. */
end_comment
begin_constructor
DECL|function|QAuthenticator
name|QAuthenticator
operator|::
name|QAuthenticator
parameter_list|(
specifier|const
name|QAuthenticator
modifier|&
name|other
parameter_list|)
member_init_list|:
name|d
argument_list|(
literal|0
argument_list|)
block|{
if|if
condition|(
name|other
operator|.
name|d
condition|)
operator|*
name|this
operator|=
name|other
expr_stmt|;
block|}
end_constructor
begin_comment
comment|/*!     Assigns the contents of \a other to this authenticator. */
end_comment
begin_function
DECL|function|operator =
name|QAuthenticator
modifier|&
name|QAuthenticator
operator|::
name|operator
name|=
parameter_list|(
specifier|const
name|QAuthenticator
modifier|&
name|other
parameter_list|)
block|{
if|if
condition|(
name|d
operator|==
name|other
operator|.
name|d
condition|)
return|return
operator|*
name|this
return|;
comment|// Do not share the d since challange reponse/based changes
comment|// could corrupt the internal store and different network requests
comment|// can utilize different types of proxies.
name|detach
argument_list|()
expr_stmt|;
if|if
condition|(
name|other
operator|.
name|d
condition|)
block|{
name|d
operator|->
name|user
operator|=
name|other
operator|.
name|d
operator|->
name|user
expr_stmt|;
name|d
operator|->
name|userDomain
operator|=
name|other
operator|.
name|d
operator|->
name|userDomain
expr_stmt|;
name|d
operator|->
name|workstation
operator|=
name|other
operator|.
name|d
operator|->
name|workstation
expr_stmt|;
name|d
operator|->
name|extractedUser
operator|=
name|other
operator|.
name|d
operator|->
name|extractedUser
expr_stmt|;
name|d
operator|->
name|password
operator|=
name|other
operator|.
name|d
operator|->
name|password
expr_stmt|;
name|d
operator|->
name|realm
operator|=
name|other
operator|.
name|d
operator|->
name|realm
expr_stmt|;
name|d
operator|->
name|method
operator|=
name|other
operator|.
name|d
operator|->
name|method
expr_stmt|;
name|d
operator|->
name|options
operator|=
name|other
operator|.
name|d
operator|->
name|options
expr_stmt|;
block|}
else|else
block|{
operator|delete
name|d
expr_stmt|;
name|d
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|*
name|this
return|;
block|}
end_function
begin_comment
comment|/*!     Returns true if this authenticator is identical to \a other; otherwise     returns false. */
end_comment
begin_function
DECL|function|operator ==
name|bool
name|QAuthenticator
operator|::
name|operator
name|==
parameter_list|(
specifier|const
name|QAuthenticator
modifier|&
name|other
parameter_list|)
specifier|const
block|{
if|if
condition|(
name|d
operator|==
name|other
operator|.
name|d
condition|)
return|return
literal|true
return|;
return|return
name|d
operator|->
name|user
operator|==
name|other
operator|.
name|d
operator|->
name|user
operator|&&
name|d
operator|->
name|password
operator|==
name|other
operator|.
name|d
operator|->
name|password
operator|&&
name|d
operator|->
name|realm
operator|==
name|other
operator|.
name|d
operator|->
name|realm
operator|&&
name|d
operator|->
name|method
operator|==
name|other
operator|.
name|d
operator|->
name|method
operator|&&
name|d
operator|->
name|options
operator|==
name|other
operator|.
name|d
operator|->
name|options
return|;
block|}
end_function
begin_comment
comment|/*!     \fn bool QAuthenticator::operator!=(const QAuthenticator&other) const      Returns true if this authenticator is different from \a other; otherwise     returns false. */
end_comment
begin_comment
comment|/*!   returns the user used for authentication. */
end_comment
begin_function
DECL|function|user
name|QString
name|QAuthenticator
operator|::
name|user
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|d
operator|->
name|user
else|:
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!   Sets the \a user used for authentication.    \sa QNetworkAccessManager::authenticationRequired() */
end_comment
begin_function
DECL|function|setUser
name|void
name|QAuthenticator
operator|::
name|setUser
parameter_list|(
specifier|const
name|QString
modifier|&
name|user
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|user
operator|=
name|user
expr_stmt|;
name|d
operator|->
name|updateCredentials
argument_list|()
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   returns the password used for authentication. */
end_comment
begin_function
DECL|function|password
name|QString
name|QAuthenticator
operator|::
name|password
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|d
operator|->
name|password
else|:
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!   Sets the \a password used for authentication.    \sa QNetworkAccessManager::authenticationRequired() */
end_comment
begin_function
DECL|function|setPassword
name|void
name|QAuthenticator
operator|::
name|setPassword
parameter_list|(
specifier|const
name|QString
modifier|&
name|password
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|password
operator|=
name|password
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   \internal */
end_comment
begin_function
DECL|function|detach
name|void
name|QAuthenticator
operator|::
name|detach
parameter_list|()
block|{
if|if
condition|(
operator|!
name|d
condition|)
block|{
name|d
operator|=
operator|new
name|QAuthenticatorPrivate
expr_stmt|;
return|return;
block|}
name|d
operator|->
name|phase
operator|=
name|QAuthenticatorPrivate
operator|::
name|Start
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!   returns the realm requiring authentication. */
end_comment
begin_function
DECL|function|realm
name|QString
name|QAuthenticator
operator|::
name|realm
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|d
operator|->
name|realm
else|:
name|QString
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.7     Returns the value related to option \a opt if it was set by the server.     See \l{QAuthenticator#Options} for more information on incoming options.     If option \a opt isn't found, an invalid QVariant will be returned.      \sa options(), QAuthenticator#Options */
end_comment
begin_function
DECL|function|option
name|QVariant
name|QAuthenticator
operator|::
name|option
parameter_list|(
specifier|const
name|QString
modifier|&
name|opt
parameter_list|)
specifier|const
block|{
return|return
name|d
condition|?
name|d
operator|->
name|options
operator|.
name|value
argument_list|(
name|opt
argument_list|)
else|:
name|QVariant
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.7     Returns all incoming options set in this QAuthenticator object by parsing     the server reply. See \l{QAuthenticator#Options} for more information     on incoming options.      \sa option(), QAuthenticator#Options */
end_comment
begin_function
DECL|function|options
name|QVariantHash
name|QAuthenticator
operator|::
name|options
parameter_list|()
specifier|const
block|{
return|return
name|d
condition|?
name|d
operator|->
name|options
else|:
name|QVariantHash
argument_list|()
return|;
block|}
end_function
begin_comment
comment|/*!     \since 4.7      Sets the outgoing option \a opt to value \a value.     See \l{QAuthenticator#Options} for more information on outgoing options.      \sa options(), option(), QAuthenticator#Options */
end_comment
begin_function
DECL|function|setOption
name|void
name|QAuthenticator
operator|::
name|setOption
parameter_list|(
specifier|const
name|QString
modifier|&
name|opt
parameter_list|,
specifier|const
name|QVariant
modifier|&
name|value
parameter_list|)
block|{
name|detach
argument_list|()
expr_stmt|;
name|d
operator|->
name|options
operator|.
name|insert
argument_list|(
name|opt
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function
begin_comment
comment|/*!     Returns true if the authenticator is null. */
end_comment
begin_function
DECL|function|isNull
name|bool
name|QAuthenticator
operator|::
name|isNull
parameter_list|()
specifier|const
block|{
return|return
operator|!
name|d
return|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_WIN
end_ifdef
begin_class
DECL|class|QNtlmWindowsHandles
class|class
name|QNtlmWindowsHandles
block|{
public|public:
DECL|member|credHandle
name|CredHandle
name|credHandle
decl_stmt|;
DECL|member|ctxHandle
name|CtxtHandle
name|ctxHandle
decl_stmt|;
block|}
class|;
end_class
begin_endif
endif|#
directive|endif
end_endif
begin_constructor
DECL|function|QAuthenticatorPrivate
name|QAuthenticatorPrivate
operator|::
name|QAuthenticatorPrivate
parameter_list|()
member_init_list|:
name|method
argument_list|(
name|None
argument_list|)
ifdef|#
directive|ifdef
name|Q_OS_WIN
member_init_list|,
name|ntlmWindowsHandles
argument_list|(
literal|0
argument_list|)
endif|#
directive|endif
member_init_list|,
name|hasFailed
argument_list|(
literal|false
argument_list|)
member_init_list|,
name|phase
argument_list|(
name|Start
argument_list|)
member_init_list|,
name|nonceCount
argument_list|(
literal|0
argument_list|)
block|{
name|cnonce
operator|=
name|QCryptographicHash
operator|::
name|hash
argument_list|(
name|QByteArray
operator|::
name|number
argument_list|(
name|qrand
argument_list|()
argument_list|,
literal|16
argument_list|)
operator|+
name|QByteArray
operator|::
name|number
argument_list|(
name|qrand
argument_list|()
argument_list|,
literal|16
argument_list|)
argument_list|,
name|QCryptographicHash
operator|::
name|Md5
argument_list|)
operator|.
name|toHex
argument_list|()
expr_stmt|;
name|nonceCount
operator|=
literal|0
expr_stmt|;
block|}
end_constructor
begin_destructor
DECL|function|~QAuthenticatorPrivate
name|QAuthenticatorPrivate
operator|::
name|~
name|QAuthenticatorPrivate
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|Q_OS_WIN
if|if
condition|(
name|ntlmWindowsHandles
condition|)
operator|delete
name|ntlmWindowsHandles
expr_stmt|;
endif|#
directive|endif
block|}
end_destructor
begin_function
DECL|function|updateCredentials
name|void
name|QAuthenticatorPrivate
operator|::
name|updateCredentials
parameter_list|()
block|{
name|int
name|separatorPosn
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|method
condition|)
block|{
case|case
name|QAuthenticatorPrivate
operator|::
name|Ntlm
case|:
if|if
condition|(
operator|(
name|separatorPosn
operator|=
name|user
operator|.
name|indexOf
argument_list|(
name|QLatin1String
argument_list|(
literal|"\\"
argument_list|)
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
comment|//domain name is present
name|realm
operator|.
name|clear
argument_list|()
expr_stmt|;
name|userDomain
operator|=
name|user
operator|.
name|left
argument_list|(
name|separatorPosn
argument_list|)
expr_stmt|;
name|extractedUser
operator|=
name|user
operator|.
name|mid
argument_list|(
name|separatorPosn
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|extractedUser
operator|=
name|user
expr_stmt|;
name|realm
operator|.
name|clear
argument_list|()
expr_stmt|;
name|userDomain
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
break|break;
default|default:
name|userDomain
operator|.
name|clear
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
end_function
begin_function
DECL|function|parseHttpResponse
name|void
name|QAuthenticatorPrivate
operator|::
name|parseHttpResponse
parameter_list|(
specifier|const
name|QList
argument_list|<
name|QPair
argument_list|<
name|QByteArray
argument_list|,
name|QByteArray
argument_list|>
argument_list|>
modifier|&
name|values
parameter_list|,
name|bool
name|isProxy
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|search
init|=
name|isProxy
condition|?
literal|"proxy-authenticate"
else|:
literal|"www-authenticate"
decl_stmt|;
name|method
operator|=
name|None
expr_stmt|;
comment|/*       Fun from the HTTP 1.1 specs, that we currently ignore:        User agents are advised to take special care in parsing the WWW-       Authenticate field value as it might contain more than one challenge,       or if more than one WWW-Authenticate header field is provided, the       contents of a challenge itself can contain a comma-separated list of       authentication parameters.     */
name|QByteArray
name|headerVal
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|values
operator|.
name|size
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|QPair
argument_list|<
name|QByteArray
argument_list|,
name|QByteArray
argument_list|>
modifier|&
name|current
init|=
name|values
operator|.
name|at
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|current
operator|.
name|first
operator|.
name|toLower
argument_list|()
operator|!=
name|search
condition|)
continue|continue;
name|QByteArray
name|str
init|=
name|current
operator|.
name|second
operator|.
name|toLower
argument_list|()
decl_stmt|;
if|if
condition|(
name|method
operator|<
name|Basic
operator|&&
name|str
operator|.
name|startsWith
argument_list|(
literal|"basic"
argument_list|)
condition|)
block|{
name|method
operator|=
name|Basic
expr_stmt|;
name|headerVal
operator|=
name|current
operator|.
name|second
operator|.
name|mid
argument_list|(
literal|6
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|method
operator|<
name|Ntlm
operator|&&
name|str
operator|.
name|startsWith
argument_list|(
literal|"ntlm"
argument_list|)
condition|)
block|{
name|method
operator|=
name|Ntlm
expr_stmt|;
name|headerVal
operator|=
name|current
operator|.
name|second
operator|.
name|mid
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|method
operator|<
name|DigestMd5
operator|&&
name|str
operator|.
name|startsWith
argument_list|(
literal|"digest"
argument_list|)
condition|)
block|{
name|method
operator|=
name|DigestMd5
expr_stmt|;
name|headerVal
operator|=
name|current
operator|.
name|second
operator|.
name|mid
argument_list|(
literal|7
argument_list|)
expr_stmt|;
block|}
block|}
comment|// Reparse credentials since we know the method now
name|updateCredentials
argument_list|()
expr_stmt|;
name|challenge
operator|=
name|headerVal
operator|.
name|trimmed
argument_list|()
expr_stmt|;
name|QHash
argument_list|<
name|QByteArray
argument_list|,
name|QByteArray
argument_list|>
name|options
init|=
name|parseDigestAuthenticationChallenge
argument_list|(
name|challenge
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|method
condition|)
block|{
case|case
name|Basic
case|:
name|this
operator|->
name|options
index|[
name|QLatin1String
argument_list|(
literal|"realm"
argument_list|)
index|]
operator|=
name|realm
operator|=
name|QString
operator|::
name|fromLatin1
argument_list|(
name|options
operator|.
name|value
argument_list|(
literal|"realm"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|user
operator|.
name|isEmpty
argument_list|()
operator|&&
name|password
operator|.
name|isEmpty
argument_list|()
condition|)
name|phase
operator|=
name|Done
expr_stmt|;
break|break;
case|case
name|Ntlm
case|:
comment|// #### extract from header
if|if
condition|(
name|user
operator|.
name|isEmpty
argument_list|()
operator|&&
name|password
operator|.
name|isEmpty
argument_list|()
condition|)
name|phase
operator|=
name|Done
expr_stmt|;
break|break;
case|case
name|DigestMd5
case|:
block|{
name|this
operator|->
name|options
index|[
name|QLatin1String
argument_list|(
literal|"realm"
argument_list|)
index|]
operator|=
name|realm
operator|=
name|QString
operator|::
name|fromLatin1
argument_list|(
name|options
operator|.
name|value
argument_list|(
literal|"realm"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|options
operator|.
name|value
argument_list|(
literal|"stale"
argument_list|)
operator|.
name|toLower
argument_list|()
operator|==
literal|"true"
condition|)
name|phase
operator|=
name|Start
expr_stmt|;
if|if
condition|(
name|user
operator|.
name|isEmpty
argument_list|()
operator|&&
name|password
operator|.
name|isEmpty
argument_list|()
condition|)
name|phase
operator|=
name|Done
expr_stmt|;
break|break;
block|}
default|default:
name|realm
operator|.
name|clear
argument_list|()
expr_stmt|;
name|challenge
operator|=
name|QByteArray
argument_list|()
expr_stmt|;
name|phase
operator|=
name|Invalid
expr_stmt|;
block|}
block|}
end_function
begin_function
DECL|function|calculateResponse
name|QByteArray
name|QAuthenticatorPrivate
operator|::
name|calculateResponse
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|requestMethod
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|path
parameter_list|)
block|{
name|QByteArray
name|response
decl_stmt|;
specifier|const
name|char
modifier|*
name|methodString
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|method
condition|)
block|{
case|case
name|QAuthenticatorPrivate
operator|::
name|None
case|:
name|methodString
operator|=
literal|""
expr_stmt|;
name|phase
operator|=
name|Done
expr_stmt|;
break|break;
case|case
name|QAuthenticatorPrivate
operator|::
name|Plain
case|:
name|response
operator|=
literal|'\0'
operator|+
name|user
operator|.
name|toUtf8
argument_list|()
operator|+
literal|'\0'
operator|+
name|password
operator|.
name|toUtf8
argument_list|()
expr_stmt|;
name|phase
operator|=
name|Done
expr_stmt|;
break|break;
case|case
name|QAuthenticatorPrivate
operator|::
name|Basic
case|:
name|methodString
operator|=
literal|"Basic "
expr_stmt|;
name|response
operator|=
name|user
operator|.
name|toLatin1
argument_list|()
operator|+
literal|':'
operator|+
name|password
operator|.
name|toLatin1
argument_list|()
expr_stmt|;
name|response
operator|=
name|response
operator|.
name|toBase64
argument_list|()
expr_stmt|;
name|phase
operator|=
name|Done
expr_stmt|;
break|break;
case|case
name|QAuthenticatorPrivate
operator|::
name|Login
case|:
if|if
condition|(
name|challenge
operator|.
name|contains
argument_list|(
literal|"VXNlciBOYW1lAA=="
argument_list|)
condition|)
block|{
name|response
operator|=
name|user
operator|.
name|toUtf8
argument_list|()
operator|.
name|toBase64
argument_list|()
expr_stmt|;
name|phase
operator|=
name|Phase2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|challenge
operator|.
name|contains
argument_list|(
literal|"UGFzc3dvcmQA"
argument_list|)
condition|)
block|{
name|response
operator|=
name|password
operator|.
name|toUtf8
argument_list|()
operator|.
name|toBase64
argument_list|()
expr_stmt|;
name|phase
operator|=
name|Done
expr_stmt|;
block|}
break|break;
case|case
name|QAuthenticatorPrivate
operator|::
name|CramMd5
case|:
break|break;
case|case
name|QAuthenticatorPrivate
operator|::
name|DigestMd5
case|:
name|methodString
operator|=
literal|"Digest "
expr_stmt|;
name|response
operator|=
name|digestMd5Response
argument_list|(
name|challenge
argument_list|,
name|requestMethod
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|phase
operator|=
name|Done
expr_stmt|;
break|break;
case|case
name|QAuthenticatorPrivate
operator|::
name|Ntlm
case|:
name|methodString
operator|=
literal|"NTLM "
expr_stmt|;
if|if
condition|(
name|challenge
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
ifdef|#
directive|ifdef
name|Q_OS_WIN
name|QByteArray
name|phase1Token
decl_stmt|;
if|if
condition|(
name|user
operator|.
name|isEmpty
argument_list|()
condition|)
comment|// Only pull from system if no user was specified in authenticator
name|phase1Token
operator|=
name|qNtlmPhase1_SSPI
argument_list|(
name|this
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|phase1Token
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|response
operator|=
name|phase1Token
operator|.
name|toBase64
argument_list|()
expr_stmt|;
name|phase
operator|=
name|Phase2
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|response
operator|=
name|qNtlmPhase1
argument_list|()
operator|.
name|toBase64
argument_list|()
expr_stmt|;
if|if
condition|(
name|user
operator|.
name|isEmpty
argument_list|()
condition|)
name|phase
operator|=
name|Done
expr_stmt|;
else|else
name|phase
operator|=
name|Phase2
expr_stmt|;
block|}
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|Q_OS_WIN
name|QByteArray
name|phase3Token
decl_stmt|;
if|if
condition|(
name|ntlmWindowsHandles
condition|)
name|phase3Token
operator|=
name|qNtlmPhase3_SSPI
argument_list|(
name|this
argument_list|,
name|QByteArray
operator|::
name|fromBase64
argument_list|(
name|challenge
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|phase3Token
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|response
operator|=
name|phase3Token
operator|.
name|toBase64
argument_list|()
expr_stmt|;
name|phase
operator|=
name|Done
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|response
operator|=
name|qNtlmPhase3
argument_list|(
name|this
argument_list|,
name|QByteArray
operator|::
name|fromBase64
argument_list|(
name|challenge
argument_list|)
argument_list|)
operator|.
name|toBase64
argument_list|()
expr_stmt|;
name|phase
operator|=
name|Done
expr_stmt|;
block|}
block|}
break|break;
block|}
return|return
name|QByteArray
argument_list|(
name|methodString
argument_list|)
operator|+
name|response
return|;
block|}
end_function
begin_comment
comment|// ---------------------------- Digest Md5 code ----------------------------------------
end_comment
begin_function
DECL|function|parseDigestAuthenticationChallenge
name|QHash
argument_list|<
name|QByteArray
argument_list|,
name|QByteArray
argument_list|>
name|QAuthenticatorPrivate
operator|::
name|parseDigestAuthenticationChallenge
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|challenge
parameter_list|)
block|{
name|QHash
argument_list|<
name|QByteArray
argument_list|,
name|QByteArray
argument_list|>
name|options
decl_stmt|;
comment|// parse the challenge
specifier|const
name|char
modifier|*
name|d
init|=
name|challenge
operator|.
name|constData
argument_list|()
decl_stmt|;
specifier|const
name|char
modifier|*
name|end
init|=
name|d
operator|+
name|challenge
operator|.
name|length
argument_list|()
decl_stmt|;
while|while
condition|(
name|d
operator|<
name|end
condition|)
block|{
while|while
condition|(
name|d
operator|<
name|end
operator|&&
operator|(
operator|*
name|d
operator|==
literal|' '
operator|||
operator|*
name|d
operator|==
literal|'\n'
operator|||
operator|*
name|d
operator|==
literal|'\r'
operator|)
condition|)
operator|++
name|d
expr_stmt|;
specifier|const
name|char
modifier|*
name|start
init|=
name|d
decl_stmt|;
while|while
condition|(
name|d
operator|<
name|end
operator|&&
operator|*
name|d
operator|!=
literal|'='
condition|)
operator|++
name|d
expr_stmt|;
name|QByteArray
name|key
init|=
name|QByteArray
argument_list|(
name|start
argument_list|,
name|d
operator|-
name|start
argument_list|)
decl_stmt|;
operator|++
name|d
expr_stmt|;
if|if
condition|(
name|d
operator|>=
name|end
condition|)
break|break;
name|bool
name|quote
init|=
operator|(
operator|*
name|d
operator|==
literal|'"'
operator|)
decl_stmt|;
if|if
condition|(
name|quote
condition|)
operator|++
name|d
expr_stmt|;
if|if
condition|(
name|d
operator|>=
name|end
condition|)
break|break;
name|start
operator|=
name|d
expr_stmt|;
name|QByteArray
name|value
decl_stmt|;
while|while
condition|(
name|d
operator|<
name|end
condition|)
block|{
name|bool
name|backslash
init|=
literal|false
decl_stmt|;
if|if
condition|(
operator|*
name|d
operator|==
literal|'\\'
operator|&&
name|d
operator|<
name|end
operator|-
literal|1
condition|)
block|{
operator|++
name|d
expr_stmt|;
name|backslash
operator|=
literal|true
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|backslash
condition|)
block|{
if|if
condition|(
name|quote
condition|)
block|{
if|if
condition|(
operator|*
name|d
operator|==
literal|'"'
condition|)
break|break;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|d
operator|==
literal|','
condition|)
break|break;
block|}
block|}
name|value
operator|+=
operator|*
name|d
expr_stmt|;
operator|++
name|d
expr_stmt|;
block|}
while|while
condition|(
name|d
operator|<
name|end
operator|&&
operator|*
name|d
operator|!=
literal|','
condition|)
operator|++
name|d
expr_stmt|;
operator|++
name|d
expr_stmt|;
name|options
index|[
name|key
index|]
operator|=
name|value
expr_stmt|;
block|}
name|QByteArray
name|qop
init|=
name|options
operator|.
name|value
argument_list|(
literal|"qop"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|qop
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|QList
argument_list|<
name|QByteArray
argument_list|>
name|qopoptions
init|=
name|qop
operator|.
name|split
argument_list|(
literal|','
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|qopoptions
operator|.
name|contains
argument_list|(
literal|"auth"
argument_list|)
condition|)
return|return
name|QHash
argument_list|<
name|QByteArray
argument_list|,
name|QByteArray
argument_list|>
argument_list|()
return|;
comment|// #### can't do auth-int currently
comment|//         if (qop.contains("auth-int"))
comment|//             qop = "auth-int";
comment|//         else if (qop.contains("auth"))
comment|//             qop = "auth";
comment|//         else
comment|//             qop = QByteArray();
name|options
index|[
literal|"qop"
index|]
operator|=
literal|"auth"
expr_stmt|;
block|}
return|return
name|options
return|;
block|}
end_function
begin_comment
comment|/*   Digest MD5 implementation    Code taken from RFC 2617    Currently we don't support the full SASL authentication mechanism (which includes cyphers) */
end_comment
begin_comment
comment|/* calculate request-digest/response-digest as per HTTP Digest spec */
end_comment
begin_function
DECL|function|digestMd5ResponseHelper
specifier|static
name|QByteArray
name|digestMd5ResponseHelper
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|alg
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|userName
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|realm
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|password
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|nonce
parameter_list|,
comment|/* nonce from server */
specifier|const
name|QByteArray
modifier|&
name|nonceCount
parameter_list|,
comment|/* 8 hex digits */
specifier|const
name|QByteArray
modifier|&
name|cNonce
parameter_list|,
comment|/* client nonce */
specifier|const
name|QByteArray
modifier|&
name|qop
parameter_list|,
comment|/* qop-value: "", "auth", "auth-int" */
specifier|const
name|QByteArray
modifier|&
name|method
parameter_list|,
comment|/* method from the request */
specifier|const
name|QByteArray
modifier|&
name|digestUri
parameter_list|,
comment|/* requested URL */
specifier|const
name|QByteArray
modifier|&
name|hEntity
comment|/* H(entity body) if qop="auth-int" */
parameter_list|)
block|{
name|QCryptographicHash
name|hash
argument_list|(
name|QCryptographicHash
operator|::
name|Md5
argument_list|)
decl_stmt|;
name|hash
operator|.
name|addData
argument_list|(
name|userName
argument_list|)
expr_stmt|;
name|hash
operator|.
name|addData
argument_list|(
literal|":"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hash
operator|.
name|addData
argument_list|(
name|realm
argument_list|)
expr_stmt|;
name|hash
operator|.
name|addData
argument_list|(
literal|":"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hash
operator|.
name|addData
argument_list|(
name|password
argument_list|)
expr_stmt|;
name|QByteArray
name|ha1
init|=
name|hash
operator|.
name|result
argument_list|()
decl_stmt|;
if|if
condition|(
name|alg
operator|.
name|toLower
argument_list|()
operator|==
literal|"md5-sess"
condition|)
block|{
name|hash
operator|.
name|reset
argument_list|()
expr_stmt|;
comment|// RFC 2617 contains an error, it was:
comment|// hash.addData(ha1);
comment|// but according to the errata page at http://www.rfc-editor.org/errata_list.php, ID 1649, it
comment|// must be the following line:
name|hash
operator|.
name|addData
argument_list|(
name|ha1
operator|.
name|toHex
argument_list|()
argument_list|)
expr_stmt|;
name|hash
operator|.
name|addData
argument_list|(
literal|":"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hash
operator|.
name|addData
argument_list|(
name|nonce
argument_list|)
expr_stmt|;
name|hash
operator|.
name|addData
argument_list|(
literal|":"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hash
operator|.
name|addData
argument_list|(
name|cNonce
argument_list|)
expr_stmt|;
name|ha1
operator|=
name|hash
operator|.
name|result
argument_list|()
expr_stmt|;
block|}
empty_stmt|;
name|ha1
operator|=
name|ha1
operator|.
name|toHex
argument_list|()
expr_stmt|;
comment|// calculate H(A2)
name|hash
operator|.
name|reset
argument_list|()
expr_stmt|;
name|hash
operator|.
name|addData
argument_list|(
name|method
argument_list|)
expr_stmt|;
name|hash
operator|.
name|addData
argument_list|(
literal|":"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hash
operator|.
name|addData
argument_list|(
name|digestUri
argument_list|)
expr_stmt|;
if|if
condition|(
name|qop
operator|.
name|toLower
argument_list|()
operator|==
literal|"auth-int"
condition|)
block|{
name|hash
operator|.
name|addData
argument_list|(
literal|":"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hash
operator|.
name|addData
argument_list|(
name|hEntity
argument_list|)
expr_stmt|;
block|}
name|QByteArray
name|ha2hex
init|=
name|hash
operator|.
name|result
argument_list|()
operator|.
name|toHex
argument_list|()
decl_stmt|;
comment|// calculate response
name|hash
operator|.
name|reset
argument_list|()
expr_stmt|;
name|hash
operator|.
name|addData
argument_list|(
name|ha1
argument_list|)
expr_stmt|;
name|hash
operator|.
name|addData
argument_list|(
literal|":"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hash
operator|.
name|addData
argument_list|(
name|nonce
argument_list|)
expr_stmt|;
name|hash
operator|.
name|addData
argument_list|(
literal|":"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qop
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|hash
operator|.
name|addData
argument_list|(
name|nonceCount
argument_list|)
expr_stmt|;
name|hash
operator|.
name|addData
argument_list|(
literal|":"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hash
operator|.
name|addData
argument_list|(
name|cNonce
argument_list|)
expr_stmt|;
name|hash
operator|.
name|addData
argument_list|(
literal|":"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hash
operator|.
name|addData
argument_list|(
name|qop
argument_list|)
expr_stmt|;
name|hash
operator|.
name|addData
argument_list|(
literal|":"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|hash
operator|.
name|addData
argument_list|(
name|ha2hex
argument_list|)
expr_stmt|;
return|return
name|hash
operator|.
name|result
argument_list|()
operator|.
name|toHex
argument_list|()
return|;
block|}
end_function
begin_function
DECL|function|digestMd5Response
name|QByteArray
name|QAuthenticatorPrivate
operator|::
name|digestMd5Response
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|challenge
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|method
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|path
parameter_list|)
block|{
name|QHash
argument_list|<
name|QByteArray
argument_list|,
name|QByteArray
argument_list|>
name|options
init|=
name|parseDigestAuthenticationChallenge
argument_list|(
name|challenge
argument_list|)
decl_stmt|;
operator|++
name|nonceCount
expr_stmt|;
name|QByteArray
name|nonceCountString
init|=
name|QByteArray
operator|::
name|number
argument_list|(
name|nonceCount
argument_list|,
literal|16
argument_list|)
decl_stmt|;
while|while
condition|(
name|nonceCountString
operator|.
name|length
argument_list|()
operator|<
literal|8
condition|)
name|nonceCountString
operator|.
name|prepend
argument_list|(
literal|'0'
argument_list|)
expr_stmt|;
name|QByteArray
name|nonce
init|=
name|options
operator|.
name|value
argument_list|(
literal|"nonce"
argument_list|)
decl_stmt|;
name|QByteArray
name|opaque
init|=
name|options
operator|.
name|value
argument_list|(
literal|"opaque"
argument_list|)
decl_stmt|;
name|QByteArray
name|qop
init|=
name|options
operator|.
name|value
argument_list|(
literal|"qop"
argument_list|)
decl_stmt|;
comment|//    qDebug()<< "calculating digest: method="<< method<< "path="<< path;
name|QByteArray
name|response
init|=
name|digestMd5ResponseHelper
argument_list|(
name|options
operator|.
name|value
argument_list|(
literal|"algorithm"
argument_list|)
argument_list|,
name|user
operator|.
name|toLatin1
argument_list|()
argument_list|,
name|realm
operator|.
name|toLatin1
argument_list|()
argument_list|,
name|password
operator|.
name|toLatin1
argument_list|()
argument_list|,
name|nonce
argument_list|,
name|nonceCountString
argument_list|,
name|cnonce
argument_list|,
name|qop
argument_list|,
name|method
argument_list|,
name|path
argument_list|,
name|QByteArray
argument_list|()
argument_list|)
decl_stmt|;
name|QByteArray
name|credentials
decl_stmt|;
name|credentials
operator|+=
literal|"username=\""
operator|+
name|user
operator|.
name|toLatin1
argument_list|()
operator|+
literal|"\", "
expr_stmt|;
name|credentials
operator|+=
literal|"realm=\""
operator|+
name|realm
operator|.
name|toLatin1
argument_list|()
operator|+
literal|"\", "
expr_stmt|;
name|credentials
operator|+=
literal|"nonce=\""
operator|+
name|nonce
operator|+
literal|"\", "
expr_stmt|;
name|credentials
operator|+=
literal|"uri=\""
operator|+
name|path
operator|+
literal|"\", "
expr_stmt|;
if|if
condition|(
operator|!
name|opaque
operator|.
name|isEmpty
argument_list|()
condition|)
name|credentials
operator|+=
literal|"opaque=\""
operator|+
name|opaque
operator|+
literal|"\", "
expr_stmt|;
name|credentials
operator|+=
literal|"response=\""
operator|+
name|response
operator|+
literal|'\"'
expr_stmt|;
if|if
condition|(
operator|!
name|options
operator|.
name|value
argument_list|(
literal|"algorithm"
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
name|credentials
operator|+=
literal|", algorithm="
operator|+
name|options
operator|.
name|value
argument_list|(
literal|"algorithm"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|options
operator|.
name|value
argument_list|(
literal|"qop"
argument_list|)
operator|.
name|isEmpty
argument_list|()
condition|)
block|{
name|credentials
operator|+=
literal|", qop="
operator|+
name|qop
operator|+
literal|", "
expr_stmt|;
name|credentials
operator|+=
literal|"nc="
operator|+
name|nonceCountString
operator|+
literal|", "
expr_stmt|;
name|credentials
operator|+=
literal|"cnonce=\""
operator|+
name|cnonce
operator|+
literal|'\"'
expr_stmt|;
block|}
return|return
name|credentials
return|;
block|}
end_function
begin_comment
comment|// ---------------------------- Digest Md5 code ----------------------------------------
end_comment
begin_comment
comment|/*  * NTLM message flags.  *  * Copyright (c) 2004 Andrey Panin<pazke@donpac.ru>  *  * This software is released under the MIT license.  */
end_comment
begin_comment
comment|/*  * Indicates that Unicode strings are supported for use in security  * buffer data.  */
end_comment
begin_define
DECL|macro|NTLMSSP_NEGOTIATE_UNICODE
define|#
directive|define
name|NTLMSSP_NEGOTIATE_UNICODE
value|0x00000001
end_define
begin_comment
comment|/*  * Indicates that OEM strings are supported for use in security buffer data.  */
end_comment
begin_define
DECL|macro|NTLMSSP_NEGOTIATE_OEM
define|#
directive|define
name|NTLMSSP_NEGOTIATE_OEM
value|0x00000002
end_define
begin_comment
comment|/*  * Requests that the server's authentication realm be included in the  * Type 2 message.  */
end_comment
begin_define
DECL|macro|NTLMSSP_REQUEST_TARGET
define|#
directive|define
name|NTLMSSP_REQUEST_TARGET
value|0x00000004
end_define
begin_comment
comment|/*  * Specifies that authenticated communication between the client and server  * should carry a digital signature (message integrity).  */
end_comment
begin_define
DECL|macro|NTLMSSP_NEGOTIATE_SIGN
define|#
directive|define
name|NTLMSSP_NEGOTIATE_SIGN
value|0x00000010
end_define
begin_comment
comment|/*  * Specifies that authenticated communication between the client and server  * should be encrypted (message confidentiality).  */
end_comment
begin_define
DECL|macro|NTLMSSP_NEGOTIATE_SEAL
define|#
directive|define
name|NTLMSSP_NEGOTIATE_SEAL
value|0x00000020
end_define
begin_comment
comment|/*  * Indicates that datagram authentication is being used.  */
end_comment
begin_define
DECL|macro|NTLMSSP_NEGOTIATE_DATAGRAM
define|#
directive|define
name|NTLMSSP_NEGOTIATE_DATAGRAM
value|0x00000040
end_define
begin_comment
comment|/*  * Indicates that the LAN Manager session key should be  * used for signing and sealing authenticated communications.  */
end_comment
begin_define
DECL|macro|NTLMSSP_NEGOTIATE_LM_KEY
define|#
directive|define
name|NTLMSSP_NEGOTIATE_LM_KEY
value|0x00000080
end_define
begin_comment
comment|/*  * Indicates that NTLM authentication is being used.  */
end_comment
begin_define
DECL|macro|NTLMSSP_NEGOTIATE_NTLM
define|#
directive|define
name|NTLMSSP_NEGOTIATE_NTLM
value|0x00000200
end_define
begin_comment
comment|/*  * Sent by the client in the Type 1 message to indicate that the name of the  * domain in which the client workstation has membership is included in the  * message. This is used by the server to determine whether the client is  * eligible for local authentication.  */
end_comment
begin_define
DECL|macro|NTLMSSP_NEGOTIATE_DOMAIN_SUPPLIED
define|#
directive|define
name|NTLMSSP_NEGOTIATE_DOMAIN_SUPPLIED
value|0x00001000
end_define
begin_comment
comment|/*  * Sent by the client in the Type 1 message to indicate that the client  * workstation's name is included in the message. This is used by the server  * to determine whether the client is eligible for local authentication.  */
end_comment
begin_define
DECL|macro|NTLMSSP_NEGOTIATE_WORKSTATION_SUPPLIED
define|#
directive|define
name|NTLMSSP_NEGOTIATE_WORKSTATION_SUPPLIED
value|0x00002000
end_define
begin_comment
comment|/*  * Sent by the server to indicate that the server and client are on the same  * machine. Implies that the client may use the established local credentials  * for authentication instead of calculating a response to the challenge.  */
end_comment
begin_define
DECL|macro|NTLMSSP_NEGOTIATE_LOCAL_CALL
define|#
directive|define
name|NTLMSSP_NEGOTIATE_LOCAL_CALL
value|0x00004000
end_define
begin_comment
comment|/*  * Indicates that authenticated communication between the client and server  * should be signed with a "dummy" signature.  */
end_comment
begin_define
DECL|macro|NTLMSSP_NEGOTIATE_ALWAYS_SIGN
define|#
directive|define
name|NTLMSSP_NEGOTIATE_ALWAYS_SIGN
value|0x00008000
end_define
begin_comment
comment|/*  * Sent by the server in the Type 2 message to indicate that the target  * authentication realm is a domain.  */
end_comment
begin_define
DECL|macro|NTLMSSP_TARGET_TYPE_DOMAIN
define|#
directive|define
name|NTLMSSP_TARGET_TYPE_DOMAIN
value|0x00010000
end_define
begin_comment
comment|/*  * Sent by the server in the Type 2 message to indicate that the target  * authentication realm is a server.  */
end_comment
begin_define
DECL|macro|NTLMSSP_TARGET_TYPE_SERVER
define|#
directive|define
name|NTLMSSP_TARGET_TYPE_SERVER
value|0x00020000
end_define
begin_comment
comment|/*  * Sent by the server in the Type 2 message to indicate that the target  * authentication realm is a share. Presumably, this is for share-level  * authentication. Usage is unclear.  */
end_comment
begin_define
DECL|macro|NTLMSSP_TARGET_TYPE_SHARE
define|#
directive|define
name|NTLMSSP_TARGET_TYPE_SHARE
value|0x00040000
end_define
begin_comment
comment|/*  * Indicates that the NTLM2 signing and sealing scheme should be used for  * protecting authenticated communications. Note that this refers to a  * particular session security scheme, and is not related to the use of  * NTLMv2 authentication.  */
end_comment
begin_define
DECL|macro|NTLMSSP_NEGOTIATE_NTLM2
define|#
directive|define
name|NTLMSSP_NEGOTIATE_NTLM2
value|0x00080000
end_define
begin_comment
comment|/*  * Sent by the server in the Type 2 message to indicate that it is including  * a Target Information block in the message. The Target Information block  * is used in the calculation of the NTLMv2 response.  */
end_comment
begin_define
DECL|macro|NTLMSSP_NEGOTIATE_TARGET_INFO
define|#
directive|define
name|NTLMSSP_NEGOTIATE_TARGET_INFO
value|0x00800000
end_define
begin_comment
comment|/*  * Indicates that 128-bit encryption is supported.  */
end_comment
begin_define
DECL|macro|NTLMSSP_NEGOTIATE_128
define|#
directive|define
name|NTLMSSP_NEGOTIATE_128
value|0x20000000
end_define
begin_comment
comment|/*  * Indicates that the client will provide an encrypted master session key in  * the "Session Key" field of the Type 3 message. This is used in signing and  * sealing, and is RC4-encrypted using the previous session key as the  * encryption key.  */
end_comment
begin_define
DECL|macro|NTLMSSP_NEGOTIATE_KEY_EXCHANGE
define|#
directive|define
name|NTLMSSP_NEGOTIATE_KEY_EXCHANGE
value|0x40000000
end_define
begin_comment
comment|/*  * Indicates that 56-bit encryption is supported.  */
end_comment
begin_define
DECL|macro|NTLMSSP_NEGOTIATE_56
define|#
directive|define
name|NTLMSSP_NEGOTIATE_56
value|0x80000000
end_define
begin_comment
comment|/*  * AvId values  */
end_comment
begin_define
DECL|macro|AVTIMESTAMP
define|#
directive|define
name|AVTIMESTAMP
value|7
end_define
begin_comment
comment|//#define NTLMV1_CLIENT
end_comment
begin_comment
comment|//************************Global variables***************************
end_comment
begin_decl_stmt
DECL|variable|blockSize
specifier|const
name|int
name|blockSize
init|=
literal|64
decl_stmt|;
end_decl_stmt
begin_comment
DECL|variable|blockSize
comment|//As per RFC2104 Block-size is 512 bits
end_comment
begin_decl_stmt
DECL|variable|respversion
specifier|const
name|quint8
name|respversion
init|=
literal|1
decl_stmt|;
end_decl_stmt
begin_decl_stmt
DECL|variable|hirespversion
specifier|const
name|quint8
name|hirespversion
init|=
literal|1
decl_stmt|;
end_decl_stmt
begin_comment
comment|/* usage:    // fill up ctx with what we know.    QByteArray response = qNtlmPhase1(ctx);    // send response (b64 encoded??)    // get response from server (b64 decode?)    Phase2Block pb;    qNtlmDecodePhase2(response, pb);    response = qNtlmPhase3(ctx, pb);    // send response (b64 encoded??) */
end_comment
begin_comment
comment|/*    TODO:     - Fix unicode handling     - add v2 handling */
end_comment
begin_class
DECL|class|QNtlmBuffer
class|class
name|QNtlmBuffer
block|{
public|public:
DECL|function|QNtlmBuffer
name|QNtlmBuffer
parameter_list|()
member_init_list|:
name|len
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|maxLen
argument_list|(
literal|0
argument_list|)
member_init_list|,
name|offset
argument_list|(
literal|0
argument_list|)
block|{}
DECL|member|len
name|quint16
name|len
decl_stmt|;
DECL|member|maxLen
name|quint16
name|maxLen
decl_stmt|;
DECL|member|offset
name|quint32
name|offset
decl_stmt|;
DECL|enumerator|Size
enum|enum
block|{
name|Size
init|=
literal|8
block|}
enum|;
block|}
class|;
end_class
begin_class
DECL|class|QNtlmPhase1BlockBase
class|class
name|QNtlmPhase1BlockBase
block|{
public|public:
DECL|member|magic
name|char
name|magic
index|[
literal|8
index|]
decl_stmt|;
DECL|member|type
name|quint32
name|type
decl_stmt|;
DECL|member|flags
name|quint32
name|flags
decl_stmt|;
DECL|member|domain
name|QNtlmBuffer
name|domain
decl_stmt|;
DECL|member|workstation
name|QNtlmBuffer
name|workstation
decl_stmt|;
DECL|enumerator|Size
enum|enum
block|{
name|Size
init|=
literal|32
block|}
enum|;
block|}
class|;
end_class
begin_comment
comment|// ################# check paddings
end_comment
begin_class
DECL|class|QNtlmPhase2BlockBase
class|class
name|QNtlmPhase2BlockBase
block|{
public|public:
DECL|member|magic
name|char
name|magic
index|[
literal|8
index|]
decl_stmt|;
DECL|member|type
name|quint32
name|type
decl_stmt|;
DECL|member|targetName
name|QNtlmBuffer
name|targetName
decl_stmt|;
DECL|member|flags
name|quint32
name|flags
decl_stmt|;
DECL|member|challenge
name|unsigned
name|char
name|challenge
index|[
literal|8
index|]
decl_stmt|;
DECL|member|context
name|quint32
name|context
index|[
literal|2
index|]
decl_stmt|;
DECL|member|targetInfo
name|QNtlmBuffer
name|targetInfo
decl_stmt|;
DECL|enumerator|Size
enum|enum
block|{
name|Size
init|=
literal|48
block|}
enum|;
block|}
class|;
end_class
begin_class
DECL|class|QNtlmPhase3BlockBase
class|class
name|QNtlmPhase3BlockBase
block|{
public|public:
DECL|member|magic
name|char
name|magic
index|[
literal|8
index|]
decl_stmt|;
DECL|member|type
name|quint32
name|type
decl_stmt|;
DECL|member|lmResponse
name|QNtlmBuffer
name|lmResponse
decl_stmt|;
DECL|member|ntlmResponse
name|QNtlmBuffer
name|ntlmResponse
decl_stmt|;
DECL|member|domain
name|QNtlmBuffer
name|domain
decl_stmt|;
DECL|member|user
name|QNtlmBuffer
name|user
decl_stmt|;
DECL|member|workstation
name|QNtlmBuffer
name|workstation
decl_stmt|;
DECL|member|sessionKey
name|QNtlmBuffer
name|sessionKey
decl_stmt|;
DECL|member|flags
name|quint32
name|flags
decl_stmt|;
DECL|enumerator|Size
enum|enum
block|{
name|Size
init|=
literal|64
block|}
enum|;
block|}
class|;
end_class
begin_function
DECL|function|qStreamNtlmBuffer
specifier|static
name|void
name|qStreamNtlmBuffer
parameter_list|(
name|QDataStream
modifier|&
name|ds
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|s
parameter_list|)
block|{
name|ds
operator|.
name|writeRawData
argument_list|(
name|s
operator|.
name|constData
argument_list|()
argument_list|,
name|s
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function
begin_function
DECL|function|qStreamNtlmString
specifier|static
name|void
name|qStreamNtlmString
parameter_list|(
name|QDataStream
modifier|&
name|ds
parameter_list|,
specifier|const
name|QString
modifier|&
name|s
parameter_list|,
name|bool
name|unicode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|unicode
condition|)
block|{
name|qStreamNtlmBuffer
argument_list|(
name|ds
argument_list|,
name|s
operator|.
name|toLatin1
argument_list|()
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|const
name|ushort
modifier|*
name|d
init|=
name|s
operator|.
name|utf16
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|s
operator|.
name|length
argument_list|()
condition|;
operator|++
name|i
control|)
name|ds
operator|<<
name|d
index|[
name|i
index|]
expr_stmt|;
block|}
end_function
begin_function
DECL|function|qEncodeNtlmBuffer
specifier|static
name|int
name|qEncodeNtlmBuffer
parameter_list|(
name|QNtlmBuffer
modifier|&
name|buf
parameter_list|,
name|int
name|offset
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|s
parameter_list|)
block|{
name|buf
operator|.
name|len
operator|=
name|s
operator|.
name|size
argument_list|()
expr_stmt|;
name|buf
operator|.
name|maxLen
operator|=
name|buf
operator|.
name|len
expr_stmt|;
name|buf
operator|.
name|offset
operator|=
operator|(
name|offset
operator|+
literal|1
operator|)
operator|&
operator|~
literal|1
expr_stmt|;
return|return
name|buf
operator|.
name|offset
operator|+
name|buf
operator|.
name|len
return|;
block|}
end_function
begin_function
DECL|function|qEncodeNtlmString
specifier|static
name|int
name|qEncodeNtlmString
parameter_list|(
name|QNtlmBuffer
modifier|&
name|buf
parameter_list|,
name|int
name|offset
parameter_list|,
specifier|const
name|QString
modifier|&
name|s
parameter_list|,
name|bool
name|unicode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|unicode
condition|)
return|return
name|qEncodeNtlmBuffer
argument_list|(
name|buf
argument_list|,
name|offset
argument_list|,
name|s
operator|.
name|toLatin1
argument_list|()
argument_list|)
return|;
name|buf
operator|.
name|len
operator|=
literal|2
operator|*
name|s
operator|.
name|length
argument_list|()
expr_stmt|;
name|buf
operator|.
name|maxLen
operator|=
name|buf
operator|.
name|len
expr_stmt|;
name|buf
operator|.
name|offset
operator|=
operator|(
name|offset
operator|+
literal|1
operator|)
operator|&
operator|~
literal|1
expr_stmt|;
return|return
name|buf
operator|.
name|offset
operator|+
name|buf
operator|.
name|len
return|;
block|}
end_function
begin_function
DECL|function|operator <<
specifier|static
name|QDataStream
modifier|&
name|operator
name|<<
parameter_list|(
name|QDataStream
modifier|&
name|s
parameter_list|,
specifier|const
name|QNtlmBuffer
modifier|&
name|b
parameter_list|)
block|{
name|s
operator|<<
name|b
operator|.
name|len
operator|<<
name|b
operator|.
name|maxLen
operator|<<
name|b
operator|.
name|offset
expr_stmt|;
return|return
name|s
return|;
block|}
end_function
begin_function
DECL|function|operator >>
specifier|static
name|QDataStream
modifier|&
name|operator
name|>>
parameter_list|(
name|QDataStream
modifier|&
name|s
parameter_list|,
name|QNtlmBuffer
modifier|&
name|b
parameter_list|)
block|{
name|s
operator|>>
name|b
operator|.
name|len
operator|>>
name|b
operator|.
name|maxLen
operator|>>
name|b
operator|.
name|offset
expr_stmt|;
return|return
name|s
return|;
block|}
end_function
begin_class
DECL|class|QNtlmPhase1Block
class|class
name|QNtlmPhase1Block
super|:
specifier|public
name|QNtlmPhase1BlockBase
block|{
comment|// request
public|public:
DECL|function|QNtlmPhase1Block
name|QNtlmPhase1Block
parameter_list|()
block|{
name|qstrncpy
argument_list|(
name|magic
argument_list|,
literal|"NTLMSSP"
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|type
operator|=
literal|1
expr_stmt|;
name|flags
operator|=
name|NTLMSSP_NEGOTIATE_UNICODE
operator||
name|NTLMSSP_NEGOTIATE_NTLM
operator||
name|NTLMSSP_REQUEST_TARGET
expr_stmt|;
block|}
comment|// extracted
DECL|member|domainStr
DECL|member|workstationStr
name|QString
name|domainStr
decl_stmt|,
name|workstationStr
decl_stmt|;
block|}
class|;
end_class
begin_class
DECL|class|QNtlmPhase2Block
class|class
name|QNtlmPhase2Block
super|:
specifier|public
name|QNtlmPhase2BlockBase
block|{
comment|// challenge
public|public:
DECL|function|QNtlmPhase2Block
name|QNtlmPhase2Block
parameter_list|()
block|{
name|magic
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|type
operator|=
literal|0xffffffff
expr_stmt|;
block|}
comment|// extracted
DECL|member|targetNameStr
DECL|member|targetInfoStr
name|QString
name|targetNameStr
decl_stmt|,
name|targetInfoStr
decl_stmt|;
DECL|member|targetInfoBuff
name|QByteArray
name|targetInfoBuff
decl_stmt|;
block|}
class|;
end_class
begin_class
DECL|class|QNtlmPhase3Block
class|class
name|QNtlmPhase3Block
super|:
specifier|public
name|QNtlmPhase3BlockBase
block|{
comment|// response
public|public:
DECL|function|QNtlmPhase3Block
name|QNtlmPhase3Block
parameter_list|()
block|{
name|qstrncpy
argument_list|(
name|magic
argument_list|,
literal|"NTLMSSP"
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|type
operator|=
literal|3
expr_stmt|;
name|flags
operator|=
name|NTLMSSP_NEGOTIATE_UNICODE
operator||
name|NTLMSSP_NEGOTIATE_NTLM
operator||
name|NTLMSSP_NEGOTIATE_TARGET_INFO
expr_stmt|;
block|}
comment|// extracted
DECL|member|lmResponseBuf
DECL|member|ntlmResponseBuf
name|QByteArray
name|lmResponseBuf
decl_stmt|,
name|ntlmResponseBuf
decl_stmt|;
DECL|member|domainStr
DECL|member|userStr
DECL|member|workstationStr
DECL|member|sessionKeyStr
name|QString
name|domainStr
decl_stmt|,
name|userStr
decl_stmt|,
name|workstationStr
decl_stmt|,
name|sessionKeyStr
decl_stmt|;
DECL|member|v2Hash
name|QByteArray
name|v2Hash
decl_stmt|;
block|}
class|;
end_class
begin_function
DECL|function|operator <<
specifier|static
name|QDataStream
modifier|&
name|operator
name|<<
parameter_list|(
name|QDataStream
modifier|&
name|s
parameter_list|,
specifier|const
name|QNtlmPhase1Block
modifier|&
name|b
parameter_list|)
block|{
name|bool
name|unicode
init|=
operator|(
name|b
operator|.
name|flags
operator|&
name|NTLMSSP_NEGOTIATE_UNICODE
operator|)
decl_stmt|;
name|s
operator|.
name|writeRawData
argument_list|(
name|b
operator|.
name|magic
argument_list|,
sizeof|sizeof
argument_list|(
name|b
operator|.
name|magic
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|<<
name|b
operator|.
name|type
expr_stmt|;
name|s
operator|<<
name|b
operator|.
name|flags
expr_stmt|;
name|s
operator|<<
name|b
operator|.
name|domain
expr_stmt|;
name|s
operator|<<
name|b
operator|.
name|workstation
expr_stmt|;
if|if
condition|(
operator|!
name|b
operator|.
name|domainStr
operator|.
name|isEmpty
argument_list|()
condition|)
name|qStreamNtlmString
argument_list|(
name|s
argument_list|,
name|b
operator|.
name|domainStr
argument_list|,
name|unicode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|b
operator|.
name|workstationStr
operator|.
name|isEmpty
argument_list|()
condition|)
name|qStreamNtlmString
argument_list|(
name|s
argument_list|,
name|b
operator|.
name|workstationStr
argument_list|,
name|unicode
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function
begin_function
DECL|function|operator <<
specifier|static
name|QDataStream
modifier|&
name|operator
name|<<
parameter_list|(
name|QDataStream
modifier|&
name|s
parameter_list|,
specifier|const
name|QNtlmPhase3Block
modifier|&
name|b
parameter_list|)
block|{
name|bool
name|unicode
init|=
operator|(
name|b
operator|.
name|flags
operator|&
name|NTLMSSP_NEGOTIATE_UNICODE
operator|)
decl_stmt|;
name|s
operator|.
name|writeRawData
argument_list|(
name|b
operator|.
name|magic
argument_list|,
sizeof|sizeof
argument_list|(
name|b
operator|.
name|magic
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|<<
name|b
operator|.
name|type
expr_stmt|;
name|s
operator|<<
name|b
operator|.
name|lmResponse
expr_stmt|;
name|s
operator|<<
name|b
operator|.
name|ntlmResponse
expr_stmt|;
name|s
operator|<<
name|b
operator|.
name|domain
expr_stmt|;
name|s
operator|<<
name|b
operator|.
name|user
expr_stmt|;
name|s
operator|<<
name|b
operator|.
name|workstation
expr_stmt|;
name|s
operator|<<
name|b
operator|.
name|sessionKey
expr_stmt|;
name|s
operator|<<
name|b
operator|.
name|flags
expr_stmt|;
if|if
condition|(
operator|!
name|b
operator|.
name|domainStr
operator|.
name|isEmpty
argument_list|()
condition|)
name|qStreamNtlmString
argument_list|(
name|s
argument_list|,
name|b
operator|.
name|domainStr
argument_list|,
name|unicode
argument_list|)
expr_stmt|;
name|qStreamNtlmString
argument_list|(
name|s
argument_list|,
name|b
operator|.
name|userStr
argument_list|,
name|unicode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|b
operator|.
name|workstationStr
operator|.
name|isEmpty
argument_list|()
condition|)
name|qStreamNtlmString
argument_list|(
name|s
argument_list|,
name|b
operator|.
name|workstationStr
argument_list|,
name|unicode
argument_list|)
expr_stmt|;
comment|// Send auth info
name|qStreamNtlmBuffer
argument_list|(
name|s
argument_list|,
name|b
operator|.
name|lmResponseBuf
argument_list|)
expr_stmt|;
name|qStreamNtlmBuffer
argument_list|(
name|s
argument_list|,
name|b
operator|.
name|ntlmResponseBuf
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function
begin_function
DECL|function|qNtlmPhase1
specifier|static
name|QByteArray
name|qNtlmPhase1
parameter_list|()
block|{
name|QByteArray
name|rc
decl_stmt|;
name|QDataStream
name|ds
argument_list|(
operator|&
name|rc
argument_list|,
name|QIODevice
operator|::
name|WriteOnly
argument_list|)
decl_stmt|;
name|ds
operator|.
name|setByteOrder
argument_list|(
name|QDataStream
operator|::
name|LittleEndian
argument_list|)
expr_stmt|;
name|QNtlmPhase1Block
name|pb
decl_stmt|;
name|ds
operator|<<
name|pb
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function
begin_function
DECL|function|qStringAsUcs2Le
specifier|static
name|QByteArray
name|qStringAsUcs2Le
parameter_list|(
specifier|const
name|QString
modifier|&
name|src
parameter_list|)
block|{
name|QByteArray
name|rc
argument_list|(
literal|2
operator|*
name|src
operator|.
name|length
argument_list|()
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|const
name|unsigned
name|short
modifier|*
name|s
init|=
name|src
operator|.
name|utf16
argument_list|()
decl_stmt|;
name|unsigned
name|short
modifier|*
name|d
init|=
operator|(
name|unsigned
name|short
operator|*
operator|)
name|rc
operator|.
name|data
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|src
operator|.
name|length
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|d
index|[
name|i
index|]
operator|=
name|qToLittleEndian
argument_list|(
name|s
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|rc
return|;
block|}
end_function
begin_function
DECL|function|qStringFromUcs2Le
specifier|static
name|QString
name|qStringFromUcs2Le
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|src
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|src
operator|.
name|size
argument_list|()
operator|%
literal|2
operator|==
literal|0
argument_list|)
expr_stmt|;
name|unsigned
name|short
modifier|*
name|d
init|=
operator|(
name|unsigned
name|short
operator|*
operator|)
name|src
operator|.
name|data
argument_list|()
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|src
operator|.
name|length
argument_list|()
operator|/
literal|2
condition|;
operator|++
name|i
control|)
block|{
name|d
index|[
name|i
index|]
operator|=
name|qFromLittleEndian
argument_list|(
name|d
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|QString
argument_list|(
operator|(
specifier|const
name|QChar
operator|*
operator|)
name|src
operator|.
name|data
argument_list|()
argument_list|,
name|src
operator|.
name|size
argument_list|()
operator|/
literal|2
argument_list|)
return|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|NTLMV1_CLIENT
end_ifdef
begin_function
DECL|function|qEncodeNtlmResponse
specifier|static
name|QByteArray
name|qEncodeNtlmResponse
parameter_list|(
specifier|const
name|QAuthenticatorPrivate
modifier|*
name|ctx
parameter_list|,
specifier|const
name|QNtlmPhase2Block
modifier|&
name|ch
parameter_list|)
block|{
name|QCryptographicHash
name|md4
argument_list|(
name|QCryptographicHash
operator|::
name|Md4
argument_list|)
decl_stmt|;
name|QByteArray
name|asUcs2Le
init|=
name|qStringAsUcs2Le
argument_list|(
name|ctx
operator|->
name|password
argument_list|)
decl_stmt|;
name|md4
operator|.
name|addData
argument_list|(
name|asUcs2Le
operator|.
name|data
argument_list|()
argument_list|,
name|asUcs2Le
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|unsigned
name|char
name|md4hash
index|[
literal|22
index|]
decl_stmt|;
name|memset
argument_list|(
name|md4hash
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|md4hash
argument_list|)
argument_list|)
expr_stmt|;
name|QByteArray
name|hash
init|=
name|md4
operator|.
name|result
argument_list|()
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|hash
operator|.
name|size
argument_list|()
operator|==
literal|16
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|md4hash
argument_list|,
name|hash
operator|.
name|constData
argument_list|()
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|QByteArray
name|rc
argument_list|(
literal|24
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|deshash
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|rc
operator|.
name|data
argument_list|()
argument_list|,
name|md4hash
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ch
operator|.
name|challenge
argument_list|)
expr_stmt|;
name|deshash
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|rc
operator|.
name|data
argument_list|()
operator|+
literal|8
argument_list|,
name|md4hash
operator|+
literal|7
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ch
operator|.
name|challenge
argument_list|)
expr_stmt|;
name|deshash
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|rc
operator|.
name|data
argument_list|()
operator|+
literal|16
argument_list|,
name|md4hash
operator|+
literal|14
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|ch
operator|.
name|challenge
argument_list|)
expr_stmt|;
name|hash
operator|.
name|fill
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function
begin_function
DECL|function|qEncodeLmResponse
specifier|static
name|QByteArray
name|qEncodeLmResponse
parameter_list|(
specifier|const
name|QAuthenticatorPrivate
modifier|*
name|ctx
parameter_list|,
specifier|const
name|QNtlmPhase2Block
modifier|&
name|ch
parameter_list|)
block|{
name|QByteArray
name|hash
argument_list|(
literal|21
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|QByteArray
name|key
argument_list|(
literal|14
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|qstrncpy
argument_list|(
name|key
operator|.
name|data
argument_list|()
argument_list|,
name|ctx
operator|->
name|password
operator|.
name|toUpper
argument_list|()
operator|.
name|toLatin1
argument_list|()
argument_list|,
literal|14
argument_list|)
expr_stmt|;
specifier|const
name|char
modifier|*
name|block
init|=
literal|"KGS!@#$%"
decl_stmt|;
name|deshash
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|hash
operator|.
name|data
argument_list|()
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|key
operator|.
name|data
argument_list|()
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|block
argument_list|)
expr_stmt|;
name|deshash
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|hash
operator|.
name|data
argument_list|()
operator|+
literal|8
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|key
operator|.
name|data
argument_list|()
operator|+
literal|7
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|block
argument_list|)
expr_stmt|;
name|key
operator|.
name|fill
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|QByteArray
name|rc
argument_list|(
literal|24
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|deshash
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|rc
operator|.
name|data
argument_list|()
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|hash
operator|.
name|data
argument_list|()
argument_list|,
name|ch
operator|.
name|challenge
argument_list|)
expr_stmt|;
name|deshash
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|rc
operator|.
name|data
argument_list|()
operator|+
literal|8
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|hash
operator|.
name|data
argument_list|()
operator|+
literal|7
argument_list|,
name|ch
operator|.
name|challenge
argument_list|)
expr_stmt|;
name|deshash
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|rc
operator|.
name|data
argument_list|()
operator|+
literal|16
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|hash
operator|.
name|data
argument_list|()
operator|+
literal|14
argument_list|,
name|ch
operator|.
name|challenge
argument_list|)
expr_stmt|;
name|hash
operator|.
name|fill
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|/********************************************************************* * Function Name: qEncodeHmacMd5 * Params: *    key:   Type - QByteArray *         - It is the Authentication key *    message:   Type - QByteArray *         - This is the actual message which will be encoded *           using HMacMd5 hash algorithm * * Return Value: *    hmacDigest:   Type - QByteArray * * Description: *    This function will be used to encode the input message using *    HMacMd5 hash algorithm. * *    As per the RFC2104 the HMacMd5 algorithm can be specified *        --------------------------------------- *         MD5(K XOR opad, MD5(K XOR ipad, text)) *        --------------------------------------- * *********************************************************************/
end_comment
begin_function
DECL|function|qEncodeHmacMd5
name|QByteArray
name|qEncodeHmacMd5
parameter_list|(
name|QByteArray
modifier|&
name|key
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|message
parameter_list|)
block|{
name|Q_ASSERT_X
argument_list|(
operator|!
operator|(
name|message
operator|.
name|isEmpty
argument_list|()
operator|)
argument_list|,
literal|"qEncodeHmacMd5"
argument_list|,
literal|"Empty message check"
argument_list|)
expr_stmt|;
name|Q_ASSERT_X
argument_list|(
operator|!
operator|(
name|key
operator|.
name|isEmpty
argument_list|()
operator|)
argument_list|,
literal|"qEncodeHmacMd5"
argument_list|,
literal|"Empty key check"
argument_list|)
expr_stmt|;
name|QCryptographicHash
name|hash
argument_list|(
name|QCryptographicHash
operator|::
name|Md5
argument_list|)
decl_stmt|;
name|QByteArray
name|hMsg
decl_stmt|;
name|QByteArray
name|iKeyPad
argument_list|(
name|blockSize
argument_list|,
literal|0x36
argument_list|)
decl_stmt|;
name|QByteArray
name|oKeyPad
argument_list|(
name|blockSize
argument_list|,
literal|0x5c
argument_list|)
decl_stmt|;
name|hash
operator|.
name|reset
argument_list|()
expr_stmt|;
comment|// Adjust the key length to blockSize
if|if
condition|(
name|blockSize
operator|<
name|key
operator|.
name|length
argument_list|()
condition|)
block|{
name|hash
operator|.
name|addData
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|key
operator|=
name|hash
operator|.
name|result
argument_list|()
expr_stmt|;
comment|//MD5 will always return 16 bytes length output
block|}
comment|//Key will be<= 16 or 20 bytes as hash function (MD5 or SHA hash algorithms)
comment|//key size can be max of Block size only
name|key
operator|=
name|key
operator|.
name|leftJustified
argument_list|(
name|blockSize
argument_list|,
literal|0
argument_list|,
literal|true
argument_list|)
expr_stmt|;
comment|//iKeyPad, oKeyPad and key are all of same size "blockSize"
comment|//xor of iKeyPad with Key and store the result into iKeyPad
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|key
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|iKeyPad
index|[
name|i
index|]
operator|=
name|key
index|[
name|i
index|]
operator|^
name|iKeyPad
index|[
name|i
index|]
expr_stmt|;
block|}
comment|//xor of oKeyPad with Key and store the result into oKeyPad
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|key
operator|.
name|size
argument_list|()
condition|;
name|i
operator|++
control|)
block|{
name|oKeyPad
index|[
name|i
index|]
operator|=
name|key
index|[
name|i
index|]
operator|^
name|oKeyPad
index|[
name|i
index|]
expr_stmt|;
block|}
name|iKeyPad
operator|.
name|append
argument_list|(
name|message
argument_list|)
expr_stmt|;
comment|// (K0 xor ipad) || text
name|hash
operator|.
name|reset
argument_list|()
expr_stmt|;
name|hash
operator|.
name|addData
argument_list|(
name|iKeyPad
argument_list|)
expr_stmt|;
name|hMsg
operator|=
name|hash
operator|.
name|result
argument_list|()
expr_stmt|;
comment|//Digest gen after pass-1: H((K0 xor ipad)||text)
name|QByteArray
name|hmacDigest
decl_stmt|;
name|oKeyPad
operator|.
name|append
argument_list|(
name|hMsg
argument_list|)
expr_stmt|;
name|hash
operator|.
name|reset
argument_list|()
expr_stmt|;
name|hash
operator|.
name|addData
argument_list|(
name|oKeyPad
argument_list|)
expr_stmt|;
name|hmacDigest
operator|=
name|hash
operator|.
name|result
argument_list|()
expr_stmt|;
comment|// H((K0 xor opad )|| H((K0 xor ipad) || text))
comment|/*hmacDigest should not be less than half the length of the HMAC output       (to match the birthday attack bound) and not less than 80 bits       (a suitable lower bound on the number of bits that need to be       predicted by an attacker).       Refer RFC 2104 for more details on truncation part */
comment|/*MD5 hash always returns 16 byte digest only and HMAC-MD5 spec       (RFC 2104) also says digest length should be 16 bytes*/
return|return
name|hmacDigest
return|;
block|}
end_function
begin_function
DECL|function|qCreatev2Hash
specifier|static
name|QByteArray
name|qCreatev2Hash
parameter_list|(
specifier|const
name|QAuthenticatorPrivate
modifier|*
name|ctx
parameter_list|,
name|QNtlmPhase3Block
modifier|*
name|phase3
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|phase3
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|// since v2 Hash is need for both NTLMv2 and LMv2 it is calculated
comment|// only once and stored and reused
if|if
condition|(
name|phase3
operator|->
name|v2Hash
operator|.
name|size
argument_list|()
operator|==
literal|0
condition|)
block|{
name|QCryptographicHash
name|md4
argument_list|(
name|QCryptographicHash
operator|::
name|Md4
argument_list|)
decl_stmt|;
name|QByteArray
name|passUnicode
init|=
name|qStringAsUcs2Le
argument_list|(
name|ctx
operator|->
name|password
argument_list|)
decl_stmt|;
name|md4
operator|.
name|addData
argument_list|(
name|passUnicode
operator|.
name|data
argument_list|()
argument_list|,
name|passUnicode
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|QByteArray
name|hashKey
init|=
name|md4
operator|.
name|result
argument_list|()
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|hashKey
operator|.
name|size
argument_list|()
operator|==
literal|16
argument_list|)
expr_stmt|;
comment|// Assuming the user and domain is always unicode in challenge
name|QByteArray
name|message
init|=
name|qStringAsUcs2Le
argument_list|(
name|ctx
operator|->
name|extractedUser
operator|.
name|toUpper
argument_list|()
argument_list|)
operator|+
name|qStringAsUcs2Le
argument_list|(
name|phase3
operator|->
name|domainStr
argument_list|)
decl_stmt|;
name|phase3
operator|->
name|v2Hash
operator|=
name|qEncodeHmacMd5
argument_list|(
name|hashKey
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
return|return
name|phase3
operator|->
name|v2Hash
return|;
block|}
end_function
begin_function
DECL|function|clientChallenge
specifier|static
name|QByteArray
name|clientChallenge
parameter_list|(
specifier|const
name|QAuthenticatorPrivate
modifier|*
name|ctx
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|ctx
operator|->
name|cnonce
operator|.
name|size
argument_list|()
operator|>=
literal|8
argument_list|)
expr_stmt|;
name|QByteArray
name|clientCh
init|=
name|ctx
operator|->
name|cnonce
operator|.
name|right
argument_list|(
literal|8
argument_list|)
decl_stmt|;
return|return
name|clientCh
return|;
block|}
end_function
begin_comment
comment|// caller has to ensure a valid targetInfoBuff
end_comment
begin_function
DECL|function|qExtractServerTime
specifier|static
name|QByteArray
name|qExtractServerTime
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|targetInfoBuff
parameter_list|)
block|{
name|QByteArray
name|timeArray
decl_stmt|;
name|QDataStream
name|ds
argument_list|(
name|targetInfoBuff
argument_list|)
decl_stmt|;
name|ds
operator|.
name|setByteOrder
argument_list|(
name|QDataStream
operator|::
name|LittleEndian
argument_list|)
expr_stmt|;
name|quint16
name|avId
decl_stmt|;
name|quint16
name|avLen
decl_stmt|;
name|ds
operator|>>
name|avId
expr_stmt|;
name|ds
operator|>>
name|avLen
expr_stmt|;
while|while
condition|(
name|avId
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|avId
operator|==
name|AVTIMESTAMP
condition|)
block|{
name|timeArray
operator|.
name|resize
argument_list|(
name|avLen
argument_list|)
expr_stmt|;
comment|//avLen size of QByteArray is allocated
name|ds
operator|.
name|readRawData
argument_list|(
name|timeArray
operator|.
name|data
argument_list|()
argument_list|,
name|avLen
argument_list|)
expr_stmt|;
break|break;
block|}
name|ds
operator|.
name|skipRawData
argument_list|(
name|avLen
argument_list|)
expr_stmt|;
name|ds
operator|>>
name|avId
expr_stmt|;
name|ds
operator|>>
name|avLen
expr_stmt|;
block|}
return|return
name|timeArray
return|;
block|}
end_function
begin_function
DECL|function|qEncodeNtlmv2Response
specifier|static
name|QByteArray
name|qEncodeNtlmv2Response
parameter_list|(
specifier|const
name|QAuthenticatorPrivate
modifier|*
name|ctx
parameter_list|,
specifier|const
name|QNtlmPhase2Block
modifier|&
name|ch
parameter_list|,
name|QNtlmPhase3Block
modifier|*
name|phase3
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|phase3
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|// return value stored in phase3
name|qCreatev2Hash
argument_list|(
name|ctx
argument_list|,
name|phase3
argument_list|)
expr_stmt|;
name|QByteArray
name|temp
decl_stmt|;
name|QDataStream
name|ds
argument_list|(
operator|&
name|temp
argument_list|,
name|QIODevice
operator|::
name|WriteOnly
argument_list|)
decl_stmt|;
name|ds
operator|.
name|setByteOrder
argument_list|(
name|QDataStream
operator|::
name|LittleEndian
argument_list|)
expr_stmt|;
name|ds
operator|<<
name|respversion
expr_stmt|;
name|ds
operator|<<
name|hirespversion
expr_stmt|;
comment|//Reserved
name|QByteArray
name|reserved1
argument_list|(
literal|6
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|ds
operator|.
name|writeRawData
argument_list|(
name|reserved1
operator|.
name|constData
argument_list|()
argument_list|,
name|reserved1
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|quint64
name|time
init|=
literal|0
decl_stmt|;
name|QByteArray
name|timeArray
decl_stmt|;
if|if
condition|(
name|ch
operator|.
name|targetInfo
operator|.
name|len
condition|)
block|{
name|timeArray
operator|=
name|qExtractServerTime
argument_list|(
name|ch
operator|.
name|targetInfoBuff
argument_list|)
expr_stmt|;
block|}
comment|//if server sends time, use it instead of current time
if|if
condition|(
name|timeArray
operator|.
name|size
argument_list|()
condition|)
block|{
name|ds
operator|.
name|writeRawData
argument_list|(
name|timeArray
operator|.
name|constData
argument_list|()
argument_list|,
name|timeArray
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|QDateTime
name|currentTime
argument_list|(
name|QDate
operator|::
name|currentDate
argument_list|()
argument_list|,
name|QTime
operator|::
name|currentTime
argument_list|()
argument_list|,
name|Qt
operator|::
name|UTC
argument_list|)
decl_stmt|;
comment|// number of seconds between 1601 and epoc(1970)
comment|// 369 years, 89 leap years
comment|// ((369 * 365) + 89) * 24 * 3600 = 11644473600
name|time
operator|=
name|Q_UINT64_C
argument_list|(
name|currentTime
operator|.
name|toTime_t
argument_list|()
operator|+
literal|11644473600
argument_list|)
expr_stmt|;
comment|// represented as 100 nano seconds
name|time
operator|=
name|Q_UINT64_C
argument_list|(
name|time
operator|*
literal|10000000
argument_list|)
expr_stmt|;
name|ds
operator|<<
name|time
expr_stmt|;
block|}
comment|//8 byte client challenge
name|QByteArray
name|clientCh
init|=
name|clientChallenge
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
name|ds
operator|.
name|writeRawData
argument_list|(
name|clientCh
operator|.
name|constData
argument_list|()
argument_list|,
name|clientCh
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
comment|//Reserved
name|QByteArray
name|reserved2
argument_list|(
literal|4
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|ds
operator|.
name|writeRawData
argument_list|(
name|reserved2
operator|.
name|constData
argument_list|()
argument_list|,
name|reserved2
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|.
name|targetInfo
operator|.
name|len
operator|>
literal|0
condition|)
block|{
name|ds
operator|.
name|writeRawData
argument_list|(
name|ch
operator|.
name|targetInfoBuff
operator|.
name|constData
argument_list|()
argument_list|,
name|ch
operator|.
name|targetInfoBuff
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|//Reserved
name|QByteArray
name|reserved3
argument_list|(
literal|4
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|ds
operator|.
name|writeRawData
argument_list|(
name|reserved3
operator|.
name|constData
argument_list|()
argument_list|,
name|reserved3
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|QByteArray
name|message
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|ch
operator|.
name|challenge
argument_list|,
sizeof|sizeof
argument_list|(
name|ch
operator|.
name|challenge
argument_list|)
argument_list|)
decl_stmt|;
name|message
operator|.
name|append
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|QByteArray
name|ntChallengeResp
init|=
name|qEncodeHmacMd5
argument_list|(
name|phase3
operator|->
name|v2Hash
argument_list|,
name|message
argument_list|)
decl_stmt|;
name|ntChallengeResp
operator|.
name|append
argument_list|(
name|temp
argument_list|)
expr_stmt|;
return|return
name|ntChallengeResp
return|;
block|}
end_function
begin_function
DECL|function|qEncodeLmv2Response
specifier|static
name|QByteArray
name|qEncodeLmv2Response
parameter_list|(
specifier|const
name|QAuthenticatorPrivate
modifier|*
name|ctx
parameter_list|,
specifier|const
name|QNtlmPhase2Block
modifier|&
name|ch
parameter_list|,
name|QNtlmPhase3Block
modifier|*
name|phase3
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|phase3
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|// return value stored in phase3
name|qCreatev2Hash
argument_list|(
name|ctx
argument_list|,
name|phase3
argument_list|)
expr_stmt|;
name|QByteArray
name|message
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|ch
operator|.
name|challenge
argument_list|,
sizeof|sizeof
argument_list|(
name|ch
operator|.
name|challenge
argument_list|)
argument_list|)
decl_stmt|;
name|QByteArray
name|clientCh
init|=
name|clientChallenge
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
name|message
operator|.
name|append
argument_list|(
name|clientCh
argument_list|)
expr_stmt|;
name|QByteArray
name|lmChallengeResp
init|=
name|qEncodeHmacMd5
argument_list|(
name|phase3
operator|->
name|v2Hash
argument_list|,
name|message
argument_list|)
decl_stmt|;
name|lmChallengeResp
operator|.
name|append
argument_list|(
name|clientCh
argument_list|)
expr_stmt|;
return|return
name|lmChallengeResp
return|;
block|}
end_function
begin_function
DECL|function|qNtlmDecodePhase2
specifier|static
name|bool
name|qNtlmDecodePhase2
parameter_list|(
specifier|const
name|QByteArray
modifier|&
name|data
parameter_list|,
name|QNtlmPhase2Block
modifier|&
name|ch
parameter_list|)
block|{
name|Q_ASSERT
argument_list|(
name|QNtlmPhase2BlockBase
operator|::
name|Size
operator|==
sizeof|sizeof
argument_list|(
name|QNtlmPhase2BlockBase
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|.
name|size
argument_list|()
operator|<
name|QNtlmPhase2BlockBase
operator|::
name|Size
condition|)
return|return
literal|false
return|;
name|QDataStream
name|ds
argument_list|(
name|data
argument_list|)
decl_stmt|;
name|ds
operator|.
name|setByteOrder
argument_list|(
name|QDataStream
operator|::
name|LittleEndian
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|.
name|readRawData
argument_list|(
name|ch
operator|.
name|magic
argument_list|,
literal|8
argument_list|)
operator|<
literal|8
condition|)
return|return
literal|false
return|;
if|if
condition|(
name|strncmp
argument_list|(
name|ch
operator|.
name|magic
argument_list|,
literal|"NTLMSSP"
argument_list|,
literal|8
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|false
return|;
name|ds
operator|>>
name|ch
operator|.
name|type
expr_stmt|;
if|if
condition|(
name|ch
operator|.
name|type
operator|!=
literal|2
condition|)
return|return
literal|false
return|;
name|ds
operator|>>
name|ch
operator|.
name|targetName
expr_stmt|;
name|ds
operator|>>
name|ch
operator|.
name|flags
expr_stmt|;
if|if
condition|(
name|ds
operator|.
name|readRawData
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ch
operator|.
name|challenge
argument_list|,
literal|8
argument_list|)
operator|<
literal|8
condition|)
return|return
literal|false
return|;
name|ds
operator|>>
name|ch
operator|.
name|context
index|[
literal|0
index|]
operator|>>
name|ch
operator|.
name|context
index|[
literal|1
index|]
expr_stmt|;
name|ds
operator|>>
name|ch
operator|.
name|targetInfo
expr_stmt|;
if|if
condition|(
name|ch
operator|.
name|targetName
operator|.
name|len
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|ch
operator|.
name|targetName
operator|.
name|len
operator|+
name|ch
operator|.
name|targetName
operator|.
name|offset
operator|>=
operator|(
name|unsigned
operator|)
name|data
operator|.
name|size
argument_list|()
condition|)
return|return
literal|false
return|;
name|ch
operator|.
name|targetNameStr
operator|=
name|qStringFromUcs2Le
argument_list|(
name|data
operator|.
name|mid
argument_list|(
name|ch
operator|.
name|targetName
operator|.
name|offset
argument_list|,
name|ch
operator|.
name|targetName
operator|.
name|len
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|.
name|targetInfo
operator|.
name|len
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|ch
operator|.
name|targetInfo
operator|.
name|len
operator|+
name|ch
operator|.
name|targetInfo
operator|.
name|offset
operator|>
operator|(
name|unsigned
operator|)
name|data
operator|.
name|size
argument_list|()
condition|)
return|return
literal|false
return|;
name|ch
operator|.
name|targetInfoBuff
operator|=
name|data
operator|.
name|mid
argument_list|(
name|ch
operator|.
name|targetInfo
operator|.
name|offset
argument_list|,
name|ch
operator|.
name|targetInfo
operator|.
name|len
argument_list|)
expr_stmt|;
block|}
return|return
literal|true
return|;
block|}
end_function
begin_function
DECL|function|qNtlmPhase3
specifier|static
name|QByteArray
name|qNtlmPhase3
parameter_list|(
name|QAuthenticatorPrivate
modifier|*
name|ctx
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|phase2data
parameter_list|)
block|{
name|QNtlmPhase2Block
name|ch
decl_stmt|;
if|if
condition|(
operator|!
name|qNtlmDecodePhase2
argument_list|(
name|phase2data
argument_list|,
name|ch
argument_list|)
condition|)
return|return
name|QByteArray
argument_list|()
return|;
name|QByteArray
name|rc
decl_stmt|;
name|QDataStream
name|ds
argument_list|(
operator|&
name|rc
argument_list|,
name|QIODevice
operator|::
name|WriteOnly
argument_list|)
decl_stmt|;
name|ds
operator|.
name|setByteOrder
argument_list|(
name|QDataStream
operator|::
name|LittleEndian
argument_list|)
expr_stmt|;
name|QNtlmPhase3Block
name|pb
decl_stmt|;
name|bool
name|unicode
init|=
name|ch
operator|.
name|flags
operator|&
name|NTLMSSP_NEGOTIATE_UNICODE
decl_stmt|;
name|pb
operator|.
name|flags
operator|=
name|NTLMSSP_NEGOTIATE_NTLM
expr_stmt|;
if|if
condition|(
name|unicode
condition|)
name|pb
operator|.
name|flags
operator||=
name|NTLMSSP_NEGOTIATE_UNICODE
expr_stmt|;
else|else
name|pb
operator|.
name|flags
operator||=
name|NTLMSSP_NEGOTIATE_OEM
expr_stmt|;
name|int
name|offset
init|=
name|QNtlmPhase3BlockBase
operator|::
name|Size
decl_stmt|;
name|Q_ASSERT
argument_list|(
name|QNtlmPhase3BlockBase
operator|::
name|Size
operator|==
sizeof|sizeof
argument_list|(
name|QNtlmPhase3BlockBase
argument_list|)
argument_list|)
expr_stmt|;
comment|// for kerberos style user@domain logins, NTLM domain string should be left empty
if|if
condition|(
name|ctx
operator|->
name|userDomain
operator|.
name|isEmpty
argument_list|()
operator|&&
operator|!
name|ctx
operator|->
name|extractedUser
operator|.
name|contains
argument_list|(
name|QLatin1Char
argument_list|(
literal|'@'
argument_list|)
argument_list|)
condition|)
block|{
name|offset
operator|=
name|qEncodeNtlmString
argument_list|(
name|pb
operator|.
name|domain
argument_list|,
name|offset
argument_list|,
name|ch
operator|.
name|targetNameStr
argument_list|,
name|unicode
argument_list|)
expr_stmt|;
name|pb
operator|.
name|domainStr
operator|=
name|ch
operator|.
name|targetNameStr
expr_stmt|;
block|}
else|else
block|{
name|offset
operator|=
name|qEncodeNtlmString
argument_list|(
name|pb
operator|.
name|domain
argument_list|,
name|offset
argument_list|,
name|ctx
operator|->
name|userDomain
argument_list|,
name|unicode
argument_list|)
expr_stmt|;
name|pb
operator|.
name|domainStr
operator|=
name|ctx
operator|->
name|userDomain
expr_stmt|;
block|}
name|offset
operator|=
name|qEncodeNtlmString
argument_list|(
name|pb
operator|.
name|user
argument_list|,
name|offset
argument_list|,
name|ctx
operator|->
name|extractedUser
argument_list|,
name|unicode
argument_list|)
expr_stmt|;
name|pb
operator|.
name|userStr
operator|=
name|ctx
operator|->
name|extractedUser
expr_stmt|;
name|offset
operator|=
name|qEncodeNtlmString
argument_list|(
name|pb
operator|.
name|workstation
argument_list|,
name|offset
argument_list|,
name|ctx
operator|->
name|workstation
argument_list|,
name|unicode
argument_list|)
expr_stmt|;
name|pb
operator|.
name|workstationStr
operator|=
name|ctx
operator|->
name|workstation
expr_stmt|;
comment|// Get LM response
ifdef|#
directive|ifdef
name|NTLMV1_CLIENT
name|pb
operator|.
name|lmResponseBuf
operator|=
name|qEncodeLmResponse
argument_list|(
name|ctx
argument_list|,
name|ch
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|ch
operator|.
name|targetInfo
operator|.
name|len
operator|>
literal|0
condition|)
block|{
name|pb
operator|.
name|lmResponseBuf
operator|=
name|QByteArray
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|pb
operator|.
name|lmResponseBuf
operator|=
name|qEncodeLmv2Response
argument_list|(
name|ctx
argument_list|,
name|ch
argument_list|,
operator|&
name|pb
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|offset
operator|=
name|qEncodeNtlmBuffer
argument_list|(
name|pb
operator|.
name|lmResponse
argument_list|,
name|offset
argument_list|,
name|pb
operator|.
name|lmResponseBuf
argument_list|)
expr_stmt|;
comment|// Get NTLM response
ifdef|#
directive|ifdef
name|NTLMV1_CLIENT
name|pb
operator|.
name|ntlmResponseBuf
operator|=
name|qEncodeNtlmResponse
argument_list|(
name|ctx
argument_list|,
name|ch
argument_list|)
expr_stmt|;
else|#
directive|else
name|pb
operator|.
name|ntlmResponseBuf
operator|=
name|qEncodeNtlmv2Response
argument_list|(
name|ctx
argument_list|,
name|ch
argument_list|,
operator|&
name|pb
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|offset
operator|=
name|qEncodeNtlmBuffer
argument_list|(
name|pb
operator|.
name|ntlmResponse
argument_list|,
name|offset
argument_list|,
name|pb
operator|.
name|ntlmResponseBuf
argument_list|)
expr_stmt|;
comment|// Encode and send
name|ds
operator|<<
name|pb
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_WIN
end_ifdef
begin_comment
comment|// See http://davenport.sourceforge.net/ntlm.html
end_comment
begin_comment
comment|// and libcurl http_ntlm.c
end_comment
begin_comment
comment|// Handle of secur32.dll
end_comment
begin_decl_stmt
DECL|variable|securityDLLHandle
specifier|static
name|HMODULE
name|securityDLLHandle
init|=
name|NULL
decl_stmt|;
end_decl_stmt
begin_comment
comment|// Pointer to SSPI dispatch table
end_comment
begin_decl_stmt
DECL|variable|pSecurityFunctionTable
specifier|static
name|PSecurityFunctionTable
name|pSecurityFunctionTable
init|=
name|NULL
decl_stmt|;
end_decl_stmt
begin_function
DECL|function|q_NTLM_SSPI_library_load
specifier|static
name|bool
name|q_NTLM_SSPI_library_load
parameter_list|()
block|{
name|QMutexLocker
name|locker
argument_list|(
name|QMutexPool
operator|::
name|globalInstanceGet
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|pSecurityFunctionTable
argument_list|)
argument_list|)
decl_stmt|;
comment|// Initialize security interface
if|if
condition|(
name|pSecurityFunctionTable
operator|==
name|NULL
condition|)
block|{
name|securityDLLHandle
operator|=
name|LoadLibrary
argument_list|(
literal|L"secur32.dll"
argument_list|)
expr_stmt|;
if|if
condition|(
name|securityDLLHandle
operator|!=
name|NULL
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|Q_OS_WINCE
argument_list|)
name|INIT_SECURITY_INTERFACE
name|pInitSecurityInterface
init|=
operator|(
name|INIT_SECURITY_INTERFACE
operator|)
name|GetProcAddress
argument_list|(
name|securityDLLHandle
argument_list|,
literal|L"InitSecurityInterfaceW"
argument_list|)
decl_stmt|;
else|#
directive|else
name|INIT_SECURITY_INTERFACE
name|pInitSecurityInterface
init|=
operator|(
name|INIT_SECURITY_INTERFACE
operator|)
name|GetProcAddress
argument_list|(
name|securityDLLHandle
argument_list|,
literal|"InitSecurityInterfaceW"
argument_list|)
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pInitSecurityInterface
operator|!=
name|NULL
condition|)
name|pSecurityFunctionTable
operator|=
name|pInitSecurityInterface
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pSecurityFunctionTable
operator|==
name|NULL
condition|)
return|return
literal|false
return|;
return|return
literal|true
return|;
block|}
end_function
begin_ifdef
ifdef|#
directive|ifdef
name|Q_OS_WIN
end_ifdef
begin_comment
comment|// Phase 1:
end_comment
begin_function
DECL|function|qNtlmPhase1_SSPI
specifier|static
name|QByteArray
name|qNtlmPhase1_SSPI
parameter_list|(
name|QAuthenticatorPrivate
modifier|*
name|ctx
parameter_list|)
block|{
name|QByteArray
name|result
decl_stmt|;
if|if
condition|(
operator|!
name|q_NTLM_SSPI_library_load
argument_list|()
condition|)
return|return
name|result
return|;
comment|// 1. The client obtains a representation of the credential set
comment|// for the user via the SSPI AcquireCredentialsHandle function.
if|if
condition|(
operator|!
name|ctx
operator|->
name|ntlmWindowsHandles
condition|)
name|ctx
operator|->
name|ntlmWindowsHandles
operator|=
operator|new
name|QNtlmWindowsHandles
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ctx
operator|->
name|ntlmWindowsHandles
operator|->
name|credHandle
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|CredHandle
argument_list|)
argument_list|)
expr_stmt|;
name|TimeStamp
name|tsDummy
decl_stmt|;
name|SECURITY_STATUS
name|secStatus
init|=
name|pSecurityFunctionTable
operator|->
name|AcquireCredentialsHandle
argument_list|(
name|NULL
argument_list|,
operator|(
name|SEC_WCHAR
operator|*
operator|)
literal|L"NTLM"
argument_list|,
name|SECPKG_CRED_OUTBOUND
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|ctx
operator|->
name|ntlmWindowsHandles
operator|->
name|credHandle
argument_list|,
operator|&
name|tsDummy
argument_list|)
decl_stmt|;
if|if
condition|(
name|secStatus
operator|!=
name|SEC_E_OK
condition|)
block|{
operator|delete
name|ctx
operator|->
name|ntlmWindowsHandles
expr_stmt|;
name|ctx
operator|->
name|ntlmWindowsHandles
operator|=
literal|0
expr_stmt|;
return|return
name|result
return|;
block|}
comment|// 2. The client calls the SSPI InitializeSecurityContext function
comment|// to obtain an authentication request token (in our case, a Type 1 message).
comment|// The client sends this token to the server.
name|SecBufferDesc
name|desc
decl_stmt|;
name|SecBuffer
name|buf
decl_stmt|;
name|desc
operator|.
name|ulVersion
operator|=
name|SECBUFFER_VERSION
expr_stmt|;
name|desc
operator|.
name|cBuffers
operator|=
literal|1
expr_stmt|;
name|desc
operator|.
name|pBuffers
operator|=
operator|&
name|buf
expr_stmt|;
name|buf
operator|.
name|cbBuffer
operator|=
literal|0
expr_stmt|;
name|buf
operator|.
name|BufferType
operator|=
name|SECBUFFER_TOKEN
expr_stmt|;
name|buf
operator|.
name|pvBuffer
operator|=
name|NULL
expr_stmt|;
name|ULONG
name|attrs
decl_stmt|;
name|secStatus
operator|=
name|pSecurityFunctionTable
operator|->
name|InitializeSecurityContext
argument_list|(
operator|&
name|ctx
operator|->
name|ntlmWindowsHandles
operator|->
name|credHandle
argument_list|,
name|NULL
argument_list|,
cast|const_cast
argument_list|<
name|SEC_WCHAR
operator|*
argument_list|>
argument_list|(
literal|L""
argument_list|)
comment|/* host */
argument_list|,
name|ISC_REQ_ALLOCATE_MEMORY
argument_list|,
literal|0
argument_list|,
name|SECURITY_NETWORK_DREP
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|ctx
operator|->
name|ntlmWindowsHandles
operator|->
name|ctxHandle
argument_list|,
operator|&
name|desc
argument_list|,
operator|&
name|attrs
argument_list|,
operator|&
name|tsDummy
argument_list|)
expr_stmt|;
if|if
condition|(
name|secStatus
operator|==
name|SEC_I_COMPLETE_AND_CONTINUE
operator|||
name|secStatus
operator|==
name|SEC_I_CONTINUE_NEEDED
condition|)
block|{
name|pSecurityFunctionTable
operator|->
name|CompleteAuthToken
argument_list|(
operator|&
name|ctx
operator|->
name|ntlmWindowsHandles
operator|->
name|ctxHandle
argument_list|,
operator|&
name|desc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|secStatus
operator|!=
name|SEC_E_OK
condition|)
block|{
if|if
condition|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|buf
operator|.
name|pvBuffer
condition|)
name|pSecurityFunctionTable
operator|->
name|FreeContextBuffer
argument_list|(
name|buf
operator|.
name|pvBuffer
argument_list|)
expr_stmt|;
name|pSecurityFunctionTable
operator|->
name|FreeCredentialsHandle
argument_list|(
operator|&
name|ctx
operator|->
name|ntlmWindowsHandles
operator|->
name|credHandle
argument_list|)
expr_stmt|;
operator|delete
name|ctx
operator|->
name|ntlmWindowsHandles
expr_stmt|;
name|ctx
operator|->
name|ntlmWindowsHandles
operator|=
literal|0
expr_stmt|;
return|return
name|result
return|;
block|}
name|result
operator|=
name|QByteArray
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|buf
operator|.
name|pvBuffer
argument_list|,
name|buf
operator|.
name|cbBuffer
argument_list|)
expr_stmt|;
name|pSecurityFunctionTable
operator|->
name|FreeContextBuffer
argument_list|(
name|buf
operator|.
name|pvBuffer
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_comment
comment|// Phase 2:
end_comment
begin_comment
comment|// 3. The server receives the token from the client, and uses it as input to the
end_comment
begin_comment
comment|// AcceptSecurityContext SSPI function. This creates a local security context on
end_comment
begin_comment
comment|// the server to represent the client, and yields an authentication response token
end_comment
begin_comment
comment|// (the Type 2 message), which is sent to the client.
end_comment
begin_comment
comment|// Phase 3:
end_comment
begin_function
DECL|function|qNtlmPhase3_SSPI
specifier|static
name|QByteArray
name|qNtlmPhase3_SSPI
parameter_list|(
name|QAuthenticatorPrivate
modifier|*
name|ctx
parameter_list|,
specifier|const
name|QByteArray
modifier|&
name|phase2data
parameter_list|)
block|{
comment|// 4. The client receives the response token from the server and calls
comment|// InitializeSecurityContext again, passing the server's token as input.
comment|// This provides us with another authentication request token (the Type 3 message).
comment|// The return value indicates that the security context was successfully initialized;
comment|// the token is sent to the server.
name|QByteArray
name|result
decl_stmt|;
if|if
condition|(
name|pSecurityFunctionTable
operator|==
name|NULL
condition|)
return|return
name|result
return|;
name|SecBuffer
name|type_2
decl_stmt|,
name|type_3
decl_stmt|;
name|SecBufferDesc
name|type_2_desc
decl_stmt|,
name|type_3_desc
decl_stmt|;
name|ULONG
name|attrs
decl_stmt|;
name|TimeStamp
name|tsDummy
decl_stmt|;
comment|// For Windows 9x compatibility of SPPI calls
name|type_2_desc
operator|.
name|ulVersion
operator|=
name|type_3_desc
operator|.
name|ulVersion
operator|=
name|SECBUFFER_VERSION
expr_stmt|;
name|type_2_desc
operator|.
name|cBuffers
operator|=
name|type_3_desc
operator|.
name|cBuffers
operator|=
literal|1
expr_stmt|;
name|type_2_desc
operator|.
name|pBuffers
operator|=
operator|&
name|type_2
expr_stmt|;
name|type_3_desc
operator|.
name|pBuffers
operator|=
operator|&
name|type_3
expr_stmt|;
name|type_2
operator|.
name|BufferType
operator|=
name|SECBUFFER_TOKEN
expr_stmt|;
name|type_2
operator|.
name|pvBuffer
operator|=
operator|(
name|PVOID
operator|)
name|phase2data
operator|.
name|data
argument_list|()
expr_stmt|;
name|type_2
operator|.
name|cbBuffer
operator|=
name|phase2data
operator|.
name|length
argument_list|()
expr_stmt|;
name|type_3
operator|.
name|BufferType
operator|=
name|SECBUFFER_TOKEN
expr_stmt|;
name|type_3
operator|.
name|pvBuffer
operator|=
literal|0
expr_stmt|;
name|type_3
operator|.
name|cbBuffer
operator|=
literal|0
expr_stmt|;
name|SECURITY_STATUS
name|secStatus
init|=
name|pSecurityFunctionTable
operator|->
name|InitializeSecurityContext
argument_list|(
operator|&
name|ctx
operator|->
name|ntlmWindowsHandles
operator|->
name|credHandle
argument_list|,
operator|&
name|ctx
operator|->
name|ntlmWindowsHandles
operator|->
name|ctxHandle
argument_list|,
cast|const_cast
argument_list|<
name|SEC_WCHAR
operator|*
argument_list|>
argument_list|(
literal|L""
argument_list|)
comment|/* host */
argument_list|,
name|ISC_REQ_ALLOCATE_MEMORY
argument_list|,
literal|0
argument_list|,
name|SECURITY_NETWORK_DREP
argument_list|,
operator|&
name|type_2_desc
argument_list|,
literal|0
argument_list|,
operator|&
name|ctx
operator|->
name|ntlmWindowsHandles
operator|->
name|ctxHandle
argument_list|,
operator|&
name|type_3_desc
argument_list|,
operator|&
name|attrs
argument_list|,
operator|&
name|tsDummy
argument_list|)
decl_stmt|;
if|if
condition|(
name|secStatus
operator|==
name|SEC_E_OK
operator|&&
operator|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|type_3
operator|.
name|pvBuffer
operator|)
condition|)
block|{
name|result
operator|=
name|QByteArray
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|type_3
operator|.
name|pvBuffer
argument_list|,
name|type_3
operator|.
name|cbBuffer
argument_list|)
expr_stmt|;
name|pSecurityFunctionTable
operator|->
name|FreeContextBuffer
argument_list|(
name|type_3
operator|.
name|pvBuffer
argument_list|)
expr_stmt|;
block|}
name|pSecurityFunctionTable
operator|->
name|FreeCredentialsHandle
argument_list|(
operator|&
name|ctx
operator|->
name|ntlmWindowsHandles
operator|->
name|credHandle
argument_list|)
expr_stmt|;
name|pSecurityFunctionTable
operator|->
name|DeleteSecurityContext
argument_list|(
operator|&
name|ctx
operator|->
name|ntlmWindowsHandles
operator|->
name|ctxHandle
argument_list|)
expr_stmt|;
operator|delete
name|ctx
operator|->
name|ntlmWindowsHandles
expr_stmt|;
name|ctx
operator|->
name|ntlmWindowsHandles
operator|=
literal|0
expr_stmt|;
return|return
name|result
return|;
block|}
end_function
begin_endif
endif|#
directive|endif
end_endif
begin_comment
comment|// Q_OS_WIN
end_comment
begin_endif
endif|#
directive|endif
end_endif
begin_macro
name|QT_END_NAMESPACE
end_macro
end_unit
