
equals(TEMPLATE, app) {

    # If the application uses Qt, it needs to be an application bundle
    # to be able to deploy and run on iOS. The only exception to this
    # is if you're working with a jailbroken device and can run the
    # resulting binary from the console/over SSH, but that's not a
    # use-case we care about, so no need to complicate the logic.
    qt: CONFIG *= app_bundle

    # Application bundles require building through Xcode
    app_bundle:!macx-xcode {
        # For Qt applications we want Xcode project files as the generated output,
        # but since qmake doesn't handle the transition between makefiles and Xcode
        # project files (which happens when using subdirs), we create a wrapper
        # makefile that takes care of generating the Xcode project, and allows
        # building by calling out to xcodebuild.
        TEMPLATE = aux

        CONFIG =
        SOURCES =
        OBJECTIVE_SOURCES =
        RESOURCES =
        INSTALLS =
        QMAKE_EXTRA_COMPILERS =
        QMAKE_EXTRA_TARGETS =

        TARGET_XCODE_PROJECT_DIR = $${TARGET}.xcodeproj

        args =
        for(arg, QMAKE_ARGS): \
            args += $$system_quote($$arg)

        system("cd $$system_quote($$OUT_PWD) && $$QMAKE_QMAKE $$args $$system_quote($$_PRO_FILE_) -spec macx-xcode")

        # We use xcodebuild to do the actual build, but filter out the verbose
        # output that shows all environment variables for each build step.
        xcodebuild_build.commands = "@bash -o pipefail -c 'xcodebuild | grep -v setenv'"
        QMAKE_EXTRA_TARGETS += xcodebuild_build
        all.depends = xcodebuild_build
        QMAKE_EXTRA_TARGETS += all

        # We do the same for the clean action
        xcodebuild_clean.commands = "@xcodebuild clean"
        QMAKE_EXTRA_TARGETS += xcodebuild_clean
        clean.depends = xcodebuild_clean
        QMAKE_EXTRA_TARGETS += clean

        # And distclean
        xcodebuild_distclean.commands = "$(DEL_FILE) -R $$TARGET_XCODE_PROJECT_DIR"
        xcodebuild_distclean.depends = xcodebuild_clean
        QMAKE_EXTRA_TARGETS += xcodebuild_distclean
        distclean.depends = xcodebuild_distclean
        QMAKE_EXTRA_TARGETS += distclean
    }
}

macx-xcode {
    ios_device_family.name = TARGETED_DEVICE_FAMILY
    ios_device_family.value = $$QMAKE_IOS_TARGETED_DEVICE_FAMILY
    QMAKE_MAC_XCODE_SETTINGS += ios_device_family
}

# Be more specific about which architecture we're targeting
equals(QT_ARCH, arm): \
    actual_archs = $$QMAKE_IOS_DEVICE_ARCHS
else: \
    actual_archs = $$QMAKE_IOS_SIMULATOR_ARCHS

macx-xcode {
    QMAKE_XCODE_ARCHS = $$actual_archs
} else {
    for(arch, actual_archs): \
        arch_flags += -arch $$arch

    QMAKE_CFLAGS           += $$arch_flags
    QMAKE_CXXFLAGS         += $$arch_flags
    QMAKE_OBJECTIVE_CFLAGS += $$arch_flags
    QMAKE_LFLAGS           += $$arch_flags
}
unset(actual_archs)

load(default_post)
