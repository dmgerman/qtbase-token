load(default_post)
!no_objective_c:CONFIG += objective_c


equals(TEMPLATE, app):qt: {
    deps = $$replace(QT, -private$, )
    deps = $$resolve_depends(deps, "QT.", ".depends" ".private_depends" ".run_depends")
    contains(deps, gui): {
        DEFINES += QT_NEEDS_QMAIN
        CONFIG += link_prl
        # When CI'ing Qt we still need to link against libqtcocoamain.a, even before deployment.
        # Hence the /get variable, suffix which looks for the libraries location effective path.
        QMAKE_LIBDIR += $$[QT_INSTALL_LIBS/get]
        QMAKE_LIBS += -lqtcocoamain
    }
}

qt:!isEmpty(QT_CONFIG) {
    # Pick a suitable default architecture for qmake-based applications.
    # If the Qt package contains one of x86 and x86_64, pick that one. If it
    # contains both then use the compiler default. Make a similar decision for
    # PowerPC-based systems. Note that this logic assumes that Qt has been
    # configured with an architecture that is usable on the system.
    contains(QMAKE_HOST.arch, ppc)|contains(QMAKE_HOST.arch, "Power Macintosh") {
        !contains(QT_CONFIG, ppc64):contains(QT_CONFIG, ppc):CONFIG += ppc
        contains(QT_CONFIG, ppc64):!contains(QT_CONFIG, ppc):CONFIG += ppc64
    } else {
        !contains(QT_CONFIG, x86_64):contains(QT_CONFIG, x86):CONFIG += x86
        contains(QT_CONFIG, x86_64):!contains(QT_CONFIG, x86):CONFIG += x86_64
    }

    # Ensure that C++11 is always used when linking against a static Qt build
    contains(QT_CONFIG, static):contains(QT_CONFIG, c++11): CONFIG += c++11
}

isEmpty(_QMAKE_CACHE_) {
    warning("No .qmake.cache is present. This significantly slows down qmake with this makespec.")
    warning("Call 'cache()' in the top-level project file to rectify this problem.")
} else {
    cache(QMAKE_XCODE_DEVELOPER_PATH)
    cache(QMAKE_XCODE_VERSION)
}

# Ensure that we process sdk.prf first, as it will update QMAKE_CXX
# and friends that other features/extra compilers may depend on.
sdk: load(sdk)
