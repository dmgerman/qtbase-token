defineReplace(qtPlatformTargetSuffix) {
    CONFIG(debug, debug|release) {
        !debug_and_release|build_pass {
           mac:return(_debug)
           win32:return(d)
        }
    }
    return()
}

defineReplace(qtLibraryTarget) {
   unset(LIBRARY_NAME)
   LIBRARY_NAME = $$1
   mac:!static:contains(QT_CONFIG, qt_framework) {
      QMAKE_FRAMEWORK_BUNDLE_NAME = $$LIBRARY_NAME
      export(QMAKE_FRAMEWORK_BUNDLE_NAME)
   }
   unset(LIBRARY_SUFFIX)
   contains(TEMPLATE, .*lib):LIBRARY_SUFFIX = $$qtPlatformTargetSuffix()
   isEmpty(LIBRARY_SUFFIX):return($$LIBRARY_NAME)
   else:return($$member(LIBRARY_NAME, 0)$$LIBRARY_SUFFIX)
}

defineTest(qtAddLibrary) {
    warning("qtAddLibrary() is deprecated. Use qtAddModule() or QT+= instead.")

    # Reverse-engineer the module name from the library name.
    for(var, $$list($$find($$list($$enumerate_vars()), ^QT\\.[^.]+\\.name$))) {
        isEqual($$var, $$1) {
            var ~= s,^QT\\.([^.]+)\\.name$,\\1,
            qtAddModule($$var):return(true):break()
            return(false):break() # Yes, the break is insanity. But necessary.
        }
    }
    error("No module matching library '$$1' found.")
}

defineTest(qtAddModule) {
    MODULE_NAME = $$eval(QT.$${1}.name)
    MODULE_INCLUDES = $$eval(QT.$${1}.includes)
    MODULE_LIBS = $$eval(QT.$${1}.libs)
    MODULE_CONFIG = $$eval(QT.$${1}.module_config)
    MODULE_MAJOR_VERSION = $$eval(QT.$${1}.MAJOR_VERSION)

    CONFIG += $$eval(QT.$${1}.CONFIG)
    DEFINES += $$eval(QT.$${1}.DEFINES)

    unix {
        MODULE_INCLUDES -= /usr/include /usr/local/include
        MODULE_LIBS -= /usr/lib /usr/local/lib
    }

    INCLUDEPATH *= $$MODULE_INCLUDES
    auto_use_privates|isEqual(2, UsePrivate) { # Tests function parameter 2 ($$2) being equal to 'UsePrivate'
        # This adds both
        #     <module privates include path>/
        # and <module privates include path>/<module name>
        # since we have code using both #include <QtCore/private/foo> and #include <private/foo>
        # Both need to be supported with the new private includes structure
        MODULE_INCLUDES_PRIVATES = $$eval(QT.$${1}.private_includes)
        INCLUDEPATH += $$MODULE_INCLUDES_PRIVATES $$MODULE_INCLUDES_PRIVATES/$$MODULE_NAME
    }

    unset(LINKAGE)
    mac {
        !contains(MODULE_CONFIG,staticlib):CONFIG(qt_framework, qt_framework|qt_no_framework) { #forced
          QMAKE_FRAMEWORKPATH *= $${MODULE_LIBS}
          FRAMEWORK_INCLUDE = $${MODULE_LIBS}/$${MODULE_NAME}.framework/Headers
          !qt_no_framework_direct_includes:exists($$FRAMEWORK_INCLUDE): \
               INCLUDEPATH *= $$FRAMEWORK_INCLUDE
           LINKAGE = -framework $${MODULE_NAME}$${QT_LIBINFIX}
        }
    }

    win32 {
        # Make sure we link against the version pulled from the module's .pri
        ver_var    = QMAKE_$${upper($$MODULE_NAME$$QT_LIBINFIX)}_VERSION_OVERRIDE
        dver_var   = QMAKE_$${upper($$MODULE_NAME$$QT_LIBINFIX)}D_VERSION_OVERRIDE
        $$ver_var  = $$MODULE_MAJOR_VERSION
        $$dver_var = $$MODULE_MAJOR_VERSION
        export($$ver_var)
        export($$dver_var)
    }

    isEmpty(LINKAGE) {
       !isEmpty(MODULE_LIBS) {
           QMAKE_LIBDIR *= $$MODULE_LIBS
           !isEqual(MODULE_LIBS, $$[QT_INSTALL_LIBS]) {
               # Make sure we can link to uninstalled libraries
               unix:!mac:QMAKE_LFLAGS *= "-Wl,-rpath-link,$$MODULE_LIBS"
           }
       }
       if(!debug_and_release|build_pass):CONFIG(debug, debug|release) {
           win32:LINKAGE = -l$${MODULE_NAME}$${QT_LIBINFIX}d
           mac:LINKAGE = -l$${MODULE_NAME}$${QT_LIBINFIX}_debug
       }
       isEmpty(LINKAGE):LINKAGE = -l$${MODULE_NAME}$${QT_LIBINFIX}
    }
    # Only link to this module if a libs directory is set, else this is just a module
    # to give access to sources or include files, and not for linking.
    !isEmpty(MODULE_LIBS) {
        !isEmpty(QMAKE_LSB) {
            QMAKE_LFLAGS *= --lsb-libpath=$$MODULE_LIBS
            QMAKE_LFLAGS *= -L/opt/lsb/lib
            QMAKE_LFLAGS *= --lsb-shared-libs=$${MODULE_NAME}$${QT_LIBINFIX}
        }
        LIBS += $$LINKAGE
    }
    export(CONFIG)
    export(DEFINES)
    export(LIBS)
    export(INCLUDEPATH)
    export(QMAKE_FRAMEWORKPATH)
    export(QMAKE_LFLAGS)
    export(QMAKE_LIBDIR)
    return(true)
}

# variable, default
defineTest(qtPrepareTool) {
    $$1 = $$eval(QT_TOOL.$${2}.binary)
    isEmpty($$1) {
        MODBASE = $$[QT_HOST_BINS/get]
        count(ARGS, 2, greaterThan) {
            isEmpty(QT.$${3}.bins):warning("No QT.$${3}.bins, module path ignored for qtPrepareTool($$1, $$2, $$3)")
            else:MODBASE = $$eval(QT.$${3}.bins)
        }
        isEmpty($$1):$$1 = $$MODBASE/$$2
        contains(QMAKE_HOST.os, Windows):!contains($$1, .*\\.(exe|bat)$) {
            exists($$eval($$1).bat) {
                $$1 = $$eval($$1).bat
            } else {
                $$1 = $$eval($$1).exe
            }
        } else:contains(QMAKE_HOST.os, Darwin) {
            BUNDLENAME = $$eval($$1).app/Contents/MacOS/$$2
            exists($$BUNDLENAME) {
                $$1 = $$BUNDLENAME
            }
        }
    }
    $$1 = $$native_path($$eval($$1))

    deps = $$resolve_depends(QT_TOOL.$${2}.depends, "QT.")
    !isEmpty(deps) {
        for(dep, deps): \
            deppath += $$native_path($$eval(QT.$${dep}.libs))
        deppath = $$unique(deppath)
        equals(QMAKE_DIR_SEP, /) {
            equals(QMAKE_HOST.os, Windows): \
                var = PATH
            else:contains(QMAKE_HOST.os, Linux): \
                var = LD_LIBRARY_PATH
            else:equals(QMAKE_HOST.os, Darwin): \
                var = DYLD_LIBRARY_PATH
            else: \
                error("Operating system not supported.")
            $$1 = "$$var=$$join(deppath, :)${$$var:+:\$$$var} $$eval($$1)"
        } else {
            $$1 = "(set PATH=$$join(deppath, ;);%PATH%) & $$eval($$1)"
        }
    }

    export($$1)
}

defineReplace(pkgConfigExecutable) {
    isEmpty(PKG_CONFIG) {
        PKG_CONFIG = pkg-config

        !isEmpty(PKG_CONFIG_SYSROOT_DIR) {
            win32:isEmpty(MINGW_IN_SHELL):PKG_CONFIG = set PKG_CONFIG_SYSROOT_DIR=$$PKG_CONFIG_SYSROOT_DIR& $$PKG_CONFIG
            else:PKG_CONFIG = PKG_CONFIG_SYSROOT_DIR=\"$$PKG_CONFIG_SYSROOT_DIR\" $$PKG_CONFIG
        }

        !isEmpty(PKG_CONFIG_LIBDIR) {
            win32:isEmpty(MINGW_IN_SHELL):PKG_CONFIG = set PKG_CONFIG_LIBDIR=$$PKG_CONFIG_LIBDIR& $$PKG_CONFIG
            else:PKG_CONFIG = PKG_CONFIG_LIBDIR=\"$$PKG_CONFIG_LIBDIR\" $$PKG_CONFIG
        }
    }

    return($$PKG_CONFIG)
}

defineTest(packagesExist) {
    # this can't be done in global scope here because qt_functions is loaded
    # before the .pro is parsed, so if the .pro set PKG_CONFIG, we wouldn't know it
    # yet. oops.

    pkg_config = $$pkgConfigExecutable()

    for(package, ARGS) {
        !system($$pkg_config --exists $$package):return(false)
    }

    return(true)
}

