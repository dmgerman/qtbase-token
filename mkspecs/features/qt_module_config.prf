!no_qt_module_warning:if(!contains(QMAKE_INTERNAL_INCLUDED_FILES, .*qmodule\\\\.pri)|isEmpty(QMAKE_QT_MODULE_PRI_LOADED)) {
    QMAKE_ACTUAL_PRO_FILE = $$basename(_PRO_FILE_)
    isEmpty(QMAKE_ACTUAL_PRO_FILE): QMAKE_ACTUAL_PRO_FILE=.pro
    warning("You should probably load(qt_module) first in $$QMAKE_ACTUAL_PRO_FILE for $$TARGET, as it also load()s qt_module_config.")
    message("Not doing so may lead to qt_module_config.prf overriding compiler/linker options in your .pro file.")
    message("Ignore this warning with CONFIG+=no_qt_module_warning if you know what you are doing.")
    unset(QMAKE_ACTUAL_PRO_FILE)
}
load(qt_module) # loads qmodule.pri if hasn't been loaded already

isEmpty(MODULE):MODULE = $$section($$list($$basename(_PRO_FILE_)), ., 0, 0)
isEmpty(TARGET):error("You must set TARGET before include()'ing $${_FILE_}")

MODULE_INCLUDES = $$eval(QT.$${MODULE}.includes)
MODULE_PRIVATE_INCLUDES = $$eval(QT.$${MODULE}.private_includes)
INCLUDEPATH *= $$MODULE_PRIVATE_INCLUDES
INCLUDEPATH *= $$MODULE_PRIVATE_INCLUDES/$$TARGET
INCLUDEPATH *= $$MODULE_INCLUDES $$MODULE_INCLUDES/.. #just for today to have some compat
!isEmpty(RCC_DIR): INCLUDEPATH += $$RCC_DIR
TEMPLATE        = lib
isEmpty(QT_MAJOR_VERSION) {
   VERSION=5.0.0
} else {
   VERSION=$${QT_MAJOR_VERSION}.$${QT_MINOR_VERSION}.$${QT_PATCH_VERSION}
}

#load up the headers info
CONFIG += qt_install_headers
#headers.pri is loaded from the last include path
LAST_MODULE_INCLUDE=$$MODULE_INCLUDES
for(include_path, MODULE_INCLUDES):LAST_MODULE_INCLUDE=$${include_path}
HEADERS_PRI = $$LAST_MODULE_INCLUDE/headers.pri
include($$HEADERS_PRI, "", true)|clear(HEADERS_PRI)

#other
DESTDIR          = $$eval(QT.$${MODULE}.libs)
win32:!wince*:DLLDESTDIR = $$[QT_INSTALL_PREFIX]/bin

CONFIG          += qt warn_on depend_includepath
CONFIG          += qmake_cache target_qt
CONFIG          -= fix_output_dirs

# If Qt was configured with -debug-and-release then build the module the same way
if(win32|mac):!wince*:!macx-xcode {
    contains(QT_CONFIG, debug_and_release):CONFIG += debug_and_release
    contains(QT_CONFIG, build_all):CONFIG += build_all
}

linux*:QMAKE_LFLAGS += $$QMAKE_LFLAGS_NOUNDEF

!isEmpty(DESTDIR):CONFIG += create_cmake

contains(QT_CONFIG, reduce_exports):CONFIG += hide_symbols
unix:contains(QT_CONFIG, reduce_relocations):CONFIG += bsymbolic_functions
contains(QT_CONFIG, largefile):CONFIG += largefile
contains(QT_CONFIG, separate_debug_info):CONFIG += separate_debug_info
contains(QT_CONFIG, separate_debug_info_nocopy):CONFIG += separate_debug_info_nocopy
contains(QT_CONFIG, c++11):CONFIG += c++11

#mac frameworks
mac:!static:contains(QT_CONFIG, qt_framework) {
   #QMAKE_FRAMEWORK_VERSION = 4.0
   CONFIG += lib_bundle qt_no_framework_direct_includes qt_framework
   CONFIG(release, debug|release) {
      !debug_and_release|build_pass {
          CONFIG -= qt_install_headers #no need to install these as well
          FRAMEWORK_HEADERS.version = Versions
          FRAMEWORK_HEADERS.files = $$SYNCQT.HEADER_FILES $$SYNCQT.HEADER_CLASSES
          FRAMEWORK_HEADERS.path = Headers
          equals(TARGET, QtCore) {
              #headers generated by configure
              !contains(FRAMEWORK_HEADERS.files, .*/qconfig.h) {
                  FRAMEWORK_HEADERS.files *= $$QT_BUILD_TREE/src/corelib/global/qconfig.h
              }
          }
      }
      QMAKE_BUNDLE_DATA += FRAMEWORK_HEADERS
   }
}

mac {
   CONFIG += explicitlib
   macx-g++ {
       QMAKE_CFLAGS += -fconstant-cfstrings
       QMAKE_CXXFLAGS += -fconstant-cfstrings
   }
}

win32:!shared:CONFIG += static

win32-borland {
    # Keep the size of the .tds file for the Qt library smaller than
    # 34 Mbytes to avoid linking problems
    QMAKE_CFLAGS_DEBUG += -vi -y-
    QMAKE_CXXFLAGS_DEBUG += -vi -y-
}

win32 {
    INCLUDEPATH += tmp
    !static: DEFINES+=QT_MAKEDLL
}
win32-borland:INCLUDEPATH += kernel

aix-g++* {
     QMAKE_CFLAGS   += -mminimal-toc
     QMAKE_CXXFLAGS += -mminimal-toc
}

!static:PRL_EXPORT_DEFINES += QT_SHARED

#install directives
load(qt_installs)

unix|win32-g++* {
   CONFIG += create_pc
   QMAKE_PKGCONFIG_LIBDIR = $$[QT_INSTALL_LIBS/raw]
   QMAKE_PKGCONFIG_INCDIR = $$[QT_INSTALL_HEADERS/raw]/$$TARGET
   QMAKE_PKGCONFIG_CFLAGS = -I$$[QT_INSTALL_HEADERS/raw]
   QMAKE_PKGCONFIG_DESTDIR = pkgconfig
   include_replace.match = $$QMAKE_INCDIR_QT
   include_replace.replace = $$[QT_INSTALL_HEADERS/raw]
   lib_replace.match = $$QMAKE_LIBDIR_QT
   lib_replace.replace = $$[QT_INSTALL_LIBS/raw]
   prefix_replace.match = $$QT_BUILD_TREE
   prefix_replace.replace = $$[QT_INSTALL_PREFIX/raw]
   QMAKE_PKGCONFIG_INSTALL_REPLACE += include_replace lib_replace prefix_replace
}

unix {
   CONFIG += create_libtool explicitlib
   QMAKE_PRL_LIBDIR = $$[QT_INSTALL_LIBS/raw] ### XXX
   QMAKE_PRL_INSTALL_REPLACE += include_replace lib_replace
   QMAKE_LIBTOOL_LIBDIR = $$[QT_INSTALL_LIBS/raw]
   QMAKE_LIBTOOL_INSTALL_REPLACE += include_replace lib_replace
}

contains(QT_PRODUCT, OpenSource.*):DEFINES *= QT_OPENSOURCE
DEFINES *= QT_NO_CAST_TO_ASCII QT_ASCII_CAST_WARNINGS
DEFINES *= QT_MOC_COMPAT #we don't need warnings from calling moc code in our generated code
DEFINES *= QT_USE_QSTRINGBUILDER
DEFINES *= QT_DEPRECATED_WARNINGS

TARGET = $$qtLibraryTarget($$TARGET$$QT_LIBINFIX) #do this towards the end

qtPrepareTool(QMAKE_MOC, moc)
qtPrepareTool(QMAKE_UIC, uic)
qtPrepareTool(QMAKE_RCC, rcc)
qtPrepareTool(QMAKE_LUPDATE, lupdate)
qtPrepareTool(QMAKE_LRELEASE, lrelease)

moc_dir.name = moc_location
moc_dir.variable = QMAKE_MOC

uic_dir.name = uic_location
uic_dir.variable = QMAKE_UIC

rcc_dir.name = rcc_location
rcc_dir.variable = QMAKE_RCC

lupdate_dir.name = lupdate_location
lupdate_dir.variable = QMAKE_LUPDATE

lrelease_dir.name = lrelease_location
lrelease_dir.variable = QMAKE_LRELEASE

QMAKE_PKGCONFIG_VARIABLES += moc_dir uic_dir rcc_dir lupdate_dir lrelease_dir

load(qt_targets)

win32:DEFINES+=_USE_MATH_DEFINES

