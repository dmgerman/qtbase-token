
CONFIG(qt):contains(QT, gui):equals(TEMPLATE, app): CONFIG += gui_app

isEmpty(MAKEFILE_GENERATOR) {
    gui_app:app_bundle: \
        # For applications we want Xcode project files
        MAKEFILE_GENERATOR = XCODE
    else: \
        # For libs, etc we still want regular Makefiles
        MAKEFILE_GENERATOR = UNIX
}

gui_app {
    LIBS *= -L$$[QT_INSTALL_PLUGINS/get]/platforms

    lib_name = qios
    lib_path_and_base = $$[QT_INSTALL_PLUGINS/get]/platforms/lib$${lib_name}$$qtPlatformTargetSuffix()
    LIBS += -l$${lib_name}$$qtPlatformTargetSuffix() $$fromfile($${lib_path_and_base}.prl, QMAKE_PRL_LIBS)

    # By marking qt_registerPlatformPlugin as undefined, we ensure that
    # the plugin.o translation unit is considered for inclusion in
    # the final binary, which in turn ensures that the plugin's
    # static initializer is included and run.
    QMAKE_LFLAGS += -u _qt_registerPlatformPlugin

    # We do link and dependency resolution for the platform plugin
    # manually, since we know we always need the plugin, so we don't
    # need to generate an import for it.
    CONFIG -= import_qpa_plugin

    !no_main_wrapper {
        # We link the iosmain library manually as well, since it's not really a plugin
        lib_name = qiosmain
        lib_path_and_base = $$[QT_INSTALL_PLUGINS/get]/platforms/lib$${lib_name}$$qtPlatformTargetSuffix()
        LIBS += -L$$[QT_INSTALL_PLUGINS/get]/platforms -l$${lib_name}$$qtPlatformTargetSuffix()
        LIBS += $$fromfile($${lib_path_and_base}.prl, QMAKE_PRL_LIBS)
        DEFINES += main=qt_main
    }
}

contains(MAKEFILE_GENERATOR, XCODE) {
    ios_device_family.name = TARGETED_DEVICE_FAMILY
    ios_device_family.value = $$QMAKE_IOS_TARGETED_DEVICE_FAMILY
    QMAKE_MAC_XCODE_SETTINGS += ios_device_family
}

isEmpty(QT_ARCH) {
    # The iPhoneOS and iPhoneSimulator targets share the same toolchain,
    # so when configure runs the arch tests it passes the correct sysroot,
    # but we fail to pick up the architecture since we're not passing -arch
    # yet. Xcode does not seem to have a way to run the shared toolchain
    # in a way that will automatically  do this (for example xcrun -sdk).
    contains(QMAKE_MAC_SDK, iphoneos.*): QT_ARCH = arm
    else: QT_ARCH = i386 # Simulator
}

# Be more specific about which architecture we're targeting
equals(QT_ARCH, arm): \
    actual_archs = armv7
else: \
    actual_archs = $$QT_ARCH

equals(MAKEFILE_GENERATOR, XCODE) {
    QMAKE_XCODE_ARCHS = $$actual_archs
} else {
    for(arch, actual_archs): \
        arch_flags += -arch $$arch

    QMAKE_CFLAGS           += $$arch_flags
    QMAKE_CXXFLAGS         += $$arch_flags
    QMAKE_OBJECTIVE_CFLAGS += $$arch_flags
    QMAKE_LFLAGS           += $$arch_flags
}
unset(actual_archs)

load(default_post)
